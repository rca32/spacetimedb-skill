import { fromByteArray } from 'base64-js';
import * as React from 'react';
import { createContext, useContext, useState, useRef, useCallback, useEffect, useSyncExternalStore } from 'react';

// src/lib/time_duration.ts
var TimeDuration = class _TimeDuration {
  __time_duration_micros__;
  static MICROS_PER_MILLIS = 1000n;
  /**
   * Get the algebraic type representation of the {@link TimeDuration} type.
   * @returns The algebraic type representation of the type.
   */
  static getAlgebraicType() {
    return AlgebraicType.Product({
      elements: [
        {
          name: "__time_duration_micros__",
          algebraicType: AlgebraicType.I64
        }
      ]
    });
  }
  static isTimeDuration(algebraicType) {
    if (algebraicType.tag !== "Product") {
      return false;
    }
    const elements = algebraicType.value.elements;
    if (elements.length !== 1) {
      return false;
    }
    const microsElement = elements[0];
    return microsElement.name === "__time_duration_micros__" && microsElement.algebraicType.tag === "I64";
  }
  get micros() {
    return this.__time_duration_micros__;
  }
  get millis() {
    return Number(this.micros / _TimeDuration.MICROS_PER_MILLIS);
  }
  constructor(micros) {
    this.__time_duration_micros__ = micros;
  }
  static fromMillis(millis) {
    return new _TimeDuration(BigInt(millis) * _TimeDuration.MICROS_PER_MILLIS);
  }
  /** This outputs the same string format that we use in the host and in Rust modules */
  toString() {
    const micros = this.micros;
    const sign = micros < 0 ? "-" : "+";
    const pos = micros < 0 ? -micros : micros;
    const secs = pos / 1000000n;
    const micros_remaining = pos % 1000000n;
    return `${sign}${secs}.${String(micros_remaining).padStart(6, "0")}`;
  }
};

// src/lib/timestamp.ts
var Timestamp = class _Timestamp {
  __timestamp_micros_since_unix_epoch__;
  static MICROS_PER_MILLIS = 1000n;
  get microsSinceUnixEpoch() {
    return this.__timestamp_micros_since_unix_epoch__;
  }
  constructor(micros) {
    this.__timestamp_micros_since_unix_epoch__ = micros;
  }
  /**
   * Get the algebraic type representation of the {@link Timestamp} type.
   * @returns The algebraic type representation of the type.
   */
  static getAlgebraicType() {
    return AlgebraicType.Product({
      elements: [
        {
          name: "__timestamp_micros_since_unix_epoch__",
          algebraicType: AlgebraicType.I64
        }
      ]
    });
  }
  static isTimestamp(algebraicType) {
    if (algebraicType.tag !== "Product") {
      return false;
    }
    const elements = algebraicType.value.elements;
    if (elements.length !== 1) {
      return false;
    }
    const microsElement = elements[0];
    return microsElement.name === "__timestamp_micros_since_unix_epoch__" && microsElement.algebraicType.tag === "I64";
  }
  /**
   * The Unix epoch, the midnight at the beginning of January 1, 1970, UTC.
   */
  static UNIX_EPOCH = new _Timestamp(0n);
  /**
   * Get a `Timestamp` representing the execution environment's belief of the current moment in time.
   */
  static now() {
    return _Timestamp.fromDate(/* @__PURE__ */ new Date());
  }
  /** Convert to milliseconds since Unix epoch. */
  toMillis() {
    return this.microsSinceUnixEpoch / 1000n;
  }
  /**
   * Get a `Timestamp` representing the same point in time as `date`.
   */
  static fromDate(date) {
    const millis = date.getTime();
    const micros = BigInt(millis) * _Timestamp.MICROS_PER_MILLIS;
    return new _Timestamp(micros);
  }
  /**
   * Get a `Date` representing approximately the same point in time as `this`.
   *
   * This method truncates to millisecond precision,
   * and throws `RangeError` if the `Timestamp` is outside the range representable as a `Date`.
   */
  toDate() {
    const micros = this.__timestamp_micros_since_unix_epoch__;
    const millis = micros / _Timestamp.MICROS_PER_MILLIS;
    if (millis > BigInt(Number.MAX_SAFE_INTEGER) || millis < BigInt(Number.MIN_SAFE_INTEGER)) {
      throw new RangeError(
        "Timestamp is outside of the representable range of JS's Date"
      );
    }
    return new Date(Number(millis));
  }
  since(other) {
    return new TimeDuration(
      this.__timestamp_micros_since_unix_epoch__ - other.__timestamp_micros_since_unix_epoch__
    );
  }
};

// src/lib/uuid.ts
var Uuid = class _Uuid {
  __uuid__;
  /**
   * The nil UUID (all zeros).
   *
   * @example
   * ```ts
   * const uuid = Uuid.NIL;
   * console.assert(
   *   uuid.toString() === "00000000-0000-0000-0000-000000000000"
   * );
   * ```
   */
  static NIL = new _Uuid(0n);
  static MAX_UUID_BIGINT = 0xffffffffffffffffffffffffffffffffn;
  /**
   * The max UUID (all ones).
   *
   * @example
   * ```ts
   * const uuid = Uuid.MAX;
   * console.assert(
   *   uuid.toString() === "ffffffff-ffff-ffff-ffff-ffffffffffff"
   * );
   * ```
   */
  static MAX = new _Uuid(_Uuid.MAX_UUID_BIGINT);
  /**
   * Create a UUID from a raw 128-bit value.
   *
   * @param u - Unsigned 128-bit integer
   * @throws {Error} If the value is outside the valid UUID range
   */
  constructor(u) {
    if (u < 0n || u > _Uuid.MAX_UUID_BIGINT) {
      throw new Error("Invalid UUID: must be between 0 and `MAX_UUID_BIGINT`");
    }
    this.__uuid__ = u;
  }
  /**
   * Create a UUID `v4` from explicit random bytes.
   *
   * This method assumes the bytes are already sufficiently random.
   * It only sets the appropriate bits for the UUID version and variant.
   *
   * @param bytes - Exactly 16 random bytes
   * @returns A UUID `v4`
   * @throws {Error} If `bytes.length !== 16`
   *
   * @example
   * ```ts
   * const randomBytes = new Uint8Array(16);
   * const uuid = Uuid.fromRandomBytesV4(randomBytes);
   *
   * console.assert(
   *   uuid.toString() === "00000000-0000-4000-8000-000000000000"
   * );
   * ```
   */
  static fromRandomBytesV4(bytes) {
    if (bytes.length !== 16) throw new Error("UUID v4 requires 16 bytes");
    const arr = new Uint8Array(bytes);
    arr[6] = arr[6] & 15 | 64;
    arr[8] = arr[8] & 63 | 128;
    return new _Uuid(_Uuid.bytesToBigInt(arr));
  }
  /**
   * Generate a UUID `v7` using a monotonic counter from `0` to `2^31 - 1`,
   * a timestamp, and 4 random bytes.
   *
   * The counter wraps around on overflow.
   *
   * The UUID `v7` is structured as follows:
   *
   * ```ascii
   * ┌───────────────────────────────────────────────┬───────────────────┐
   * | B0  | B1  | B2  | B3  | B4  | B5              |         B6        |
   * ├───────────────────────────────────────────────┼───────────────────┤
   * |                 unix_ts_ms                    |      version 7    |
   * └───────────────────────────────────────────────┴───────────────────┘
   * ┌──────────────┬─────────┬──────────────────┬───────────────────────┐
   * | B7           | B8      | B9  | B10 | B11  | B12 | B13 | B14 | B15 |
   * ├──────────────┼─────────┼──────────────────┼───────────────────────┤
   * | counter_high | variant |    counter_low   |        random         |
   * └──────────────┴─────────┴──────────────────┴───────────────────────┘
   * ```
   *
   * @param counter - Mutable monotonic counter (31-bit)
   * @param now - Timestamp since the Unix epoch
   * @param randomBytes - Exactly 4 random bytes
   * @returns A UUID `v7`
   *
   * @throws {Error} If the `counter` is negative
   * @throws {Error} If the `timestamp` is before the Unix epoch
   * @throws {Error} If `randomBytes.length !== 4`
   *
   * @example
   * ```ts
   * const now = Timestamp.fromMillis(1_686_000_000_000n);
   * const counter = { value: 1 };
   * const randomBytes = new Uint8Array(4);
   *
   * const uuid = Uuid.fromCounterV7(counter, now, randomBytes);
   *
   * console.assert(
   *   uuid.toString() === "0000647e-5180-7000-8000-000200000000"
   * );
   * ```
   */
  static fromCounterV7(counter, now, randomBytes) {
    if (randomBytes.length !== 4) {
      throw new Error("`fromCounterV7` requires `randomBytes.length == 4`");
    }
    if (counter.value < 0) {
      throw new Error("`fromCounterV7` uuid `counter` must be non-negative");
    }
    if (now.__timestamp_micros_since_unix_epoch__ < 0) {
      throw new Error("`fromCounterV7` `timestamp` before unix epoch");
    }
    const counterVal = counter.value;
    counter.value = counterVal + 1 & 2147483647;
    const tsMs = now.toMillis() & 0xffffffffffffn;
    const bytes = new Uint8Array(16);
    bytes[0] = Number(tsMs >> 40n & 0xffn);
    bytes[1] = Number(tsMs >> 32n & 0xffn);
    bytes[2] = Number(tsMs >> 24n & 0xffn);
    bytes[3] = Number(tsMs >> 16n & 0xffn);
    bytes[4] = Number(tsMs >> 8n & 0xffn);
    bytes[5] = Number(tsMs & 0xffn);
    bytes[7] = counterVal >>> 23 & 255;
    bytes[9] = counterVal >>> 15 & 255;
    bytes[10] = counterVal >>> 7 & 255;
    bytes[11] = (counterVal & 127) << 1 & 255;
    bytes[12] |= randomBytes[0] & 127;
    bytes[13] = randomBytes[1];
    bytes[14] = randomBytes[2];
    bytes[15] = randomBytes[3];
    bytes[6] = bytes[6] & 15 | 112;
    bytes[8] = bytes[8] & 63 | 128;
    return new _Uuid(_Uuid.bytesToBigInt(bytes));
  }
  /**
   * Parse a UUID from a string representation.
   *
   * @param s - UUID string
   * @returns Parsed UUID
   * @throws {Error} If the string is not a valid UUID
   *
   * @example
   * ```ts
   * const s = "01888d6e-5c00-7000-8000-000000000000";
   * const uuid = Uuid.parse(s);
   *
   * console.assert(uuid.toString() === s);
   * ```
   */
  static parse(s) {
    const hex = s.replace(/-/g, "");
    if (hex.length !== 32) throw new Error("Invalid hex UUID");
    let v = 0n;
    for (let i = 0; i < 32; i += 2) {
      v = v << 8n | BigInt(parseInt(hex.slice(i, i + 2), 16));
    }
    return new _Uuid(v);
  }
  /** Convert to string (hyphenated form). */
  toString() {
    const bytes = _Uuid.bigIntToBytes(this.__uuid__);
    const hex = [...bytes].map((b) => b.toString(16).padStart(2, "0")).join("");
    return hex.slice(0, 8) + "-" + hex.slice(8, 12) + "-" + hex.slice(12, 16) + "-" + hex.slice(16, 20) + "-" + hex.slice(20);
  }
  /** Convert to bigint (u128). */
  asBigInt() {
    return this.__uuid__;
  }
  /** Return a `Uint8Array` of 16 bytes. */
  toBytes() {
    return _Uuid.bigIntToBytes(this.__uuid__);
  }
  static bytesToBigInt(bytes) {
    let result = 0n;
    for (const b of bytes) result = result << 8n | BigInt(b);
    return result;
  }
  static bigIntToBytes(value) {
    const bytes = new Uint8Array(16);
    for (let i = 15; i >= 0; i--) {
      bytes[i] = Number(value & 0xffn);
      value >>= 8n;
    }
    return bytes;
  }
  /**
   * Returns the version of this UUID.
   *
   * This represents the algorithm used to generate the value.
   *
   * @returns A `UuidVersion`
   * @throws {Error} If the version field is not recognized
   */
  getVersion() {
    const version = this.toBytes()[6] >> 4 & 15;
    switch (version) {
      case 4:
        return "V4";
      case 7:
        return "V7";
      default:
        if (this == _Uuid.NIL) {
          return "Nil";
        }
        if (this == _Uuid.MAX) {
          return "Max";
        }
        throw new Error(`Unsupported UUID version: ${version}`);
    }
  }
  /**
   * Extract the monotonic counter from a UUIDv7.
   *
   * Intended for testing and diagnostics.
   * Behavior is undefined if called on a non-V7 UUID.
   *
   * @returns 31-bit counter value
   */
  getCounter() {
    const bytes = this.toBytes();
    const high = bytes[7];
    const mid1 = bytes[9];
    const mid2 = bytes[10];
    const low = bytes[11] >>> 1;
    return high << 23 | mid1 << 15 | mid2 << 7 | low | 0;
  }
  compareTo(other) {
    if (this.__uuid__ < other.__uuid__) return -1;
    if (this.__uuid__ > other.__uuid__) return 1;
    return 0;
  }
  static getAlgebraicType() {
    return AlgebraicType.Product({
      elements: [
        {
          name: "__uuid__",
          algebraicType: AlgebraicType.U128
        }
      ]
    });
  }
};
var BinaryWriter = class {
  #buffer;
  #view;
  #offset = 0;
  constructor(size) {
    this.#buffer = new Uint8Array(size);
    this.#view = new DataView(this.#buffer.buffer);
  }
  #expandBuffer(additionalCapacity) {
    const minCapacity = this.#offset + additionalCapacity + 1;
    if (minCapacity <= this.#buffer.length) return;
    let newCapacity = this.#buffer.length * 2;
    if (newCapacity < minCapacity) newCapacity = minCapacity;
    const newBuffer = new Uint8Array(newCapacity);
    newBuffer.set(this.#buffer);
    this.#buffer = newBuffer;
    this.#view = new DataView(this.#buffer.buffer);
  }
  toBase64() {
    return fromByteArray(this.#buffer.subarray(0, this.#offset));
  }
  getBuffer() {
    return this.#buffer.slice(0, this.#offset);
  }
  get offset() {
    return this.#offset;
  }
  writeUInt8Array(value) {
    const length = value.length;
    this.#expandBuffer(4 + length);
    this.writeU32(length);
    this.#buffer.set(value, this.#offset);
    this.#offset += value.length;
  }
  writeBool(value) {
    this.#expandBuffer(1);
    this.#view.setUint8(this.#offset, value ? 1 : 0);
    this.#offset += 1;
  }
  writeByte(value) {
    this.#expandBuffer(1);
    this.#view.setUint8(this.#offset, value);
    this.#offset += 1;
  }
  writeI8(value) {
    this.#expandBuffer(1);
    this.#view.setInt8(this.#offset, value);
    this.#offset += 1;
  }
  writeU8(value) {
    this.#expandBuffer(1);
    this.#view.setUint8(this.#offset, value);
    this.#offset += 1;
  }
  writeI16(value) {
    this.#expandBuffer(2);
    this.#view.setInt16(this.#offset, value, true);
    this.#offset += 2;
  }
  writeU16(value) {
    this.#expandBuffer(2);
    this.#view.setUint16(this.#offset, value, true);
    this.#offset += 2;
  }
  writeI32(value) {
    this.#expandBuffer(4);
    this.#view.setInt32(this.#offset, value, true);
    this.#offset += 4;
  }
  writeU32(value) {
    this.#expandBuffer(4);
    this.#view.setUint32(this.#offset, value, true);
    this.#offset += 4;
  }
  writeI64(value) {
    this.#expandBuffer(8);
    this.#view.setBigInt64(this.#offset, value, true);
    this.#offset += 8;
  }
  writeU64(value) {
    this.#expandBuffer(8);
    this.#view.setBigUint64(this.#offset, value, true);
    this.#offset += 8;
  }
  writeU128(value) {
    this.#expandBuffer(16);
    const lowerPart = value & BigInt("0xFFFFFFFFFFFFFFFF");
    const upperPart = value >> BigInt(64);
    this.#view.setBigUint64(this.#offset, lowerPart, true);
    this.#view.setBigUint64(this.#offset + 8, upperPart, true);
    this.#offset += 16;
  }
  writeI128(value) {
    this.#expandBuffer(16);
    const lowerPart = value & BigInt("0xFFFFFFFFFFFFFFFF");
    const upperPart = value >> BigInt(64);
    this.#view.setBigInt64(this.#offset, lowerPart, true);
    this.#view.setBigInt64(this.#offset + 8, upperPart, true);
    this.#offset += 16;
  }
  writeU256(value) {
    this.#expandBuffer(32);
    const low_64_mask = BigInt("0xFFFFFFFFFFFFFFFF");
    const p0 = value & low_64_mask;
    const p1 = value >> BigInt(64 * 1) & low_64_mask;
    const p2 = value >> BigInt(64 * 2) & low_64_mask;
    const p3 = value >> BigInt(64 * 3);
    this.#view.setBigUint64(this.#offset + 8 * 0, p0, true);
    this.#view.setBigUint64(this.#offset + 8 * 1, p1, true);
    this.#view.setBigUint64(this.#offset + 8 * 2, p2, true);
    this.#view.setBigUint64(this.#offset + 8 * 3, p3, true);
    this.#offset += 32;
  }
  writeI256(value) {
    this.#expandBuffer(32);
    const low_64_mask = BigInt("0xFFFFFFFFFFFFFFFF");
    const p0 = value & low_64_mask;
    const p1 = value >> BigInt(64 * 1) & low_64_mask;
    const p2 = value >> BigInt(64 * 2) & low_64_mask;
    const p3 = value >> BigInt(64 * 3);
    this.#view.setBigUint64(this.#offset + 8 * 0, p0, true);
    this.#view.setBigUint64(this.#offset + 8 * 1, p1, true);
    this.#view.setBigUint64(this.#offset + 8 * 2, p2, true);
    this.#view.setBigInt64(this.#offset + 8 * 3, p3, true);
    this.#offset += 32;
  }
  writeF32(value) {
    this.#expandBuffer(4);
    this.#view.setFloat32(this.#offset, value, true);
    this.#offset += 4;
  }
  writeF64(value) {
    this.#expandBuffer(8);
    this.#view.setFloat64(this.#offset, value, true);
    this.#offset += 8;
  }
  writeString(value) {
    const encoder = new TextEncoder();
    const encodedString = encoder.encode(value);
    this.writeU32(encodedString.length);
    this.#expandBuffer(encodedString.length);
    this.#buffer.set(encodedString, this.#offset);
    this.#offset += encodedString.length;
  }
};

// src/lib/binary_reader.ts
var BinaryReader = class {
  /**
   * The DataView used to read values from the binary data.
   *
   * Note: The DataView's `byteOffset` is relative to the beginning of the
   * underlying ArrayBuffer, not the start of the provided Uint8Array input.
   * This `BinaryReader`'s `#offset` field is used to track the current read position
   * relative to the start of the provided Uint8Array input.
   */
  #view;
  /**
   * Represents the offset (in bytes) relative to the start of the DataView
   * and provided Uint8Array input.
   *
   * Note: This is *not* the absolute byte offset within the underlying ArrayBuffer.
   */
  #offset = 0;
  constructor(input) {
    this.#view = new DataView(input.buffer, input.byteOffset, input.byteLength);
    this.#offset = 0;
  }
  get offset() {
    return this.#offset;
  }
  get remaining() {
    return this.#view.byteLength - this.#offset;
  }
  /** Ensure we have at least `n` bytes left to read */
  #ensure(n) {
    if (this.#offset + n > this.#view.byteLength) {
      throw new RangeError(
        `Tried to read ${n} byte(s) at relative offset ${this.#offset}, but only ${this.remaining} byte(s) remain`
      );
    }
  }
  readUInt8Array() {
    const length = this.readU32();
    this.#ensure(length);
    return this.readBytes(length);
  }
  readBool() {
    const value = this.#view.getUint8(this.#offset);
    this.#offset += 1;
    return value !== 0;
  }
  readByte() {
    const value = this.#view.getUint8(this.#offset);
    this.#offset += 1;
    return value;
  }
  readBytes(length) {
    const array = new Uint8Array(
      this.#view.buffer,
      this.#view.byteOffset + this.#offset,
      length
    );
    this.#offset += length;
    return array;
  }
  readI8() {
    const value = this.#view.getInt8(this.#offset);
    this.#offset += 1;
    return value;
  }
  readU8() {
    return this.readByte();
  }
  readI16() {
    const value = this.#view.getInt16(this.#offset, true);
    this.#offset += 2;
    return value;
  }
  readU16() {
    const value = this.#view.getUint16(this.#offset, true);
    this.#offset += 2;
    return value;
  }
  readI32() {
    const value = this.#view.getInt32(this.#offset, true);
    this.#offset += 4;
    return value;
  }
  readU32() {
    const value = this.#view.getUint32(this.#offset, true);
    this.#offset += 4;
    return value;
  }
  readI64() {
    const value = this.#view.getBigInt64(this.#offset, true);
    this.#offset += 8;
    return value;
  }
  readU64() {
    const value = this.#view.getBigUint64(this.#offset, true);
    this.#offset += 8;
    return value;
  }
  readU128() {
    const lowerPart = this.#view.getBigUint64(this.#offset, true);
    const upperPart = this.#view.getBigUint64(this.#offset + 8, true);
    this.#offset += 16;
    return (upperPart << BigInt(64)) + lowerPart;
  }
  readI128() {
    const lowerPart = this.#view.getBigUint64(this.#offset, true);
    const upperPart = this.#view.getBigInt64(this.#offset + 8, true);
    this.#offset += 16;
    return (upperPart << BigInt(64)) + lowerPart;
  }
  readU256() {
    const p0 = this.#view.getBigUint64(this.#offset, true);
    const p1 = this.#view.getBigUint64(this.#offset + 8, true);
    const p2 = this.#view.getBigUint64(this.#offset + 16, true);
    const p3 = this.#view.getBigUint64(this.#offset + 24, true);
    this.#offset += 32;
    return (p3 << BigInt(3 * 64)) + (p2 << BigInt(2 * 64)) + (p1 << BigInt(1 * 64)) + p0;
  }
  readI256() {
    const p0 = this.#view.getBigUint64(this.#offset, true);
    const p1 = this.#view.getBigUint64(this.#offset + 8, true);
    const p2 = this.#view.getBigUint64(this.#offset + 16, true);
    const p3 = this.#view.getBigInt64(this.#offset + 24, true);
    this.#offset += 32;
    return (p3 << BigInt(3 * 64)) + (p2 << BigInt(2 * 64)) + (p1 << BigInt(1 * 64)) + p0;
  }
  readF32() {
    const value = this.#view.getFloat32(this.#offset, true);
    this.#offset += 4;
    return value;
  }
  readF64() {
    const value = this.#view.getFloat64(this.#offset, true);
    this.#offset += 8;
    return value;
  }
  readString() {
    const uint8Array = this.readUInt8Array();
    return new TextDecoder("utf-8").decode(uint8Array);
  }
};

// src/lib/util.ts
function uint8ArrayToHexString(array) {
  return Array.prototype.map.call(array.reverse(), (x) => ("00" + x.toString(16)).slice(-2)).join("");
}
function uint8ArrayToU128(array) {
  if (array.length != 16) {
    throw new Error(`Uint8Array is not 16 bytes long: ${array}`);
  }
  return new BinaryReader(array).readU128();
}
function uint8ArrayToU256(array) {
  if (array.length != 32) {
    throw new Error(`Uint8Array is not 32 bytes long: [${array}]`);
  }
  return new BinaryReader(array).readU256();
}
function hexStringToUint8Array(str) {
  if (str.startsWith("0x")) {
    str = str.slice(2);
  }
  const matches = str.match(/.{1,2}/g) || [];
  const data = Uint8Array.from(
    matches.map((byte) => parseInt(byte, 16))
  );
  return data.reverse();
}
function hexStringToU128(str) {
  return uint8ArrayToU128(hexStringToUint8Array(str));
}
function hexStringToU256(str) {
  return uint8ArrayToU256(hexStringToUint8Array(str));
}
function u128ToUint8Array(data) {
  const writer = new BinaryWriter(16);
  writer.writeU128(data);
  return writer.getBuffer();
}
function u128ToHexString(data) {
  return uint8ArrayToHexString(u128ToUint8Array(data));
}
function u256ToUint8Array(data) {
  const writer = new BinaryWriter(32);
  writer.writeU256(data);
  return writer.getBuffer();
}
function u256ToHexString(data) {
  return uint8ArrayToHexString(u256ToUint8Array(data));
}

// src/lib/identity.ts
var Identity = class _Identity {
  __identity__;
  /**
   * Creates a new `Identity`.
   *
   * `data` can be a hexadecimal string or a `bigint`.
   */
  constructor(data) {
    this.__identity__ = typeof data === "string" ? hexStringToU256(data) : data;
  }
  /**
   * Get the algebraic type representation of the {@link Identity} type.
   * @returns The algebraic type representation of the type.
   */
  static getAlgebraicType() {
    return AlgebraicType.Product({
      elements: [{ name: "__identity__", algebraicType: AlgebraicType.U256 }]
    });
  }
  /**
   * Check if two identities are equal.
   */
  isEqual(other) {
    return this.toHexString() === other.toHexString();
  }
  /**
   * Check if two identities are equal.
   */
  equals(other) {
    return this.isEqual(other);
  }
  /**
   * Print the identity as a hexadecimal string.
   */
  toHexString() {
    return u256ToHexString(this.__identity__);
  }
  /**
   * Convert the address to a Uint8Array.
   */
  toUint8Array() {
    return u256ToUint8Array(this.__identity__);
  }
  /**
   * Parse an Identity from a hexadecimal string.
   */
  static fromString(str) {
    return new _Identity(str);
  }
  /**
   * Zero identity (0x0000000000000000000000000000000000000000000000000000000000000000)
   */
  static zero() {
    return new _Identity(0n);
  }
  toString() {
    return this.toHexString();
  }
};

// src/lib/algebraic_type.ts
var AlgebraicType = {
  Ref: (value) => ({ tag: "Ref", value }),
  Sum: (value) => ({
    tag: "Sum",
    value
  }),
  Product: (value) => ({
    tag: "Product",
    value
  }),
  Array: (value) => ({
    tag: "Array",
    value
  }),
  String: { tag: "String" },
  Bool: { tag: "Bool" },
  I8: { tag: "I8" },
  U8: { tag: "U8" },
  I16: { tag: "I16" },
  U16: { tag: "U16" },
  I32: { tag: "I32" },
  U32: { tag: "U32" },
  I64: { tag: "I64" },
  U64: { tag: "U64" },
  I128: { tag: "I128" },
  U128: { tag: "U128" },
  I256: { tag: "I256" },
  U256: { tag: "U256" },
  F32: { tag: "F32" },
  F64: { tag: "F64" },
  serializeValue(writer, ty, value, typespace) {
    if (ty.tag === "Ref") {
      if (!typespace)
        throw new Error("cannot serialize refs without a typespace");
      while (ty.tag === "Ref") ty = typespace.types[ty.value];
    }
    switch (ty.tag) {
      case "Product":
        ProductType.serializeValue(writer, ty.value, value, typespace);
        break;
      case "Sum":
        SumType.serializeValue(writer, ty.value, value, typespace);
        break;
      case "Array":
        if (ty.value.tag === "U8") {
          writer.writeUInt8Array(value);
        } else {
          const elemType = ty.value;
          writer.writeU32(value.length);
          for (const elem of value) {
            AlgebraicType.serializeValue(writer, elemType, elem, typespace);
          }
        }
        break;
      case "Bool":
        writer.writeBool(value);
        break;
      case "I8":
        writer.writeI8(value);
        break;
      case "U8":
        writer.writeU8(value);
        break;
      case "I16":
        writer.writeI16(value);
        break;
      case "U16":
        writer.writeU16(value);
        break;
      case "I32":
        writer.writeI32(value);
        break;
      case "U32":
        writer.writeU32(value);
        break;
      case "I64":
        writer.writeI64(value);
        break;
      case "U64":
        writer.writeU64(value);
        break;
      case "I128":
        writer.writeI128(value);
        break;
      case "U128":
        writer.writeU128(value);
        break;
      case "I256":
        writer.writeI256(value);
        break;
      case "U256":
        writer.writeU256(value);
        break;
      case "F32":
        writer.writeF32(value);
        break;
      case "F64":
        writer.writeF64(value);
        break;
      case "String":
        writer.writeString(value);
        break;
    }
  },
  deserializeValue: function(reader, ty, typespace) {
    if (ty.tag === "Ref") {
      if (!typespace)
        throw new Error("cannot deserialize refs without a typespace");
      while (ty.tag === "Ref") ty = typespace.types[ty.value];
    }
    switch (ty.tag) {
      case "Product":
        return ProductType.deserializeValue(reader, ty.value, typespace);
      case "Sum":
        return SumType.deserializeValue(reader, ty.value, typespace);
      case "Array":
        if (ty.value.tag === "U8") {
          return reader.readUInt8Array();
        } else {
          const elemType = ty.value;
          const length = reader.readU32();
          const result = [];
          for (let i = 0; i < length; i++) {
            result.push(
              AlgebraicType.deserializeValue(reader, elemType, typespace)
            );
          }
          return result;
        }
      case "Bool":
        return reader.readBool();
      case "I8":
        return reader.readI8();
      case "U8":
        return reader.readU8();
      case "I16":
        return reader.readI16();
      case "U16":
        return reader.readU16();
      case "I32":
        return reader.readI32();
      case "U32":
        return reader.readU32();
      case "I64":
        return reader.readI64();
      case "U64":
        return reader.readU64();
      case "I128":
        return reader.readI128();
      case "U128":
        return reader.readU128();
      case "I256":
        return reader.readI256();
      case "U256":
        return reader.readU256();
      case "F32":
        return reader.readF32();
      case "F64":
        return reader.readF64();
      case "String":
        return reader.readString();
    }
  },
  /**
   * Convert a value of the algebraic type into something that can be used as a key in a map.
   * There are no guarantees about being able to order it.
   * This is only guaranteed to be comparable to other values of the same type.
   * @param value A value of the algebraic type
   * @returns Something that can be used as a key in a map.
   */
  intoMapKey: function(ty, value) {
    switch (ty.tag) {
      case "U8":
      case "U16":
      case "U32":
      case "U64":
      case "U128":
      case "U256":
      case "I8":
      case "I16":
      case "I32":
      case "I64":
      case "I128":
      case "I256":
      case "F32":
      case "F64":
      case "String":
      case "Bool":
        return value;
      case "Product":
        return ProductType.intoMapKey(ty.value, value);
      default: {
        const writer = new BinaryWriter(10);
        AlgebraicType.serializeValue(writer, ty, value);
        return writer.toBase64();
      }
    }
  }
};
var ProductType = {
  serializeValue(writer, ty, value, typespace) {
    for (const element of ty.elements) {
      AlgebraicType.serializeValue(
        writer,
        element.algebraicType,
        value[element.name],
        typespace
      );
    }
  },
  deserializeValue(reader, ty, typespace) {
    const result = {};
    if (ty.elements.length === 1) {
      if (ty.elements[0].name === "__time_duration_micros__") {
        return new TimeDuration(reader.readI64());
      }
      if (ty.elements[0].name === "__timestamp_micros_since_unix_epoch__") {
        return new Timestamp(reader.readI64());
      }
      if (ty.elements[0].name === "__identity__") {
        return new Identity(reader.readU256());
      }
      if (ty.elements[0].name === "__connection_id__") {
        return new ConnectionId(reader.readU128());
      }
      if (ty.elements[0].name === "__uuid__") {
        return new Uuid(reader.readU128());
      }
    }
    for (const element of ty.elements) {
      result[element.name] = AlgebraicType.deserializeValue(
        reader,
        element.algebraicType,
        typespace
      );
    }
    return result;
  },
  intoMapKey(ty, value) {
    if (ty.elements.length === 1) {
      if (ty.elements[0].name === "__time_duration_micros__") {
        return value.__time_duration_micros__;
      }
      if (ty.elements[0].name === "__timestamp_micros_since_unix_epoch__") {
        return value.__timestamp_micros_since_unix_epoch__;
      }
      if (ty.elements[0].name === "__identity__") {
        return value.__identity__;
      }
      if (ty.elements[0].name === "__connection_id__") {
        return value.__connection_id__;
      }
      if (ty.elements[0].name === "__uuid__") {
        return value.__uuid__;
      }
    }
    const writer = new BinaryWriter(10);
    AlgebraicType.serializeValue(writer, AlgebraicType.Product(ty), value);
    return writer.toBase64();
  }
};
var SumType = {
  serializeValue: function(writer, ty, value, typespace) {
    if (ty.variants.length == 2 && ty.variants[0].name === "some" && ty.variants[1].name === "none") {
      if (value !== null && value !== void 0) {
        writer.writeByte(0);
        AlgebraicType.serializeValue(
          writer,
          ty.variants[0].algebraicType,
          value,
          typespace
        );
      } else {
        writer.writeByte(1);
      }
    } else if (ty.variants.length == 2 && ty.variants[0].name === "ok" && ty.variants[1].name === "err") {
      let variantName;
      let innerValue;
      let index;
      if ("ok" in value) {
        variantName = "ok";
        innerValue = value.ok;
        index = 0;
      } else {
        variantName = "err";
        innerValue = value.err;
        index = 1;
      }
      if (index < 0) {
        throw `Result serialization error: variant '${variantName}' not found in ${JSON.stringify(ty)}`;
      }
      writer.writeU8(index);
      AlgebraicType.serializeValue(
        writer,
        ty.variants[index].algebraicType,
        innerValue,
        typespace
      );
    } else {
      const variant = value["tag"];
      const index = ty.variants.findIndex((v) => v.name === variant);
      if (index < 0) {
        throw `Can't serialize a sum type, couldn't find ${value.tag} tag ${JSON.stringify(value)} in variants ${JSON.stringify(ty)}`;
      }
      writer.writeU8(index);
      AlgebraicType.serializeValue(
        writer,
        ty.variants[index].algebraicType,
        value["value"],
        typespace
      );
    }
  },
  deserializeValue: function(reader, ty, typespace) {
    const tag = reader.readU8();
    if (ty.variants.length == 2 && ty.variants[0].name === "some" && ty.variants[1].name === "none") {
      if (tag === 0) {
        return AlgebraicType.deserializeValue(
          reader,
          ty.variants[0].algebraicType,
          typespace
        );
      } else if (tag === 1) {
        return void 0;
      } else {
        throw `Can't deserialize an option type, couldn't find ${tag} tag`;
      }
    } else if (ty.variants.length == 2 && ty.variants[0].name === "ok" && ty.variants[1].name === "err") {
      if (tag === 0) {
        const value = AlgebraicType.deserializeValue(
          reader,
          ty.variants[0].algebraicType,
          typespace
        );
        return { ok: value };
      } else if (tag === 1) {
        const value = AlgebraicType.deserializeValue(
          reader,
          ty.variants[1].algebraicType,
          typespace
        );
        return { err: value };
      } else {
        throw `Can't deserialize a result type, couldn't find ${tag} tag`;
      }
    } else {
      const variant = ty.variants[tag];
      const value = AlgebraicType.deserializeValue(
        reader,
        variant.algebraicType,
        typespace
      );
      return { tag: variant.name, value };
    }
  }
};

// src/lib/connection_id.ts
var ConnectionId = class _ConnectionId {
  __connection_id__;
  /**
   * Creates a new `ConnectionId`.
   */
  constructor(data) {
    this.__connection_id__ = data;
  }
  /**
   * Get the algebraic type representation of the {@link ConnectionId} type.
   * @returns The algebraic type representation of the type.
   */
  static getAlgebraicType() {
    return AlgebraicType.Product({
      elements: [
        { name: "__connection_id__", algebraicType: AlgebraicType.U128 }
      ]
    });
  }
  isZero() {
    return this.__connection_id__ === BigInt(0);
  }
  static nullIfZero(addr) {
    if (addr.isZero()) {
      return null;
    } else {
      return addr;
    }
  }
  static random() {
    function randomU8() {
      return Math.floor(Math.random() * 255);
    }
    let result = BigInt(0);
    for (let i = 0; i < 16; i++) {
      result = result << BigInt(8) | BigInt(randomU8());
    }
    return new _ConnectionId(result);
  }
  /**
   * Compare two connection IDs for equality.
   */
  isEqual(other) {
    return this.__connection_id__ == other.__connection_id__;
  }
  /**
   * Check if two connection IDs are equal.
   */
  equals(other) {
    return this.isEqual(other);
  }
  /**
   * Print the connection ID as a hexadecimal string.
   */
  toHexString() {
    return u128ToHexString(this.__connection_id__);
  }
  /**
   * Convert the connection ID to a Uint8Array.
   */
  toUint8Array() {
    return u128ToUint8Array(this.__connection_id__);
  }
  /**
   * Parse a connection ID from a hexadecimal string.
   */
  static fromString(str) {
    return new _ConnectionId(hexStringToU128(str));
  }
  static fromStringOrNull(str) {
    const addr = _ConnectionId.fromString(str);
    if (addr.isZero()) {
      return null;
    } else {
      return addr;
    }
  }
};
var SpacetimeDBContext = createContext(
  void 0
);
function useSpacetimeDB() {
  const context = useContext(SpacetimeDBContext);
  if (!context) {
    throw new Error(
      "useSpacetimeDB must be used within a SpacetimeDBProvider component. Did you forget to add a `SpacetimeDBProvider` to your component tree?"
    );
  }
  return context;
}

// src/react/SpacetimeDBProvider.ts
function SpacetimeDBProvider({
  connectionBuilder,
  children
}) {
  const connRef = React.useRef(null);
  const getConnection = React.useCallback(() => connRef.current, []);
  const [state, setState] = React.useState({
    isActive: false,
    identity: void 0,
    token: void 0,
    connectionId: ConnectionId.random(),
    connectionError: void 0,
    getConnection
  });
  React.useEffect(() => {
    if (!connRef.current) {
      connRef.current = connectionBuilder.build();
    }
    const onConnect = (conn2) => {
      setState((s) => ({
        ...s,
        isActive: conn2.isActive,
        identity: conn2.identity,
        token: conn2.token,
        connectionId: conn2.connectionId
      }));
    };
    const onDisconnect = (ctx) => {
      setState((s) => ({
        ...s,
        isActive: ctx.isActive
      }));
    };
    const onConnectError = (ctx, err) => {
      setState((s) => ({
        ...s,
        isActive: ctx.isActive,
        connectionError: err
      }));
    };
    connectionBuilder.onConnect(onConnect);
    connectionBuilder.onDisconnect(onDisconnect);
    connectionBuilder.onConnectError(onConnectError);
    const conn = connRef.current;
    setState((s) => ({
      ...s,
      isActive: conn.isActive,
      identity: conn.identity,
      token: conn.token,
      connectionId: conn.connectionId
    }));
    return () => {
      connRef.current?.removeOnConnect(onConnect);
      connRef.current?.removeOnDisconnect(onDisconnect);
      connRef.current?.removeOnConnectError(onConnectError);
      connRef.current?.disconnect();
      connRef.current = null;
    };
  }, [connectionBuilder]);
  return React.createElement(
    SpacetimeDBContext.Provider,
    { value: state },
    children
  );
}
var eq = (key, value) => ({ type: "eq", key, value });
function evaluate(expr, row) {
  switch (expr.type) {
    case "eq": {
      const v = row[expr.key];
      if (typeof v === "string" || typeof v === "number" || typeof v === "boolean") {
        return v === expr.value;
      }
      return false;
    }
    case "and":
      return expr.children.length === 0 || expr.children.every((c) => evaluate(c, row));
    case "or":
      return expr.children.length !== 0 && expr.children.some((c) => evaluate(c, row));
  }
}
function formatValue(v) {
  switch (typeof v) {
    case "string":
      return `'${v.replace(/'/g, "''")}'`;
    case "number":
      return Number.isFinite(v) ? String(v) : `'${String(v)}'`;
    case "boolean":
      return v ? "TRUE" : "FALSE";
  }
}
function escapeIdent(id) {
  if (/^[A-Za-z_][A-Za-z0-9_]*$/.test(id)) return id;
  return `"${id.replace(/"/g, '""')}"`;
}
function parenthesize(s) {
  if (!s.includes(" AND ") && !s.includes(" OR ")) return s;
  return `(${s})`;
}
function toString(tableDef, expr) {
  switch (expr.type) {
    case "eq": {
      const key = tableDef.columns[expr.key].columnMetadata.name ?? expr.key;
      return `${escapeIdent(key)} = ${formatValue(expr.value)}`;
    }
    case "and":
      return parenthesize(
        expr.children.map((expr2) => toString(tableDef, expr2)).join(" AND ")
      );
    case "or":
      return parenthesize(
        expr.children.map((expr2) => toString(tableDef, expr2)).join(" OR ")
      );
  }
}
function where(expr) {
  return expr;
}
function classifyMembership(where2, oldRow, newRow) {
  if (!where2) {
    return "stayIn";
  }
  const oldIn = evaluate(where2, oldRow);
  const newIn = evaluate(where2, newRow);
  if (oldIn && !newIn) {
    return "leave";
  }
  if (!oldIn && newIn) {
    return "enter";
  }
  if (oldIn && newIn) {
    return "stayIn";
  }
  return "stayOut";
}
function useTable(tableDef, whereClauseOrCallbacks, callbacks) {
  const tableName = tableDef.name;
  const accessorName = tableDef.accessorName;
  let whereClause;
  if (whereClauseOrCallbacks && typeof whereClauseOrCallbacks === "object" && "type" in whereClauseOrCallbacks) {
    whereClause = whereClauseOrCallbacks;
  } else {
    callbacks = whereClauseOrCallbacks;
  }
  const [subscribeApplied, setSubscribeApplied] = useState(false);
  let connectionState;
  try {
    connectionState = useSpacetimeDB();
  } catch {
    throw new Error(
      "Could not find SpacetimeDB client! Did you forget to add a `SpacetimeDBProvider`? `useTable` must be used in the React component tree under a `SpacetimeDBProvider` component."
    );
  }
  const query = `SELECT * FROM ${tableName}` + (whereClause ? ` WHERE ${toString(tableDef, whereClause)}` : "");
  const latestTransactionEvent = useRef(null);
  const lastSnapshotRef = useRef(null);
  const whereKey = whereClause ? toString(tableDef, whereClause) : "";
  const computeSnapshot = useCallback(() => {
    const connection = connectionState.getConnection();
    if (!connection) {
      return [[], false];
    }
    const table = connection.db[accessorName];
    const result = whereClause ? Array.from(table.iter()).filter(
      (row) => evaluate(whereClause, row)
    ) : Array.from(table.iter());
    return [result, subscribeApplied];
  }, [connectionState, accessorName, whereKey, subscribeApplied]);
  useEffect(() => {
    const connection = connectionState.getConnection();
    if (connectionState.isActive && connection) {
      const cancel = connection.subscriptionBuilder().onApplied(() => {
        setSubscribeApplied(true);
      }).subscribe(query);
      return () => {
        cancel.unsubscribe();
      };
    }
  }, [query, connectionState.isActive, connectionState]);
  const subscribe = useCallback(
    (onStoreChange) => {
      const onInsert = (ctx, row) => {
        if (whereClause && !evaluate(whereClause, row)) {
          return;
        }
        callbacks?.onInsert?.(row);
        if (ctx.event !== latestTransactionEvent.current || !latestTransactionEvent.current) {
          latestTransactionEvent.current = ctx.event;
          lastSnapshotRef.current = computeSnapshot();
          onStoreChange();
        }
      };
      const onDelete = (ctx, row) => {
        if (whereClause && !evaluate(whereClause, row)) {
          return;
        }
        callbacks?.onDelete?.(row);
        if (ctx.event !== latestTransactionEvent.current || !latestTransactionEvent.current) {
          latestTransactionEvent.current = ctx.event;
          lastSnapshotRef.current = computeSnapshot();
          onStoreChange();
        }
      };
      const onUpdate = (ctx, oldRow, newRow) => {
        const change = classifyMembership(whereClause, oldRow, newRow);
        switch (change) {
          case "leave":
            callbacks?.onDelete?.(oldRow);
            break;
          case "enter":
            callbacks?.onInsert?.(newRow);
            break;
          case "stayIn":
            callbacks?.onUpdate?.(oldRow, newRow);
            break;
          case "stayOut":
            return;
        }
        if (ctx.event !== latestTransactionEvent.current || !latestTransactionEvent.current) {
          latestTransactionEvent.current = ctx.event;
          lastSnapshotRef.current = computeSnapshot();
          onStoreChange();
        }
      };
      const connection = connectionState.getConnection();
      if (!connection) {
        return () => {
        };
      }
      const table = connection.db[accessorName];
      table.onInsert(onInsert);
      table.onDelete(onDelete);
      table.onUpdate?.(onUpdate);
      return () => {
        table.removeOnInsert(onInsert);
        table.removeOnDelete(onDelete);
        table.removeOnUpdate?.(onUpdate);
      };
    },
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [
      connectionState,
      accessorName,
      whereKey,
      callbacks?.onDelete,
      callbacks?.onInsert,
      callbacks?.onUpdate
    ]
  );
  const getSnapshot = useCallback(() => {
    if (!lastSnapshotRef.current) {
      lastSnapshotRef.current = computeSnapshot();
    }
    return lastSnapshotRef.current;
  }, [computeSnapshot]);
  return useSyncExternalStore(subscribe, getSnapshot, getSnapshot);
}
function useReducer(reducerDef) {
  const { getConnection, isActive } = useSpacetimeDB();
  const reducerName = reducerDef.accessorName;
  const queueRef = useRef([]);
  useEffect(() => {
    const conn = getConnection();
    if (!conn) {
      return;
    }
    const fn = conn.reducers[reducerName];
    if (queueRef.current.length) {
      const pending = queueRef.current.splice(0);
      for (const params of pending) {
        fn(...params);
      }
    }
  }, [getConnection, reducerName, isActive]);
  return useCallback(
    (...params) => {
      const conn = getConnection();
      if (!conn) {
        queueRef.current.push(params);
        return;
      }
      const fn = conn.reducers[reducerName];
      return fn(...params);
    },
    [getConnection, reducerName]
  );
}

export { SpacetimeDBProvider, eq, useReducer, useSpacetimeDB, useTable, where };
//# sourceMappingURL=index.mjs.map
//# sourceMappingURL=index.mjs.map