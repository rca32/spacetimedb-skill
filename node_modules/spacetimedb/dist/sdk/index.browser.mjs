import { fromByteArray } from 'base64-js';

// src/lib/time_duration.ts
var TimeDuration = class _TimeDuration {
  __time_duration_micros__;
  static MICROS_PER_MILLIS = 1000n;
  /**
   * Get the algebraic type representation of the {@link TimeDuration} type.
   * @returns The algebraic type representation of the type.
   */
  static getAlgebraicType() {
    return AlgebraicType.Product({
      elements: [
        {
          name: "__time_duration_micros__",
          algebraicType: AlgebraicType.I64
        }
      ]
    });
  }
  static isTimeDuration(algebraicType) {
    if (algebraicType.tag !== "Product") {
      return false;
    }
    const elements = algebraicType.value.elements;
    if (elements.length !== 1) {
      return false;
    }
    const microsElement = elements[0];
    return microsElement.name === "__time_duration_micros__" && microsElement.algebraicType.tag === "I64";
  }
  get micros() {
    return this.__time_duration_micros__;
  }
  get millis() {
    return Number(this.micros / _TimeDuration.MICROS_PER_MILLIS);
  }
  constructor(micros) {
    this.__time_duration_micros__ = micros;
  }
  static fromMillis(millis) {
    return new _TimeDuration(BigInt(millis) * _TimeDuration.MICROS_PER_MILLIS);
  }
  /** This outputs the same string format that we use in the host and in Rust modules */
  toString() {
    const micros = this.micros;
    const sign = micros < 0 ? "-" : "+";
    const pos = micros < 0 ? -micros : micros;
    const secs = pos / 1000000n;
    const micros_remaining = pos % 1000000n;
    return `${sign}${secs}.${String(micros_remaining).padStart(6, "0")}`;
  }
};

// src/lib/timestamp.ts
var Timestamp = class _Timestamp {
  __timestamp_micros_since_unix_epoch__;
  static MICROS_PER_MILLIS = 1000n;
  get microsSinceUnixEpoch() {
    return this.__timestamp_micros_since_unix_epoch__;
  }
  constructor(micros) {
    this.__timestamp_micros_since_unix_epoch__ = micros;
  }
  /**
   * Get the algebraic type representation of the {@link Timestamp} type.
   * @returns The algebraic type representation of the type.
   */
  static getAlgebraicType() {
    return AlgebraicType.Product({
      elements: [
        {
          name: "__timestamp_micros_since_unix_epoch__",
          algebraicType: AlgebraicType.I64
        }
      ]
    });
  }
  static isTimestamp(algebraicType) {
    if (algebraicType.tag !== "Product") {
      return false;
    }
    const elements = algebraicType.value.elements;
    if (elements.length !== 1) {
      return false;
    }
    const microsElement = elements[0];
    return microsElement.name === "__timestamp_micros_since_unix_epoch__" && microsElement.algebraicType.tag === "I64";
  }
  /**
   * The Unix epoch, the midnight at the beginning of January 1, 1970, UTC.
   */
  static UNIX_EPOCH = new _Timestamp(0n);
  /**
   * Get a `Timestamp` representing the execution environment's belief of the current moment in time.
   */
  static now() {
    return _Timestamp.fromDate(/* @__PURE__ */ new Date());
  }
  /** Convert to milliseconds since Unix epoch. */
  toMillis() {
    return this.microsSinceUnixEpoch / 1000n;
  }
  /**
   * Get a `Timestamp` representing the same point in time as `date`.
   */
  static fromDate(date) {
    const millis = date.getTime();
    const micros = BigInt(millis) * _Timestamp.MICROS_PER_MILLIS;
    return new _Timestamp(micros);
  }
  /**
   * Get a `Date` representing approximately the same point in time as `this`.
   *
   * This method truncates to millisecond precision,
   * and throws `RangeError` if the `Timestamp` is outside the range representable as a `Date`.
   */
  toDate() {
    const micros = this.__timestamp_micros_since_unix_epoch__;
    const millis = micros / _Timestamp.MICROS_PER_MILLIS;
    if (millis > BigInt(Number.MAX_SAFE_INTEGER) || millis < BigInt(Number.MIN_SAFE_INTEGER)) {
      throw new RangeError(
        "Timestamp is outside of the representable range of JS's Date"
      );
    }
    return new Date(Number(millis));
  }
  since(other) {
    return new TimeDuration(
      this.__timestamp_micros_since_unix_epoch__ - other.__timestamp_micros_since_unix_epoch__
    );
  }
};

// src/lib/uuid.ts
var Uuid = class _Uuid {
  __uuid__;
  /**
   * The nil UUID (all zeros).
   *
   * @example
   * ```ts
   * const uuid = Uuid.NIL;
   * console.assert(
   *   uuid.toString() === "00000000-0000-0000-0000-000000000000"
   * );
   * ```
   */
  static NIL = new _Uuid(0n);
  static MAX_UUID_BIGINT = 0xffffffffffffffffffffffffffffffffn;
  /**
   * The max UUID (all ones).
   *
   * @example
   * ```ts
   * const uuid = Uuid.MAX;
   * console.assert(
   *   uuid.toString() === "ffffffff-ffff-ffff-ffff-ffffffffffff"
   * );
   * ```
   */
  static MAX = new _Uuid(_Uuid.MAX_UUID_BIGINT);
  /**
   * Create a UUID from a raw 128-bit value.
   *
   * @param u - Unsigned 128-bit integer
   * @throws {Error} If the value is outside the valid UUID range
   */
  constructor(u) {
    if (u < 0n || u > _Uuid.MAX_UUID_BIGINT) {
      throw new Error("Invalid UUID: must be between 0 and `MAX_UUID_BIGINT`");
    }
    this.__uuid__ = u;
  }
  /**
   * Create a UUID `v4` from explicit random bytes.
   *
   * This method assumes the bytes are already sufficiently random.
   * It only sets the appropriate bits for the UUID version and variant.
   *
   * @param bytes - Exactly 16 random bytes
   * @returns A UUID `v4`
   * @throws {Error} If `bytes.length !== 16`
   *
   * @example
   * ```ts
   * const randomBytes = new Uint8Array(16);
   * const uuid = Uuid.fromRandomBytesV4(randomBytes);
   *
   * console.assert(
   *   uuid.toString() === "00000000-0000-4000-8000-000000000000"
   * );
   * ```
   */
  static fromRandomBytesV4(bytes) {
    if (bytes.length !== 16) throw new Error("UUID v4 requires 16 bytes");
    const arr = new Uint8Array(bytes);
    arr[6] = arr[6] & 15 | 64;
    arr[8] = arr[8] & 63 | 128;
    return new _Uuid(_Uuid.bytesToBigInt(arr));
  }
  /**
   * Generate a UUID `v7` using a monotonic counter from `0` to `2^31 - 1`,
   * a timestamp, and 4 random bytes.
   *
   * The counter wraps around on overflow.
   *
   * The UUID `v7` is structured as follows:
   *
   * ```ascii
   * ┌───────────────────────────────────────────────┬───────────────────┐
   * | B0  | B1  | B2  | B3  | B4  | B5              |         B6        |
   * ├───────────────────────────────────────────────┼───────────────────┤
   * |                 unix_ts_ms                    |      version 7    |
   * └───────────────────────────────────────────────┴───────────────────┘
   * ┌──────────────┬─────────┬──────────────────┬───────────────────────┐
   * | B7           | B8      | B9  | B10 | B11  | B12 | B13 | B14 | B15 |
   * ├──────────────┼─────────┼──────────────────┼───────────────────────┤
   * | counter_high | variant |    counter_low   |        random         |
   * └──────────────┴─────────┴──────────────────┴───────────────────────┘
   * ```
   *
   * @param counter - Mutable monotonic counter (31-bit)
   * @param now - Timestamp since the Unix epoch
   * @param randomBytes - Exactly 4 random bytes
   * @returns A UUID `v7`
   *
   * @throws {Error} If the `counter` is negative
   * @throws {Error} If the `timestamp` is before the Unix epoch
   * @throws {Error} If `randomBytes.length !== 4`
   *
   * @example
   * ```ts
   * const now = Timestamp.fromMillis(1_686_000_000_000n);
   * const counter = { value: 1 };
   * const randomBytes = new Uint8Array(4);
   *
   * const uuid = Uuid.fromCounterV7(counter, now, randomBytes);
   *
   * console.assert(
   *   uuid.toString() === "0000647e-5180-7000-8000-000200000000"
   * );
   * ```
   */
  static fromCounterV7(counter, now, randomBytes) {
    if (randomBytes.length !== 4) {
      throw new Error("`fromCounterV7` requires `randomBytes.length == 4`");
    }
    if (counter.value < 0) {
      throw new Error("`fromCounterV7` uuid `counter` must be non-negative");
    }
    if (now.__timestamp_micros_since_unix_epoch__ < 0) {
      throw new Error("`fromCounterV7` `timestamp` before unix epoch");
    }
    const counterVal = counter.value;
    counter.value = counterVal + 1 & 2147483647;
    const tsMs = now.toMillis() & 0xffffffffffffn;
    const bytes = new Uint8Array(16);
    bytes[0] = Number(tsMs >> 40n & 0xffn);
    bytes[1] = Number(tsMs >> 32n & 0xffn);
    bytes[2] = Number(tsMs >> 24n & 0xffn);
    bytes[3] = Number(tsMs >> 16n & 0xffn);
    bytes[4] = Number(tsMs >> 8n & 0xffn);
    bytes[5] = Number(tsMs & 0xffn);
    bytes[7] = counterVal >>> 23 & 255;
    bytes[9] = counterVal >>> 15 & 255;
    bytes[10] = counterVal >>> 7 & 255;
    bytes[11] = (counterVal & 127) << 1 & 255;
    bytes[12] |= randomBytes[0] & 127;
    bytes[13] = randomBytes[1];
    bytes[14] = randomBytes[2];
    bytes[15] = randomBytes[3];
    bytes[6] = bytes[6] & 15 | 112;
    bytes[8] = bytes[8] & 63 | 128;
    return new _Uuid(_Uuid.bytesToBigInt(bytes));
  }
  /**
   * Parse a UUID from a string representation.
   *
   * @param s - UUID string
   * @returns Parsed UUID
   * @throws {Error} If the string is not a valid UUID
   *
   * @example
   * ```ts
   * const s = "01888d6e-5c00-7000-8000-000000000000";
   * const uuid = Uuid.parse(s);
   *
   * console.assert(uuid.toString() === s);
   * ```
   */
  static parse(s) {
    const hex = s.replace(/-/g, "");
    if (hex.length !== 32) throw new Error("Invalid hex UUID");
    let v = 0n;
    for (let i = 0; i < 32; i += 2) {
      v = v << 8n | BigInt(parseInt(hex.slice(i, i + 2), 16));
    }
    return new _Uuid(v);
  }
  /** Convert to string (hyphenated form). */
  toString() {
    const bytes = _Uuid.bigIntToBytes(this.__uuid__);
    const hex = [...bytes].map((b) => b.toString(16).padStart(2, "0")).join("");
    return hex.slice(0, 8) + "-" + hex.slice(8, 12) + "-" + hex.slice(12, 16) + "-" + hex.slice(16, 20) + "-" + hex.slice(20);
  }
  /** Convert to bigint (u128). */
  asBigInt() {
    return this.__uuid__;
  }
  /** Return a `Uint8Array` of 16 bytes. */
  toBytes() {
    return _Uuid.bigIntToBytes(this.__uuid__);
  }
  static bytesToBigInt(bytes) {
    let result = 0n;
    for (const b of bytes) result = result << 8n | BigInt(b);
    return result;
  }
  static bigIntToBytes(value) {
    const bytes = new Uint8Array(16);
    for (let i = 15; i >= 0; i--) {
      bytes[i] = Number(value & 0xffn);
      value >>= 8n;
    }
    return bytes;
  }
  /**
   * Returns the version of this UUID.
   *
   * This represents the algorithm used to generate the value.
   *
   * @returns A `UuidVersion`
   * @throws {Error} If the version field is not recognized
   */
  getVersion() {
    const version = this.toBytes()[6] >> 4 & 15;
    switch (version) {
      case 4:
        return "V4";
      case 7:
        return "V7";
      default:
        if (this == _Uuid.NIL) {
          return "Nil";
        }
        if (this == _Uuid.MAX) {
          return "Max";
        }
        throw new Error(`Unsupported UUID version: ${version}`);
    }
  }
  /**
   * Extract the monotonic counter from a UUIDv7.
   *
   * Intended for testing and diagnostics.
   * Behavior is undefined if called on a non-V7 UUID.
   *
   * @returns 31-bit counter value
   */
  getCounter() {
    const bytes = this.toBytes();
    const high = bytes[7];
    const mid1 = bytes[9];
    const mid2 = bytes[10];
    const low = bytes[11] >>> 1;
    return high << 23 | mid1 << 15 | mid2 << 7 | low | 0;
  }
  compareTo(other) {
    if (this.__uuid__ < other.__uuid__) return -1;
    if (this.__uuid__ > other.__uuid__) return 1;
    return 0;
  }
  static getAlgebraicType() {
    return AlgebraicType.Product({
      elements: [
        {
          name: "__uuid__",
          algebraicType: AlgebraicType.U128
        }
      ]
    });
  }
};
var BinaryWriter = class {
  #buffer;
  #view;
  #offset = 0;
  constructor(size) {
    this.#buffer = new Uint8Array(size);
    this.#view = new DataView(this.#buffer.buffer);
  }
  #expandBuffer(additionalCapacity) {
    const minCapacity = this.#offset + additionalCapacity + 1;
    if (minCapacity <= this.#buffer.length) return;
    let newCapacity = this.#buffer.length * 2;
    if (newCapacity < minCapacity) newCapacity = minCapacity;
    const newBuffer = new Uint8Array(newCapacity);
    newBuffer.set(this.#buffer);
    this.#buffer = newBuffer;
    this.#view = new DataView(this.#buffer.buffer);
  }
  toBase64() {
    return fromByteArray(this.#buffer.subarray(0, this.#offset));
  }
  getBuffer() {
    return this.#buffer.slice(0, this.#offset);
  }
  get offset() {
    return this.#offset;
  }
  writeUInt8Array(value) {
    const length = value.length;
    this.#expandBuffer(4 + length);
    this.writeU32(length);
    this.#buffer.set(value, this.#offset);
    this.#offset += value.length;
  }
  writeBool(value) {
    this.#expandBuffer(1);
    this.#view.setUint8(this.#offset, value ? 1 : 0);
    this.#offset += 1;
  }
  writeByte(value) {
    this.#expandBuffer(1);
    this.#view.setUint8(this.#offset, value);
    this.#offset += 1;
  }
  writeI8(value) {
    this.#expandBuffer(1);
    this.#view.setInt8(this.#offset, value);
    this.#offset += 1;
  }
  writeU8(value) {
    this.#expandBuffer(1);
    this.#view.setUint8(this.#offset, value);
    this.#offset += 1;
  }
  writeI16(value) {
    this.#expandBuffer(2);
    this.#view.setInt16(this.#offset, value, true);
    this.#offset += 2;
  }
  writeU16(value) {
    this.#expandBuffer(2);
    this.#view.setUint16(this.#offset, value, true);
    this.#offset += 2;
  }
  writeI32(value) {
    this.#expandBuffer(4);
    this.#view.setInt32(this.#offset, value, true);
    this.#offset += 4;
  }
  writeU32(value) {
    this.#expandBuffer(4);
    this.#view.setUint32(this.#offset, value, true);
    this.#offset += 4;
  }
  writeI64(value) {
    this.#expandBuffer(8);
    this.#view.setBigInt64(this.#offset, value, true);
    this.#offset += 8;
  }
  writeU64(value) {
    this.#expandBuffer(8);
    this.#view.setBigUint64(this.#offset, value, true);
    this.#offset += 8;
  }
  writeU128(value) {
    this.#expandBuffer(16);
    const lowerPart = value & BigInt("0xFFFFFFFFFFFFFFFF");
    const upperPart = value >> BigInt(64);
    this.#view.setBigUint64(this.#offset, lowerPart, true);
    this.#view.setBigUint64(this.#offset + 8, upperPart, true);
    this.#offset += 16;
  }
  writeI128(value) {
    this.#expandBuffer(16);
    const lowerPart = value & BigInt("0xFFFFFFFFFFFFFFFF");
    const upperPart = value >> BigInt(64);
    this.#view.setBigInt64(this.#offset, lowerPart, true);
    this.#view.setBigInt64(this.#offset + 8, upperPart, true);
    this.#offset += 16;
  }
  writeU256(value) {
    this.#expandBuffer(32);
    const low_64_mask = BigInt("0xFFFFFFFFFFFFFFFF");
    const p0 = value & low_64_mask;
    const p1 = value >> BigInt(64 * 1) & low_64_mask;
    const p2 = value >> BigInt(64 * 2) & low_64_mask;
    const p3 = value >> BigInt(64 * 3);
    this.#view.setBigUint64(this.#offset + 8 * 0, p0, true);
    this.#view.setBigUint64(this.#offset + 8 * 1, p1, true);
    this.#view.setBigUint64(this.#offset + 8 * 2, p2, true);
    this.#view.setBigUint64(this.#offset + 8 * 3, p3, true);
    this.#offset += 32;
  }
  writeI256(value) {
    this.#expandBuffer(32);
    const low_64_mask = BigInt("0xFFFFFFFFFFFFFFFF");
    const p0 = value & low_64_mask;
    const p1 = value >> BigInt(64 * 1) & low_64_mask;
    const p2 = value >> BigInt(64 * 2) & low_64_mask;
    const p3 = value >> BigInt(64 * 3);
    this.#view.setBigUint64(this.#offset + 8 * 0, p0, true);
    this.#view.setBigUint64(this.#offset + 8 * 1, p1, true);
    this.#view.setBigUint64(this.#offset + 8 * 2, p2, true);
    this.#view.setBigInt64(this.#offset + 8 * 3, p3, true);
    this.#offset += 32;
  }
  writeF32(value) {
    this.#expandBuffer(4);
    this.#view.setFloat32(this.#offset, value, true);
    this.#offset += 4;
  }
  writeF64(value) {
    this.#expandBuffer(8);
    this.#view.setFloat64(this.#offset, value, true);
    this.#offset += 8;
  }
  writeString(value) {
    const encoder = new TextEncoder();
    const encodedString = encoder.encode(value);
    this.writeU32(encodedString.length);
    this.#expandBuffer(encodedString.length);
    this.#buffer.set(encodedString, this.#offset);
    this.#offset += encodedString.length;
  }
};

// src/lib/binary_reader.ts
var BinaryReader = class {
  /**
   * The DataView used to read values from the binary data.
   *
   * Note: The DataView's `byteOffset` is relative to the beginning of the
   * underlying ArrayBuffer, not the start of the provided Uint8Array input.
   * This `BinaryReader`'s `#offset` field is used to track the current read position
   * relative to the start of the provided Uint8Array input.
   */
  #view;
  /**
   * Represents the offset (in bytes) relative to the start of the DataView
   * and provided Uint8Array input.
   *
   * Note: This is *not* the absolute byte offset within the underlying ArrayBuffer.
   */
  #offset = 0;
  constructor(input) {
    this.#view = new DataView(input.buffer, input.byteOffset, input.byteLength);
    this.#offset = 0;
  }
  get offset() {
    return this.#offset;
  }
  get remaining() {
    return this.#view.byteLength - this.#offset;
  }
  /** Ensure we have at least `n` bytes left to read */
  #ensure(n) {
    if (this.#offset + n > this.#view.byteLength) {
      throw new RangeError(
        `Tried to read ${n} byte(s) at relative offset ${this.#offset}, but only ${this.remaining} byte(s) remain`
      );
    }
  }
  readUInt8Array() {
    const length = this.readU32();
    this.#ensure(length);
    return this.readBytes(length);
  }
  readBool() {
    const value = this.#view.getUint8(this.#offset);
    this.#offset += 1;
    return value !== 0;
  }
  readByte() {
    const value = this.#view.getUint8(this.#offset);
    this.#offset += 1;
    return value;
  }
  readBytes(length) {
    const array = new Uint8Array(
      this.#view.buffer,
      this.#view.byteOffset + this.#offset,
      length
    );
    this.#offset += length;
    return array;
  }
  readI8() {
    const value = this.#view.getInt8(this.#offset);
    this.#offset += 1;
    return value;
  }
  readU8() {
    return this.readByte();
  }
  readI16() {
    const value = this.#view.getInt16(this.#offset, true);
    this.#offset += 2;
    return value;
  }
  readU16() {
    const value = this.#view.getUint16(this.#offset, true);
    this.#offset += 2;
    return value;
  }
  readI32() {
    const value = this.#view.getInt32(this.#offset, true);
    this.#offset += 4;
    return value;
  }
  readU32() {
    const value = this.#view.getUint32(this.#offset, true);
    this.#offset += 4;
    return value;
  }
  readI64() {
    const value = this.#view.getBigInt64(this.#offset, true);
    this.#offset += 8;
    return value;
  }
  readU64() {
    const value = this.#view.getBigUint64(this.#offset, true);
    this.#offset += 8;
    return value;
  }
  readU128() {
    const lowerPart = this.#view.getBigUint64(this.#offset, true);
    const upperPart = this.#view.getBigUint64(this.#offset + 8, true);
    this.#offset += 16;
    return (upperPart << BigInt(64)) + lowerPart;
  }
  readI128() {
    const lowerPart = this.#view.getBigUint64(this.#offset, true);
    const upperPart = this.#view.getBigInt64(this.#offset + 8, true);
    this.#offset += 16;
    return (upperPart << BigInt(64)) + lowerPart;
  }
  readU256() {
    const p0 = this.#view.getBigUint64(this.#offset, true);
    const p1 = this.#view.getBigUint64(this.#offset + 8, true);
    const p2 = this.#view.getBigUint64(this.#offset + 16, true);
    const p3 = this.#view.getBigUint64(this.#offset + 24, true);
    this.#offset += 32;
    return (p3 << BigInt(3 * 64)) + (p2 << BigInt(2 * 64)) + (p1 << BigInt(1 * 64)) + p0;
  }
  readI256() {
    const p0 = this.#view.getBigUint64(this.#offset, true);
    const p1 = this.#view.getBigUint64(this.#offset + 8, true);
    const p2 = this.#view.getBigUint64(this.#offset + 16, true);
    const p3 = this.#view.getBigInt64(this.#offset + 24, true);
    this.#offset += 32;
    return (p3 << BigInt(3 * 64)) + (p2 << BigInt(2 * 64)) + (p1 << BigInt(1 * 64)) + p0;
  }
  readF32() {
    const value = this.#view.getFloat32(this.#offset, true);
    this.#offset += 4;
    return value;
  }
  readF64() {
    const value = this.#view.getFloat64(this.#offset, true);
    this.#offset += 8;
    return value;
  }
  readString() {
    const uint8Array = this.readUInt8Array();
    return new TextDecoder("utf-8").decode(uint8Array);
  }
};

// src/lib/util.ts
function toPascalCase(s) {
  const str = s.replace(/([-_][a-z])/gi, ($1) => {
    return $1.toUpperCase().replace("-", "").replace("_", "");
  });
  return str.charAt(0).toUpperCase() + str.slice(1);
}
function deepEqual(obj1, obj2) {
  if (obj1 === obj2) return true;
  if (typeof obj1 !== "object" || obj1 === null || typeof obj2 !== "object" || obj2 === null) {
    return false;
  }
  const keys1 = Object.keys(obj1);
  const keys2 = Object.keys(obj2);
  if (keys1.length !== keys2.length) return false;
  for (const key of keys1) {
    if (!keys2.includes(key) || !deepEqual(obj1[key], obj2[key])) {
      return false;
    }
  }
  return true;
}
function uint8ArrayToHexString(array) {
  return Array.prototype.map.call(array.reverse(), (x) => ("00" + x.toString(16)).slice(-2)).join("");
}
function uint8ArrayToU128(array) {
  if (array.length != 16) {
    throw new Error(`Uint8Array is not 16 bytes long: ${array}`);
  }
  return new BinaryReader(array).readU128();
}
function uint8ArrayToU256(array) {
  if (array.length != 32) {
    throw new Error(`Uint8Array is not 32 bytes long: [${array}]`);
  }
  return new BinaryReader(array).readU256();
}
function hexStringToUint8Array(str) {
  if (str.startsWith("0x")) {
    str = str.slice(2);
  }
  const matches = str.match(/.{1,2}/g) || [];
  const data = Uint8Array.from(
    matches.map((byte) => parseInt(byte, 16))
  );
  return data.reverse();
}
function hexStringToU128(str) {
  return uint8ArrayToU128(hexStringToUint8Array(str));
}
function hexStringToU256(str) {
  return uint8ArrayToU256(hexStringToUint8Array(str));
}
function u128ToUint8Array(data) {
  const writer = new BinaryWriter(16);
  writer.writeU128(data);
  return writer.getBuffer();
}
function u128ToHexString(data) {
  return uint8ArrayToHexString(u128ToUint8Array(data));
}
function u256ToUint8Array(data) {
  const writer = new BinaryWriter(32);
  writer.writeU256(data);
  return writer.getBuffer();
}
function u256ToHexString(data) {
  return uint8ArrayToHexString(u256ToUint8Array(data));
}
function toCamelCase(str) {
  return str.replace(/[-_]+/g, "_").replace(/_([a-zA-Z0-9])/g, (_, c) => c.toUpperCase());
}
function bsatnBaseSize(typespace, ty) {
  const assumedArrayLength = 4;
  while (ty.tag === "Ref") ty = typespace.types[ty.value];
  if (ty.tag === "Product") {
    let sum = 0;
    for (const { algebraicType: elem } of ty.value.elements) {
      sum += bsatnBaseSize(typespace, elem);
    }
    return sum;
  } else if (ty.tag === "Sum") {
    let min = Infinity;
    for (const { algebraicType: vari } of ty.value.variants) {
      const vSize = bsatnBaseSize(typespace, vari);
      if (vSize < min) min = vSize;
    }
    if (min === Infinity) min = 0;
    return 4 + min;
  } else if (ty.tag == "Array") {
    return 4 + assumedArrayLength * bsatnBaseSize(typespace, ty.value);
  }
  return {
    String: 4 + assumedArrayLength,
    Sum: 1,
    Bool: 1,
    I8: 1,
    U8: 1,
    I16: 2,
    U16: 2,
    I32: 4,
    U32: 4,
    F32: 4,
    I64: 8,
    U64: 8,
    F64: 8,
    I128: 16,
    U128: 16,
    I256: 32,
    U256: 32
  }[ty.tag];
}
function coerceParams(params) {
  return Object.fromEntries(
    Object.entries(params).map(([n, c]) => [
      n,
      "typeBuilder" in c ? c.typeBuilder : c
    ])
  );
}

// src/lib/identity.ts
var Identity = class _Identity {
  __identity__;
  /**
   * Creates a new `Identity`.
   *
   * `data` can be a hexadecimal string or a `bigint`.
   */
  constructor(data) {
    this.__identity__ = typeof data === "string" ? hexStringToU256(data) : data;
  }
  /**
   * Get the algebraic type representation of the {@link Identity} type.
   * @returns The algebraic type representation of the type.
   */
  static getAlgebraicType() {
    return AlgebraicType.Product({
      elements: [{ name: "__identity__", algebraicType: AlgebraicType.U256 }]
    });
  }
  /**
   * Check if two identities are equal.
   */
  isEqual(other) {
    return this.toHexString() === other.toHexString();
  }
  /**
   * Check if two identities are equal.
   */
  equals(other) {
    return this.isEqual(other);
  }
  /**
   * Print the identity as a hexadecimal string.
   */
  toHexString() {
    return u256ToHexString(this.__identity__);
  }
  /**
   * Convert the address to a Uint8Array.
   */
  toUint8Array() {
    return u256ToUint8Array(this.__identity__);
  }
  /**
   * Parse an Identity from a hexadecimal string.
   */
  static fromString(str) {
    return new _Identity(str);
  }
  /**
   * Zero identity (0x0000000000000000000000000000000000000000000000000000000000000000)
   */
  static zero() {
    return new _Identity(0n);
  }
  toString() {
    return this.toHexString();
  }
};

// src/lib/algebraic_type.ts
var AlgebraicType = {
  Ref: (value) => ({ tag: "Ref", value }),
  Sum: (value) => ({
    tag: "Sum",
    value
  }),
  Product: (value) => ({
    tag: "Product",
    value
  }),
  Array: (value) => ({
    tag: "Array",
    value
  }),
  String: { tag: "String" },
  Bool: { tag: "Bool" },
  I8: { tag: "I8" },
  U8: { tag: "U8" },
  I16: { tag: "I16" },
  U16: { tag: "U16" },
  I32: { tag: "I32" },
  U32: { tag: "U32" },
  I64: { tag: "I64" },
  U64: { tag: "U64" },
  I128: { tag: "I128" },
  U128: { tag: "U128" },
  I256: { tag: "I256" },
  U256: { tag: "U256" },
  F32: { tag: "F32" },
  F64: { tag: "F64" },
  serializeValue(writer, ty, value, typespace) {
    if (ty.tag === "Ref") {
      if (!typespace)
        throw new Error("cannot serialize refs without a typespace");
      while (ty.tag === "Ref") ty = typespace.types[ty.value];
    }
    switch (ty.tag) {
      case "Product":
        ProductType.serializeValue(writer, ty.value, value, typespace);
        break;
      case "Sum":
        SumType.serializeValue(writer, ty.value, value, typespace);
        break;
      case "Array":
        if (ty.value.tag === "U8") {
          writer.writeUInt8Array(value);
        } else {
          const elemType = ty.value;
          writer.writeU32(value.length);
          for (const elem of value) {
            AlgebraicType.serializeValue(writer, elemType, elem, typespace);
          }
        }
        break;
      case "Bool":
        writer.writeBool(value);
        break;
      case "I8":
        writer.writeI8(value);
        break;
      case "U8":
        writer.writeU8(value);
        break;
      case "I16":
        writer.writeI16(value);
        break;
      case "U16":
        writer.writeU16(value);
        break;
      case "I32":
        writer.writeI32(value);
        break;
      case "U32":
        writer.writeU32(value);
        break;
      case "I64":
        writer.writeI64(value);
        break;
      case "U64":
        writer.writeU64(value);
        break;
      case "I128":
        writer.writeI128(value);
        break;
      case "U128":
        writer.writeU128(value);
        break;
      case "I256":
        writer.writeI256(value);
        break;
      case "U256":
        writer.writeU256(value);
        break;
      case "F32":
        writer.writeF32(value);
        break;
      case "F64":
        writer.writeF64(value);
        break;
      case "String":
        writer.writeString(value);
        break;
    }
  },
  deserializeValue: function(reader, ty, typespace) {
    if (ty.tag === "Ref") {
      if (!typespace)
        throw new Error("cannot deserialize refs without a typespace");
      while (ty.tag === "Ref") ty = typespace.types[ty.value];
    }
    switch (ty.tag) {
      case "Product":
        return ProductType.deserializeValue(reader, ty.value, typespace);
      case "Sum":
        return SumType.deserializeValue(reader, ty.value, typespace);
      case "Array":
        if (ty.value.tag === "U8") {
          return reader.readUInt8Array();
        } else {
          const elemType = ty.value;
          const length = reader.readU32();
          const result = [];
          for (let i = 0; i < length; i++) {
            result.push(
              AlgebraicType.deserializeValue(reader, elemType, typespace)
            );
          }
          return result;
        }
      case "Bool":
        return reader.readBool();
      case "I8":
        return reader.readI8();
      case "U8":
        return reader.readU8();
      case "I16":
        return reader.readI16();
      case "U16":
        return reader.readU16();
      case "I32":
        return reader.readI32();
      case "U32":
        return reader.readU32();
      case "I64":
        return reader.readI64();
      case "U64":
        return reader.readU64();
      case "I128":
        return reader.readI128();
      case "U128":
        return reader.readU128();
      case "I256":
        return reader.readI256();
      case "U256":
        return reader.readU256();
      case "F32":
        return reader.readF32();
      case "F64":
        return reader.readF64();
      case "String":
        return reader.readString();
    }
  },
  /**
   * Convert a value of the algebraic type into something that can be used as a key in a map.
   * There are no guarantees about being able to order it.
   * This is only guaranteed to be comparable to other values of the same type.
   * @param value A value of the algebraic type
   * @returns Something that can be used as a key in a map.
   */
  intoMapKey: function(ty, value) {
    switch (ty.tag) {
      case "U8":
      case "U16":
      case "U32":
      case "U64":
      case "U128":
      case "U256":
      case "I8":
      case "I16":
      case "I32":
      case "I64":
      case "I128":
      case "I256":
      case "F32":
      case "F64":
      case "String":
      case "Bool":
        return value;
      case "Product":
        return ProductType.intoMapKey(ty.value, value);
      default: {
        const writer = new BinaryWriter(10);
        AlgebraicType.serializeValue(writer, ty, value);
        return writer.toBase64();
      }
    }
  }
};
var ProductType = {
  serializeValue(writer, ty, value, typespace) {
    for (const element of ty.elements) {
      AlgebraicType.serializeValue(
        writer,
        element.algebraicType,
        value[element.name],
        typespace
      );
    }
  },
  deserializeValue(reader, ty, typespace) {
    const result = {};
    if (ty.elements.length === 1) {
      if (ty.elements[0].name === "__time_duration_micros__") {
        return new TimeDuration(reader.readI64());
      }
      if (ty.elements[0].name === "__timestamp_micros_since_unix_epoch__") {
        return new Timestamp(reader.readI64());
      }
      if (ty.elements[0].name === "__identity__") {
        return new Identity(reader.readU256());
      }
      if (ty.elements[0].name === "__connection_id__") {
        return new ConnectionId(reader.readU128());
      }
      if (ty.elements[0].name === "__uuid__") {
        return new Uuid(reader.readU128());
      }
    }
    for (const element of ty.elements) {
      result[element.name] = AlgebraicType.deserializeValue(
        reader,
        element.algebraicType,
        typespace
      );
    }
    return result;
  },
  intoMapKey(ty, value) {
    if (ty.elements.length === 1) {
      if (ty.elements[0].name === "__time_duration_micros__") {
        return value.__time_duration_micros__;
      }
      if (ty.elements[0].name === "__timestamp_micros_since_unix_epoch__") {
        return value.__timestamp_micros_since_unix_epoch__;
      }
      if (ty.elements[0].name === "__identity__") {
        return value.__identity__;
      }
      if (ty.elements[0].name === "__connection_id__") {
        return value.__connection_id__;
      }
      if (ty.elements[0].name === "__uuid__") {
        return value.__uuid__;
      }
    }
    const writer = new BinaryWriter(10);
    AlgebraicType.serializeValue(writer, AlgebraicType.Product(ty), value);
    return writer.toBase64();
  }
};
var SumType = {
  serializeValue: function(writer, ty, value, typespace) {
    if (ty.variants.length == 2 && ty.variants[0].name === "some" && ty.variants[1].name === "none") {
      if (value !== null && value !== void 0) {
        writer.writeByte(0);
        AlgebraicType.serializeValue(
          writer,
          ty.variants[0].algebraicType,
          value,
          typespace
        );
      } else {
        writer.writeByte(1);
      }
    } else if (ty.variants.length == 2 && ty.variants[0].name === "ok" && ty.variants[1].name === "err") {
      let variantName;
      let innerValue;
      let index;
      if ("ok" in value) {
        variantName = "ok";
        innerValue = value.ok;
        index = 0;
      } else {
        variantName = "err";
        innerValue = value.err;
        index = 1;
      }
      if (index < 0) {
        throw `Result serialization error: variant '${variantName}' not found in ${JSON.stringify(ty)}`;
      }
      writer.writeU8(index);
      AlgebraicType.serializeValue(
        writer,
        ty.variants[index].algebraicType,
        innerValue,
        typespace
      );
    } else {
      const variant = value["tag"];
      const index = ty.variants.findIndex((v) => v.name === variant);
      if (index < 0) {
        throw `Can't serialize a sum type, couldn't find ${value.tag} tag ${JSON.stringify(value)} in variants ${JSON.stringify(ty)}`;
      }
      writer.writeU8(index);
      AlgebraicType.serializeValue(
        writer,
        ty.variants[index].algebraicType,
        value["value"],
        typespace
      );
    }
  },
  deserializeValue: function(reader, ty, typespace) {
    const tag = reader.readU8();
    if (ty.variants.length == 2 && ty.variants[0].name === "some" && ty.variants[1].name === "none") {
      if (tag === 0) {
        return AlgebraicType.deserializeValue(
          reader,
          ty.variants[0].algebraicType,
          typespace
        );
      } else if (tag === 1) {
        return void 0;
      } else {
        throw `Can't deserialize an option type, couldn't find ${tag} tag`;
      }
    } else if (ty.variants.length == 2 && ty.variants[0].name === "ok" && ty.variants[1].name === "err") {
      if (tag === 0) {
        const value = AlgebraicType.deserializeValue(
          reader,
          ty.variants[0].algebraicType,
          typespace
        );
        return { ok: value };
      } else if (tag === 1) {
        const value = AlgebraicType.deserializeValue(
          reader,
          ty.variants[1].algebraicType,
          typespace
        );
        return { err: value };
      } else {
        throw `Can't deserialize a result type, couldn't find ${tag} tag`;
      }
    } else {
      const variant = ty.variants[tag];
      const value = AlgebraicType.deserializeValue(
        reader,
        variant.algebraicType,
        typespace
      );
      return { tag: variant.name, value };
    }
  }
};

// src/lib/connection_id.ts
var ConnectionId = class _ConnectionId {
  __connection_id__;
  /**
   * Creates a new `ConnectionId`.
   */
  constructor(data) {
    this.__connection_id__ = data;
  }
  /**
   * Get the algebraic type representation of the {@link ConnectionId} type.
   * @returns The algebraic type representation of the type.
   */
  static getAlgebraicType() {
    return AlgebraicType.Product({
      elements: [
        { name: "__connection_id__", algebraicType: AlgebraicType.U128 }
      ]
    });
  }
  isZero() {
    return this.__connection_id__ === BigInt(0);
  }
  static nullIfZero(addr) {
    if (addr.isZero()) {
      return null;
    } else {
      return addr;
    }
  }
  static random() {
    function randomU8() {
      return Math.floor(Math.random() * 255);
    }
    let result = BigInt(0);
    for (let i = 0; i < 16; i++) {
      result = result << BigInt(8) | BigInt(randomU8());
    }
    return new _ConnectionId(result);
  }
  /**
   * Compare two connection IDs for equality.
   */
  isEqual(other) {
    return this.__connection_id__ == other.__connection_id__;
  }
  /**
   * Check if two connection IDs are equal.
   */
  equals(other) {
    return this.isEqual(other);
  }
  /**
   * Print the connection ID as a hexadecimal string.
   */
  toHexString() {
    return u128ToHexString(this.__connection_id__);
  }
  /**
   * Convert the connection ID to a Uint8Array.
   */
  toUint8Array() {
    return u128ToUint8Array(this.__connection_id__);
  }
  /**
   * Parse a connection ID from a hexadecimal string.
   */
  static fromString(str) {
    return new _ConnectionId(hexStringToU128(str));
  }
  static fromStringOrNull(str) {
    const addr = _ConnectionId.fromString(str);
    if (addr.isZero()) {
      return null;
    } else {
      return addr;
    }
  }
};

// src/lib/schedule_at.ts
var ScheduleAt = {
  interval(value) {
    return Interval(value);
  },
  time(value) {
    return Time(value);
  },
  getAlgebraicType() {
    return AlgebraicType.Sum({
      variants: [
        {
          name: "Interval",
          algebraicType: TimeDuration.getAlgebraicType()
        },
        { name: "Time", algebraicType: Timestamp.getAlgebraicType() }
      ]
    });
  },
  isScheduleAt(algebraicType) {
    if (algebraicType.tag !== "Sum") {
      return false;
    }
    const variants = algebraicType.value.variants;
    if (variants.length !== 2) {
      return false;
    }
    const intervalVariant = variants.find((v) => v.name === "Interval");
    const timeVariant = variants.find((v) => v.name === "Time");
    if (!intervalVariant || !timeVariant) {
      return false;
    }
    return TimeDuration.isTimeDuration(intervalVariant.algebraicType) && Timestamp.isTimestamp(timeVariant.algebraicType);
  }
};
var Interval = (micros) => ({
  tag: "Interval",
  value: new TimeDuration(micros)
});
var Time = (microsSinceUnixEpoch) => ({
  tag: "Time",
  value: new Timestamp(microsSinceUnixEpoch)
});
var schedule_at_default = ScheduleAt;

// src/lib/option.ts
var Option = {
  getAlgebraicType(innerType) {
    return AlgebraicType.Sum({
      variants: [
        { name: "some", algebraicType: innerType },
        {
          name: "none",
          algebraicType: AlgebraicType.Product({ elements: [] })
        }
      ]
    });
  }
};

// src/lib/result.ts
var Result = {
  getAlgebraicType(okType, errType) {
    return AlgebraicType.Sum({
      variants: [
        { name: "ok", algebraicType: okType },
        { name: "err", algebraicType: errType }
      ]
    });
  }
};

// src/lib/type_util.ts
function set(x, t2) {
  return { ...x, ...t2 };
}

// src/lib/type_builders.ts
var TypeBuilder = class {
  /**
   * The TypeScript phantom type. This is not stored at runtime,
   * but is visible to the compiler
   */
  type;
  /**
   * The SpacetimeDB algebraic type (run‑time value). In addition to storing
   * the runtime representation of the `AlgebraicType`, it also captures
   * the TypeScript type information of the `AlgebraicType`. That is to say
   * the value is not merely an `AlgebraicType`, but is constructed to be
   * the corresponding concrete `AlgebraicType` for the TypeScript type `Type`.
   *
   * e.g. `string` corresponds to `AlgebraicType.String`
   */
  algebraicType;
  constructor(algebraicType) {
    this.algebraicType = algebraicType;
  }
  optional() {
    return new OptionBuilder(this);
  }
  serialize(writer, value) {
    AlgebraicType.serializeValue(writer, this.algebraicType, value);
  }
  deserialize(reader) {
    return AlgebraicType.deserializeValue(reader, this.algebraicType);
  }
};
var U8Builder = class extends TypeBuilder {
  constructor() {
    super(AlgebraicType.U8);
  }
  index(algorithm = "btree") {
    return new U8ColumnBuilder(
      this,
      set(defaultMetadata, { indexType: algorithm })
    );
  }
  unique() {
    return new U8ColumnBuilder(this, set(defaultMetadata, { isUnique: true }));
  }
  primaryKey() {
    return new U8ColumnBuilder(
      this,
      set(defaultMetadata, { isPrimaryKey: true })
    );
  }
  autoInc() {
    return new U8ColumnBuilder(
      this,
      set(defaultMetadata, { isAutoIncrement: true })
    );
  }
  default(value) {
    return new U8ColumnBuilder(
      this,
      set(defaultMetadata, { defaultValue: value })
    );
  }
  name(name) {
    return new U8ColumnBuilder(this, set(defaultMetadata, { name }));
  }
};
var U16Builder = class extends TypeBuilder {
  constructor() {
    super(AlgebraicType.U16);
  }
  index(algorithm = "btree") {
    return new U16ColumnBuilder(
      this,
      set(defaultMetadata, { indexType: algorithm })
    );
  }
  unique() {
    return new U16ColumnBuilder(this, set(defaultMetadata, { isUnique: true }));
  }
  primaryKey() {
    return new U16ColumnBuilder(
      this,
      set(defaultMetadata, { isPrimaryKey: true })
    );
  }
  autoInc() {
    return new U16ColumnBuilder(
      this,
      set(defaultMetadata, { isAutoIncrement: true })
    );
  }
  default(value) {
    return new U16ColumnBuilder(
      this,
      set(defaultMetadata, { defaultValue: value })
    );
  }
  name(name) {
    return new U16ColumnBuilder(this, set(defaultMetadata, { name }));
  }
};
var U32Builder = class extends TypeBuilder {
  constructor() {
    super(AlgebraicType.U32);
  }
  index(algorithm = "btree") {
    return new U32ColumnBuilder(
      this,
      set(defaultMetadata, { indexType: algorithm })
    );
  }
  unique() {
    return new U32ColumnBuilder(this, set(defaultMetadata, { isUnique: true }));
  }
  primaryKey() {
    return new U32ColumnBuilder(
      this,
      set(defaultMetadata, { isPrimaryKey: true })
    );
  }
  autoInc() {
    return new U32ColumnBuilder(
      this,
      set(defaultMetadata, { isAutoIncrement: true })
    );
  }
  default(value) {
    return new U32ColumnBuilder(
      this,
      set(defaultMetadata, { defaultValue: value })
    );
  }
  name(name) {
    return new U32ColumnBuilder(this, set(defaultMetadata, { name }));
  }
};
var U64Builder = class extends TypeBuilder {
  constructor() {
    super(AlgebraicType.U64);
  }
  index(algorithm = "btree") {
    return new U64ColumnBuilder(
      this,
      set(defaultMetadata, { indexType: algorithm })
    );
  }
  unique() {
    return new U64ColumnBuilder(this, set(defaultMetadata, { isUnique: true }));
  }
  primaryKey() {
    return new U64ColumnBuilder(
      this,
      set(defaultMetadata, { isPrimaryKey: true })
    );
  }
  autoInc() {
    return new U64ColumnBuilder(
      this,
      set(defaultMetadata, { isAutoIncrement: true })
    );
  }
  default(value) {
    return new U64ColumnBuilder(
      this,
      set(defaultMetadata, { defaultValue: value })
    );
  }
  name(name) {
    return new U64ColumnBuilder(this, set(defaultMetadata, { name }));
  }
};
var U128Builder = class extends TypeBuilder {
  constructor() {
    super(AlgebraicType.U128);
  }
  index(algorithm = "btree") {
    return new U128ColumnBuilder(
      this,
      set(defaultMetadata, { indexType: algorithm })
    );
  }
  unique() {
    return new U128ColumnBuilder(
      this,
      set(defaultMetadata, { isUnique: true })
    );
  }
  primaryKey() {
    return new U128ColumnBuilder(
      this,
      set(defaultMetadata, { isPrimaryKey: true })
    );
  }
  autoInc() {
    return new U128ColumnBuilder(
      this,
      set(defaultMetadata, { isAutoIncrement: true })
    );
  }
  default(value) {
    return new U128ColumnBuilder(
      this,
      set(defaultMetadata, { defaultValue: value })
    );
  }
  name(name) {
    return new U128ColumnBuilder(this, set(defaultMetadata, { name }));
  }
};
var U256Builder = class extends TypeBuilder {
  constructor() {
    super(AlgebraicType.U256);
  }
  index(algorithm = "btree") {
    return new U256ColumnBuilder(
      this,
      set(defaultMetadata, { indexType: algorithm })
    );
  }
  unique() {
    return new U256ColumnBuilder(
      this,
      set(defaultMetadata, { isUnique: true })
    );
  }
  primaryKey() {
    return new U256ColumnBuilder(
      this,
      set(defaultMetadata, { isPrimaryKey: true })
    );
  }
  autoInc() {
    return new U256ColumnBuilder(
      this,
      set(defaultMetadata, { isAutoIncrement: true })
    );
  }
  default(value) {
    return new U256ColumnBuilder(
      this,
      set(defaultMetadata, { defaultValue: value })
    );
  }
  name(name) {
    return new U256ColumnBuilder(this, set(defaultMetadata, { name }));
  }
};
var I8Builder = class extends TypeBuilder {
  constructor() {
    super(AlgebraicType.I8);
  }
  index(algorithm = "btree") {
    return new I8ColumnBuilder(
      this,
      set(defaultMetadata, { indexType: algorithm })
    );
  }
  unique() {
    return new I8ColumnBuilder(this, set(defaultMetadata, { isUnique: true }));
  }
  primaryKey() {
    return new I8ColumnBuilder(
      this,
      set(defaultMetadata, { isPrimaryKey: true })
    );
  }
  autoInc() {
    return new I8ColumnBuilder(
      this,
      set(defaultMetadata, { isAutoIncrement: true })
    );
  }
  default(value) {
    return new I8ColumnBuilder(
      this,
      set(defaultMetadata, { defaultValue: value })
    );
  }
  name(name) {
    return new I8ColumnBuilder(this, set(defaultMetadata, { name }));
  }
};
var I16Builder = class extends TypeBuilder {
  constructor() {
    super(AlgebraicType.I16);
  }
  index(algorithm = "btree") {
    return new I16ColumnBuilder(
      this,
      set(defaultMetadata, { indexType: algorithm })
    );
  }
  unique() {
    return new I16ColumnBuilder(this, set(defaultMetadata, { isUnique: true }));
  }
  primaryKey() {
    return new I16ColumnBuilder(
      this,
      set(defaultMetadata, { isPrimaryKey: true })
    );
  }
  autoInc() {
    return new I16ColumnBuilder(
      this,
      set(defaultMetadata, { isAutoIncrement: true })
    );
  }
  default(value) {
    return new I16ColumnBuilder(
      this,
      set(defaultMetadata, { defaultValue: value })
    );
  }
  name(name) {
    return new I16ColumnBuilder(this, set(defaultMetadata, { name }));
  }
};
var I32Builder = class extends TypeBuilder {
  constructor() {
    super(AlgebraicType.I32);
  }
  index(algorithm = "btree") {
    return new I32ColumnBuilder(
      this,
      set(defaultMetadata, { indexType: algorithm })
    );
  }
  unique() {
    return new I32ColumnBuilder(this, set(defaultMetadata, { isUnique: true }));
  }
  primaryKey() {
    return new I32ColumnBuilder(
      this,
      set(defaultMetadata, { isPrimaryKey: true })
    );
  }
  autoInc() {
    return new I32ColumnBuilder(
      this,
      set(defaultMetadata, { isAutoIncrement: true })
    );
  }
  default(value) {
    return new I32ColumnBuilder(
      this,
      set(defaultMetadata, { defaultValue: value })
    );
  }
  name(name) {
    return new I32ColumnBuilder(this, set(defaultMetadata, { name }));
  }
};
var I64Builder = class extends TypeBuilder {
  constructor() {
    super(AlgebraicType.I64);
  }
  index(algorithm = "btree") {
    return new I64ColumnBuilder(
      this,
      set(defaultMetadata, { indexType: algorithm })
    );
  }
  unique() {
    return new I64ColumnBuilder(this, set(defaultMetadata, { isUnique: true }));
  }
  primaryKey() {
    return new I64ColumnBuilder(
      this,
      set(defaultMetadata, { isPrimaryKey: true })
    );
  }
  autoInc() {
    return new I64ColumnBuilder(
      this,
      set(defaultMetadata, { isAutoIncrement: true })
    );
  }
  default(value) {
    return new I64ColumnBuilder(
      this,
      set(defaultMetadata, { defaultValue: value })
    );
  }
  name(name) {
    return new I64ColumnBuilder(this, set(defaultMetadata, { name }));
  }
};
var I128Builder = class extends TypeBuilder {
  constructor() {
    super(AlgebraicType.I128);
  }
  index(algorithm = "btree") {
    return new I128ColumnBuilder(
      this,
      set(defaultMetadata, { indexType: algorithm })
    );
  }
  unique() {
    return new I128ColumnBuilder(
      this,
      set(defaultMetadata, { isUnique: true })
    );
  }
  primaryKey() {
    return new I128ColumnBuilder(
      this,
      set(defaultMetadata, { isPrimaryKey: true })
    );
  }
  autoInc() {
    return new I128ColumnBuilder(
      this,
      set(defaultMetadata, { isAutoIncrement: true })
    );
  }
  default(value) {
    return new I128ColumnBuilder(
      this,
      set(defaultMetadata, { defaultValue: value })
    );
  }
  name(name) {
    return new I128ColumnBuilder(this, set(defaultMetadata, { name }));
  }
};
var I256Builder = class extends TypeBuilder {
  constructor() {
    super(AlgebraicType.I256);
  }
  index(algorithm = "btree") {
    return new I256ColumnBuilder(
      this,
      set(defaultMetadata, { indexType: algorithm })
    );
  }
  unique() {
    return new I256ColumnBuilder(
      this,
      set(defaultMetadata, { isUnique: true })
    );
  }
  primaryKey() {
    return new I256ColumnBuilder(
      this,
      set(defaultMetadata, { isPrimaryKey: true })
    );
  }
  autoInc() {
    return new I256ColumnBuilder(
      this,
      set(defaultMetadata, { isAutoIncrement: true })
    );
  }
  default(value) {
    return new I256ColumnBuilder(
      this,
      set(defaultMetadata, { defaultValue: value })
    );
  }
  name(name) {
    return new I256ColumnBuilder(this, set(defaultMetadata, { name }));
  }
};
var F32Builder = class extends TypeBuilder {
  constructor() {
    super(AlgebraicType.F32);
  }
  default(value) {
    return new F32ColumnBuilder(
      this,
      set(defaultMetadata, { defaultValue: value })
    );
  }
  name(name) {
    return new F32ColumnBuilder(this, set(defaultMetadata, { name }));
  }
};
var F64Builder = class extends TypeBuilder {
  constructor() {
    super(AlgebraicType.F64);
  }
  default(value) {
    return new F64ColumnBuilder(
      this,
      set(defaultMetadata, { defaultValue: value })
    );
  }
  name(name) {
    return new F64ColumnBuilder(this, set(defaultMetadata, { name }));
  }
};
var BoolBuilder = class extends TypeBuilder {
  constructor() {
    super(AlgebraicType.Bool);
  }
  index(algorithm = "btree") {
    return new BoolColumnBuilder(
      this,
      set(defaultMetadata, { indexType: algorithm })
    );
  }
  unique() {
    return new BoolColumnBuilder(
      this,
      set(defaultMetadata, { isUnique: true })
    );
  }
  primaryKey() {
    return new BoolColumnBuilder(
      this,
      set(defaultMetadata, { isPrimaryKey: true })
    );
  }
  default(value) {
    return new BoolColumnBuilder(
      this,
      set(defaultMetadata, { defaultValue: value })
    );
  }
  name(name) {
    return new BoolColumnBuilder(this, set(defaultMetadata, { name }));
  }
};
var StringBuilder = class extends TypeBuilder {
  constructor() {
    super(AlgebraicType.String);
  }
  index(algorithm = "btree") {
    return new StringColumnBuilder(
      this,
      set(defaultMetadata, { indexType: algorithm })
    );
  }
  unique() {
    return new StringColumnBuilder(
      this,
      set(defaultMetadata, { isUnique: true })
    );
  }
  primaryKey() {
    return new StringColumnBuilder(
      this,
      set(defaultMetadata, { isPrimaryKey: true })
    );
  }
  default(value) {
    return new StringColumnBuilder(
      this,
      set(defaultMetadata, { defaultValue: value })
    );
  }
  name(name) {
    return new StringColumnBuilder(this, set(defaultMetadata, { name }));
  }
};
var ArrayBuilder = class extends TypeBuilder {
  element;
  constructor(element) {
    super(AlgebraicType.Array(element.algebraicType));
    this.element = element;
  }
  default(value) {
    return new ArrayColumnBuilder(
      this.element,
      set(defaultMetadata, { defaultValue: value })
    );
  }
  name(name) {
    return new ArrayColumnBuilder(this.element, set(defaultMetadata, { name }));
  }
};
var ByteArrayBuilder = class extends TypeBuilder {
  constructor() {
    super(AlgebraicType.Array(AlgebraicType.U8));
  }
  default(value) {
    return new ByteArrayColumnBuilder(
      set(defaultMetadata, { defaultValue: value })
    );
  }
  name(name) {
    return new ByteArrayColumnBuilder(set(defaultMetadata, { name }));
  }
};
var OptionBuilder = class extends TypeBuilder {
  value;
  constructor(value) {
    super(Option.getAlgebraicType(value.algebraicType));
    this.value = value;
  }
  default(value) {
    return new OptionColumnBuilder(
      this,
      set(defaultMetadata, { defaultValue: value })
    );
  }
  name(name) {
    return new OptionColumnBuilder(this, set(defaultMetadata, { name }));
  }
};
var ProductBuilder = class extends TypeBuilder {
  typeName;
  elements;
  constructor(elements, name) {
    function elementsArrayFromElementsObj(obj) {
      return Object.keys(obj).map((key) => ({
        name: key,
        // Lazily resolve the underlying object's algebraicType.
        // This will call obj[key].algebraicType only when someone
        // actually reads this property.
        get algebraicType() {
          return obj[key].algebraicType;
        }
      }));
    }
    super(
      AlgebraicType.Product({
        elements: elementsArrayFromElementsObj(elements)
      })
    );
    this.typeName = name;
    this.elements = elements;
  }
  default(value) {
    return new ProductColumnBuilder(
      this,
      set(defaultMetadata, { defaultValue: value })
    );
  }
  name(name) {
    return new ProductColumnBuilder(this, set(defaultMetadata, { name }));
  }
};
var ResultBuilder = class extends TypeBuilder {
  ok;
  err;
  constructor(ok, err) {
    super(Result.getAlgebraicType(ok.algebraicType, err.algebraicType));
    this.ok = ok;
    this.err = err;
  }
  default(value) {
    return new ResultColumnBuilder(this, set(defaultMetadata, { defaultValue: value }));
  }
};
var UnitBuilder = class extends TypeBuilder {
  constructor() {
    super({ tag: "Product", value: { elements: [] } });
  }
};
var RowBuilder = class extends TypeBuilder {
  row;
  typeName;
  constructor(row, name) {
    const mappedRow = Object.fromEntries(
      Object.entries(row).map(([colName, builder]) => [
        colName,
        builder instanceof ColumnBuilder ? builder : new ColumnBuilder(builder, {})
      ])
    );
    const elements = Object.keys(mappedRow).map((name2) => ({
      name: name2,
      get algebraicType() {
        return mappedRow[name2].typeBuilder.algebraicType;
      }
    }));
    super(AlgebraicType.Product({ elements }));
    this.row = mappedRow;
    this.typeName = name;
  }
};
var SumBuilderImpl = class extends TypeBuilder {
  variants;
  typeName;
  constructor(variants, name) {
    function variantsArrayFromVariantsObj(variants2) {
      return Object.keys(variants2).map((key) => ({
        name: key,
        // Lazily resolve the underlying object's algebraicType.
        // This will call obj[key].algebraicType only when someone
        // actually reads this property.
        get algebraicType() {
          return variants2[key].algebraicType;
        }
      }));
    }
    super(
      AlgebraicType.Sum({
        variants: variantsArrayFromVariantsObj(variants)
      })
    );
    this.variants = variants;
    this.typeName = name;
    for (const key of Object.keys(variants)) {
      const desc = Object.getOwnPropertyDescriptor(variants, key);
      const isAccessor = !!desc && (typeof desc.get === "function" || typeof desc.set === "function");
      let isUnit2 = false;
      if (!isAccessor) {
        const variant = variants[key];
        isUnit2 = variant instanceof UnitBuilder;
      }
      if (isUnit2) {
        const constant = this.create(key);
        Object.defineProperty(this, key, {
          value: constant,
          writable: false,
          enumerable: true,
          configurable: false
        });
      } else {
        const fn = ((value) => this.create(key, value));
        Object.defineProperty(this, key, {
          value: fn,
          writable: false,
          enumerable: true,
          configurable: false
        });
      }
    }
  }
  create(tag, value) {
    return value === void 0 ? { tag } : { tag, value };
  }
  default(value) {
    return new SumColumnBuilder(
      this,
      set(defaultMetadata, { defaultValue: value })
    );
  }
  name(name) {
    return new SumColumnBuilder(this, set(defaultMetadata, { name }));
  }
};
var SumBuilder = SumBuilderImpl;
var SimpleSumBuilderImpl = class extends SumBuilderImpl {
  index(algorithm = "btree") {
    return new SimpleSumColumnBuilder(
      this,
      set(defaultMetadata, { indexType: algorithm })
    );
  }
  primaryKey() {
    return new SimpleSumColumnBuilder(
      this,
      set(defaultMetadata, { isPrimaryKey: true })
    );
  }
};
var SimpleSumBuilder = SimpleSumBuilderImpl;
var ScheduleAtBuilder = class extends TypeBuilder {
  constructor() {
    super(schedule_at_default.getAlgebraicType());
  }
  default(value) {
    return new ScheduleAtColumnBuilder(
      this,
      set(defaultMetadata, { defaultValue: value })
    );
  }
  name(name) {
    return new ScheduleAtColumnBuilder(this, set(defaultMetadata, { name }));
  }
};
var IdentityBuilder = class extends TypeBuilder {
  constructor() {
    super(Identity.getAlgebraicType());
  }
  index(algorithm = "btree") {
    return new IdentityColumnBuilder(
      this,
      set(defaultMetadata, { indexType: algorithm })
    );
  }
  unique() {
    return new IdentityColumnBuilder(
      this,
      set(defaultMetadata, { isUnique: true })
    );
  }
  primaryKey() {
    return new IdentityColumnBuilder(
      this,
      set(defaultMetadata, { isPrimaryKey: true })
    );
  }
  autoInc() {
    return new IdentityColumnBuilder(
      this,
      set(defaultMetadata, { isAutoIncrement: true })
    );
  }
  default(value) {
    return new IdentityColumnBuilder(
      this,
      set(defaultMetadata, { defaultValue: value })
    );
  }
  name(name) {
    return new IdentityColumnBuilder(this, set(defaultMetadata, { name }));
  }
};
var ConnectionIdBuilder = class extends TypeBuilder {
  constructor() {
    super(ConnectionId.getAlgebraicType());
  }
  index(algorithm = "btree") {
    return new ConnectionIdColumnBuilder(
      this,
      set(defaultMetadata, { indexType: algorithm })
    );
  }
  unique() {
    return new ConnectionIdColumnBuilder(
      this,
      set(defaultMetadata, { isUnique: true })
    );
  }
  primaryKey() {
    return new ConnectionIdColumnBuilder(
      this,
      set(defaultMetadata, { isPrimaryKey: true })
    );
  }
  autoInc() {
    return new ConnectionIdColumnBuilder(
      this,
      set(defaultMetadata, { isAutoIncrement: true })
    );
  }
  default(value) {
    return new ConnectionIdColumnBuilder(
      this,
      set(defaultMetadata, { defaultValue: value })
    );
  }
  name(name) {
    return new ConnectionIdColumnBuilder(this, set(defaultMetadata, { name }));
  }
};
var TimestampBuilder = class extends TypeBuilder {
  constructor() {
    super(Timestamp.getAlgebraicType());
  }
  index(algorithm = "btree") {
    return new TimestampColumnBuilder(
      this,
      set(defaultMetadata, { indexType: algorithm })
    );
  }
  unique() {
    return new TimestampColumnBuilder(
      this,
      set(defaultMetadata, { isUnique: true })
    );
  }
  primaryKey() {
    return new TimestampColumnBuilder(
      this,
      set(defaultMetadata, { isPrimaryKey: true })
    );
  }
  autoInc() {
    return new TimestampColumnBuilder(
      this,
      set(defaultMetadata, { isAutoIncrement: true })
    );
  }
  default(value) {
    return new TimestampColumnBuilder(
      this,
      set(defaultMetadata, { defaultValue: value })
    );
  }
  name(name) {
    return new TimestampColumnBuilder(this, set(defaultMetadata, { name }));
  }
};
var TimeDurationBuilder = class extends TypeBuilder {
  constructor() {
    super(TimeDuration.getAlgebraicType());
  }
  index(algorithm = "btree") {
    return new TimeDurationColumnBuilder(
      this,
      set(defaultMetadata, { indexType: algorithm })
    );
  }
  unique() {
    return new TimeDurationColumnBuilder(
      this,
      set(defaultMetadata, { isUnique: true })
    );
  }
  primaryKey() {
    return new TimeDurationColumnBuilder(
      this,
      set(defaultMetadata, { isPrimaryKey: true })
    );
  }
  autoInc() {
    return new TimeDurationColumnBuilder(
      this,
      set(defaultMetadata, { isAutoIncrement: true })
    );
  }
  default(value) {
    return new TimeDurationColumnBuilder(
      this,
      set(defaultMetadata, { defaultValue: value })
    );
  }
  name(name) {
    return new TimeDurationColumnBuilder(this, set(defaultMetadata, { name }));
  }
};
var UuidBuilder = class extends TypeBuilder {
  constructor() {
    super(Uuid.getAlgebraicType());
  }
  index(algorithm = "btree") {
    return new UuidColumnBuilder(
      this,
      set(defaultMetadata, { indexType: algorithm })
    );
  }
  unique() {
    return new UuidColumnBuilder(
      this,
      set(defaultMetadata, { isUnique: true })
    );
  }
  primaryKey() {
    return new UuidColumnBuilder(
      this,
      set(defaultMetadata, { isPrimaryKey: true })
    );
  }
  autoInc() {
    return new UuidColumnBuilder(
      this,
      set(defaultMetadata, { isAutoIncrement: true })
    );
  }
  default(value) {
    return new UuidColumnBuilder(
      this,
      set(defaultMetadata, { defaultValue: value })
    );
  }
};
var defaultMetadata = {};
var ColumnBuilder = class {
  typeBuilder;
  columnMetadata;
  constructor(typeBuilder, metadata) {
    this.typeBuilder = typeBuilder;
    this.columnMetadata = metadata;
  }
  serialize(writer, value) {
    AlgebraicType.serializeValue(writer, this.typeBuilder.algebraicType, value);
  }
  deserialize(reader) {
    return AlgebraicType.deserializeValue(
      reader,
      this.typeBuilder.algebraicType
    );
  }
};
var U8ColumnBuilder = class _U8ColumnBuilder extends ColumnBuilder {
  index(algorithm = "btree") {
    return new _U8ColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { indexType: algorithm })
    );
  }
  unique() {
    return new _U8ColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { isUnique: true })
    );
  }
  primaryKey() {
    return new _U8ColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { isPrimaryKey: true })
    );
  }
  autoInc() {
    return new _U8ColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { isAutoIncrement: true })
    );
  }
  default(value) {
    return new _U8ColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, {
        defaultValue: value
      })
    );
  }
  name(name) {
    return new _U8ColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { name })
    );
  }
};
var U16ColumnBuilder = class _U16ColumnBuilder extends ColumnBuilder {
  index(algorithm = "btree") {
    return new _U16ColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { indexType: algorithm })
    );
  }
  unique() {
    return new _U16ColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { isUnique: true })
    );
  }
  primaryKey() {
    return new _U16ColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { isPrimaryKey: true })
    );
  }
  autoInc() {
    return new _U16ColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { isAutoIncrement: true })
    );
  }
  default(value) {
    return new _U16ColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, {
        defaultValue: value
      })
    );
  }
  name(name) {
    return new _U16ColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { name })
    );
  }
};
var U32ColumnBuilder = class _U32ColumnBuilder extends ColumnBuilder {
  index(algorithm = "btree") {
    return new _U32ColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { indexType: algorithm })
    );
  }
  unique() {
    return new _U32ColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { isUnique: true })
    );
  }
  primaryKey() {
    return new _U32ColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { isPrimaryKey: true })
    );
  }
  autoInc() {
    return new _U32ColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { isAutoIncrement: true })
    );
  }
  default(value) {
    return new _U32ColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, {
        defaultValue: value
      })
    );
  }
  name(name) {
    return new _U32ColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { name })
    );
  }
};
var U64ColumnBuilder = class _U64ColumnBuilder extends ColumnBuilder {
  index(algorithm = "btree") {
    return new _U64ColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { indexType: algorithm })
    );
  }
  unique() {
    return new _U64ColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { isUnique: true })
    );
  }
  primaryKey() {
    return new _U64ColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { isPrimaryKey: true })
    );
  }
  autoInc() {
    return new _U64ColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { isAutoIncrement: true })
    );
  }
  default(value) {
    return new _U64ColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, {
        defaultValue: value
      })
    );
  }
  name(name) {
    return new _U64ColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { name })
    );
  }
};
var U128ColumnBuilder = class _U128ColumnBuilder extends ColumnBuilder {
  index(algorithm = "btree") {
    return new _U128ColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { indexType: algorithm })
    );
  }
  unique() {
    return new _U128ColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { isUnique: true })
    );
  }
  primaryKey() {
    return new _U128ColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { isPrimaryKey: true })
    );
  }
  autoInc() {
    return new _U128ColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { isAutoIncrement: true })
    );
  }
  default(value) {
    return new _U128ColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, {
        defaultValue: value
      })
    );
  }
  name(name) {
    return new _U128ColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { name })
    );
  }
};
var U256ColumnBuilder = class _U256ColumnBuilder extends ColumnBuilder {
  index(algorithm = "btree") {
    return new _U256ColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { indexType: algorithm })
    );
  }
  unique() {
    return new _U256ColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { isUnique: true })
    );
  }
  primaryKey() {
    return new _U256ColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { isPrimaryKey: true })
    );
  }
  autoInc() {
    return new _U256ColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { isAutoIncrement: true })
    );
  }
  default(value) {
    return new _U256ColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, {
        defaultValue: value
      })
    );
  }
  name(name) {
    return new _U256ColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { name })
    );
  }
};
var I8ColumnBuilder = class _I8ColumnBuilder extends ColumnBuilder {
  index(algorithm = "btree") {
    return new _I8ColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { indexType: algorithm })
    );
  }
  unique() {
    return new _I8ColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { isUnique: true })
    );
  }
  primaryKey() {
    return new _I8ColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { isPrimaryKey: true })
    );
  }
  autoInc() {
    return new _I8ColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { isAutoIncrement: true })
    );
  }
  default(value) {
    return new _I8ColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, {
        defaultValue: value
      })
    );
  }
  name(name) {
    return new _I8ColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { name })
    );
  }
};
var I16ColumnBuilder = class _I16ColumnBuilder extends ColumnBuilder {
  index(algorithm = "btree") {
    return new _I16ColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { indexType: algorithm })
    );
  }
  unique() {
    return new _I16ColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { isUnique: true })
    );
  }
  primaryKey() {
    return new _I16ColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { isPrimaryKey: true })
    );
  }
  autoInc() {
    return new _I16ColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { isAutoIncrement: true })
    );
  }
  default(value) {
    return new _I16ColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, {
        defaultValue: value
      })
    );
  }
  name(name) {
    return new _I16ColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { name })
    );
  }
};
var I32ColumnBuilder = class _I32ColumnBuilder extends ColumnBuilder {
  index(algorithm = "btree") {
    return new _I32ColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { indexType: algorithm })
    );
  }
  unique() {
    return new _I32ColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { isUnique: true })
    );
  }
  primaryKey() {
    return new _I32ColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { isPrimaryKey: true })
    );
  }
  autoInc() {
    return new _I32ColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { isAutoIncrement: true })
    );
  }
  default(value) {
    return new _I32ColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, {
        defaultValue: value
      })
    );
  }
  name(name) {
    return new _I32ColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { name })
    );
  }
};
var I64ColumnBuilder = class _I64ColumnBuilder extends ColumnBuilder {
  index(algorithm = "btree") {
    return new _I64ColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { indexType: algorithm })
    );
  }
  unique() {
    return new _I64ColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { isUnique: true })
    );
  }
  primaryKey() {
    return new _I64ColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { isPrimaryKey: true })
    );
  }
  autoInc() {
    return new _I64ColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { isAutoIncrement: true })
    );
  }
  default(value) {
    return new _I64ColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, {
        defaultValue: value
      })
    );
  }
  name(name) {
    return new _I64ColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { name })
    );
  }
};
var I128ColumnBuilder = class _I128ColumnBuilder extends ColumnBuilder {
  index(algorithm = "btree") {
    return new _I128ColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { indexType: algorithm })
    );
  }
  unique() {
    return new _I128ColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { isUnique: true })
    );
  }
  primaryKey() {
    return new _I128ColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { isPrimaryKey: true })
    );
  }
  autoInc() {
    return new _I128ColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { isAutoIncrement: true })
    );
  }
  default(value) {
    return new _I128ColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, {
        defaultValue: value
      })
    );
  }
  name(name) {
    return new _I128ColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { name })
    );
  }
};
var I256ColumnBuilder = class _I256ColumnBuilder extends ColumnBuilder {
  index(algorithm = "btree") {
    return new _I256ColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { indexType: algorithm })
    );
  }
  unique() {
    return new _I256ColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { isUnique: true })
    );
  }
  primaryKey() {
    return new _I256ColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { isPrimaryKey: true })
    );
  }
  autoInc() {
    return new _I256ColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { isAutoIncrement: true })
    );
  }
  default(value) {
    return new _I256ColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, {
        defaultValue: value
      })
    );
  }
  name(name) {
    return new _I256ColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { name })
    );
  }
};
var F32ColumnBuilder = class _F32ColumnBuilder extends ColumnBuilder {
  default(value) {
    return new _F32ColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, {
        defaultValue: value
      })
    );
  }
  name(name) {
    return new _F32ColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { name })
    );
  }
};
var F64ColumnBuilder = class _F64ColumnBuilder extends ColumnBuilder {
  default(value) {
    return new _F64ColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, {
        defaultValue: value
      })
    );
  }
  name(name) {
    return new _F64ColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { name })
    );
  }
};
var BoolColumnBuilder = class _BoolColumnBuilder extends ColumnBuilder {
  index(algorithm = "btree") {
    return new _BoolColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { indexType: algorithm })
    );
  }
  unique() {
    return new _BoolColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { isUnique: true })
    );
  }
  primaryKey() {
    return new _BoolColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { isPrimaryKey: true })
    );
  }
  default(value) {
    return new _BoolColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, {
        defaultValue: value
      })
    );
  }
  name(name) {
    return new _BoolColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { name })
    );
  }
};
var StringColumnBuilder = class _StringColumnBuilder extends ColumnBuilder {
  index(algorithm = "btree") {
    return new _StringColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { indexType: algorithm })
    );
  }
  unique() {
    return new _StringColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { isUnique: true })
    );
  }
  primaryKey() {
    return new _StringColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { isPrimaryKey: true })
    );
  }
  default(value) {
    return new _StringColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, {
        defaultValue: value
      })
    );
  }
  name(name) {
    return new _StringColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { name })
    );
  }
};
var ArrayColumnBuilder = class _ArrayColumnBuilder extends ColumnBuilder {
  default(value) {
    return new _ArrayColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, {
        defaultValue: value
      })
    );
  }
  name(name) {
    return new _ArrayColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { name })
    );
  }
};
var ByteArrayColumnBuilder = class _ByteArrayColumnBuilder extends ColumnBuilder {
  constructor(metadata) {
    super(new TypeBuilder(AlgebraicType.Array(AlgebraicType.U8)), metadata);
  }
  default(value) {
    return new _ByteArrayColumnBuilder(
      set(this.columnMetadata, { defaultValue: value })
    );
  }
  name(name) {
    return new _ByteArrayColumnBuilder(set(this.columnMetadata, { name }));
  }
};
var OptionColumnBuilder = class _OptionColumnBuilder extends ColumnBuilder {
  default(value) {
    return new _OptionColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, {
        defaultValue: value
      })
    );
  }
  name(name) {
    return new _OptionColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { name })
    );
  }
};
var ResultColumnBuilder = class _ResultColumnBuilder extends ColumnBuilder {
  constructor(typeBuilder, metadata) {
    super(typeBuilder, metadata);
  }
  default(value) {
    return new _ResultColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, {
        defaultValue: value
      })
    );
  }
};
var ProductColumnBuilder = class _ProductColumnBuilder extends ColumnBuilder {
  default(value) {
    return new _ProductColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { defaultValue: value })
    );
  }
  name(name) {
    return new _ProductColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { name })
    );
  }
};
var SumColumnBuilder = class _SumColumnBuilder extends ColumnBuilder {
  default(value) {
    return new _SumColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { defaultValue: value })
    );
  }
  name(name) {
    return new _SumColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { name })
    );
  }
};
var SimpleSumColumnBuilder = class _SimpleSumColumnBuilder extends SumColumnBuilder {
  index(algorithm = "btree") {
    return new _SimpleSumColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { indexType: algorithm })
    );
  }
  primaryKey() {
    return new _SimpleSumColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { isPrimaryKey: true })
    );
  }
};
var ScheduleAtColumnBuilder = class _ScheduleAtColumnBuilder extends ColumnBuilder {
  default(value) {
    return new _ScheduleAtColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { defaultValue: value })
    );
  }
  name(name) {
    return new _ScheduleAtColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { name })
    );
  }
};
var IdentityColumnBuilder = class _IdentityColumnBuilder extends ColumnBuilder {
  index(algorithm = "btree") {
    return new _IdentityColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { indexType: algorithm })
    );
  }
  unique() {
    return new _IdentityColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { isUnique: true })
    );
  }
  primaryKey() {
    return new _IdentityColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { isPrimaryKey: true })
    );
  }
  default(value) {
    return new _IdentityColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { defaultValue: value })
    );
  }
  name(name) {
    return new _IdentityColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { name })
    );
  }
};
var ConnectionIdColumnBuilder = class _ConnectionIdColumnBuilder extends ColumnBuilder {
  index(algorithm = "btree") {
    return new _ConnectionIdColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { indexType: algorithm })
    );
  }
  unique() {
    return new _ConnectionIdColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { isUnique: true })
    );
  }
  primaryKey() {
    return new _ConnectionIdColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { isPrimaryKey: true })
    );
  }
  default(value) {
    return new _ConnectionIdColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { defaultValue: value })
    );
  }
  name(name) {
    return new _ConnectionIdColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { name })
    );
  }
};
var TimestampColumnBuilder = class _TimestampColumnBuilder extends ColumnBuilder {
  index(algorithm = "btree") {
    return new _TimestampColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { indexType: algorithm })
    );
  }
  unique() {
    return new _TimestampColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { isUnique: true })
    );
  }
  primaryKey() {
    return new _TimestampColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { isPrimaryKey: true })
    );
  }
  default(value) {
    return new _TimestampColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { defaultValue: value })
    );
  }
  name(name) {
    return new _TimestampColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { name })
    );
  }
};
var TimeDurationColumnBuilder = class _TimeDurationColumnBuilder extends ColumnBuilder {
  index(algorithm = "btree") {
    return new _TimeDurationColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { indexType: algorithm })
    );
  }
  unique() {
    return new _TimeDurationColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { isUnique: true })
    );
  }
  primaryKey() {
    return new _TimeDurationColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { isPrimaryKey: true })
    );
  }
  default(value) {
    return new _TimeDurationColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { defaultValue: value })
    );
  }
  name(name) {
    return new _TimeDurationColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { name })
    );
  }
};
var UuidColumnBuilder = class _UuidColumnBuilder extends ColumnBuilder {
  index(algorithm = "btree") {
    return new _UuidColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { indexType: algorithm })
    );
  }
  unique() {
    return new _UuidColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { isUnique: true })
    );
  }
  primaryKey() {
    return new _UuidColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { isPrimaryKey: true })
    );
  }
  default(value) {
    return new _UuidColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { defaultValue: value })
    );
  }
};
var RefBuilder = class extends TypeBuilder {
  ref;
  /** The phantom type of the pointee of this ref. */
  __spacetimeType;
  constructor(ref) {
    super(AlgebraicType.Ref(ref));
    this.ref = ref;
  }
};
var enumImpl = ((nameOrObj, maybeObj) => {
  let obj = nameOrObj;
  let name = void 0;
  if (typeof nameOrObj === "string") {
    if (!maybeObj) {
      throw new TypeError(
        "When providing a name, you must also provide the variants object or array."
      );
    }
    obj = maybeObj;
    name = nameOrObj;
  }
  if (Array.isArray(obj)) {
    const simpleVariantsObj = {};
    for (const variant of obj) {
      simpleVariantsObj[variant] = new UnitBuilder();
    }
    return new SimpleSumBuilderImpl(simpleVariantsObj, name);
  }
  return new SumBuilder(obj, name);
});
var t = {
  /**
   * Creates a new `Bool` {@link AlgebraicType} to be used in table definitions
   * Represented as `boolean` in TypeScript.
   * @returns A new {@link BoolBuilder} instance
   */
  bool: () => new BoolBuilder(),
  /**
   * Creates a new `String` {@link AlgebraicType} to be used in table definitions
   * Represented as `string` in TypeScript.
   * @returns A new {@link StringBuilder} instance
   */
  string: () => new StringBuilder(),
  /**
   * Creates a new `F64` {@link AlgebraicType} to be used in table definitions
   * Represented as `number` in TypeScript.
   * @returns A new {@link F64Builder} instance
   */
  number: () => new F64Builder(),
  /**
   * Creates a new `I8` {@link AlgebraicType} to be used in table definitions
   * Represented as `number` in TypeScript.
   * @returns A new {@link I8Builder} instance
   */
  i8: () => new I8Builder(),
  /**
   * Creates a new `U8` {@link AlgebraicType} to be used in table definitions
   * Represented as `number` in TypeScript.
   * @returns A new {@link U8Builder} instance
   */
  u8: () => new U8Builder(),
  /**
   * Creates a new `I16` {@link AlgebraicType} to be used in table definitions
   * Represented as `number` in TypeScript.
   * @returns A new {@link I16Builder} instance
   */
  i16: () => new I16Builder(),
  /**
   * Creates a new `U16` {@link AlgebraicType} to be used in table definitions
   * Represented as `number` in TypeScript.
   * @returns A new {@link U16Builder} instance
   */
  u16: () => new U16Builder(),
  /**
   * Creates a new `I32` {@link AlgebraicType} to be used in table definitions
   * Represented as `number` in TypeScript.
   * @returns A new {@link I32Builder} instance
   */
  i32: () => new I32Builder(),
  /**
   * Creates a new `U32` {@link AlgebraicType} to be used in table definitions
   * Represented as `number` in TypeScript.
   * @returns A new {@link U32Builder} instance
   */
  u32: () => new U32Builder(),
  /**
   * Creates a new `I64` {@link AlgebraicType} to be used in table definitions
   * Represented as `bigint` in TypeScript.
   * @returns A new {@link I64Builder} instance
   */
  i64: () => new I64Builder(),
  /**
   * Creates a new `U64` {@link AlgebraicType} to be used in table definitions
   * Represented as `bigint` in TypeScript.
   * @returns A new {@link U64Builder} instance
   */
  u64: () => new U64Builder(),
  /**
   * Creates a new `I128` {@link AlgebraicType} to be used in table definitions
   * Represented as `bigint` in TypeScript.
   * @returns A new {@link I128Builder} instance
   */
  i128: () => new I128Builder(),
  /**
   * Creates a new `U128` {@link AlgebraicType} to be used in table definitions
   * Represented as `bigint` in TypeScript.
   * @returns A new {@link U128Builder} instance
   */
  u128: () => new U128Builder(),
  /**
   * Creates a new `I256` {@link AlgebraicType} to be used in table definitions
   * Represented as `bigint` in TypeScript.
   * @returns A new {@link I256Builder} instance
   */
  i256: () => new I256Builder(),
  /**
   * Creates a new `U256` {@link AlgebraicType} to be used in table definitions
   * Represented as `bigint` in TypeScript.
   * @returns A new {@link U256Builder} instance
   */
  u256: () => new U256Builder(),
  /**
   * Creates a new `F32` {@link AlgebraicType} to be used in table definitions
   * Represented as `number` in TypeScript.
   * @returns A new {@link F32Builder} instance
   */
  f32: () => new F32Builder(),
  /**
   * Creates a new `F64` {@link AlgebraicType} to be used in table definitions
   * Represented as `number` in TypeScript.
   * @returns A new {@link F64Builder} instance
   */
  f64: () => new F64Builder(),
  /**
   * Creates a new `Product` {@link AlgebraicType} to be used in table definitions. Product types in SpacetimeDB
   * are essentially the same as objects in JavaScript/TypeScript.
   * Properties of the object must also be {@link TypeBuilder}s.
   * Represented as an object with specific properties in TypeScript.
   *
   * @param name (optional) A display name for the product type. If omitted, an anonymous product type is created.
   * @param obj The object defining the properties of the type, whose property
   * values must be {@link TypeBuilder}s.
   * @returns A new {@link ProductBuilder} instance.
   */
  object: ((nameOrObj, maybeObj) => {
    if (typeof nameOrObj === "string") {
      if (!maybeObj) {
        throw new TypeError(
          "When providing a name, you must also provide the object."
        );
      }
      return new ProductBuilder(maybeObj, nameOrObj);
    }
    return new ProductBuilder(nameOrObj, void 0);
  }),
  /**
   * Creates a new `Row` {@link AlgebraicType} to be used in table definitions. Row types in SpacetimeDB
   * are similar to `Product` types, but are specifically used to define the schema of a table row.
   * Properties of the object must also be {@link TypeBuilder} or {@link ColumnBuilder}s.
   *
   * You can represent a `Row` as either a {@link RowObj} or an {@link RowBuilder} type when
   * defining a table schema.
   *
   * The {@link RowBuilder} type is useful when you want to create a type which can be used anywhere
   * a {@link TypeBuilder} is accepted, such as in nested objects or arrays, or as the argument
   * to a scheduled function.
   *
   * @param obj The object defining the properties of the row, whose property
   * values must be {@link TypeBuilder}s or {@link ColumnBuilder}s.
   * @returns A new {@link RowBuilder} instance
   */
  row: ((nameOrObj, maybeObj) => {
    const [obj, name] = typeof nameOrObj === "string" ? [maybeObj, nameOrObj] : [nameOrObj, void 0];
    return new RowBuilder(obj, name);
  }),
  /**
   * Creates a new `Array` {@link AlgebraicType} to be used in table definitions.
   * Represented as an array in TypeScript.
   * @param element The element type of the array, which must be a `TypeBuilder`.
   * @returns A new {@link ArrayBuilder} instance
   */
  array(e) {
    return new ArrayBuilder(e);
  },
  enum: enumImpl,
  /**
   * This is a special helper function for conveniently creating {@link Product} type columns with no fields.
   *
   * @returns A new {@link ProductBuilder} instance with no fields.
   */
  unit() {
    return new UnitBuilder();
  },
  /**
   * Creates a lazily-evaluated {@link TypeBuilder}. This is useful for creating
   * recursive types, such as a tree or linked list.
   * @param thunk A function that returns a {@link TypeBuilder}.
   * @returns A proxy {@link TypeBuilder} that evaluates the thunk on first access.
   */
  lazy(thunk) {
    let cached = null;
    const get = () => cached ??= thunk();
    const proxy = new Proxy({}, {
      get(_t, prop, recv) {
        const target = get();
        const val = Reflect.get(target, prop, recv);
        return typeof val === "function" ? val.bind(target) : val;
      },
      set(_t, prop, value, recv) {
        return Reflect.set(get(), prop, value, recv);
      },
      has(_t, prop) {
        return prop in get();
      },
      ownKeys() {
        return Reflect.ownKeys(get());
      },
      getOwnPropertyDescriptor(_t, prop) {
        return Object.getOwnPropertyDescriptor(get(), prop);
      },
      getPrototypeOf() {
        return Object.getPrototypeOf(get());
      }
    });
    return proxy;
  },
  /**
   * This is a special helper function for conveniently creating {@link ScheduleAt} type columns.
   * @returns A new ColumnBuilder instance with the {@link ScheduleAt} type.
   */
  scheduleAt: () => {
    return new ScheduleAtBuilder();
  },
  /**
   * This is a convenience method for creating a column with the {@link Option} type.
   * You can create a column of the same type by constructing an enum with a `some` and `none` variant.
   * @param value The type of the value contained in the `some` variant of the `Option`.
   * @returns A new {@link OptionBuilder} instance with the {@link Option} type.
   */
  option(value) {
    return new OptionBuilder(value);
  },
  /**
   * This is a convenience method for creating a column with the {@link Result} type.
   * You can create a column of the same type by constructing an enum with an `ok` and `err` variant.
   * @param ok The type of the value contained in the `ok` variant of the `Result`.
   * @param err The type of the value contained in the `err` variant of the `Result`.
   * @returns A new {@link ResultBuilder} instance with the {@link Result} type.
   */
  result(ok, err) {
    return new ResultBuilder(ok, err);
  },
  /**
   * This is a convenience method for creating a column with the {@link Identity} type.
   * You can create a column of the same type by constructing an `object` with a single `__identity__` element.
   * @returns A new {@link TypeBuilder} instance with the {@link Identity} type.
   */
  identity: () => {
    return new IdentityBuilder();
  },
  /**
   * This is a convenience method for creating a column with the {@link ConnectionId} type.
   * You can create a column of the same type by constructing an `object` with a single `__connection_id__` element.
   * @returns A new {@link TypeBuilder} instance with the {@link ConnectionId} type.
   */
  connectionId: () => {
    return new ConnectionIdBuilder();
  },
  /**
   * This is a convenience method for creating a column with the {@link Timestamp} type.
   * You can create a column of the same type by constructing an `object` with a single `__timestamp_micros_since_unix_epoch__` element.
   * @returns A new {@link TypeBuilder} instance with the {@link Timestamp} type.
   */
  timestamp: () => {
    return new TimestampBuilder();
  },
  /**
   * This is a convenience method for creating a column with the {@link TimeDuration} type.
   * You can create a column of the same type by constructing an `object` with a single `__time_duration_micros__` element.
   * @returns A new {@link TypeBuilder} instance with the {@link TimeDuration} type.
   */
  timeDuration: () => {
    return new TimeDurationBuilder();
  },
  /**
   * This is a convenience method for creating a column with the {@link Uuid} type.
   * You can create a column of the same type by constructing an `object` with a single `__uuid__` element.
   * @returns A new {@link TypeBuilder} instance with the {@link Uuid} type.
   */
  uuid: () => {
    return new UuidBuilder();
  },
  /**
   * This is a convenience method for creating a column with the {@link ByteArray} type.
   * You can create a column of the same type by constructing an `array` of `u8`.
   * The TypeScript representation is {@link Uint8Array}.
   * @returns A new {@link ByteArrayBuilder} instance with the {@link ByteArray} type.
   */
  byteArray: () => {
    return new ByteArrayBuilder();
  }
};

// src/sdk/client_api/row_size_hint_type.ts
var RowSizeHint = t.enum("RowSizeHint", {
  FixedSize: t.u16(),
  RowOffsets: t.array(t.u64())
});
var row_size_hint_type_default = RowSizeHint;

// src/sdk/client_api/bsatn_row_list_type.ts
var bsatn_row_list_type_default = t.object("BsatnRowList", {
  get sizeHint() {
    return row_size_hint_type_default;
  },
  rowsData: t.byteArray()
});

// src/sdk/client_api/call_reducer_type.ts
var call_reducer_type_default = t.object("CallReducer", {
  reducer: t.string(),
  args: t.byteArray(),
  requestId: t.u32(),
  flags: t.u8()
});

// src/sdk/client_api/subscribe_type.ts
var subscribe_type_default = t.object("Subscribe", {
  queryStrings: t.array(t.string()),
  requestId: t.u32()
});

// src/sdk/client_api/one_off_query_type.ts
var one_off_query_type_default = t.object("OneOffQuery", {
  messageId: t.byteArray(),
  queryString: t.string()
});

// src/sdk/client_api/query_id_type.ts
var query_id_type_default = t.object("QueryId", {
  id: t.u32()
});

// src/sdk/client_api/subscribe_single_type.ts
var subscribe_single_type_default = t.object("SubscribeSingle", {
  query: t.string(),
  requestId: t.u32(),
  get queryId() {
    return query_id_type_default;
  }
});

// src/sdk/client_api/subscribe_multi_type.ts
var subscribe_multi_type_default = t.object("SubscribeMulti", {
  queryStrings: t.array(t.string()),
  requestId: t.u32(),
  get queryId() {
    return query_id_type_default;
  }
});

// src/sdk/client_api/unsubscribe_type.ts
var unsubscribe_type_default = t.object("Unsubscribe", {
  requestId: t.u32(),
  get queryId() {
    return query_id_type_default;
  }
});

// src/sdk/client_api/unsubscribe_multi_type.ts
var unsubscribe_multi_type_default = t.object("UnsubscribeMulti", {
  requestId: t.u32(),
  get queryId() {
    return query_id_type_default;
  }
});

// src/sdk/client_api/call_procedure_type.ts
var call_procedure_type_default = t.object("CallProcedure", {
  procedure: t.string(),
  args: t.byteArray(),
  requestId: t.u32(),
  flags: t.u8()
});

// src/sdk/client_api/client_message_type.ts
var ClientMessage = t.enum("ClientMessage", {
  get CallReducer() {
    return call_reducer_type_default;
  },
  get Subscribe() {
    return subscribe_type_default;
  },
  get OneOffQuery() {
    return one_off_query_type_default;
  },
  get SubscribeSingle() {
    return subscribe_single_type_default;
  },
  get SubscribeMulti() {
    return subscribe_multi_type_default;
  },
  get Unsubscribe() {
    return unsubscribe_type_default;
  },
  get UnsubscribeMulti() {
    return unsubscribe_multi_type_default;
  },
  get CallProcedure() {
    return call_procedure_type_default;
  }
});
var client_message_type_default = ClientMessage;

// src/sdk/client_api/query_update_type.ts
var query_update_type_default = t.object("QueryUpdate", {
  get deletes() {
    return bsatn_row_list_type_default;
  },
  get inserts() {
    return bsatn_row_list_type_default;
  }
});

// src/sdk/client_api/compressable_query_update_type.ts
var CompressableQueryUpdate = t.enum("CompressableQueryUpdate", {
  get Uncompressed() {
    return query_update_type_default;
  },
  Brotli: t.byteArray(),
  Gzip: t.byteArray()
});
var compressable_query_update_type_default = CompressableQueryUpdate;

// src/sdk/client_api/table_update_type.ts
var table_update_type_default = t.object("TableUpdate", {
  tableId: t.u32(),
  tableName: t.string(),
  numRows: t.u64(),
  get updates() {
    return t.array(compressable_query_update_type_default);
  }
});

// src/sdk/client_api/database_update_type.ts
var database_update_type_default = t.object("DatabaseUpdate", {
  get tables() {
    return t.array(table_update_type_default);
  }
});

// src/sdk/client_api/initial_subscription_type.ts
var initial_subscription_type_default = t.object("InitialSubscription", {
  get databaseUpdate() {
    return database_update_type_default;
  },
  requestId: t.u32(),
  totalHostExecutionDuration: t.timeDuration()
});

// src/sdk/client_api/update_status_type.ts
var UpdateStatus = t.enum("UpdateStatus", {
  get Committed() {
    return database_update_type_default;
  },
  Failed: t.string(),
  OutOfEnergy: t.unit()
});
var update_status_type_default = UpdateStatus;

// src/sdk/client_api/reducer_call_info_type.ts
var reducer_call_info_type_default = t.object("ReducerCallInfo", {
  reducerName: t.string(),
  reducerId: t.u32(),
  args: t.byteArray(),
  requestId: t.u32()
});

// src/sdk/client_api/energy_quanta_type.ts
var energy_quanta_type_default = t.object("EnergyQuanta", {
  quanta: t.u128()
});

// src/sdk/client_api/transaction_update_type.ts
var transaction_update_type_default = t.object("TransactionUpdate", {
  get status() {
    return update_status_type_default;
  },
  timestamp: t.timestamp(),
  callerIdentity: t.identity(),
  callerConnectionId: t.connectionId(),
  get reducerCall() {
    return reducer_call_info_type_default;
  },
  get energyQuantaUsed() {
    return energy_quanta_type_default;
  },
  totalHostExecutionDuration: t.timeDuration()
});

// src/sdk/client_api/transaction_update_light_type.ts
var transaction_update_light_type_default = t.object("TransactionUpdateLight", {
  requestId: t.u32(),
  get update() {
    return database_update_type_default;
  }
});

// src/sdk/client_api/identity_token_type.ts
var identity_token_type_default = t.object("IdentityToken", {
  identity: t.identity(),
  token: t.string(),
  connectionId: t.connectionId()
});

// src/sdk/client_api/one_off_table_type.ts
var one_off_table_type_default = t.object("OneOffTable", {
  tableName: t.string(),
  get rows() {
    return bsatn_row_list_type_default;
  }
});

// src/sdk/client_api/one_off_query_response_type.ts
var one_off_query_response_type_default = t.object("OneOffQueryResponse", {
  messageId: t.byteArray(),
  error: t.option(t.string()),
  get tables() {
    return t.array(one_off_table_type_default);
  },
  totalHostExecutionDuration: t.timeDuration()
});

// src/sdk/client_api/subscribe_rows_type.ts
var subscribe_rows_type_default = t.object("SubscribeRows", {
  tableId: t.u32(),
  tableName: t.string(),
  get tableRows() {
    return table_update_type_default;
  }
});

// src/sdk/client_api/subscribe_applied_type.ts
var subscribe_applied_type_default = t.object("SubscribeApplied", {
  requestId: t.u32(),
  totalHostExecutionDurationMicros: t.u64(),
  get queryId() {
    return query_id_type_default;
  },
  get rows() {
    return subscribe_rows_type_default;
  }
});

// src/sdk/client_api/unsubscribe_applied_type.ts
var unsubscribe_applied_type_default = t.object("UnsubscribeApplied", {
  requestId: t.u32(),
  totalHostExecutionDurationMicros: t.u64(),
  get queryId() {
    return query_id_type_default;
  },
  get rows() {
    return subscribe_rows_type_default;
  }
});

// src/sdk/client_api/subscription_error_type.ts
var subscription_error_type_default = t.object("SubscriptionError", {
  totalHostExecutionDurationMicros: t.u64(),
  requestId: t.option(t.u32()),
  queryId: t.option(t.u32()),
  tableId: t.option(t.u32()),
  error: t.string()
});

// src/sdk/client_api/subscribe_multi_applied_type.ts
var subscribe_multi_applied_type_default = t.object("SubscribeMultiApplied", {
  requestId: t.u32(),
  totalHostExecutionDurationMicros: t.u64(),
  get queryId() {
    return query_id_type_default;
  },
  get update() {
    return database_update_type_default;
  }
});

// src/sdk/client_api/unsubscribe_multi_applied_type.ts
var unsubscribe_multi_applied_type_default = t.object("UnsubscribeMultiApplied", {
  requestId: t.u32(),
  totalHostExecutionDurationMicros: t.u64(),
  get queryId() {
    return query_id_type_default;
  },
  get update() {
    return database_update_type_default;
  }
});

// src/sdk/client_api/procedure_status_type.ts
var ProcedureStatus = t.enum("ProcedureStatus", {
  Returned: t.byteArray(),
  OutOfEnergy: t.unit(),
  InternalError: t.string()
});
var procedure_status_type_default = ProcedureStatus;

// src/sdk/client_api/procedure_result_type.ts
var procedure_result_type_default = t.object("ProcedureResult", {
  get status() {
    return procedure_status_type_default;
  },
  timestamp: t.timestamp(),
  totalHostExecutionDuration: t.timeDuration(),
  requestId: t.u32()
});

// src/sdk/client_api/server_message_type.ts
var ServerMessage = t.enum("ServerMessage", {
  get InitialSubscription() {
    return initial_subscription_type_default;
  },
  get TransactionUpdate() {
    return transaction_update_type_default;
  },
  get TransactionUpdateLight() {
    return transaction_update_light_type_default;
  },
  get IdentityToken() {
    return identity_token_type_default;
  },
  get OneOffQueryResponse() {
    return one_off_query_response_type_default;
  },
  get SubscribeApplied() {
    return subscribe_applied_type_default;
  },
  get UnsubscribeApplied() {
    return unsubscribe_applied_type_default;
  },
  get SubscriptionError() {
    return subscription_error_type_default;
  },
  get SubscribeMultiApplied() {
    return subscribe_multi_applied_type_default;
  },
  get UnsubscribeMultiApplied() {
    return unsubscribe_multi_applied_type_default;
  },
  get ProcedureResult() {
    return procedure_result_type_default;
  }
});
var server_message_type_default = ServerMessage;

// src/sdk/event_emitter.ts
var EventEmitter = class {
  #events = /* @__PURE__ */ new Map();
  on(event, callback) {
    let callbacks = this.#events.get(event);
    if (!callbacks) {
      callbacks = /* @__PURE__ */ new Set();
      this.#events.set(event, callbacks);
    }
    callbacks.add(callback);
  }
  off(event, callback) {
    const callbacks = this.#events.get(event);
    if (!callbacks) {
      return;
    }
    callbacks.delete(callback);
  }
  emit(event, ...args) {
    const callbacks = this.#events.get(event);
    if (!callbacks) {
      return;
    }
    for (const callback of callbacks) {
      callback(...args);
    }
  }
};

// src/sdk/logger.ts
var LogLevelIdentifierIcon = {
  component: "\u{1F4E6}",
  info: "\u2139\uFE0F",
  warn: "\u26A0\uFE0F",
  error: "\u274C",
  debug: "\u{1F41B}"
};
var LogStyle = {
  component: "color: #fff; background-color: #8D6FDD; padding: 2px 5px; border-radius: 3px;",
  info: "color: #fff; background-color: #007bff; padding: 2px 5px; border-radius: 3px;",
  warn: "color: #fff; background-color: #ffc107; padding: 2px 5px; border-radius: 3px;",
  error: "color: #fff; background-color: #dc3545; padding: 2px 5px; border-radius: 3px;",
  debug: "color: #fff; background-color: #28a745; padding: 2px 5px; border-radius: 3px;"
};
var LogTextStyle = {
  component: "color: #8D6FDD;",
  info: "color: #007bff;",
  warn: "color: #ffc107;",
  error: "color: #dc3545;",
  debug: "color: #28a745;"
};
var stdbLogger = (level, message) => {
  console.log(
    `%c${LogLevelIdentifierIcon[level]} ${level.toUpperCase()}%c ${message}`,
    LogStyle[level],
    LogTextStyle[level]
  );
};

// src/sdk/table_cache.ts
var scalarCompare = (x, y) => {
  if (x === y) return 0;
  return x < y ? -1 : 1;
};
var TableCacheImpl = class {
  rows;
  tableDef;
  emitter;
  /**
   * @param name the table name
   * @param primaryKeyCol column index designated as `#[primarykey]`
   * @param primaryKey column name designated as `#[primarykey]`
   * @param entityClass the entityClass
   */
  constructor(tableDef) {
    this.tableDef = tableDef;
    this.rows = /* @__PURE__ */ new Map();
    this.emitter = new EventEmitter();
    const indexesDef = this.tableDef.indexes || [];
    for (const idx of indexesDef) {
      const idxDef = idx;
      const index = this.#makeReadonlyIndex(this.tableDef, idxDef);
      this[idx.name] = index;
    }
  }
  // TODO: this just scans the whole table; we should build proper index structures
  #makeReadonlyIndex(tableDef, idx) {
    if (idx.algorithm !== "btree") {
      throw new Error("Only btree indexes are supported in TableCacheImpl");
    }
    const columns = idx.columns;
    const getKey = (row) => columns.map((c) => row[c]);
    const matchRange = (row, rangeArg) => {
      const key = getKey(row);
      const arr = Array.isArray(rangeArg) ? rangeArg : [rangeArg];
      const prefixLen = Math.max(0, arr.length - 1);
      for (let i = 0; i < prefixLen; i++) {
        if (!deepEqual(key[i], arr[i])) return false;
      }
      const lastProvided = arr[arr.length - 1];
      const kLast = key[prefixLen];
      if (lastProvided && typeof lastProvided === "object" && "from" in lastProvided && "to" in lastProvided) {
        const from = lastProvided.from;
        const to = lastProvided.to;
        if (from.tag !== "unbounded") {
          const c = scalarCompare(kLast, from.value);
          if (c < 0) return false;
          if (c === 0 && from.tag === "excluded") return false;
        }
        if (to.tag !== "unbounded") {
          const c = scalarCompare(kLast, to.value);
          if (c > 0) return false;
          if (c === 0 && to.tag === "excluded") return false;
        }
        return true;
      } else {
        if (!deepEqual(kLast, lastProvided)) return false;
        return true;
      }
    };
    const isUnique = tableDef.constraints.some((constraint) => {
      if (constraint.constraint !== "unique") {
        return false;
      }
      return deepEqual(constraint.columns, idx.columns);
    });
    const self = this;
    if (isUnique) {
      const impl = {
        find: (colVal) => {
          const expected = Array.isArray(colVal) ? colVal : [colVal];
          for (const row of self.iter()) {
            if (deepEqual(getKey(row), expected)) return row;
          }
          return null;
        }
      };
      return impl;
    } else {
      const impl = {
        *filter(range) {
          for (const row of self.iter()) {
            if (matchRange(row, range)) yield row;
          }
        }
      };
      return impl;
    }
  }
  /**
   * @returns number of rows in the table
   */
  count() {
    return BigInt(this.rows.size);
  }
  /**
   * @returns The values of the rows in the table
   */
  iter() {
    function* generator(rows) {
      for (const [row] of rows.values()) {
        yield row;
      }
    }
    return generator(this.rows);
  }
  /**
   * Allows iteration over the rows in the table
   * @returns An iterator over the rows in the table
   */
  [Symbol.iterator]() {
    return this.iter();
  }
  applyOperations = (operations, ctx) => {
    const pendingCallbacks = [];
    const hasPrimaryKey = Object.values(this.tableDef.columns).some(
      (col) => col.columnMetadata.isPrimaryKey === true
    );
    if (hasPrimaryKey) {
      const insertMap = /* @__PURE__ */ new Map();
      const deleteMap = /* @__PURE__ */ new Map();
      for (const op of operations) {
        if (op.type === "insert") {
          const [_, prevCount] = insertMap.get(op.rowId) || [op, 0];
          insertMap.set(op.rowId, [op, prevCount + 1]);
        } else {
          const [_, prevCount] = deleteMap.get(op.rowId) || [op, 0];
          deleteMap.set(op.rowId, [op, prevCount + 1]);
        }
      }
      for (const [primaryKey, [insertOp, refCount]] of insertMap) {
        const deleteEntry = deleteMap.get(primaryKey);
        if (deleteEntry) {
          const [_, deleteCount] = deleteEntry;
          const refCountDelta = refCount - deleteCount;
          const maybeCb = this.update(
            ctx,
            primaryKey,
            insertOp.row,
            refCountDelta
          );
          if (maybeCb) {
            pendingCallbacks.push(maybeCb);
          }
          deleteMap.delete(primaryKey);
        } else {
          const maybeCb = this.insert(ctx, insertOp, refCount);
          if (maybeCb) {
            pendingCallbacks.push(maybeCb);
          }
        }
      }
      for (const [deleteOp, refCount] of deleteMap.values()) {
        const maybeCb = this.delete(ctx, deleteOp, refCount);
        if (maybeCb) {
          pendingCallbacks.push(maybeCb);
        }
      }
    } else {
      for (const op of operations) {
        if (op.type === "insert") {
          const maybeCb = this.insert(ctx, op);
          if (maybeCb) {
            pendingCallbacks.push(maybeCb);
          }
        } else {
          const maybeCb = this.delete(ctx, op);
          if (maybeCb) {
            pendingCallbacks.push(maybeCb);
          }
        }
      }
    }
    return pendingCallbacks;
  };
  update = (ctx, rowId, newRow, refCountDelta = 0) => {
    const existingEntry = this.rows.get(rowId);
    if (!existingEntry) {
      stdbLogger(
        "error",
        `Updating a row that was not present in the cache. Table: ${this.tableDef.name}, RowId: ${rowId}`
      );
      return void 0;
    }
    const [oldRow, previousCount] = existingEntry;
    const refCount = Math.max(1, previousCount + refCountDelta);
    if (previousCount + refCountDelta <= 0) {
      stdbLogger(
        "error",
        `Negative reference count for in table ${this.tableDef.name} row ${rowId} (${previousCount} + ${refCountDelta})`
      );
      return void 0;
    }
    this.rows.set(rowId, [newRow, refCount]);
    if (previousCount === 0) {
      stdbLogger(
        "error",
        `Updating a row id in table ${this.tableDef.name} which was not present in the cache (rowId: ${rowId})`
      );
      return {
        type: "insert",
        table: this.tableDef.name,
        cb: () => {
          this.emitter.emit("insert", ctx, newRow);
        }
      };
    }
    return {
      type: "update",
      table: this.tableDef.name,
      cb: () => {
        this.emitter.emit("update", ctx, oldRow, newRow);
      }
    };
  };
  insert = (ctx, operation, count = 1) => {
    const [_, previousCount] = this.rows.get(operation.rowId) || [
      operation.row,
      0
    ];
    this.rows.set(operation.rowId, [operation.row, previousCount + count]);
    if (previousCount === 0) {
      return {
        type: "insert",
        table: this.tableDef.name,
        cb: () => {
          this.emitter.emit("insert", ctx, operation.row);
        }
      };
    }
    return void 0;
  };
  delete = (ctx, operation, count = 1) => {
    const [_, previousCount] = this.rows.get(operation.rowId) || [
      operation.row,
      0
    ];
    if (previousCount === 0) {
      stdbLogger("warn", "Deleting a row that was not present in the cache");
      return void 0;
    }
    if (previousCount <= count) {
      this.rows.delete(operation.rowId);
      return {
        type: "delete",
        table: this.tableDef.name,
        cb: () => {
          this.emitter.emit("delete", ctx, operation.row);
        }
      };
    }
    this.rows.set(operation.rowId, [operation.row, previousCount - count]);
    return void 0;
  };
  /**
   * Register a callback for when a row is newly inserted into the database.
   *
   * ```ts
   * ctx.db.user.onInsert((reducerEvent, user) => {
   *   if (reducerEvent) {
   *      console.log("New user on reducer", reducerEvent, user);
   *   } else {
   *      console.log("New user received during subscription update on insert", user);
   *  }
   * });
   * ```
   *
   * @param cb Callback to be called when a new row is inserted
   */
  onInsert = (cb) => {
    this.emitter.on("insert", cb);
  };
  /**
   * Register a callback for when a row is deleted from the database.
   *
   * ```ts
   * ctx.db.user.onDelete((reducerEvent, user) => {
   *   if (reducerEvent) {
   *      console.log("Deleted user on reducer", reducerEvent, user);
   *   } else {
   *      console.log("Deleted user received during subscription update on update", user);
   *  }
   * });
   * ```
   *
   * @param cb Callback to be called when a new row is inserted
   */
  onDelete = (cb) => {
    this.emitter.on("delete", cb);
  };
  /**
   * Register a callback for when a row is updated into the database.
   *
   * ```ts
   * ctx.db.user.onInsert((reducerEvent, oldUser, user) => {
   *   if (reducerEvent) {
   *      console.log("Updated user on reducer", reducerEvent, user);
   *   } else {
   *      console.log("Updated user received during subscription update on delete", user);
   *  }
   * });
   * ```
   *
   * @param cb Callback to be called when a new row is inserted
   */
  onUpdate = (cb) => {
    this.emitter.on("update", cb);
  };
  /**
   * Remove a callback for when a row is newly inserted into the database.
   *
   * @param cb Callback to be removed
   */
  removeOnInsert = (cb) => {
    this.emitter.off("insert", cb);
  };
  /**
   * Remove a callback for when a row is deleted from the database.
   *
   * @param cb Callback to be removed
   */
  removeOnDelete = (cb) => {
    this.emitter.off("delete", cb);
  };
  /**
   * Remove a callback for when a row is updated into the database.
   *
   * @param cb Callback to be removed
   */
  removeOnUpdate = (cb) => {
    this.emitter.off("update", cb);
  };
};

// src/sdk/client_cache.ts
var TableMap = class {
  map = /* @__PURE__ */ new Map();
  get(key) {
    return this.map.get(key);
  }
  set(key, value) {
    this.map.set(key, value);
    return this;
  }
  has(key) {
    return this.map.has(key);
  }
  delete(key) {
    return this.map.delete(key);
  }
  // optional: iteration stays broadly typed (cannot express per-key relation here)
  keys() {
    return this.map.keys();
  }
  values() {
    return this.map.values();
  }
  entries() {
    return this.map.entries();
  }
  [Symbol.iterator]() {
    return this.entries();
  }
};
var ClientCache = class {
  /**
   * The tables in the database.
   */
  tables = new TableMap();
  /**
   * Returns the table with the given name.
   * - If SchemaDef is a concrete schema, `name` is constrained to known table names,
   *   and the return type matches that table.
   * - If SchemaDef is undefined, `name` is string and the return type is untyped.
   */
  getTable(name) {
    const table2 = this.tables.get(name);
    if (!table2) {
      console.error(
        "The table has not been registered for this client. Please register the table before using it. If you have registered global tables using the SpacetimeDBClient.registerTables() or `registerTable()` method, please make sure that is executed first!"
      );
      throw new Error(`Table ${String(name)} does not exist`);
    }
    return table2;
  }
  /**
   * Returns the table with the given name, creating it if needed.
   * - Typed mode: `tableTypeInfo.tableName` is constrained to known names and
   *   the return type matches that table.
   * - Untyped mode: accepts any string and returns an untyped TableCache.
   */
  getOrCreateTable(tableDef) {
    const name = tableDef.name;
    const table2 = this.tables.get(name);
    if (table2) {
      return table2;
    }
    const newTable = new TableCacheImpl(
      tableDef
    );
    this.tables.set(name, newTable);
    return newTable;
  }
};

// src/sdk/version.ts
function comparePreReleases(a, b) {
  const len = Math.min(a.length, b.length);
  for (let i = 0; i < len; i++) {
    const aPart = a[i];
    const bPart = b[i];
    if (aPart === bPart) continue;
    if (typeof aPart === "number" && typeof bPart === "number") {
      return aPart - bPart;
    }
    if (typeof aPart === "string" && typeof bPart === "string") {
      return aPart.localeCompare(bPart);
    }
    return typeof aPart === "string" ? 1 : -1;
  }
  return a.length - b.length;
}
var SemanticVersion = class _SemanticVersion {
  major;
  minor;
  patch;
  preRelease;
  buildInfo;
  constructor(major, minor, patch, preRelease = null, buildInfo = null) {
    this.major = major;
    this.minor = minor;
    this.patch = patch;
    this.preRelease = preRelease;
    this.buildInfo = buildInfo;
  }
  toString() {
    let versionString = `${this.major}.${this.minor}.${this.patch}`;
    if (this.preRelease) {
      versionString += `-${this.preRelease.join(".")}`;
    }
    if (this.buildInfo) {
      versionString += `+${this.buildInfo}`;
    }
    return versionString;
  }
  compare(other) {
    if (this.major !== other.major) {
      return this.major - other.major;
    }
    if (this.minor !== other.minor) {
      return this.minor - other.minor;
    }
    if (this.patch !== other.patch) {
      return this.patch - other.patch;
    }
    if (this.preRelease && other.preRelease) {
      return comparePreReleases(this.preRelease, other.preRelease);
    }
    if (this.preRelease) {
      return -1;
    }
    if (other.preRelease) {
      return -1;
    }
    return 0;
  }
  clone() {
    return new _SemanticVersion(
      this.major,
      this.minor,
      this.patch,
      this.preRelease ? [...this.preRelease] : null,
      this.buildInfo
    );
  }
  static parseVersionString(version) {
    const regex = /^(0|[1-9]\d*)\.(0|[1-9]\d*)\.(0|[1-9]\d*)(?:-([\da-zA-Z-]+(?:\.[\da-zA-Z-]+)*))?(?:\+([\da-zA-Z-]+(?:\.[\da-zA-Z-]+)*))?$/;
    const match = version.match(regex);
    if (!match) {
      throw new Error(`Invalid version string: ${version}`);
    }
    const major = parseInt(match[1], 10);
    const minor = parseInt(match[2], 10);
    const patch = parseInt(match[3], 10);
    const preRelease = match[4] ? match[4].split(".").map((id) => isNaN(Number(id)) ? id : Number(id)) : null;
    const buildInfo = match[5] || null;
    return new _SemanticVersion(major, minor, patch, preRelease, buildInfo);
  }
};
var _MINIMUM_CLI_VERSION = new SemanticVersion(
  1,
  4,
  0
);
function ensureMinimumVersionOrThrow(versionString) {
  if (versionString === void 0) {
    throw new Error(versionErrorMessage(versionString));
  }
  const version = SemanticVersion.parseVersionString(versionString);
  if (version.compare(_MINIMUM_CLI_VERSION) < 0) {
    throw new Error(versionErrorMessage(versionString));
  }
}
function versionErrorMessage(incompatibleVersion) {
  return `Module code was generated with an incompatible version of the spacetimedb cli (${incompatibleVersion}). Update the cli version to at least ${_MINIMUM_CLI_VERSION.toString()} and regenerate the bindings. You can upgrade to the latest cli version by running: spacetime version upgrade`;
}

// src/sdk/decompress.ts
async function decompress(buffer, type, chunkSize = 128 * 1024) {
  let offset = 0;
  const readableStream = new ReadableStream({
    pull(controller) {
      if (offset < buffer.length) {
        const chunk = buffer.subarray(
          offset,
          Math.min(offset + chunkSize, buffer.length)
        );
        controller.enqueue(chunk);
        offset += chunkSize;
      } else {
        controller.close();
      }
    }
  });
  const decompressionStream = new DecompressionStream(type);
  const decompressedStream = readableStream.pipeThrough(decompressionStream);
  const reader = decompressedStream.getReader();
  const chunks = [];
  let totalLength = 0;
  let result;
  while (!(result = await reader.read()).done) {
    chunks.push(result.value);
    totalLength += result.value.length;
  }
  const decompressedArray = new Uint8Array(totalLength);
  let chunkOffset = 0;
  for (const chunk of chunks) {
    decompressedArray.set(chunk, chunkOffset);
    chunkOffset += chunk.length;
  }
  return decompressedArray;
}

// src/sdk/ws.ts
async function resolveWS() {
  if (typeof globalThis.WebSocket !== "undefined") {
    return globalThis.WebSocket;
  }
  const dynamicImport = new Function("m", "return import(m)");
  try {
    const { WebSocket: UndiciWS } = await dynamicImport("undici");
    return UndiciWS;
  } catch (err) {
    console.warn(
      "[spacetimedb-sdk] No global WebSocket found. On Node 18\u201321, please install `undici` (npm install undici) to enable WebSocket support."
    );
    throw err;
  }
}

// src/sdk/websocket_decompress_adapter.ts
var WebsocketDecompressAdapter = class _WebsocketDecompressAdapter {
  onclose;
  onopen;
  onmessage;
  onerror;
  #ws;
  async #handleOnMessage(msg) {
    const buffer = new Uint8Array(msg.data);
    let decompressed;
    if (buffer[0] === 0) {
      decompressed = buffer.slice(1);
    } else if (buffer[0] === 1) {
      throw new Error(
        "Brotli Compression not supported. Please use gzip or none compression in withCompression method on DbConnection."
      );
    } else if (buffer[0] === 2) {
      decompressed = await decompress(buffer.slice(1), "gzip");
    } else {
      throw new Error(
        "Unexpected Compression Algorithm. Please use `gzip` or `none`"
      );
    }
    this.onmessage?.({ data: decompressed });
  }
  #handleOnOpen(msg) {
    this.onopen?.(msg);
  }
  #handleOnError(msg) {
    this.onerror?.(msg);
  }
  #handleOnClose(msg) {
    this.onclose?.(msg);
  }
  send(msg) {
    this.#ws.send(msg);
  }
  close() {
    this.#ws.close();
  }
  constructor(ws) {
    this.onmessage = void 0;
    this.onopen = void 0;
    this.onmessage = void 0;
    this.onerror = void 0;
    ws.onmessage = this.#handleOnMessage.bind(this);
    ws.onerror = this.#handleOnError.bind(this);
    ws.onclose = this.#handleOnClose.bind(this);
    ws.onopen = this.#handleOnOpen.bind(this);
    ws.binaryType = "arraybuffer";
    this.#ws = ws;
  }
  static async createWebSocketFn({
    url,
    nameOrAddress,
    wsProtocol,
    authToken,
    compression,
    lightMode,
    confirmedReads
  }) {
    const headers = new Headers();
    const WS = await resolveWS();
    let temporaryAuthToken = void 0;
    if (authToken) {
      headers.set("Authorization", `Bearer ${authToken}`);
      const tokenUrl = new URL("v1/identity/websocket-token", url);
      tokenUrl.protocol = url.protocol === "wss:" ? "https:" : "http:";
      const response = await fetch(tokenUrl, { method: "POST", headers });
      if (response.ok) {
        const { token } = await response.json();
        temporaryAuthToken = token;
      } else {
        return Promise.reject(
          new Error(`Failed to verify token: ${response.statusText}`)
        );
      }
    }
    const databaseUrl = new URL(`v1/database/${nameOrAddress}/subscribe`, url);
    if (temporaryAuthToken) {
      databaseUrl.searchParams.set("token", temporaryAuthToken);
    }
    databaseUrl.searchParams.set(
      "compression",
      compression === "gzip" ? "Gzip" : "None"
    );
    if (lightMode) {
      databaseUrl.searchParams.set("light", "true");
    }
    if (confirmedReads !== void 0) {
      databaseUrl.searchParams.set("confirmed", confirmedReads.toString());
    }
    const ws = new WS(databaseUrl.toString(), wsProtocol);
    return new _WebsocketDecompressAdapter(ws);
  }
};

// src/sdk/db_connection_builder.ts
var DbConnectionBuilder = class {
  /**
   * Creates a new `DbConnectionBuilder` database client and set the initial parameters.
   *
   * Users are not expected to call this constructor directly. Instead, use the static method `DbConnection.builder()`.
   *
   * @param remoteModule The remote module to use to connect to the SpacetimeDB server.
   * @param dbConnectionConstructor The constructor to use to create a new `DbConnection`.
   */
  constructor(remoteModule, dbConnectionCtor) {
    this.remoteModule = remoteModule;
    this.dbConnectionCtor = dbConnectionCtor;
    this.#createWSFn = WebsocketDecompressAdapter.createWebSocketFn;
  }
  #uri;
  #nameOrAddress;
  #identity;
  #token;
  #emitter = new EventEmitter();
  #compression = "gzip";
  #lightMode = false;
  #confirmedReads;
  #createWSFn;
  /**
   * Set the URI of the SpacetimeDB server to connect to.
   *
   * @param uri The URI of the SpacetimeDB server to connect to.
   *
   **/
  withUri(uri) {
    this.#uri = new URL(uri);
    return this;
  }
  /**
   * Set the name or Identity of the database module to connect to.
   *
   * @param nameOrAddress
   *
   * @returns The `DbConnectionBuilder` instance.
   */
  withModuleName(nameOrAddress) {
    this.#nameOrAddress = nameOrAddress;
    return this;
  }
  /**
   * Set the identity of the client to connect to the database.
   *
   * @param token The credentials to use to authenticate with SpacetimeDB. This
   * is optional. You can store the token returned by the `onConnect` callback
   * to use in future connections.
   *
   * @returns The `DbConnectionBuilder` instance.
   */
  withToken(token) {
    this.#token = token;
    return this;
  }
  withWSFn(createWSFn) {
    this.#createWSFn = createWSFn;
    return this;
  }
  /**
   * Set the compression algorithm to use for the connection.
   *
   * @param compression The compression algorithm to use for the connection.
   */
  withCompression(compression) {
    this.#compression = compression;
    return this;
  }
  /**
   * Sets the connection to operate in light mode.
   *
   * Light mode is a mode that reduces the amount of data sent over the network.
   *
   * @param lightMode The light mode for the connection.
   */
  withLightMode(lightMode) {
    this.#lightMode = lightMode;
    return this;
  }
  /**
   * Sets the connection to use confirmed reads.
   *
   * When enabled, the server will send query results only after they are
   * confirmed to be durable.
   *
   * What durable means depends on the server configuration: a single node
   * server may consider a transaction durable once it is `fsync`'ed to disk,
   * whereas a cluster may require that some number of replicas have
   * acknowledge that they have stored the transactions.
   *
   * Note that enabling confirmed reads will increase the latency between a
   * reducer call and the corresponding subscription update arriving at the
   * client.
   *
   * If this method is not called, not preference is sent to the server, and
   * the server will choose the default.
   *
   * @param confirmedReads `true` to enable confirmed reads, `false` to disable.
   */
  withConfirmedReads(confirmedReads) {
    this.#confirmedReads = confirmedReads;
    return this;
  }
  /**
   * Register a callback to be invoked upon authentication with the database.
   *
   * @param identity A unique identifier for a client connected to a database.
   * @param token The credentials to use to authenticate with SpacetimeDB.
   *
   * @returns The `DbConnectionBuilder` instance.
   *
   * The callback will be invoked with the `Identity` and private authentication `token` provided by the database to identify this connection.
   *
   * If credentials were supplied to connect, those passed to the callback will be equivalent to the ones used to connect.
   *
   * If the initial connection was anonymous, a new set of credentials will be generated by the database to identify this user.
   *
   * The credentials passed to the callback can be saved and used to authenticate the same user in future connections.
   *
   * @example
   *
   * ```ts
   * DbConnection.builder().onConnect((ctx, identity, token) => {
   *  console.log("Connected to SpacetimeDB with identity:", identity.toHexString());
   * });
   * ```
   */
  onConnect(callback) {
    this.#emitter.on("connect", callback);
    return this;
  }
  /**
   * Register a callback to be invoked upon an error.
   *
   * @example
   *
   * ```ts
   * DbConnection.builder().onConnectError((ctx, error) => {
   *   console.log("Error connecting to SpacetimeDB:", error);
   * });
   * ```
   */
  onConnectError(callback) {
    this.#emitter.on("connectError", callback);
    return this;
  }
  /**
   * Registers a callback to run when a {@link DbConnection} whose connection initially succeeded
   * is disconnected, either after a {@link DbConnection.disconnect} call or due to an error.
   *
   * If the connection ended because of an error, the error is passed to the callback.
   *
   * The `callback` will be installed on the `DbConnection` created by `build`
   * before initiating the connection, ensuring there's no opportunity for the disconnect to happen
   * before the callback is installed.
   *
   * Note that this does not trigger if `build` fails
   * or in cases where {@link DbConnectionBuilder.onConnectError} would trigger.
   * This callback only triggers if the connection closes after `build` returns successfully
   * and {@link DbConnectionBuilder.onConnect} is invoked, i.e., after the `IdentityToken` is received.
   *
   * To simplify SDK implementation, at most one such callback can be registered.
   * Calling `onDisconnect` on the same `DbConnectionBuilder` multiple times throws an error.
   *
   * Unlike callbacks registered via {@link DbConnection},
   * no mechanism is provided to unregister the provided callback.
   * This is a concession to ergonomics; there's no clean place to return a `CallbackId` from this method
   * or from `build`.
   *
   * @param {function(error?: Error): void} callback - The callback to invoke upon disconnection.
   * @throws {Error} Throws an error if called multiple times on the same `DbConnectionBuilder`.
   */
  onDisconnect(callback) {
    this.#emitter.on("disconnect", callback);
    return this;
  }
  /**
   * Builds a new `DbConnection` with the parameters set on this `DbConnectionBuilder` and attempts to connect to the SpacetimeDB server.
   *
   * @returns A new `DbConnection` with the parameters set on this `DbConnectionBuilder`.
   *
   * @example
   *
   * ```ts
   * const host = "http://localhost:3000";
   * const name_or_address = "database_name"
   * const auth_token = undefined;
   * DbConnection.builder().withUri(host).withModuleName(name_or_address).withToken(auth_token).build();
   * ```
   */
  build() {
    if (!this.#uri) {
      throw new Error("URI is required to connect to SpacetimeDB");
    }
    if (!this.#nameOrAddress) {
      throw new Error(
        "Database name or address is required to connect to SpacetimeDB"
      );
    }
    ensureMinimumVersionOrThrow(this.remoteModule.versionInfo?.cliVersion);
    return this.dbConnectionCtor({
      uri: this.#uri,
      nameOrAddress: this.#nameOrAddress,
      identity: this.#identity,
      token: this.#token,
      emitter: this.#emitter,
      compression: this.#compression,
      lightMode: this.#lightMode,
      confirmedReads: this.#confirmedReads,
      createWSFn: this.#createWSFn,
      remoteModule: this.remoteModule
    });
  }
};

// src/sdk/subscription_builder_impl.ts
var SubscriptionBuilderImpl = class {
  constructor(db) {
    this.db = db;
  }
  #onApplied = void 0;
  #onError = void 0;
  /**
   * Registers `callback` to run when this query is successfully added to our subscribed set,
   * I.e. when its `SubscriptionApplied` message is received.
   *
   * The database state exposed via the `&EventContext` argument
   * includes all the rows added to the client cache as a result of the new subscription.
   *
   * The event in the `&EventContext` argument is `Event::SubscribeApplied`.
   *
   * Multiple `on_applied` callbacks for the same query may coexist.
   * No mechanism for un-registering `on_applied` callbacks is exposed.
   *
   * @param cb - Callback to run when the subscription is applied.
   * @returns The current `SubscriptionBuilder` instance.
   */
  onApplied(cb) {
    this.#onApplied = cb;
    return this;
  }
  /**
   * Registers `callback` to run when this query either:
   * - Fails to be added to our subscribed set.
   * - Is unexpectedly removed from our subscribed set.
   *
   * If the subscription had previously started and has been unexpectedly removed,
   * the database state exposed via the `&EventContext` argument contains no rows
   * from any subscriptions removed within the same error event.
   * As proposed, it must therefore contain no rows.
   *
   * The event in the `&EventContext` argument is `Event::SubscribeError`,
   * containing a dynamic error object with a human-readable description of the error
   * for diagnostic purposes.
   *
   * Multiple `on_error` callbacks for the same query may coexist.
   * No mechanism for un-registering `on_error` callbacks is exposed.
   *
   * @param cb - Callback to run when there is an error in subscription.
   * @returns The current `SubscriptionBuilder` instance.
   */
  onError(cb) {
    this.#onError = cb;
    return this;
  }
  /**
   * Subscribe to a single query. The results of the query will be merged into the client
   * cache and deduplicated on the client.
   *
   * @param query_sql A `SQL` query to subscribe to.
   *
   * @example
   *
   * ```ts
   * const subscription = connection.subscriptionBuilder().onApplied(() => {
   *   console.log("SDK client cache initialized.");
   * }).subscribe("SELECT * FROM User");
   *
   * subscription.unsubscribe();
   * ```
   */
  subscribe(query_sql) {
    const queries = Array.isArray(query_sql) ? query_sql : [query_sql];
    if (queries.length === 0) {
      throw new Error("Subscriptions must have at least one query");
    }
    return new SubscriptionHandleImpl(
      this.db,
      queries,
      this.#onApplied,
      this.#onError
    );
  }
  /**
   * Subscribes to all rows from all tables.
   *
   * This method is intended as a convenience
   * for applications where client-side memory use and network bandwidth are not concerns.
   * Applications where these resources are a constraint
   * should register more precise queries via `subscribe`
   * in order to replicate only the subset of data which the client needs to function.
   *
   * This method should not be combined with `subscribe` on the same `DbConnection`.
   * A connection may either `subscribe` to particular queries,
   * or `subscribeToAllTables`, but not both.
   * Attempting to call `subscribe`
   * on a `DbConnection` that has previously used `subscribeToAllTables`,
   * or vice versa, may misbehave in any number of ways,
   * including dropping subscriptions, corrupting the client cache, or throwing errors.
   */
  subscribeToAllTables() {
    this.subscribe("SELECT * FROM *");
  }
};
var SubscriptionManager = class {
  subscriptions = /* @__PURE__ */ new Map();
};
var SubscriptionHandleImpl = class {
  constructor(db, querySql, onApplied, onError) {
    this.db = db;
    this.#emitter.on(
      "applied",
      (ctx) => {
        this.#activeState = true;
        if (onApplied) {
          onApplied(ctx);
        }
      }
    );
    this.#emitter.on(
      "error",
      (ctx, error) => {
        this.#activeState = false;
        this.#endedState = true;
        if (onError) {
          onError(ctx, error);
        }
      }
    );
    this.#queryId = this.db.registerSubscription(this, this.#emitter, querySql);
  }
  #queryId;
  #unsubscribeCalled = false;
  #endedState = false;
  #activeState = false;
  #emitter = new EventEmitter();
  /**
   * Consumes self and issues an `Unsubscribe` message,
   * removing this query from the client's set of subscribed queries.
   * It is only valid to call this method if `is_active()` is `true`.
   */
  unsubscribe() {
    if (this.#unsubscribeCalled) {
      throw new Error("Unsubscribe has already been called");
    }
    this.#unsubscribeCalled = true;
    this.db.unregisterSubscription(this.#queryId);
    this.#emitter.on(
      "end",
      (_ctx) => {
        this.#endedState = true;
        this.#activeState = false;
      }
    );
  }
  /**
   * Unsubscribes and also registers a callback to run upon success.
   * I.e. when an `UnsubscribeApplied` message is received.
   *
   * If `Unsubscribe` returns an error,
   * or if the `on_error` callback(s) are invoked before this subscription would end normally,
   * the `on_end` callback is not invoked.
   *
   * @param onEnd - Callback to run upon successful unsubscribe.
   */
  unsubscribeThen(onEnd) {
    if (this.#endedState) {
      throw new Error("Subscription has already ended");
    }
    if (this.#unsubscribeCalled) {
      throw new Error("Unsubscribe has already been called");
    }
    this.#unsubscribeCalled = true;
    this.db.unregisterSubscription(this.#queryId);
    this.#emitter.on(
      "end",
      (ctx) => {
        this.#endedState = true;
        this.#activeState = false;
        onEnd(ctx);
      }
    );
  }
  /**
   * True if this `SubscriptionHandle` has ended,
   * either due to an error or a call to `unsubscribe`.
   *
   * This is initially false, and becomes true when either the `on_end` or `on_error` callback is invoked.
   * A subscription which has not yet been applied is not active, but is also not ended.
   */
  isEnded() {
    return this.#endedState;
  }
  /**
   * True if this `SubscriptionHandle` is active, meaning it has been successfully applied
   * and has not since ended, either due to an error or a complete `unsubscribe` request-response pair.
   *
   * This corresponds exactly to the interval bounded at the start by the `on_applied` callback
   * and at the end by either the `on_end` or `on_error` callback.
   */
  isActive() {
    return this.#activeState;
  }
};
function callReducerFlagsToNumber(flags) {
  switch (flags) {
    case "FullUpdate":
      return 0;
    case "NoSuccessNotify":
      return 1;
  }
}
var DbConnectionImpl = class {
  /**
   * Whether or not the connection is active.
   */
  isActive = false;
  /**
   * This connection's public identity.
   */
  identity = void 0;
  /**
   * This connection's private authentication token.
   */
  token = void 0;
  /**
   * The accessor field to access the tables in the database and associated
   * callback functions.
   */
  db;
  /**
   * The accessor field to access the reducers in the database and associated
   * callback functions.
   */
  reducers;
  /**
   * The accessor field to access functions related to setting flags on
   * reducers regarding how the server should handle the reducer call and
   * the events that it sends back to the client.
   */
  setReducerFlags;
  /**
   * The accessor field to access the reducers in the database and associated
   * callback functions.
   */
  procedures;
  /**
   * The `ConnectionId` of the connection to to the database.
   */
  connectionId = ConnectionId.random();
  // These fields are meant to be strictly private.
  #queryId = 0;
  #requestId = 0;
  #emitter;
  #reducerEmitter = new EventEmitter();
  #onApplied;
  #messageQueue = Promise.resolve();
  #subscriptionManager = new SubscriptionManager();
  #remoteModule;
  #callReducerFlags = /* @__PURE__ */ new Map();
  #procedureCallbacks = /* @__PURE__ */ new Map();
  // These fields are not part of the public API, but in a pinch you
  // could use JavaScript to access them by bypassing TypeScript's
  // private fields.
  // We use them in testing.
  clientCache;
  ws;
  wsPromise;
  constructor({
    uri,
    nameOrAddress,
    identity,
    token,
    emitter,
    remoteModule,
    createWSFn,
    compression,
    lightMode,
    confirmedReads
  }) {
    stdbLogger("info", "Connecting to SpacetimeDB WS...");
    const url = new URL(uri.toString());
    if (!/^wss?:/.test(uri.protocol)) {
      url.protocol = url.protocol === "https:" ? "wss:" : "ws:";
    }
    this.identity = identity;
    this.token = token;
    this.#remoteModule = remoteModule;
    this.#emitter = emitter;
    const connectionId = this.connectionId.toHexString();
    url.searchParams.set("connection_id", connectionId);
    this.clientCache = new ClientCache();
    this.db = this.#makeDbView(remoteModule);
    this.reducers = this.#makeReducers(remoteModule);
    this.setReducerFlags = this.#makeSetReducerFlags(remoteModule);
    this.procedures = this.#makeProcedures(remoteModule);
    this.wsPromise = createWSFn({
      url,
      nameOrAddress,
      wsProtocol: "v1.bsatn.spacetimedb",
      authToken: token,
      compression,
      lightMode,
      confirmedReads
    }).then((v) => {
      this.ws = v;
      this.ws.onclose = () => {
        this.#emitter.emit("disconnect", this);
        this.isActive = false;
      };
      this.ws.onerror = (e) => {
        this.#emitter.emit("connectError", this, e);
        this.isActive = false;
      };
      this.ws.onopen = this.#handleOnOpen.bind(this);
      this.ws.onmessage = this.#handleOnMessage.bind(this);
      return v;
    }).catch((e) => {
      stdbLogger("error", "Error connecting to SpacetimeDB WS");
      this.#emitter.emit("connectError", this, e);
      return void 0;
    });
  }
  #getNextQueryId = () => {
    const queryId = this.#queryId;
    this.#queryId += 1;
    return queryId;
  };
  #getNextRequestId = () => this.#requestId++;
  #makeDbView(def) {
    const view = /* @__PURE__ */ Object.create(null);
    for (const tbl of def.tables) {
      const key = tbl.accessorName;
      Object.defineProperty(view, key, {
        enumerable: true,
        configurable: false,
        get: () => {
          return this.clientCache.getOrCreateTable(tbl);
        }
      });
    }
    return view;
  }
  #makeReducers(def) {
    const out = {};
    for (const reducer2 of def.reducers) {
      const key = toCamelCase(reducer2.name);
      out[key] = (params) => {
        const flags = this.#callReducerFlags.get(reducer2.name) ?? "FullUpdate";
        this.callReducerWithParams(
          reducer2.name,
          reducer2.paramsType,
          params,
          flags
        );
      };
      const onReducerEventKey = `on${toPascalCase(reducer2.name)}`;
      out[onReducerEventKey] = (callback) => {
        this.onReducer(reducer2.name, callback);
      };
      const offReducerEventKey = `removeOn${toPascalCase(reducer2.name)}`;
      out[offReducerEventKey] = (callback) => {
        this.offReducer(reducer2.name, callback);
      };
    }
    return out;
  }
  #makeSetReducerFlags(defs) {
    const out = /* @__PURE__ */ Object.create(null);
    for (const r of defs.reducers) {
      const key = toCamelCase(r.name);
      Object.defineProperty(out, key, {
        enumerable: true,
        configurable: false,
        value: (flags) => {
          this.#callReducerFlags.set(r.name, flags);
        }
      });
    }
    return out;
  }
  #makeProcedures(def) {
    const out = {};
    for (const procedure2 of def.procedures) {
      const key = toCamelCase(procedure2.name);
      const paramsType = new ProductBuilder(procedure2.params).algebraicType.value;
      const returnType = procedure2.returnType.algebraicType;
      out[key] = (params) => this.callProcedureWithParams(
        procedure2.name,
        paramsType,
        params,
        returnType
      );
    }
    return out;
  }
  #makeEventContext(event) {
    return {
      db: this.db,
      reducers: this.reducers,
      setReducerFlags: this.setReducerFlags,
      isActive: this.isActive,
      subscriptionBuilder: this.subscriptionBuilder.bind(this),
      disconnect: this.disconnect.bind(this),
      event
    };
  }
  // NOTE: This is very important!!! This is the actual function that
  // gets called when you call `connection.subscriptionBuilder()`.
  // The `subscriptionBuilder` function which is generated, just shadows
  // this function in the type system, but not the actual implementation!
  // Do not remove this function, or shoot yourself in the foot please.
  // It's not clear what would be a better way to do this at this exact
  // moment.
  subscriptionBuilder = () => {
    return new SubscriptionBuilderImpl(this);
  };
  registerSubscription(handle, handleEmitter, querySql) {
    const queryId = this.#getNextQueryId();
    this.#subscriptionManager.subscriptions.set(queryId, {
      handle,
      emitter: handleEmitter
    });
    this.#sendMessage(
      client_message_type_default.SubscribeMulti({
        queryStrings: querySql,
        queryId: { id: queryId },
        // The TypeScript SDK doesn't currently track `request_id`s,
        // so always use 0.
        requestId: 0
      })
    );
    return queryId;
  }
  unregisterSubscription(queryId) {
    this.#sendMessage(
      client_message_type_default.UnsubscribeMulti({
        queryId: { id: queryId },
        // The TypeScript SDK doesn't currently track `request_id`s,
        // so always use 0.
        requestId: 0
      })
    );
  }
  // This function is async because we decompress the message async
  async #processParsedMessage(message) {
    const parseRowList = (type, tableName, rowList) => {
      const buffer = rowList.rowsData;
      const reader = new BinaryReader(buffer);
      const rows = [];
      const table2 = this.#remoteModule.tables.find((t2) => t2.name === tableName);
      const rowType = table2.rowType;
      const columnsArray = Object.entries(table2.columns);
      const primaryKeyColumnEntry = columnsArray.find(
        (col) => col[1].columnMetadata.isPrimaryKey
      );
      let previousOffset = 0;
      while (reader.remaining > 0) {
        const row = ProductType.deserializeValue(reader, rowType);
        let rowId = void 0;
        if (primaryKeyColumnEntry !== void 0) {
          const primaryKeyColName = primaryKeyColumnEntry[0];
          const primaryKeyColType = primaryKeyColumnEntry[1].typeBuilder.algebraicType;
          rowId = AlgebraicType.intoMapKey(
            primaryKeyColType,
            row[primaryKeyColName]
          );
        } else {
          const rowBytes = buffer.subarray(previousOffset, reader.offset);
          const asBase64 = fromByteArray(rowBytes);
          rowId = asBase64;
        }
        previousOffset = reader.offset;
        rows.push({
          type,
          rowId,
          row
        });
      }
      return rows;
    };
    const parseTableUpdate = async (rawTableUpdate) => {
      const tableName = rawTableUpdate.tableName;
      let operations = [];
      for (const update of rawTableUpdate.updates) {
        let decompressed;
        if (update.tag === "Gzip") {
          const decompressedBuffer = await decompress(update.value, "gzip");
          decompressed = AlgebraicType.deserializeValue(
            new BinaryReader(decompressedBuffer),
            query_update_type_default.algebraicType
          );
        } else if (update.tag === "Brotli") {
          throw new Error(
            "Brotli compression not supported. Please use gzip or none compression in withCompression method on DbConnection."
          );
        } else {
          decompressed = update.value;
        }
        operations = operations.concat(
          parseRowList("insert", tableName, decompressed.inserts)
        );
        operations = operations.concat(
          parseRowList("delete", tableName, decompressed.deletes)
        );
      }
      return {
        tableName,
        operations
      };
    };
    const parseDatabaseUpdate = async (dbUpdate) => {
      const tableUpdates = [];
      for (const rawTableUpdate of dbUpdate.tables) {
        tableUpdates.push(await parseTableUpdate(rawTableUpdate));
      }
      return tableUpdates;
    };
    switch (message.tag) {
      case "InitialSubscription": {
        const dbUpdate = message.value.databaseUpdate;
        const tableUpdates = await parseDatabaseUpdate(dbUpdate);
        const subscriptionUpdate = {
          tag: "InitialSubscription",
          tableUpdates
        };
        return subscriptionUpdate;
      }
      case "TransactionUpdateLight": {
        const dbUpdate = message.value.update;
        const tableUpdates = await parseDatabaseUpdate(dbUpdate);
        const subscriptionUpdate = {
          tag: "TransactionUpdateLight",
          tableUpdates
        };
        return subscriptionUpdate;
      }
      case "TransactionUpdate": {
        const txUpdate = message.value;
        const identity = txUpdate.callerIdentity;
        const connectionId = ConnectionId.nullIfZero(
          txUpdate.callerConnectionId
        );
        const reducerName = txUpdate.reducerCall.reducerName;
        const args = txUpdate.reducerCall.args;
        const energyQuantaUsed = txUpdate.energyQuantaUsed;
        let tableUpdates = [];
        let errMessage = "";
        switch (txUpdate.status.tag) {
          case "Committed":
            tableUpdates = await parseDatabaseUpdate(txUpdate.status.value);
            break;
          case "Failed":
            tableUpdates = [];
            errMessage = txUpdate.status.value;
            break;
          case "OutOfEnergy":
            tableUpdates = [];
            break;
        }
        if (reducerName === "<none>") {
          const errorMessage = errMessage;
          console.error(`Received an error from the database: ${errorMessage}`);
          return;
        }
        let reducerInfo;
        if (reducerName !== "") {
          reducerInfo = {
            reducerName,
            args
          };
        }
        const transactionUpdate = {
          tag: "TransactionUpdate",
          tableUpdates,
          identity,
          connectionId,
          reducerInfo,
          status: txUpdate.status,
          energyConsumed: energyQuantaUsed.quanta,
          message: errMessage,
          timestamp: txUpdate.timestamp
        };
        return transactionUpdate;
      }
      case "IdentityToken": {
        const identityTokenMessage = {
          tag: "IdentityToken",
          identity: message.value.identity,
          token: message.value.token,
          connectionId: message.value.connectionId
        };
        return identityTokenMessage;
      }
      case "OneOffQueryResponse": {
        throw new Error(
          `TypeScript SDK never sends one-off queries, but got OneOffQueryResponse ${message}`
        );
      }
      case "SubscribeMultiApplied": {
        const parsedTableUpdates = await parseDatabaseUpdate(
          message.value.update
        );
        const subscribeAppliedMessage = {
          tag: "SubscribeApplied",
          queryId: message.value.queryId.id,
          tableUpdates: parsedTableUpdates
        };
        return subscribeAppliedMessage;
      }
      case "UnsubscribeMultiApplied": {
        const parsedTableUpdates = await parseDatabaseUpdate(
          message.value.update
        );
        const unsubscribeAppliedMessage = {
          tag: "UnsubscribeApplied",
          queryId: message.value.queryId.id,
          tableUpdates: parsedTableUpdates
        };
        return unsubscribeAppliedMessage;
      }
      case "SubscriptionError": {
        return {
          tag: "SubscriptionError",
          queryId: message.value.queryId,
          error: message.value.error
        };
      }
      case "ProcedureResult": {
        const { status, requestId } = message.value;
        return {
          tag: "ProcedureResult",
          requestId,
          result: status.tag === "Returned" ? { tag: "Ok", value: status.value } : status.tag === "OutOfEnergy" ? {
            tag: "Err",
            value: "Procedure execution aborted due to insufficient energy"
          } : { tag: "Err", value: status.value }
        };
      }
    }
  }
  #sendMessage(message) {
    this.wsPromise.then((wsResolved) => {
      if (wsResolved) {
        const writer = new BinaryWriter(1024);
        AlgebraicType.serializeValue(
          writer,
          client_message_type_default.algebraicType,
          message
        );
        const encoded = writer.getBuffer();
        wsResolved.send(encoded);
      }
    });
  }
  /**
   * Handles WebSocket onOpen event.
   */
  #handleOnOpen() {
    this.isActive = true;
  }
  #applyTableUpdates(tableUpdates, eventContext) {
    const pendingCallbacks = [];
    for (const tableUpdate of tableUpdates) {
      const tableName = tableUpdate.tableName;
      const tableDef = this.#remoteModule.tables.find(
        (t2) => t2.name === tableName
      );
      const table2 = this.clientCache.getOrCreateTable(tableDef);
      const newCallbacks = table2.applyOperations(
        tableUpdate.operations,
        eventContext
      );
      for (const callback of newCallbacks) {
        pendingCallbacks.push(callback);
      }
    }
    return pendingCallbacks;
  }
  async #processMessage(data) {
    const serverMessage = AlgebraicType.deserializeValue(
      new BinaryReader(data),
      server_message_type_default.algebraicType
    );
    const message = await this.#processParsedMessage(serverMessage);
    if (!message) {
      return;
    }
    switch (message.tag) {
      case "InitialSubscription": {
        const event = { tag: "SubscribeApplied" };
        const eventContext = this.#makeEventContext(event);
        const { event: _, ...subscriptionEventContext } = eventContext;
        const callbacks = this.#applyTableUpdates(
          message.tableUpdates,
          eventContext
        );
        if (this.#emitter) {
          this.#onApplied?.(subscriptionEventContext);
        }
        for (const callback of callbacks) {
          callback.cb();
        }
        break;
      }
      case "TransactionUpdateLight": {
        const event = { tag: "UnknownTransaction" };
        const eventContext = this.#makeEventContext(event);
        const callbacks = this.#applyTableUpdates(
          message.tableUpdates,
          eventContext
        );
        for (const callback of callbacks) {
          callback.cb();
        }
        break;
      }
      case "TransactionUpdate": {
        let reducerInfo = message.reducerInfo;
        const reducer2 = reducerInfo === void 0 ? void 0 : this.#remoteModule.reducers.find(
          (t2) => t2.name === reducerInfo.reducerName
        );
        let reducerArgs = void 0;
        let unknownTransaction = reducer2 === void 0;
        if (reducer2) {
          try {
            const reader = new BinaryReader(reducerInfo.args);
            reducerArgs = ProductType.deserializeValue(
              reader,
              reducer2.paramsType
            );
          } catch {
            console.debug("Failed to deserialize reducer arguments");
            unknownTransaction = true;
          }
        }
        if (unknownTransaction) {
          const event2 = { tag: "UnknownTransaction" };
          const eventContext2 = this.#makeEventContext(event2);
          const callbacks2 = this.#applyTableUpdates(
            message.tableUpdates,
            eventContext2
          );
          for (const callback of callbacks2) {
            callback.cb();
          }
          return;
        }
        reducerInfo = reducerInfo;
        reducerArgs = reducerArgs;
        const reducerEvent = {
          callerIdentity: message.identity,
          status: message.status,
          callerConnectionId: message.connectionId,
          timestamp: message.timestamp,
          energyConsumed: message.energyConsumed,
          reducer: {
            name: reducerInfo.reducerName,
            args: reducerArgs
          }
        };
        const event = {
          tag: "Reducer",
          value: reducerEvent
        };
        const eventContext = this.#makeEventContext(event);
        const reducerEventContext = {
          ...eventContext,
          event: reducerEvent
        };
        const callbacks = this.#applyTableUpdates(
          message.tableUpdates,
          eventContext
        );
        this.#reducerEmitter.emit(
          reducerInfo.reducerName,
          reducerEventContext,
          reducerArgs
        );
        for (const callback of callbacks) {
          callback.cb();
        }
        break;
      }
      case "IdentityToken": {
        this.identity = message.identity;
        if (!this.token && message.token) {
          this.token = message.token;
        }
        this.connectionId = message.connectionId;
        this.#emitter.emit("connect", this, this.identity, this.token);
        break;
      }
      case "SubscribeApplied": {
        const subscription = this.#subscriptionManager.subscriptions.get(
          message.queryId
        );
        if (subscription === void 0) {
          stdbLogger(
            "error",
            `Received SubscribeApplied for unknown queryId ${message.queryId}.`
          );
          break;
        }
        const event = { tag: "SubscribeApplied" };
        const eventContext = this.#makeEventContext(event);
        const { event: _, ...subscriptionEventContext } = eventContext;
        const callbacks = this.#applyTableUpdates(
          message.tableUpdates,
          eventContext
        );
        subscription?.emitter.emit("applied", subscriptionEventContext);
        for (const callback of callbacks) {
          callback.cb();
        }
        break;
      }
      case "UnsubscribeApplied": {
        const subscription = this.#subscriptionManager.subscriptions.get(
          message.queryId
        );
        if (subscription === void 0) {
          stdbLogger(
            "error",
            `Received UnsubscribeApplied for unknown queryId ${message.queryId}.`
          );
          break;
        }
        const event = { tag: "UnsubscribeApplied" };
        const eventContext = this.#makeEventContext(event);
        const { event: _, ...subscriptionEventContext } = eventContext;
        const callbacks = this.#applyTableUpdates(
          message.tableUpdates,
          eventContext
        );
        subscription?.emitter.emit("end", subscriptionEventContext);
        this.#subscriptionManager.subscriptions.delete(message.queryId);
        for (const callback of callbacks) {
          callback.cb();
        }
        break;
      }
      case "SubscriptionError": {
        const error = Error(message.error);
        const event = { tag: "Error", value: error };
        const eventContext = this.#makeEventContext(event);
        const errorContext = {
          ...eventContext,
          event: error
        };
        if (message.queryId !== void 0) {
          this.#subscriptionManager.subscriptions.get(message.queryId)?.emitter.emit("error", errorContext, error);
          this.#subscriptionManager.subscriptions.delete(message.queryId);
        } else {
          console.error("Received an error message without a queryId: ", error);
          this.#subscriptionManager.subscriptions.forEach(({ emitter }) => {
            emitter.emit("error", errorContext, error);
          });
        }
        break;
      }
      case "ProcedureResult": {
        const { requestId, result } = message;
        const cb = this.#procedureCallbacks.get(requestId);
        this.#procedureCallbacks.delete(requestId);
        cb?.(result);
        break;
      }
    }
  }
  /**
   * Handles WebSocket onMessage event.
   * @param wsMessage MessageEvent object.
   */
  #handleOnMessage(wsMessage) {
    this.#messageQueue = this.#messageQueue.then(() => {
      return this.#processMessage(wsMessage.data);
    });
  }
  /**
   * Call a reducer on your SpacetimeDB module.
   *
   * @param reducerName The name of the reducer to call
   * @param argsSerializer The arguments to pass to the reducer
   */
  callReducer(reducerName, argsBuffer, flags) {
    const message = client_message_type_default.CallReducer({
      reducer: reducerName,
      args: argsBuffer,
      // The TypeScript SDK doesn't currently track `request_id`s,
      // so always use 0.
      requestId: 0,
      flags: callReducerFlagsToNumber(flags)
    });
    this.#sendMessage(message);
  }
  /**
   * Call a reducer on your SpacetimeDB module with typed arguments.
   * @param reducerSchema The schema of the reducer to call
   * @param callReducerFlags The flags for the reducer call
   * @param params The arguments to pass to the reducer
   */
  callReducerWithParams(reducerName, paramsType, params, flags) {
    const writer = new BinaryWriter(1024);
    ProductType.serializeValue(writer, paramsType, params);
    const argsBuffer = writer.getBuffer();
    this.callReducer(reducerName, argsBuffer, flags);
  }
  /**
   * Call a reducer on your SpacetimeDB module.
   *
   * @param procedureName The name of the reducer to call
   * @param argsBuffer The arguments to pass to the reducer
   */
  callProcedure(procedureName, argsBuffer) {
    const { promise, resolve, reject } = Promise.withResolvers();
    const requestId = this.#getNextRequestId();
    const message = client_message_type_default.CallProcedure({
      procedure: procedureName,
      args: argsBuffer,
      requestId,
      // reserved for future use - 0 is the only valid value
      flags: 0
    });
    this.#sendMessage(message);
    this.#procedureCallbacks.set(requestId, (result) => {
      if (result.tag === "Ok") {
        resolve(result.value);
      } else {
        reject(result.value);
      }
    });
    return promise;
  }
  /**
   * Call a reducer on your SpacetimeDB module with typed arguments.
   * @param reducerSchema The schema of the reducer to call
   * @param callReducerFlags The flags for the reducer call
   * @param params The arguments to pass to the reducer
   */
  callProcedureWithParams(procedureName, paramsType, params, returnType) {
    const writer = new BinaryWriter(1024);
    ProductType.serializeValue(writer, paramsType, params);
    const argsBuffer = writer.getBuffer();
    return this.callProcedure(procedureName, argsBuffer).then((returnBuf) => {
      return AlgebraicType.deserializeValue(
        new BinaryReader(returnBuf),
        returnType
      );
    });
  }
  /**
   * Close the current connection.
   *
   * @example
   *
   * ```ts
   * const connection = DbConnection.builder().build();
   * connection.disconnect()
   * ```
   */
  disconnect() {
    this.wsPromise.then((wsResolved) => {
      if (wsResolved) {
        wsResolved.close();
      }
    });
  }
  on(eventName, callback) {
    this.#emitter.on(eventName, callback);
  }
  off(eventName, callback) {
    this.#emitter.off(eventName, callback);
  }
  onConnect(callback) {
    this.#emitter.on("connect", callback);
  }
  onDisconnect(callback) {
    this.#emitter.on("disconnect", callback);
  }
  onConnectError(callback) {
    this.#emitter.on("connectError", callback);
  }
  removeOnConnect(callback) {
    this.#emitter.off("connect", callback);
  }
  removeOnDisconnect(callback) {
    this.#emitter.off("disconnect", callback);
  }
  removeOnConnectError(callback) {
    this.#emitter.off("connectError", callback);
  }
  // Note: This is required to be public because it needs to be
  // called from the `RemoteReducers` class.
  onReducer(reducerName, callback) {
    this.#reducerEmitter.on(reducerName, callback);
  }
  // Note: This is required to be public because it needs to be
  // called from the `RemoteReducers` class.
  offReducer(reducerName, callback) {
    this.#reducerEmitter.off(reducerName, callback);
  }
};

// src/lib/autogen/lifecycle_type.ts
var Lifecycle = t.enum("Lifecycle", {
  Init: t.unit(),
  OnConnect: t.unit(),
  OnDisconnect: t.unit()
});
var lifecycle_type_default = Lifecycle;

// src/lib/reducers.ts
function pushReducer(name, params, fn, lifecycle) {
  if (existingReducers.has(name)) {
    throw new TypeError(`There is already a reducer with the name '${name}'`);
  }
  existingReducers.add(name);
  if (!(params instanceof RowBuilder)) {
    params = new RowBuilder(params);
  }
  if (params.typeName === void 0) {
    params.typeName = toPascalCase(name);
  }
  const ref = registerTypesRecursively(params);
  const paramsType = resolveType(MODULE_DEF.typespace, ref).value;
  MODULE_DEF.reducers.push({
    name,
    params: paramsType,
    lifecycle
    // <- lifecycle flag lands here
  });
  if (!fn.name) {
    Object.defineProperty(fn, "name", { value: name, writable: false });
  }
}
var existingReducers = /* @__PURE__ */ new Set();
function reducer(name, params, fn) {
  pushReducer(name, params, fn);
}
function init(name, params, fn) {
  pushReducer(name, params, fn, lifecycle_type_default.Init);
}
function clientConnected(name, params, fn) {
  pushReducer(name, params, fn, lifecycle_type_default.OnConnect);
}
function clientDisconnected(name, params, fn) {
  pushReducer(name, params, fn, lifecycle_type_default.OnDisconnect);
}
var Reducers = class {
  reducersType;
  constructor(handles) {
    this.reducersType = reducersToSchema(handles);
  }
};
function reducersToSchema(reducers2) {
  const mapped = reducers2.map((r) => {
    const paramsRow = r.params.row;
    return {
      name: r.reducerName,
      // Prefer the schema's own accessorName if present at runtime; otherwise derive it.
      accessorName: r.accessorName,
      params: paramsRow,
      paramsType: r.paramsSpacetimeType
    };
  });
  const result = { reducers: mapped };
  return result;
}
function reducers(...args) {
  const handles = args.length === 1 && Array.isArray(args[0]) ? args[0] : args;
  return new Reducers(handles);
}
function reducerSchema(name, params) {
  const paramType = {
    elements: Object.entries(params).map(([n, c]) => ({
      name: n,
      algebraicType: "typeBuilder" in c ? c.typeBuilder.algebraicType : c.algebraicType
    }))
  };
  return {
    reducerName: name,
    accessorName: toCamelCase(name),
    params: new RowBuilder(params),
    paramsSpacetimeType: paramType,
    reducerDef: {
      name,
      params: paramType,
      lifecycle: void 0
    }
  };
}

// src/lib/views.ts
function defineView(opts, anon, params, ret, fn) {
  const paramsBuilder = new RowBuilder(params, toPascalCase(opts.name));
  let returnType = registerTypesRecursively(ret).algebraicType;
  const { value: paramType } = resolveType(
    MODULE_DEF.typespace,
    registerTypesRecursively(paramsBuilder)
  );
  MODULE_DEF.miscExports.push({
    tag: "View",
    value: {
      name: opts.name,
      index: (anon ? ANON_VIEWS : VIEWS).length,
      isPublic: opts.public,
      isAnonymous: anon,
      params: paramType,
      returnType
    }
  });
  if (returnType.tag == "Sum") {
    const originalFn = fn;
    fn = ((ctx, args) => {
      const ret2 = originalFn(ctx, args);
      return ret2 == null ? [] : [ret2];
    });
    returnType = AlgebraicType.Array(
      returnType.value.variants[0].algebraicType
    );
  }
  (anon ? ANON_VIEWS : VIEWS).push({
    fn,
    params: paramType,
    returnType,
    returnTypeBaseSize: bsatnBaseSize(MODULE_DEF.typespace, returnType)
  });
}
var VIEWS = [];
var ANON_VIEWS = [];

// src/lib/procedures.ts
function procedure(name, params, ret, fn) {
  const paramsType = {
    elements: Object.entries(params).map(([n, c]) => ({
      name: n,
      algebraicType: registerTypesRecursively(
        "typeBuilder" in c ? c.typeBuilder : c
      ).algebraicType
    }))
  };
  const returnType = registerTypesRecursively(ret).algebraicType;
  MODULE_DEF.miscExports.push({
    tag: "Procedure",
    value: {
      name,
      params: paramsType,
      returnType
    }
  });
  PROCEDURES.push({
    fn,
    paramsType,
    returnType,
    returnTypeBaseSize: bsatnBaseSize(MODULE_DEF.typespace, returnType)
  });
}
var PROCEDURES = [];
function procedures(...args) {
  const procedures2 = args.length === 1 && Array.isArray(args[0]) ? args[0] : args;
  return { procedures: procedures2 };
}
function procedureSchema(name, params, returnType) {
  return {
    name,
    accessorName: toCamelCase(name),
    params: coerceParams(params),
    returnType
  };
}
function tablesToSchema(tables) {
  return { tables: tables.map(tableToSchema) };
}
function tableToSchema(schema2) {
  const getColName = (i) => schema2.rowType.algebraicType.value.elements[i].name;
  return {
    name: schema2.tableName,
    accessorName: toCamelCase(schema2.tableName),
    columns: schema2.rowType.row,
    // typed as T[i]['rowType']['row'] under TablesToSchema<T>
    rowType: schema2.rowSpacetimeType,
    constraints: schema2.tableDef.constraints.map((c) => ({
      name: c.name,
      constraint: "unique",
      columns: c.data.value.columns.map(getColName)
    })),
    // TODO: horrible horrible horrible. we smuggle this `Array<UntypedIndex>`
    // by casting it to an `Array<IndexOpts>` as `TableToSchema` expects.
    // This is then used in `TableCacheImpl.constructor` and who knows where else.
    // We should stop lying about our types.
    indexes: schema2.tableDef.indexes.map((idx) => {
      const columnIds = idx.algorithm.tag === "Direct" ? [idx.algorithm.value] : idx.algorithm.value;
      return {
        name: idx.accessorName,
        unique: schema2.tableDef.constraints.some(
          (c) => c.data.value.columns.every((col) => columnIds.includes(col))
        ),
        algorithm: idx.algorithm.tag.toLowerCase(),
        columns: columnIds.map(getColName)
      };
    })
  };
}
var MODULE_DEF = {
  typespace: { types: [] },
  tables: [],
  reducers: [],
  types: [],
  miscExports: [],
  rowLevelSecurity: []
};
var COMPOUND_TYPES = /* @__PURE__ */ new Map();
function resolveType(typespace, typeBuilder) {
  let ty = typeBuilder.algebraicType;
  while (ty.tag === "Ref") {
    ty = typespace.types[ty.value];
  }
  return ty;
}
function registerTypesRecursively(typeBuilder) {
  if (typeBuilder instanceof ProductBuilder && !isUnit(typeBuilder) || typeBuilder instanceof SumBuilder || typeBuilder instanceof RowBuilder) {
    return registerCompoundTypeRecursively(typeBuilder);
  } else if (typeBuilder instanceof OptionBuilder) {
    return new OptionBuilder(
      registerTypesRecursively(typeBuilder.value)
    );
  } else if (typeBuilder instanceof ResultBuilder) {
    return new ResultBuilder(
      registerTypesRecursively(typeBuilder.ok),
      registerTypesRecursively(typeBuilder.err)
    );
  } else if (typeBuilder instanceof ArrayBuilder) {
    return new ArrayBuilder(
      registerTypesRecursively(typeBuilder.element)
    );
  } else {
    return typeBuilder;
  }
}
function registerCompoundTypeRecursively(typeBuilder) {
  const ty = typeBuilder.algebraicType;
  const name = typeBuilder.typeName;
  if (name === void 0) {
    throw new Error(
      `Missing type name for ${typeBuilder.constructor.name ?? "TypeBuilder"} ${JSON.stringify(typeBuilder)}`
    );
  }
  let r = COMPOUND_TYPES.get(ty);
  if (r != null) {
    return r;
  }
  const newTy = typeBuilder instanceof RowBuilder || typeBuilder instanceof ProductBuilder ? {
    tag: "Product",
    value: { elements: [] }
  } : { tag: "Sum", value: { variants: [] } };
  r = new RefBuilder(MODULE_DEF.typespace.types.length);
  MODULE_DEF.typespace.types.push(newTy);
  COMPOUND_TYPES.set(ty, r);
  if (typeBuilder instanceof RowBuilder) {
    for (const [name2, elem] of Object.entries(typeBuilder.row)) {
      newTy.value.elements.push({
        name: name2,
        algebraicType: registerTypesRecursively(elem.typeBuilder).algebraicType
      });
    }
  } else if (typeBuilder instanceof ProductBuilder) {
    for (const [name2, elem] of Object.entries(typeBuilder.elements)) {
      newTy.value.elements.push({
        name: name2,
        algebraicType: registerTypesRecursively(elem).algebraicType
      });
    }
  } else if (typeBuilder instanceof SumBuilder) {
    for (const [name2, variant] of Object.entries(typeBuilder.variants)) {
      newTy.value.variants.push({
        name: name2,
        algebraicType: registerTypesRecursively(variant).algebraicType
      });
    }
  }
  MODULE_DEF.types.push({
    name: splitName(name),
    ty: r.ref,
    customOrdering: true
  });
  return r;
}
function isUnit(typeBuilder) {
  return typeBuilder.typeName == null && typeBuilder.algebraicType.value.elements.length === 0;
}
function splitName(name) {
  const scope = name.split(".");
  return { name: scope.pop(), scope };
}
var Schema = class {
  tablesDef;
  typespace;
  schemaType;
  constructor(tables, typespace, handles) {
    this.tablesDef = { tables };
    this.typespace = typespace;
    this.schemaType = tablesToSchema(handles);
  }
  reducer(name, paramsOrFn, fn) {
    if (typeof paramsOrFn === "function") {
      reducer(name, {}, paramsOrFn);
      return paramsOrFn;
    } else {
      reducer(name, paramsOrFn, fn);
      return fn;
    }
  }
  init(nameOrFn, maybeFn) {
    const [name, fn] = typeof nameOrFn === "string" ? [nameOrFn, maybeFn] : ["init", nameOrFn];
    init(name, {}, fn);
  }
  clientConnected(nameOrFn, maybeFn) {
    const [name, fn] = typeof nameOrFn === "string" ? [nameOrFn, maybeFn] : ["on_connect", nameOrFn];
    clientConnected(name, {}, fn);
  }
  clientDisconnected(nameOrFn, maybeFn) {
    const [name, fn] = typeof nameOrFn === "string" ? [nameOrFn, maybeFn] : ["on_disconnect", nameOrFn];
    clientDisconnected(name, {}, fn);
  }
  view(opts, ret, fn) {
    defineView(opts, false, {}, ret, fn);
  }
  // TODO: re-enable once parameterized views are supported in SQL
  // view<Ret extends ViewReturnTypeBuilder>(
  //   opts: ViewOpts,
  //   ret: Ret,
  //   fn: ViewFn<S, {}, Ret>
  // ): void;
  // view<Params extends ParamsObj, Ret extends ViewReturnTypeBuilder>(
  //   opts: ViewOpts,
  //   params: Params,
  //   ret: Ret,
  //   fn: ViewFn<S, {}, Ret>
  // ): void;
  // view<Params extends ParamsObj, Ret extends ViewReturnTypeBuilder>(
  //   opts: ViewOpts,
  //   paramsOrRet: Ret | Params,
  //   retOrFn: ViewFn<S, {}, Ret> | Ret,
  //   maybeFn?: ViewFn<S, Params, Ret>
  // ): void {
  //   if (typeof retOrFn === 'function') {
  //     defineView(name, false, {}, paramsOrRet as Ret, retOrFn);
  //   } else {
  //     defineView(name, false, paramsOrRet as Params, retOrFn, maybeFn!);
  //   }
  // }
  anonymousView(opts, ret, fn) {
    defineView(opts, true, {}, ret, fn);
  }
  procedure(name, paramsOrRet, retOrFn, maybeFn) {
    if (typeof retOrFn === "function") {
      procedure(name, {}, paramsOrRet, retOrFn);
      return retOrFn;
    } else {
      procedure(name, paramsOrRet, retOrFn, maybeFn);
      return maybeFn;
    }
  }
  clientVisibilityFilter = {
    sql(filter) {
      MODULE_DEF.rowLevelSecurity.push({ sql: filter });
    }
  };
};
function schema(...args) {
  const handles = args.length === 1 && Array.isArray(args[0]) ? args[0] : args;
  const tableDefs = handles.map((h) => h.tableDef);
  MODULE_DEF.tables.push(...tableDefs);
  ({
    tables: handles.map((handle) => ({
      name: handle.tableName,
      accessorName: handle.tableName,
      columns: handle.rowType.row,
      rowType: handle.rowSpacetimeType,
      indexes: handle.idxs,
      constraints: handle.constraints
    }))
  });
  return new Schema(tableDefs, MODULE_DEF.typespace, handles);
}
function convertToAccessorMap(arr) {
  return Object.fromEntries(
    arr.map((v) => [v.accessorName, v])
  );
}

// src/lib/autogen/raw_index_algorithm_type.ts
var RawIndexAlgorithm = t.enum("RawIndexAlgorithm", {
  BTree: t.array(t.u16()),
  Hash: t.array(t.u16()),
  Direct: t.u16()
});
var raw_index_algorithm_type_default = RawIndexAlgorithm;

// src/lib/table.ts
function table(opts, row) {
  const {
    name,
    public: isPublic = false,
    indexes: userIndexes = [],
    scheduled
  } = opts;
  const colIds = /* @__PURE__ */ new Map();
  const colNameList = [];
  if (!(row instanceof RowBuilder)) {
    row = new RowBuilder(row);
  }
  if (row.typeName === void 0) {
    row.typeName = toPascalCase(name);
  }
  const rowTypeRef = registerTypesRecursively(row);
  row.algebraicType.value.elements.forEach((elem, i) => {
    colIds.set(elem.name, i);
    colNameList.push(elem.name);
  });
  const pk = [];
  const indexes = [];
  const constraints = [];
  const sequences = [];
  let scheduleAtCol;
  for (const [name2, builder] of Object.entries(row.row)) {
    const meta = builder.columnMetadata;
    if (meta.isPrimaryKey) {
      pk.push(colIds.get(name2));
    }
    const isUnique = meta.isUnique || meta.isPrimaryKey;
    if (meta.indexType || isUnique) {
      const algo = meta.indexType ?? "btree";
      const id = colIds.get(name2);
      let algorithm;
      switch (algo) {
        case "btree":
          algorithm = raw_index_algorithm_type_default.BTree([id]);
          break;
        case "direct":
          algorithm = raw_index_algorithm_type_default.Direct(id);
          break;
      }
      indexes.push({
        name: void 0,
        // Unnamed indexes will be assigned a globally unique name
        accessorName: name2,
        // The name of this column will be used as the accessor name
        algorithm
      });
    }
    if (isUnique) {
      constraints.push({
        name: void 0,
        data: { tag: "Unique", value: { columns: [colIds.get(name2)] } }
      });
    }
    if (meta.isAutoIncrement) {
      sequences.push({
        name: void 0,
        start: void 0,
        minValue: void 0,
        maxValue: void 0,
        column: colIds.get(name2),
        increment: 1n
      });
    }
    if (scheduled) {
      const algebraicType = builder.typeBuilder.algebraicType;
      if (schedule_at_default.isScheduleAt(algebraicType)) {
        scheduleAtCol = colIds.get(name2);
      }
    }
  }
  for (const indexOpts of userIndexes ?? []) {
    let algorithm;
    switch (indexOpts.algorithm) {
      case "btree":
        algorithm = {
          tag: "BTree",
          value: indexOpts.columns.map((c) => colIds.get(c))
        };
        break;
      case "direct":
        algorithm = { tag: "Direct", value: colIds.get(indexOpts.column) };
        break;
    }
    indexes.push({ name: void 0, accessorName: indexOpts.name, algorithm });
  }
  for (const constraintOpts of opts.constraints ?? []) {
    if (constraintOpts.constraint === "unique") {
      const data = {
        tag: "Unique",
        value: { columns: constraintOpts.columns.map((c) => colIds.get(c)) }
      };
      constraints.push({ name: constraintOpts.name, data });
      continue;
    }
  }
  for (const index of indexes) {
    const cols = index.algorithm.tag === "Direct" ? [index.algorithm.value] : index.algorithm.value;
    const colS = cols.map((i) => colNameList[i]).join("_");
    index.name = `${name}_${colS}_idx_${index.algorithm.tag.toLowerCase()}`;
  }
  const tableDef = {
    name,
    productTypeRef: rowTypeRef.ref,
    primaryKey: pk,
    indexes,
    constraints,
    sequences,
    schedule: scheduled && scheduleAtCol !== void 0 ? {
      name: void 0,
      reducerName: scheduled,
      scheduledAtColumn: scheduleAtCol
    } : void 0,
    tableType: { tag: "User" },
    tableAccess: { tag: isPublic ? "Public" : "Private" }
  };
  const productType = row.algebraicType.value;
  return {
    rowType: row,
    tableName: name,
    rowSpacetimeType: productType,
    tableDef,
    idxs: {},
    constraints
  };
}

export { ArrayBuilder, ArrayColumnBuilder, BoolBuilder, BoolColumnBuilder, ByteArrayBuilder, ByteArrayColumnBuilder, ClientCache, ColumnBuilder, ConnectionIdBuilder, ConnectionIdColumnBuilder, DbConnectionBuilder, DbConnectionImpl, F32Builder, F32ColumnBuilder, F64Builder, F64ColumnBuilder, I128Builder, I128ColumnBuilder, I16Builder, I16ColumnBuilder, I256Builder, I256ColumnBuilder, I32Builder, I32ColumnBuilder, I64Builder, I64ColumnBuilder, I8Builder, I8ColumnBuilder, IdentityBuilder, IdentityColumnBuilder, OptionBuilder, OptionColumnBuilder, ProductBuilder, ProductColumnBuilder, RefBuilder, ResultBuilder, ResultColumnBuilder, RowBuilder, ScheduleAtBuilder, ScheduleAtColumnBuilder, SimpleSumBuilder, SimpleSumColumnBuilder, StringBuilder, StringColumnBuilder, SubscriptionBuilderImpl, SubscriptionHandleImpl, SumBuilder, SumColumnBuilder, TimeDurationBuilder, TimeDurationColumnBuilder, TimestampBuilder, TimestampColumnBuilder, TypeBuilder, U128Builder, U128ColumnBuilder, U16Builder, U16ColumnBuilder, U256Builder, U256ColumnBuilder, U32Builder, U32ColumnBuilder, U64Builder, U64ColumnBuilder, U8Builder, U8ColumnBuilder, UuidBuilder, UuidColumnBuilder, convertToAccessorMap, procedureSchema, procedures, reducerSchema, reducers, schema, t, table };
//# sourceMappingURL=index.browser.mjs.map
//# sourceMappingURL=index.browser.mjs.map