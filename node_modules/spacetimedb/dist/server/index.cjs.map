{"version":3,"sources":["../../../../node_modules/.pnpm/base64-js@1.5.1/node_modules/base64-js/index.js","../../../../node_modules/.pnpm/fast-text-encoding@1.0.6/node_modules/fast-text-encoding/text.min.js","../../../../node_modules/.pnpm/statuses@2.0.2/node_modules/statuses/codes.json","../../../../node_modules/.pnpm/statuses@2.0.2/node_modules/statuses/index.js","../../src/lib/time_duration.ts","../../src/lib/timestamp.ts","../../src/lib/uuid.ts","../../src/lib/binary_reader.ts","../../src/lib/binary_writer.ts","../../src/lib/util.ts","../../src/lib/connection_id.ts","../../src/lib/identity.ts","../../src/lib/algebraic_type.ts","../../src/lib/option.ts","../../src/lib/result.ts","../../src/lib/schedule_at.ts","../../src/lib/type_util.ts","../../src/lib/type_builders.ts","../../src/lib/autogen/lifecycle_type.ts","../../src/lib/reducers.ts","../../src/server/query.ts","../../src/lib/views.ts","../../src/lib/procedures.ts","../../src/lib/schema.ts","../../src/lib/autogen/raw_index_algorithm_type.ts","../../src/lib/table.ts","../../src/server/errors.ts","../../src/server/polyfills.ts","../../src/lib/autogen/sum_type_variant_type.ts","../../src/lib/autogen/sum_type_type.ts","../../src/lib/autogen/product_type_element_type.ts","../../src/lib/autogen/product_type_type.ts","../../src/lib/autogen/algebraic_type_type.ts","../../src/lib/autogen/typespace_type.ts","../../src/lib/autogen/raw_column_def_v_8_type.ts","../../src/lib/autogen/index_type_type.ts","../../src/lib/autogen/raw_index_def_v_8_type.ts","../../src/lib/autogen/raw_constraint_def_v_8_type.ts","../../src/lib/autogen/raw_sequence_def_v_8_type.ts","../../src/lib/autogen/raw_table_def_v_8_type.ts","../../src/lib/autogen/table_desc_type.ts","../../src/lib/autogen/reducer_def_type.ts","../../src/lib/autogen/type_alias_type.ts","../../src/lib/autogen/misc_module_export_type.ts","../../src/lib/autogen/raw_module_def_v_8_type.ts","../../src/lib/autogen/raw_index_def_v_9_type.ts","../../src/lib/autogen/raw_unique_constraint_data_v_9_type.ts","../../src/lib/autogen/raw_constraint_data_v_9_type.ts","../../src/lib/autogen/raw_constraint_def_v_9_type.ts","../../src/lib/autogen/raw_sequence_def_v_9_type.ts","../../src/lib/autogen/raw_schedule_def_v_9_type.ts","../../src/lib/autogen/table_type_type.ts","../../src/lib/autogen/table_access_type.ts","../../src/lib/autogen/raw_table_def_v_9_type.ts","../../src/lib/autogen/raw_reducer_def_v_9_type.ts","../../src/lib/autogen/raw_scoped_type_name_v_9_type.ts","../../src/lib/autogen/raw_type_def_v_9_type.ts","../../src/lib/autogen/raw_column_default_value_v_9_type.ts","../../src/lib/autogen/raw_procedure_def_v_9_type.ts","../../src/lib/autogen/raw_view_def_v_9_type.ts","../../src/lib/autogen/raw_misc_module_export_v_9_type.ts","../../src/lib/autogen/raw_row_level_security_def_v_9_type.ts","../../src/lib/autogen/raw_module_def_v_9_type.ts","../../src/lib/autogen/raw_module_def_type.ts","../../src/server/range.ts","../../src/server/http_internal.ts","../../src/lib/autogen/http_header_pair_type.ts","../../src/lib/autogen/http_headers_type.ts","../../src/lib/autogen/http_method_type.ts","../../src/lib/autogen/http_version_type.ts","../../src/lib/autogen/http_request_type.ts","../../src/lib/autogen/http_response_type.ts","../../src/server/procedures.ts","../../src/lib/autogen/view_result_header_type.ts","../../src/server/runtime.ts","../../src/server/register_hooks.ts"],"names":["fromByteArray","len","i","len2","t","status","codes","name","variants","isUnit","reducers","table","schema","ret","AlgebraicType","init","Headers","headersToList","v","freeze","timestamp","ctx","_syscalls1_0","_syscalls1_2","baseSize","iter","console","register_hooks","register_hooks_v1_1","register_hooks_v1_2"],"mappings":"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","file":"index.cjs","sourcesContent":["'use strict'\n\nexports.byteLength = byteLength\nexports.toByteArray = toByteArray\nexports.fromByteArray = fromByteArray\n\nvar lookup = []\nvar revLookup = []\nvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array\n\nvar code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\nfor (var i = 0, len = code.length; i < len; ++i) {\n  lookup[i] = code[i]\n  revLookup[code.charCodeAt(i)] = i\n}\n\n// Support decoding URL-safe base64 strings, as Node.js does.\n// See: https://en.wikipedia.org/wiki/Base64#URL_applications\nrevLookup['-'.charCodeAt(0)] = 62\nrevLookup['_'.charCodeAt(0)] = 63\n\nfunction getLens (b64) {\n  var len = b64.length\n\n  if (len % 4 > 0) {\n    throw new Error('Invalid string. Length must be a multiple of 4')\n  }\n\n  // Trim off extra bytes after placeholder bytes are found\n  // See: https://github.com/beatgammit/base64-js/issues/42\n  var validLen = b64.indexOf('=')\n  if (validLen === -1) validLen = len\n\n  var placeHoldersLen = validLen === len\n    ? 0\n    : 4 - (validLen % 4)\n\n  return [validLen, placeHoldersLen]\n}\n\n// base64 is 4/3 + up to two characters of the original data\nfunction byteLength (b64) {\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction _byteLength (b64, validLen, placeHoldersLen) {\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction toByteArray (b64) {\n  var tmp\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n\n  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))\n\n  var curByte = 0\n\n  // if there are placeholders, only get up to the last complete 4 chars\n  var len = placeHoldersLen > 0\n    ? validLen - 4\n    : validLen\n\n  var i\n  for (i = 0; i < len; i += 4) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 18) |\n      (revLookup[b64.charCodeAt(i + 1)] << 12) |\n      (revLookup[b64.charCodeAt(i + 2)] << 6) |\n      revLookup[b64.charCodeAt(i + 3)]\n    arr[curByte++] = (tmp >> 16) & 0xFF\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 2) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 2) |\n      (revLookup[b64.charCodeAt(i + 1)] >> 4)\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 1) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 10) |\n      (revLookup[b64.charCodeAt(i + 1)] << 4) |\n      (revLookup[b64.charCodeAt(i + 2)] >> 2)\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  return arr\n}\n\nfunction tripletToBase64 (num) {\n  return lookup[num >> 18 & 0x3F] +\n    lookup[num >> 12 & 0x3F] +\n    lookup[num >> 6 & 0x3F] +\n    lookup[num & 0x3F]\n}\n\nfunction encodeChunk (uint8, start, end) {\n  var tmp\n  var output = []\n  for (var i = start; i < end; i += 3) {\n    tmp =\n      ((uint8[i] << 16) & 0xFF0000) +\n      ((uint8[i + 1] << 8) & 0xFF00) +\n      (uint8[i + 2] & 0xFF)\n    output.push(tripletToBase64(tmp))\n  }\n  return output.join('')\n}\n\nfunction fromByteArray (uint8) {\n  var tmp\n  var len = uint8.length\n  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes\n  var parts = []\n  var maxChunkLength = 16383 // must be multiple of 3\n\n  // go through the array every three bytes, we'll deal with trailing stuff later\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))\n  }\n\n  // pad the end with zeros, but make sure to not forget the extra bytes\n  if (extraBytes === 1) {\n    tmp = uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 2] +\n      lookup[(tmp << 4) & 0x3F] +\n      '=='\n    )\n  } else if (extraBytes === 2) {\n    tmp = (uint8[len - 2] << 8) + uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 10] +\n      lookup[(tmp >> 4) & 0x3F] +\n      lookup[(tmp << 2) & 0x3F] +\n      '='\n    )\n  }\n\n  return parts.join('')\n}\n","(function(scope) {'use strict';\nfunction B(r,e){var f;return r instanceof Buffer?f=r:f=Buffer.from(r.buffer,r.byteOffset,r.byteLength),f.toString(e)}var w=function(r){return Buffer.from(r)};function h(r){for(var e=0,f=Math.min(256*256,r.length+1),n=new Uint16Array(f),i=[],o=0;;){var t=e<r.length;if(!t||o>=f-1){var s=n.subarray(0,o),m=s;if(i.push(String.fromCharCode.apply(null,m)),!t)return i.join(\"\");r=r.subarray(e),e=0,o=0}var a=r[e++];if((a&128)===0)n[o++]=a;else if((a&224)===192){var d=r[e++]&63;n[o++]=(a&31)<<6|d}else if((a&240)===224){var d=r[e++]&63,l=r[e++]&63;n[o++]=(a&31)<<12|d<<6|l}else if((a&248)===240){var d=r[e++]&63,l=r[e++]&63,R=r[e++]&63,c=(a&7)<<18|d<<12|l<<6|R;c>65535&&(c-=65536,n[o++]=c>>>10&1023|55296,c=56320|c&1023),n[o++]=c}}}function F(r){for(var e=0,f=r.length,n=0,i=Math.max(32,f+(f>>>1)+7),o=new Uint8Array(i>>>3<<3);e<f;){var t=r.charCodeAt(e++);if(t>=55296&&t<=56319){if(e<f){var s=r.charCodeAt(e);(s&64512)===56320&&(++e,t=((t&1023)<<10)+(s&1023)+65536)}if(t>=55296&&t<=56319)continue}if(n+4>o.length){i+=8,i*=1+e/r.length*2,i=i>>>3<<3;var m=new Uint8Array(i);m.set(o),o=m}if((t&4294967168)===0){o[n++]=t;continue}else if((t&4294965248)===0)o[n++]=t>>>6&31|192;else if((t&4294901760)===0)o[n++]=t>>>12&15|224,o[n++]=t>>>6&63|128;else if((t&4292870144)===0)o[n++]=t>>>18&7|240,o[n++]=t>>>12&63|128,o[n++]=t>>>6&63|128;else continue;o[n++]=t&63|128}return o.slice?o.slice(0,n):o.subarray(0,n)}var u=\"Failed to \",p=function(r,e,f){if(r)throw new Error(\"\".concat(u).concat(e,\": the '\").concat(f,\"' option is unsupported.\"))};var x=typeof Buffer==\"function\"&&Buffer.from;var A=x?w:F;function v(){this.encoding=\"utf-8\"}v.prototype.encode=function(r,e){return p(e&&e.stream,\"encode\",\"stream\"),A(r)};function U(r){var e;try{var f=new Blob([r],{type:\"text/plain;charset=UTF-8\"});e=URL.createObjectURL(f);var n=new XMLHttpRequest;return n.open(\"GET\",e,!1),n.send(),n.responseText}finally{e&&URL.revokeObjectURL(e)}}var O=!x&&typeof Blob==\"function\"&&typeof URL==\"function\"&&typeof URL.createObjectURL==\"function\",S=[\"utf-8\",\"utf8\",\"unicode-1-1-utf-8\"],T=h;x?T=B:O&&(T=function(r){try{return U(r)}catch(e){return h(r)}});var y=\"construct 'TextDecoder'\",E=\"\".concat(u,\" \").concat(y,\": the \");function g(r,e){p(e&&e.fatal,y,\"fatal\"),r=r||\"utf-8\";var f;if(x?f=Buffer.isEncoding(r):f=S.indexOf(r.toLowerCase())!==-1,!f)throw new RangeError(\"\".concat(E,\" encoding label provided ('\").concat(r,\"') is invalid.\"));this.encoding=r,this.fatal=!1,this.ignoreBOM=!1}g.prototype.decode=function(r,e){p(e&&e.stream,\"decode\",\"stream\");var f;return r instanceof Uint8Array?f=r:r.buffer instanceof ArrayBuffer?f=new Uint8Array(r.buffer):f=new Uint8Array(r),T(f,this.encoding)};scope.TextEncoder=scope.TextEncoder||v;scope.TextDecoder=scope.TextDecoder||g;\n}(typeof window !== 'undefined' ? window : (typeof global !== 'undefined' ? global : this)));\n","{\n  \"100\": \"Continue\",\n  \"101\": \"Switching Protocols\",\n  \"102\": \"Processing\",\n  \"103\": \"Early Hints\",\n  \"200\": \"OK\",\n  \"201\": \"Created\",\n  \"202\": \"Accepted\",\n  \"203\": \"Non-Authoritative Information\",\n  \"204\": \"No Content\",\n  \"205\": \"Reset Content\",\n  \"206\": \"Partial Content\",\n  \"207\": \"Multi-Status\",\n  \"208\": \"Already Reported\",\n  \"226\": \"IM Used\",\n  \"300\": \"Multiple Choices\",\n  \"301\": \"Moved Permanently\",\n  \"302\": \"Found\",\n  \"303\": \"See Other\",\n  \"304\": \"Not Modified\",\n  \"305\": \"Use Proxy\",\n  \"307\": \"Temporary Redirect\",\n  \"308\": \"Permanent Redirect\",\n  \"400\": \"Bad Request\",\n  \"401\": \"Unauthorized\",\n  \"402\": \"Payment Required\",\n  \"403\": \"Forbidden\",\n  \"404\": \"Not Found\",\n  \"405\": \"Method Not Allowed\",\n  \"406\": \"Not Acceptable\",\n  \"407\": \"Proxy Authentication Required\",\n  \"408\": \"Request Timeout\",\n  \"409\": \"Conflict\",\n  \"410\": \"Gone\",\n  \"411\": \"Length Required\",\n  \"412\": \"Precondition Failed\",\n  \"413\": \"Payload Too Large\",\n  \"414\": \"URI Too Long\",\n  \"415\": \"Unsupported Media Type\",\n  \"416\": \"Range Not Satisfiable\",\n  \"417\": \"Expectation Failed\",\n  \"418\": \"I'm a Teapot\",\n  \"421\": \"Misdirected Request\",\n  \"422\": \"Unprocessable Entity\",\n  \"423\": \"Locked\",\n  \"424\": \"Failed Dependency\",\n  \"425\": \"Too Early\",\n  \"426\": \"Upgrade Required\",\n  \"428\": \"Precondition Required\",\n  \"429\": \"Too Many Requests\",\n  \"431\": \"Request Header Fields Too Large\",\n  \"451\": \"Unavailable For Legal Reasons\",\n  \"500\": \"Internal Server Error\",\n  \"501\": \"Not Implemented\",\n  \"502\": \"Bad Gateway\",\n  \"503\": \"Service Unavailable\",\n  \"504\": \"Gateway Timeout\",\n  \"505\": \"HTTP Version Not Supported\",\n  \"506\": \"Variant Also Negotiates\",\n  \"507\": \"Insufficient Storage\",\n  \"508\": \"Loop Detected\",\n  \"509\": \"Bandwidth Limit Exceeded\",\n  \"510\": \"Not Extended\",\n  \"511\": \"Network Authentication Required\"\n}\n","/*!\n * statuses\n * Copyright(c) 2014 Jonathan Ong\n * Copyright(c) 2016 Douglas Christopher Wilson\n * MIT Licensed\n */\n\n'use strict'\n\n/**\n * Module dependencies.\n * @private\n */\n\nvar codes = require('./codes.json')\n\n/**\n * Module exports.\n * @public\n */\n\nmodule.exports = status\n\n// status code to message map\nstatus.message = codes\n\n// status message (lower-case) to code map\nstatus.code = createMessageToStatusCodeMap(codes)\n\n// array of status codes\nstatus.codes = createStatusCodeList(codes)\n\n// status codes for redirects\nstatus.redirect = {\n  300: true,\n  301: true,\n  302: true,\n  303: true,\n  305: true,\n  307: true,\n  308: true\n}\n\n// status codes for empty bodies\nstatus.empty = {\n  204: true,\n  205: true,\n  304: true\n}\n\n// status codes for when you should retry the request\nstatus.retry = {\n  502: true,\n  503: true,\n  504: true\n}\n\n/**\n * Create a map of message to status code.\n * @private\n */\n\nfunction createMessageToStatusCodeMap (codes) {\n  var map = {}\n\n  Object.keys(codes).forEach(function forEachCode (code) {\n    var message = codes[code]\n    var status = Number(code)\n\n    // populate map\n    map[message.toLowerCase()] = status\n  })\n\n  return map\n}\n\n/**\n * Create a list of all status codes.\n * @private\n */\n\nfunction createStatusCodeList (codes) {\n  return Object.keys(codes).map(function mapCode (code) {\n    return Number(code)\n  })\n}\n\n/**\n * Get the status code for given message.\n * @private\n */\n\nfunction getStatusCode (message) {\n  var msg = message.toLowerCase()\n\n  if (!Object.prototype.hasOwnProperty.call(status.code, msg)) {\n    throw new Error('invalid status message: \"' + message + '\"')\n  }\n\n  return status.code[msg]\n}\n\n/**\n * Get the status message for given code.\n * @private\n */\n\nfunction getStatusMessage (code) {\n  if (!Object.prototype.hasOwnProperty.call(status.message, code)) {\n    throw new Error('invalid status code: ' + code)\n  }\n\n  return status.message[code]\n}\n\n/**\n * Get the status code.\n *\n * Given a number, this will throw if it is not a known status\n * code, otherwise the code will be returned. Given a string,\n * the string will be parsed for a number and return the code\n * if valid, otherwise will lookup the code assuming this is\n * the status message.\n *\n * @param {string|number} code\n * @returns {number}\n * @public\n */\n\nfunction status (code) {\n  if (typeof code === 'number') {\n    return getStatusMessage(code)\n  }\n\n  if (typeof code !== 'string') {\n    throw new TypeError('code must be a number or string')\n  }\n\n  // '403'\n  var n = parseInt(code, 10)\n  if (!isNaN(n)) {\n    return getStatusMessage(n)\n  }\n\n  return getStatusCode(code)\n}\n","import { AlgebraicType } from './algebraic_type';\n\nexport type TimeDurationAlgebraicType = {\n  tag: 'Product';\n  value: {\n    elements: [\n      { name: '__time_duration_micros__'; algebraicType: { tag: 'I64' } },\n    ];\n  };\n};\n\n/**\n * A difference between two points in time, represented as a number of microseconds.\n */\nexport class TimeDuration {\n  __time_duration_micros__: bigint;\n\n  private static MICROS_PER_MILLIS: bigint = 1000n;\n\n  /**\n   * Get the algebraic type representation of the {@link TimeDuration} type.\n   * @returns The algebraic type representation of the type.\n   */\n  static getAlgebraicType(): TimeDurationAlgebraicType {\n    return AlgebraicType.Product({\n      elements: [\n        {\n          name: '__time_duration_micros__',\n          algebraicType: AlgebraicType.I64,\n        },\n      ],\n    });\n  }\n\n  static isTimeDuration(\n    algebraicType: AlgebraicType\n  ): algebraicType is TimeDurationAlgebraicType {\n    if (algebraicType.tag !== 'Product') {\n      return false;\n    }\n    const elements = algebraicType.value.elements;\n    if (elements.length !== 1) {\n      return false;\n    }\n    const microsElement = elements[0];\n    return (\n      microsElement.name === '__time_duration_micros__' &&\n      microsElement.algebraicType.tag === 'I64'\n    );\n  }\n\n  get micros(): bigint {\n    return this.__time_duration_micros__;\n  }\n\n  get millis(): number {\n    return Number(this.micros / TimeDuration.MICROS_PER_MILLIS);\n  }\n\n  constructor(micros: bigint) {\n    this.__time_duration_micros__ = micros;\n  }\n\n  static fromMillis(millis: number): TimeDuration {\n    return new TimeDuration(BigInt(millis) * TimeDuration.MICROS_PER_MILLIS);\n  }\n\n  /** This outputs the same string format that we use in the host and in Rust modules */\n  toString(): string {\n    const micros = this.micros;\n    const sign = micros < 0 ? '-' : '+';\n    const pos = micros < 0 ? -micros : micros;\n    const secs = pos / 1_000_000n;\n    const micros_remaining = pos % 1_000_000n;\n    return `${sign}${secs}.${String(micros_remaining).padStart(6, '0')}`;\n  }\n}\n","import { AlgebraicType } from './algebraic_type';\nimport { TimeDuration } from './time_duration';\n\nexport type TimestampAlgebraicType = {\n  tag: 'Product';\n  value: {\n    elements: [\n      {\n        name: '__timestamp_micros_since_unix_epoch__';\n        algebraicType: { tag: 'I64' };\n      },\n    ];\n  };\n};\n\n/**\n * A point in time, represented as a number of microseconds since the Unix epoch.\n */\nexport class Timestamp {\n  __timestamp_micros_since_unix_epoch__: bigint;\n\n  private static MICROS_PER_MILLIS: bigint = 1000n;\n\n  get microsSinceUnixEpoch(): bigint {\n    return this.__timestamp_micros_since_unix_epoch__;\n  }\n\n  constructor(micros: bigint) {\n    this.__timestamp_micros_since_unix_epoch__ = micros;\n  }\n\n  /**\n   * Get the algebraic type representation of the {@link Timestamp} type.\n   * @returns The algebraic type representation of the type.\n   */\n  static getAlgebraicType(): TimestampAlgebraicType {\n    return AlgebraicType.Product({\n      elements: [\n        {\n          name: '__timestamp_micros_since_unix_epoch__',\n          algebraicType: AlgebraicType.I64,\n        },\n      ],\n    });\n  }\n\n  static isTimestamp(\n    algebraicType: AlgebraicType\n  ): algebraicType is TimestampAlgebraicType {\n    if (algebraicType.tag !== 'Product') {\n      return false;\n    }\n    const elements = algebraicType.value.elements;\n    if (elements.length !== 1) {\n      return false;\n    }\n    const microsElement = elements[0];\n    return (\n      microsElement.name === '__timestamp_micros_since_unix_epoch__' &&\n      microsElement.algebraicType.tag === 'I64'\n    );\n  }\n\n  /**\n   * The Unix epoch, the midnight at the beginning of January 1, 1970, UTC.\n   */\n  static UNIX_EPOCH: Timestamp = new Timestamp(0n);\n\n  /**\n   * Get a `Timestamp` representing the execution environment's belief of the current moment in time.\n   */\n  static now(): Timestamp {\n    return Timestamp.fromDate(new Date());\n  }\n\n  /** Convert to milliseconds since Unix epoch. */\n  toMillis(): bigint {\n    return this.microsSinceUnixEpoch / 1000n;\n  }\n\n  /**\n   * Get a `Timestamp` representing the same point in time as `date`.\n   */\n  static fromDate(date: Date): Timestamp {\n    const millis = date.getTime();\n    const micros = BigInt(millis) * Timestamp.MICROS_PER_MILLIS;\n    return new Timestamp(micros);\n  }\n\n  /**\n   * Get a `Date` representing approximately the same point in time as `this`.\n   *\n   * This method truncates to millisecond precision,\n   * and throws `RangeError` if the `Timestamp` is outside the range representable as a `Date`.\n   */\n  toDate(): Date {\n    const micros = this.__timestamp_micros_since_unix_epoch__;\n    const millis = micros / Timestamp.MICROS_PER_MILLIS;\n    if (\n      millis > BigInt(Number.MAX_SAFE_INTEGER) ||\n      millis < BigInt(Number.MIN_SAFE_INTEGER)\n    ) {\n      throw new RangeError(\n        \"Timestamp is outside of the representable range of JS's Date\"\n      );\n    }\n    return new Date(Number(millis));\n  }\n\n  since(other: Timestamp): TimeDuration {\n    return new TimeDuration(\n      this.__timestamp_micros_since_unix_epoch__ -\n        other.__timestamp_micros_since_unix_epoch__\n    );\n  }\n}\n","import { Timestamp } from './timestamp';\nimport { AlgebraicType } from './algebraic_type.ts';\n\nexport type UuidAlgebraicType = {\n  tag: 'Product';\n  value: {\n    elements: [\n      {\n        name: '__uuid__';\n        algebraicType: { tag: 'U128' };\n      },\n    ];\n  };\n};\n\n/**\n * Supported UUID versions.\n *\n * - `Nil`  The \"Nil\" UUID (all zeros)\n * - `V4`   Version 4: random\n * - `V7`   Version 7: timestamp + counter + random\n * - `Max`  The \"Max\" UUID (all ones)\n */\ntype UuidVersion = 'Nil' | 'V4' | 'V7' | 'Max';\n\n/**\n * A universally unique identifier (UUID).\n *\n * Supports UUID `Nil`, `Max`, `V4` (random), and `V7`\n * (timestamp + counter + random).\n *\n * Internally represented as an unsigned 128-bit between 0 and `MAX_UUID_BIGINT`.\n */\nexport class Uuid {\n  __uuid__: bigint;\n\n  /**\n   * The nil UUID (all zeros).\n   *\n   * @example\n   * ```ts\n   * const uuid = Uuid.NIL;\n   * console.assert(\n   *   uuid.toString() === \"00000000-0000-0000-0000-000000000000\"\n   * );\n   * ```\n   */\n  static readonly NIL = new Uuid(0n);\n  static readonly MAX_UUID_BIGINT = 0xffffffffffffffffffffffffffffffffn;\n  /**\n   * The max UUID (all ones).\n   *\n   * @example\n   * ```ts\n   * const uuid = Uuid.MAX;\n   * console.assert(\n   *   uuid.toString() === \"ffffffff-ffff-ffff-ffff-ffffffffffff\"\n   * );\n   * ```\n   */\n  static readonly MAX = new Uuid(Uuid.MAX_UUID_BIGINT);\n\n  /**\n   * Create a UUID from a raw 128-bit value.\n   *\n   * @param u - Unsigned 128-bit integer\n   * @throws {Error} If the value is outside the valid UUID range\n   */\n  constructor(u: bigint) {\n    // Must fit in exactly 16 bytes\n    if (u < 0n || u > Uuid.MAX_UUID_BIGINT) {\n      throw new Error('Invalid UUID: must be between 0 and `MAX_UUID_BIGINT`');\n    }\n    this.__uuid__ = u;\n  }\n\n  /**\n   * Create a UUID `v4` from explicit random bytes.\n   *\n   * This method assumes the bytes are already sufficiently random.\n   * It only sets the appropriate bits for the UUID version and variant.\n   *\n   * @param bytes - Exactly 16 random bytes\n   * @returns A UUID `v4`\n   * @throws {Error} If `bytes.length !== 16`\n   *\n   * @example\n   * ```ts\n   * const randomBytes = new Uint8Array(16);\n   * const uuid = Uuid.fromRandomBytesV4(randomBytes);\n   *\n   * console.assert(\n   *   uuid.toString() === \"00000000-0000-4000-8000-000000000000\"\n   * );\n   * ```\n   */\n  static fromRandomBytesV4(bytes: Uint8Array): Uuid {\n    if (bytes.length !== 16) throw new Error('UUID v4 requires 16 bytes');\n    const arr = new Uint8Array(bytes);\n    arr[6] = (arr[6] & 0x0f) | 0x40; // version 4\n    arr[8] = (arr[8] & 0x3f) | 0x80; // variant\n    return new Uuid(Uuid.bytesToBigInt(arr));\n  }\n\n  /**\n   * Generate a UUID `v7` using a monotonic counter from `0` to `2^31 - 1`,\n   * a timestamp, and 4 random bytes.\n   *\n   * The counter wraps around on overflow.\n   *\n   * The UUID `v7` is structured as follows:\n   *\n   * ```ascii\n   * \n   * | B0  | B1  | B2  | B3  | B4  | B5              |         B6        |\n   * \n   * |                 unix_ts_ms                    |      version 7    |\n   * \n   * \n   * | B7           | B8      | B9  | B10 | B11  | B12 | B13 | B14 | B15 |\n   * \n   * | counter_high | variant |    counter_low   |        random         |\n   * \n   * ```\n   *\n   * @param counter - Mutable monotonic counter (31-bit)\n   * @param now - Timestamp since the Unix epoch\n   * @param randomBytes - Exactly 4 random bytes\n   * @returns A UUID `v7`\n   *\n   * @throws {Error} If the `counter` is negative\n   * @throws {Error} If the `timestamp` is before the Unix epoch\n   * @throws {Error} If `randomBytes.length !== 4`\n   *\n   * @example\n   * ```ts\n   * const now = Timestamp.fromMillis(1_686_000_000_000n);\n   * const counter = { value: 1 };\n   * const randomBytes = new Uint8Array(4);\n   *\n   * const uuid = Uuid.fromCounterV7(counter, now, randomBytes);\n   *\n   * console.assert(\n   *   uuid.toString() === \"0000647e-5180-7000-8000-000200000000\"\n   * );\n   * ```\n   */\n  static fromCounterV7(\n    counter: { value: number },\n    now: Timestamp,\n    randomBytes: Uint8Array\n  ): Uuid {\n    if (randomBytes.length !== 4) {\n      throw new Error('`fromCounterV7` requires `randomBytes.length == 4`');\n    }\n\n    if (counter.value < 0) {\n      throw new Error('`fromCounterV7` uuid `counter` must be non-negative');\n    }\n\n    if (now.__timestamp_micros_since_unix_epoch__ < 0) {\n      throw new Error('`fromCounterV7` `timestamp` before unix epoch');\n    }\n\n    // 31-bit monotonic counter with wraparound\n    const counterVal = counter.value;\n    counter.value = (counterVal + 1) & 0x7fff_ffff;\n\n    // 48-bit unix timestamp (ms)\n    const tsMs = now.toMillis() & 0xffff_ffff_ffffn;\n\n    const bytes = new Uint8Array(16);\n\n    // unix_ts_ms (48 bits)\n    bytes[0] = Number((tsMs >> 40n) & 0xffn);\n    bytes[1] = Number((tsMs >> 32n) & 0xffn);\n    bytes[2] = Number((tsMs >> 24n) & 0xffn);\n    bytes[3] = Number((tsMs >> 16n) & 0xffn);\n    bytes[4] = Number((tsMs >> 8n) & 0xffn);\n    bytes[5] = Number(tsMs & 0xffn);\n\n    // Counter bits (31 bits total)\n    bytes[7] = (counterVal >>> 23) & 0xff;\n    bytes[9] = (counterVal >>> 15) & 0xff;\n    bytes[10] = (counterVal >>> 7) & 0xff;\n    bytes[11] = ((counterVal & 0x7f) << 1) & 0xff;\n\n    // Random bytes\n    bytes[12] |= randomBytes[0] & 0x7f;\n    bytes[13] = randomBytes[1];\n    bytes[14] = randomBytes[2];\n    bytes[15] = randomBytes[3];\n\n    // Version 7\n    bytes[6] = (bytes[6] & 0x0f) | 0x70;\n\n    // Variant RFC4122\n    bytes[8] = (bytes[8] & 0x3f) | 0x80;\n\n    return new Uuid(Uuid.bytesToBigInt(bytes));\n  }\n\n  /**\n   * Parse a UUID from a string representation.\n   *\n   * @param s - UUID string\n   * @returns Parsed UUID\n   * @throws {Error} If the string is not a valid UUID\n   *\n   * @example\n   * ```ts\n   * const s = \"01888d6e-5c00-7000-8000-000000000000\";\n   * const uuid = Uuid.parse(s);\n   *\n   * console.assert(uuid.toString() === s);\n   * ```\n   */\n  static parse(s: string): Uuid {\n    const hex = s.replace(/-/g, '');\n    if (hex.length !== 32) throw new Error('Invalid hex UUID');\n\n    let v = 0n;\n    for (let i = 0; i < 32; i += 2) {\n      v = (v << 8n) | BigInt(parseInt(hex.slice(i, i + 2), 16));\n    }\n    return new Uuid(v);\n  }\n\n  /** Convert to string (hyphenated form). */\n  toString(): string {\n    const bytes = Uuid.bigIntToBytes(this.__uuid__);\n    const hex = [...bytes].map(b => b.toString(16).padStart(2, '0')).join('');\n\n    // Format as 8-4-4-4-12\n    return (\n      hex.slice(0, 8) +\n      '-' +\n      hex.slice(8, 12) +\n      '-' +\n      hex.slice(12, 16) +\n      '-' +\n      hex.slice(16, 20) +\n      '-' +\n      hex.slice(20)\n    );\n  }\n\n  /** Convert to bigint (u128). */\n  asBigInt(): bigint {\n    return this.__uuid__;\n  }\n\n  /** Return a `Uint8Array` of 16 bytes. */\n  toBytes(): Uint8Array {\n    return Uuid.bigIntToBytes(this.__uuid__);\n  }\n\n  private static bytesToBigInt(bytes: Uint8Array): bigint {\n    let result = 0n;\n    for (const b of bytes) result = (result << 8n) | BigInt(b);\n    return result;\n  }\n\n  private static bigIntToBytes(value: bigint): Uint8Array {\n    const bytes = new Uint8Array(16);\n    for (let i = 15; i >= 0; i--) {\n      bytes[i] = Number(value & 0xffn);\n      value >>= 8n;\n    }\n    return bytes;\n  }\n\n  /**\n   * Returns the version of this UUID.\n   *\n   * This represents the algorithm used to generate the value.\n   *\n   * @returns A `UuidVersion`\n   * @throws {Error} If the version field is not recognized\n   */\n  getVersion(): UuidVersion {\n    const version = (this.toBytes()[6] >> 4) & 0x0f;\n\n    switch (version) {\n      case 4:\n        return 'V4';\n      case 7:\n        return 'V7';\n      default:\n        if (this == Uuid.NIL) {\n          return 'Nil';\n        }\n        if (this == Uuid.MAX) {\n          return 'Max';\n        }\n        throw new Error(`Unsupported UUID version: ${version}`);\n    }\n  }\n\n  /**\n   * Extract the monotonic counter from a UUIDv7.\n   *\n   * Intended for testing and diagnostics.\n   * Behavior is undefined if called on a non-V7 UUID.\n   *\n   * @returns 31-bit counter value\n   */\n  getCounter(): number {\n    const bytes = this.toBytes(); // big-endian, 16 bytes\n\n    const high = bytes[7]; // bits 30..23\n    const mid1 = bytes[9]; // bits 22..15\n    const mid2 = bytes[10]; // bits 14..7\n    const low = bytes[11] >>> 1; // bits 6..0\n\n    // reconstruct 31-bit counter\n    return (high << 23) | (mid1 << 15) | (mid2 << 7) | low | 0; // force 32-bit int\n  }\n\n  compareTo(other: Uuid): number {\n    if (this.__uuid__ < other.__uuid__) return -1;\n    if (this.__uuid__ > other.__uuid__) return 1;\n\n    return 0;\n  }\n\n  static getAlgebraicType(): UuidAlgebraicType {\n    return AlgebraicType.Product({\n      elements: [\n        {\n          name: '__uuid__',\n          algebraicType: AlgebraicType.U128,\n        },\n      ],\n    });\n  }\n}\n","export default class BinaryReader {\n  /**\n   * The DataView used to read values from the binary data.\n   *\n   * Note: The DataView's `byteOffset` is relative to the beginning of the\n   * underlying ArrayBuffer, not the start of the provided Uint8Array input.\n   * This `BinaryReader`'s `#offset` field is used to track the current read position\n   * relative to the start of the provided Uint8Array input.\n   */\n  #view: DataView;\n\n  /**\n   * Represents the offset (in bytes) relative to the start of the DataView\n   * and provided Uint8Array input.\n   *\n   * Note: This is *not* the absolute byte offset within the underlying ArrayBuffer.\n   */\n  #offset: number = 0;\n\n  constructor(input: Uint8Array) {\n    this.#view = new DataView(input.buffer, input.byteOffset, input.byteLength);\n    this.#offset = 0;\n  }\n\n  get offset(): number {\n    return this.#offset;\n  }\n\n  get remaining(): number {\n    return this.#view.byteLength - this.#offset;\n  }\n\n  /** Ensure we have at least `n` bytes left to read */\n  #ensure(n: number): void {\n    if (this.#offset + n > this.#view.byteLength) {\n      throw new RangeError(\n        `Tried to read ${n} byte(s) at relative offset ${this.#offset}, but only ${this.remaining} byte(s) remain`\n      );\n    }\n  }\n\n  readUInt8Array(): Uint8Array {\n    const length = this.readU32();\n    this.#ensure(length);\n    return this.readBytes(length);\n  }\n\n  readBool(): boolean {\n    const value = this.#view.getUint8(this.#offset);\n    this.#offset += 1;\n    return value !== 0;\n  }\n\n  readByte(): number {\n    const value = this.#view.getUint8(this.#offset);\n    this.#offset += 1;\n    return value;\n  }\n\n  readBytes(length: number): Uint8Array {\n    // Create a Uint8Array view over the DataView's buffer at the current offset\n    // The #view.buffer is the whole ArrayBuffer, so we need to account for the\n    // #view's starting position in that buffer (#view.byteOffset) and the current #offset\n    const array = new Uint8Array(\n      this.#view.buffer,\n      this.#view.byteOffset + this.#offset,\n      length\n    );\n    this.#offset += length;\n    return array;\n  }\n\n  readI8(): number {\n    const value = this.#view.getInt8(this.#offset);\n    this.#offset += 1;\n    return value;\n  }\n\n  readU8(): number {\n    return this.readByte();\n  }\n\n  readI16(): number {\n    const value = this.#view.getInt16(this.#offset, true);\n    this.#offset += 2;\n    return value;\n  }\n\n  readU16(): number {\n    const value = this.#view.getUint16(this.#offset, true);\n    this.#offset += 2;\n    return value;\n  }\n\n  readI32(): number {\n    const value = this.#view.getInt32(this.#offset, true);\n    this.#offset += 4;\n    return value;\n  }\n\n  readU32(): number {\n    const value = this.#view.getUint32(this.#offset, true);\n    this.#offset += 4;\n    return value;\n  }\n\n  readI64(): bigint {\n    const value = this.#view.getBigInt64(this.#offset, true);\n    this.#offset += 8;\n    return value;\n  }\n\n  readU64(): bigint {\n    const value = this.#view.getBigUint64(this.#offset, true);\n    this.#offset += 8;\n    return value;\n  }\n\n  readU128(): bigint {\n    const lowerPart = this.#view.getBigUint64(this.#offset, true);\n    const upperPart = this.#view.getBigUint64(this.#offset + 8, true);\n    this.#offset += 16;\n\n    return (upperPart << BigInt(64)) + lowerPart;\n  }\n\n  readI128(): bigint {\n    const lowerPart = this.#view.getBigUint64(this.#offset, true);\n    const upperPart = this.#view.getBigInt64(this.#offset + 8, true);\n    this.#offset += 16;\n\n    return (upperPart << BigInt(64)) + lowerPart;\n  }\n\n  readU256(): bigint {\n    const p0 = this.#view.getBigUint64(this.#offset, true);\n    const p1 = this.#view.getBigUint64(this.#offset + 8, true);\n    const p2 = this.#view.getBigUint64(this.#offset + 16, true);\n    const p3 = this.#view.getBigUint64(this.#offset + 24, true);\n    this.#offset += 32;\n\n    return (\n      (p3 << BigInt(3 * 64)) +\n      (p2 << BigInt(2 * 64)) +\n      (p1 << BigInt(1 * 64)) +\n      p0\n    );\n  }\n\n  readI256(): bigint {\n    const p0 = this.#view.getBigUint64(this.#offset, true);\n    const p1 = this.#view.getBigUint64(this.#offset + 8, true);\n    const p2 = this.#view.getBigUint64(this.#offset + 16, true);\n    const p3 = this.#view.getBigInt64(this.#offset + 24, true);\n    this.#offset += 32;\n\n    return (\n      (p3 << BigInt(3 * 64)) +\n      (p2 << BigInt(2 * 64)) +\n      (p1 << BigInt(1 * 64)) +\n      p0\n    );\n  }\n\n  readF32(): number {\n    const value = this.#view.getFloat32(this.#offset, true);\n    this.#offset += 4;\n    return value;\n  }\n\n  readF64(): number {\n    const value = this.#view.getFloat64(this.#offset, true);\n    this.#offset += 8;\n    return value;\n  }\n\n  readString(): string {\n    const uint8Array = this.readUInt8Array();\n    return new TextDecoder('utf-8').decode(uint8Array);\n  }\n}\n","import { fromByteArray } from 'base64-js';\n\nexport default class BinaryWriter {\n  #buffer: Uint8Array;\n  #view: DataView;\n  #offset: number = 0;\n\n  constructor(size: number) {\n    this.#buffer = new Uint8Array(size);\n    this.#view = new DataView(this.#buffer.buffer);\n  }\n\n  #expandBuffer(additionalCapacity: number): void {\n    const minCapacity = this.#offset + additionalCapacity + 1;\n    if (minCapacity <= this.#buffer.length) return;\n    let newCapacity = this.#buffer.length * 2;\n    if (newCapacity < minCapacity) newCapacity = minCapacity;\n    const newBuffer = new Uint8Array(newCapacity);\n    newBuffer.set(this.#buffer);\n    this.#buffer = newBuffer;\n    this.#view = new DataView(this.#buffer.buffer);\n  }\n\n  toBase64(): string {\n    return fromByteArray(this.#buffer.subarray(0, this.#offset));\n  }\n\n  getBuffer(): Uint8Array {\n    return this.#buffer.slice(0, this.#offset);\n  }\n\n  get offset(): number {\n    return this.#offset;\n  }\n\n  writeUInt8Array(value: Uint8Array): void {\n    const length = value.length;\n\n    this.#expandBuffer(4 + length);\n\n    this.writeU32(length);\n    this.#buffer.set(value, this.#offset);\n    this.#offset += value.length;\n  }\n\n  writeBool(value: boolean): void {\n    this.#expandBuffer(1);\n    this.#view.setUint8(this.#offset, value ? 1 : 0);\n    this.#offset += 1;\n  }\n\n  writeByte(value: number): void {\n    this.#expandBuffer(1);\n    this.#view.setUint8(this.#offset, value);\n    this.#offset += 1;\n  }\n\n  writeI8(value: number): void {\n    this.#expandBuffer(1);\n    this.#view.setInt8(this.#offset, value);\n    this.#offset += 1;\n  }\n\n  writeU8(value: number): void {\n    this.#expandBuffer(1);\n    this.#view.setUint8(this.#offset, value);\n    this.#offset += 1;\n  }\n\n  writeI16(value: number): void {\n    this.#expandBuffer(2);\n    this.#view.setInt16(this.#offset, value, true);\n    this.#offset += 2;\n  }\n\n  writeU16(value: number): void {\n    this.#expandBuffer(2);\n    this.#view.setUint16(this.#offset, value, true);\n    this.#offset += 2;\n  }\n\n  writeI32(value: number): void {\n    this.#expandBuffer(4);\n    this.#view.setInt32(this.#offset, value, true);\n    this.#offset += 4;\n  }\n\n  writeU32(value: number): void {\n    this.#expandBuffer(4);\n    this.#view.setUint32(this.#offset, value, true);\n    this.#offset += 4;\n  }\n\n  writeI64(value: bigint): void {\n    this.#expandBuffer(8);\n    this.#view.setBigInt64(this.#offset, value, true);\n    this.#offset += 8;\n  }\n\n  writeU64(value: bigint): void {\n    this.#expandBuffer(8);\n    this.#view.setBigUint64(this.#offset, value, true);\n    this.#offset += 8;\n  }\n\n  writeU128(value: bigint): void {\n    this.#expandBuffer(16);\n    const lowerPart = value & BigInt('0xFFFFFFFFFFFFFFFF');\n    const upperPart = value >> BigInt(64);\n    this.#view.setBigUint64(this.#offset, lowerPart, true);\n    this.#view.setBigUint64(this.#offset + 8, upperPart, true);\n    this.#offset += 16;\n  }\n\n  writeI128(value: bigint): void {\n    this.#expandBuffer(16);\n    const lowerPart = value & BigInt('0xFFFFFFFFFFFFFFFF');\n    const upperPart = value >> BigInt(64);\n    this.#view.setBigInt64(this.#offset, lowerPart, true);\n    this.#view.setBigInt64(this.#offset + 8, upperPart, true);\n    this.#offset += 16;\n  }\n\n  writeU256(value: bigint): void {\n    this.#expandBuffer(32);\n    const low_64_mask = BigInt('0xFFFFFFFFFFFFFFFF');\n    const p0 = value & low_64_mask;\n    const p1 = (value >> BigInt(64 * 1)) & low_64_mask;\n    const p2 = (value >> BigInt(64 * 2)) & low_64_mask;\n    const p3 = value >> BigInt(64 * 3);\n    this.#view.setBigUint64(this.#offset + 8 * 0, p0, true);\n    this.#view.setBigUint64(this.#offset + 8 * 1, p1, true);\n    this.#view.setBigUint64(this.#offset + 8 * 2, p2, true);\n    this.#view.setBigUint64(this.#offset + 8 * 3, p3, true);\n    this.#offset += 32;\n  }\n\n  writeI256(value: bigint): void {\n    this.#expandBuffer(32);\n    const low_64_mask = BigInt('0xFFFFFFFFFFFFFFFF');\n    const p0 = value & low_64_mask;\n    const p1 = (value >> BigInt(64 * 1)) & low_64_mask;\n    const p2 = (value >> BigInt(64 * 2)) & low_64_mask;\n    const p3 = value >> BigInt(64 * 3);\n    this.#view.setBigUint64(this.#offset + 8 * 0, p0, true);\n    this.#view.setBigUint64(this.#offset + 8 * 1, p1, true);\n    this.#view.setBigUint64(this.#offset + 8 * 2, p2, true);\n    this.#view.setBigInt64(this.#offset + 8 * 3, p3, true);\n    this.#offset += 32;\n  }\n\n  writeF32(value: number): void {\n    this.#expandBuffer(4);\n    this.#view.setFloat32(this.#offset, value, true);\n    this.#offset += 4;\n  }\n\n  writeF64(value: number): void {\n    this.#expandBuffer(8);\n    this.#view.setFloat64(this.#offset, value, true);\n    this.#offset += 8;\n  }\n\n  writeString(value: string): void {\n    const encoder = new TextEncoder();\n    const encodedString = encoder.encode(value);\n    this.writeU32(encodedString.length);\n    this.#expandBuffer(encodedString.length);\n    this.#buffer.set(encodedString, this.#offset);\n    this.#offset += encodedString.length;\n  }\n}\n","import BinaryReader from './binary_reader';\nimport BinaryWriter from './binary_writer';\nimport type { CamelCase, SnakeCase } from './type_util';\n\n/**\n * Converts a string to PascalCase (UpperCamelCase).\n * @param str The string to convert\n * @returns The converted string\n */\nexport function toPascalCase(s: string): string {\n  const str = s.replace(/([-_][a-z])/gi, $1 => {\n    return $1.toUpperCase().replace('-', '').replace('_', '');\n  });\n\n  return str.charAt(0).toUpperCase() + str.slice(1);\n}\n\nexport function deepEqual(obj1: any, obj2: any): boolean {\n  // If both are strictly equal (covers primitives and reference equality), return true\n  if (obj1 === obj2) return true;\n\n  // If either is a primitive type or one is null, return false since we already checked for strict equality\n  if (\n    typeof obj1 !== 'object' ||\n    obj1 === null ||\n    typeof obj2 !== 'object' ||\n    obj2 === null\n  ) {\n    return false;\n  }\n\n  // Get keys of both objects\n  const keys1 = Object.keys(obj1);\n  const keys2 = Object.keys(obj2);\n\n  // If number of keys is different, return false\n  if (keys1.length !== keys2.length) return false;\n\n  // Check all keys and compare values recursively\n  for (const key of keys1) {\n    if (!keys2.includes(key) || !deepEqual(obj1[key], obj2[key])) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nexport function uint8ArrayToHexString(array: Uint8Array): string {\n  return Array.prototype.map\n    .call(array.reverse(), x => ('00' + x.toString(16)).slice(-2))\n    .join('');\n}\n\nexport function uint8ArrayToU128(array: Uint8Array): bigint {\n  if (array.length != 16) {\n    throw new Error(`Uint8Array is not 16 bytes long: ${array}`);\n  }\n  return new BinaryReader(array).readU128();\n}\n\nexport function uint8ArrayToU256(array: Uint8Array): bigint {\n  if (array.length != 32) {\n    throw new Error(`Uint8Array is not 32 bytes long: [${array}]`);\n  }\n  return new BinaryReader(array).readU256();\n}\n\nexport function hexStringToUint8Array(str: string): Uint8Array {\n  if (str.startsWith('0x')) {\n    str = str.slice(2);\n  }\n  const matches = str.match(/.{1,2}/g) || [];\n  const data = Uint8Array.from(\n    matches.map((byte: string) => parseInt(byte, 16))\n  );\n  return data.reverse();\n}\n\nexport function hexStringToU128(str: string): bigint {\n  return uint8ArrayToU128(hexStringToUint8Array(str));\n}\n\nexport function hexStringToU256(str: string): bigint {\n  return uint8ArrayToU256(hexStringToUint8Array(str));\n}\n\nexport function u128ToUint8Array(data: bigint): Uint8Array {\n  const writer = new BinaryWriter(16);\n  writer.writeU128(data);\n  return writer.getBuffer();\n}\n\nexport function u128ToHexString(data: bigint): string {\n  return uint8ArrayToHexString(u128ToUint8Array(data));\n}\n\nexport function u256ToUint8Array(data: bigint): Uint8Array {\n  const writer = new BinaryWriter(32);\n  writer.writeU256(data);\n  return writer.getBuffer();\n}\n\nexport function u256ToHexString(data: bigint): string {\n  return uint8ArrayToHexString(u256ToUint8Array(data));\n}\n\n/**\n * Type safe conversion from a string like \"some_identifier-name\" to \"someIdentifierName\".\n * @param str The string to convert\n * @returns The converted string\n */\nexport function toCamelCase<T extends string>(str: T): CamelCase<T> {\n  return str\n    .replace(/[-_]+/g, '_') // collapse runs to a single separator (no backtracking issue)\n    .replace(/_([a-zA-Z0-9])/g, (_, c) => c.toUpperCase()) as CamelCase<T>;\n}\n\n/** Type safe conversion from a string like \"some_Identifier-name\" to \"some_identifier_name\".\n * @param str The string to convert\n * @returns The converted string\n */\nexport function toSnakeCase<T extends string>(str: T): SnakeCase<T> {\n  return str\n    .replace(/([A-Z])/g, '_$1') // insert underscores before capitals\n    .replace(/[-\\s]+/g, '_') // replace spaces and dashes with underscores\n    .toLowerCase() as SnakeCase<T>;\n}\n\nimport type { AlgebraicType } from './algebraic_type';\nimport type Typespace from './autogen/typespace_type';\nimport type { ColumnBuilder, Infer, TypeBuilder } from './type_builders';\nimport type { ParamsObj } from './reducers';\n\nexport function bsatnBaseSize(\n  typespace: Infer<typeof Typespace>,\n  ty: AlgebraicType\n): number {\n  const assumedArrayLength = 4;\n  while (ty.tag === 'Ref') ty = typespace.types[ty.value];\n  if (ty.tag === 'Product') {\n    let sum = 0;\n    for (const { algebraicType: elem } of ty.value.elements) {\n      sum += bsatnBaseSize(typespace, elem);\n    }\n    return sum;\n  } else if (ty.tag === 'Sum') {\n    let min = Infinity;\n    for (const { algebraicType: vari } of ty.value.variants) {\n      const vSize = bsatnBaseSize(typespace, vari);\n      if (vSize < min) min = vSize;\n    }\n    if (min === Infinity) min = 0;\n    return 4 + min;\n  } else if (ty.tag == 'Array') {\n    return 4 + assumedArrayLength * bsatnBaseSize(typespace, ty.value);\n  }\n  return {\n    String: 4 + assumedArrayLength,\n    Sum: 1,\n    Bool: 1,\n    I8: 1,\n    U8: 1,\n    I16: 2,\n    U16: 2,\n    I32: 4,\n    U32: 4,\n    F32: 4,\n    I64: 8,\n    U64: 8,\n    F64: 8,\n    I128: 16,\n    U128: 16,\n    I256: 32,\n    U256: 32,\n  }[ty.tag];\n}\n\nexport type CoerceTypeBuilder<\n  Col extends TypeBuilder<any, any> | ColumnBuilder<any, any, any>,\n> = Col extends ColumnBuilder<any, any> ? Col['typeBuilder'] : Col;\n\nexport type CoerceParams<Params extends ParamsObj> = {\n  [k in keyof Params & string]: CoerceTypeBuilder<Params[k]>;\n};\n\nexport function coerceParams<Params extends ParamsObj>(\n  params: Params\n): CoerceParams<Params> {\n  return Object.fromEntries(\n    Object.entries(params).map(([n, c]) => [\n      n,\n      'typeBuilder' in c ? c.typeBuilder : c,\n    ])\n  ) as CoerceParams<Params>;\n}\n","import { AlgebraicType } from './algebraic_type';\nimport { hexStringToU128, u128ToHexString, u128ToUint8Array } from './util';\n\nexport type ConnectionIdAlgebraicType = {\n  tag: 'Product';\n  value: {\n    elements: [{ name: '__connection_id__'; algebraicType: { tag: 'U128' } }];\n  };\n};\n\n/**\n * A unique identifier for a client connected to a database.\n */\nexport class ConnectionId {\n  __connection_id__: bigint;\n\n  /**\n   * Creates a new `ConnectionId`.\n   */\n  constructor(data: bigint) {\n    this.__connection_id__ = data;\n  }\n\n  /**\n   * Get the algebraic type representation of the {@link ConnectionId} type.\n   * @returns The algebraic type representation of the type.\n   */\n  static getAlgebraicType(): ConnectionIdAlgebraicType {\n    return AlgebraicType.Product({\n      elements: [\n        { name: '__connection_id__', algebraicType: AlgebraicType.U128 },\n      ],\n    });\n  }\n\n  isZero(): boolean {\n    return this.__connection_id__ === BigInt(0);\n  }\n\n  static nullIfZero(addr: ConnectionId): ConnectionId | null {\n    if (addr.isZero()) {\n      return null;\n    } else {\n      return addr;\n    }\n  }\n\n  static random(): ConnectionId {\n    function randomU8(): number {\n      return Math.floor(Math.random() * 0xff);\n    }\n    let result = BigInt(0);\n    for (let i = 0; i < 16; i++) {\n      result = (result << BigInt(8)) | BigInt(randomU8());\n    }\n    return new ConnectionId(result);\n  }\n\n  /**\n   * Compare two connection IDs for equality.\n   */\n  isEqual(other: ConnectionId): boolean {\n    return this.__connection_id__ == other.__connection_id__;\n  }\n\n  /**\n   * Check if two connection IDs are equal.\n   */\n  equals(other: ConnectionId): boolean {\n    return this.isEqual(other);\n  }\n\n  /**\n   * Print the connection ID as a hexadecimal string.\n   */\n  toHexString(): string {\n    return u128ToHexString(this.__connection_id__);\n  }\n\n  /**\n   * Convert the connection ID to a Uint8Array.\n   */\n  toUint8Array(): Uint8Array {\n    return u128ToUint8Array(this.__connection_id__);\n  }\n\n  /**\n   * Parse a connection ID from a hexadecimal string.\n   */\n  static fromString(str: string): ConnectionId {\n    return new ConnectionId(hexStringToU128(str));\n  }\n\n  static fromStringOrNull(str: string): ConnectionId | null {\n    const addr = ConnectionId.fromString(str);\n    if (addr.isZero()) {\n      return null;\n    } else {\n      return addr;\n    }\n  }\n}\n","import { AlgebraicType } from './algebraic_type';\nimport { hexStringToU256, u256ToHexString, u256ToUint8Array } from './util';\n\nexport type IdentityAlgebraicType = {\n  tag: 'Product';\n  value: {\n    elements: [{ name: '__identity__'; algebraicType: { tag: 'U256' } }];\n  };\n};\n\n/**\n * A unique identifier for a user connected to a database.\n */\nexport class Identity {\n  __identity__: bigint;\n\n  /**\n   * Creates a new `Identity`.\n   *\n   * `data` can be a hexadecimal string or a `bigint`.\n   */\n  constructor(data: string | bigint) {\n    // we get a JSON with __identity__ when getting a token with a JSON API\n    // and an bigint when using BSATN\n    this.__identity__ = typeof data === 'string' ? hexStringToU256(data) : data;\n  }\n\n  /**\n   * Get the algebraic type representation of the {@link Identity} type.\n   * @returns The algebraic type representation of the type.\n   */\n  static getAlgebraicType(): IdentityAlgebraicType {\n    return AlgebraicType.Product({\n      elements: [{ name: '__identity__', algebraicType: AlgebraicType.U256 }],\n    });\n  }\n\n  /**\n   * Check if two identities are equal.\n   */\n  isEqual(other: Identity): boolean {\n    return this.toHexString() === other.toHexString();\n  }\n\n  /**\n   * Check if two identities are equal.\n   */\n  equals(other: Identity): boolean {\n    return this.isEqual(other);\n  }\n\n  /**\n   * Print the identity as a hexadecimal string.\n   */\n  toHexString(): string {\n    return u256ToHexString(this.__identity__);\n  }\n\n  /**\n   * Convert the address to a Uint8Array.\n   */\n  toUint8Array(): Uint8Array {\n    return u256ToUint8Array(this.__identity__);\n  }\n\n  /**\n   * Parse an Identity from a hexadecimal string.\n   */\n  static fromString(str: string): Identity {\n    return new Identity(str);\n  }\n\n  /**\n   * Zero identity (0x0000000000000000000000000000000000000000000000000000000000000000)\n   */\n  static zero(): Identity {\n    return new Identity(0n);\n  }\n\n  toString(): string {\n    return this.toHexString();\n  }\n}\n","import { TimeDuration } from './time_duration';\nimport { Timestamp } from './timestamp';\nimport { Uuid } from './uuid';\nimport { ConnectionId } from './connection_id';\nimport type BinaryReader from './binary_reader';\nimport BinaryWriter from './binary_writer';\nimport { Identity } from './identity';\nimport * as AlgebraicTypeVariants from './algebraic_type_variants';\n\ntype TypespaceType = {\n  types: AlgebraicTypeType[];\n};\n\nexport type ProductTypeType = {\n  elements: ProductTypeElement[];\n};\n\n/**\n * A factor / element of a product type.\n *\n * An element consist of an optional name and a type.\n *\n * NOTE: Each element has an implicit element tag based on its order.\n * Uniquely identifies an element similarly to protobuf tags.\n */\nexport type ProductTypeElement = {\n  name: string | undefined;\n  algebraicType: AlgebraicTypeType;\n};\n\nexport type SumTypeType = {\n  variants: SumTypeVariant[];\n};\n\n/**\n * A variant of a sum type.\n *\n * NOTE: Each element has an implicit element tag based on its order.\n * Uniquely identifies an element similarly to protobuf tags.\n */\nexport type SumTypeVariant = {\n  name: string | undefined;\n  algebraicType: AlgebraicTypeType;\n};\n\nexport type AlgebraicTypeType =\n  | AlgebraicTypeVariants.Ref\n  | AlgebraicTypeVariants.Sum\n  | AlgebraicTypeVariants.Product\n  | AlgebraicTypeVariants.Array\n  | AlgebraicTypeVariants.String\n  | AlgebraicTypeVariants.Bool\n  | AlgebraicTypeVariants.I8\n  | AlgebraicTypeVariants.U8\n  | AlgebraicTypeVariants.I16\n  | AlgebraicTypeVariants.U16\n  | AlgebraicTypeVariants.I32\n  | AlgebraicTypeVariants.U32\n  | AlgebraicTypeVariants.I64\n  | AlgebraicTypeVariants.U64\n  | AlgebraicTypeVariants.I128\n  | AlgebraicTypeVariants.U128\n  | AlgebraicTypeVariants.I256\n  | AlgebraicTypeVariants.U256\n  | AlgebraicTypeVariants.F32\n  | AlgebraicTypeVariants.F64;\n\nexport type AlgebraicType = AlgebraicTypeType;\n\n/**\n * The variant types of the Algebraic Type tagged union.\n */\nexport { AlgebraicTypeVariants };\n\n// A value with helper functions to construct the type.\nexport const AlgebraicType = {\n  Ref: (value: number): AlgebraicTypeVariants.Ref => ({ tag: 'Ref', value }),\n  Sum: <T extends SumTypeType>(value: T): { tag: 'Sum'; value: T } => ({\n    tag: 'Sum',\n    value,\n  }),\n  Product: <T extends ProductTypeType>(\n    value: T\n  ): { tag: 'Product'; value: T } => ({\n    tag: 'Product',\n    value,\n  }),\n  Array: <T extends AlgebraicTypeType>(\n    value: T\n  ): { tag: 'Array'; value: T } => ({\n    tag: 'Array',\n    value,\n  }),\n  String: { tag: 'String' } as const,\n  Bool: { tag: 'Bool' } as const,\n  I8: { tag: 'I8' } as const,\n  U8: { tag: 'U8' } as const,\n  I16: { tag: 'I16' } as const,\n  U16: { tag: 'U16' } as const,\n  I32: { tag: 'I32' } as const,\n  U32: { tag: 'U32' } as const,\n  I64: { tag: 'I64' } as const,\n  U64: { tag: 'U64' } as const,\n  I128: { tag: 'I128' } as const,\n  U128: { tag: 'U128' } as const,\n  I256: { tag: 'I256' } as const,\n  U256: { tag: 'U256' } as const,\n  F32: { tag: 'F32' } as const,\n  F64: { tag: 'F64' } as const,\n  serializeValue(\n    writer: BinaryWriter,\n    ty: AlgebraicTypeType,\n    value: any,\n    typespace?: TypespaceType\n  ) {\n    if (ty.tag === 'Ref') {\n      if (!typespace)\n        throw new Error('cannot serialize refs without a typespace');\n      while (ty.tag === 'Ref') ty = typespace.types[ty.value];\n    }\n    switch (ty.tag) {\n      case 'Product':\n        ProductType.serializeValue(writer, ty.value, value, typespace);\n        break;\n      case 'Sum':\n        SumType.serializeValue(writer, ty.value, value, typespace);\n        break;\n      case 'Array':\n        if (ty.value.tag === 'U8') {\n          writer.writeUInt8Array(value);\n        } else {\n          const elemType = ty.value;\n          writer.writeU32(value.length);\n          for (const elem of value) {\n            AlgebraicType.serializeValue(writer, elemType, elem, typespace);\n          }\n        }\n        break;\n      case 'Bool':\n        writer.writeBool(value);\n        break;\n      case 'I8':\n        writer.writeI8(value);\n        break;\n      case 'U8':\n        writer.writeU8(value);\n        break;\n      case 'I16':\n        writer.writeI16(value);\n        break;\n      case 'U16':\n        writer.writeU16(value);\n        break;\n      case 'I32':\n        writer.writeI32(value);\n        break;\n      case 'U32':\n        writer.writeU32(value);\n        break;\n      case 'I64':\n        writer.writeI64(value);\n        break;\n      case 'U64':\n        writer.writeU64(value);\n        break;\n      case 'I128':\n        writer.writeI128(value);\n        break;\n      case 'U128':\n        writer.writeU128(value);\n        break;\n      case 'I256':\n        writer.writeI256(value);\n        break;\n      case 'U256':\n        writer.writeU256(value);\n        break;\n      case 'F32':\n        writer.writeF32(value);\n        break;\n      case 'F64':\n        writer.writeF64(value);\n        break;\n      case 'String':\n        writer.writeString(value);\n        break;\n    }\n  },\n  deserializeValue: function (\n    reader: BinaryReader,\n    ty: AlgebraicTypeType,\n    typespace?: TypespaceType\n  ): any {\n    if (ty.tag === 'Ref') {\n      if (!typespace)\n        throw new Error('cannot deserialize refs without a typespace');\n      while (ty.tag === 'Ref') ty = typespace.types[ty.value];\n    }\n    switch (ty.tag) {\n      case 'Product':\n        return ProductType.deserializeValue(reader, ty.value, typespace);\n      case 'Sum':\n        return SumType.deserializeValue(reader, ty.value, typespace);\n      case 'Array':\n        if (ty.value.tag === 'U8') {\n          return reader.readUInt8Array();\n        } else {\n          const elemType = ty.value;\n          const length = reader.readU32();\n          const result: any[] = [];\n          for (let i = 0; i < length; i++) {\n            result.push(\n              AlgebraicType.deserializeValue(reader, elemType, typespace)\n            );\n          }\n          return result;\n        }\n      case 'Bool':\n        return reader.readBool();\n      case 'I8':\n        return reader.readI8();\n      case 'U8':\n        return reader.readU8();\n      case 'I16':\n        return reader.readI16();\n      case 'U16':\n        return reader.readU16();\n      case 'I32':\n        return reader.readI32();\n      case 'U32':\n        return reader.readU32();\n      case 'I64':\n        return reader.readI64();\n      case 'U64':\n        return reader.readU64();\n      case 'I128':\n        return reader.readI128();\n      case 'U128':\n        return reader.readU128();\n      case 'I256':\n        return reader.readI256();\n      case 'U256':\n        return reader.readU256();\n      case 'F32':\n        return reader.readF32();\n      case 'F64':\n        return reader.readF64();\n      case 'String':\n        return reader.readString();\n    }\n  },\n  /**\n   * Convert a value of the algebraic type into something that can be used as a key in a map.\n   * There are no guarantees about being able to order it.\n   * This is only guaranteed to be comparable to other values of the same type.\n   * @param value A value of the algebraic type\n   * @returns Something that can be used as a key in a map.\n   */\n  intoMapKey: function (\n    ty: AlgebraicTypeType,\n    value: any\n  ): ComparablePrimitive {\n    switch (ty.tag) {\n      case 'U8':\n      case 'U16':\n      case 'U32':\n      case 'U64':\n      case 'U128':\n      case 'U256':\n      case 'I8':\n      case 'I16':\n      case 'I32':\n      case 'I64':\n      case 'I128':\n      case 'I256':\n      case 'F32':\n      case 'F64':\n      case 'String':\n      case 'Bool':\n        return value;\n      case 'Product':\n        return ProductType.intoMapKey(ty.value, value);\n      default: {\n        // The fallback is to serialize and base64 encode the bytes.\n        const writer = new BinaryWriter(10);\n        AlgebraicType.serializeValue(writer, ty, value);\n        return writer.toBase64();\n      }\n    }\n  },\n};\n\n/**\n * A structural product type  of the factors given by `elements`.\n *\n * This is also known as `struct` and `tuple` in many languages,\n * but note that unlike most languages, products in SATs are *[structural]* and not nominal.\n * When checking whether two nominal types are the same,\n * their names and/or declaration sites (e.g., module / namespace) are considered.\n * Meanwhile, a structural type system would only check the structure of the type itself,\n * e.g., the names of its fields and their types in the case of a record.\n * The name \"product\" comes from category theory.\n *\n * See also: https://ncatlab.org/nlab/show/product+type.\n *\n * These structures are known as product types because the number of possible values in product\n * ```ignore\n * { N_0: T_0, N_1: T_1, ..., N_n: T_n }\n * ```\n * is:\n * ```ignore\n *  (i  0..n). values(T_i)\n * ```\n * so for example, `values({ A: U64, B: Bool }) = values(U64) * values(Bool)`.\n *\n * [structural]: https://en.wikipedia.org/wiki/Structural_type_system\n */\nexport type ProductType = ProductTypeType;\n\nexport const ProductType = {\n  serializeValue(\n    writer: BinaryWriter,\n    ty: ProductTypeType,\n    value: any,\n    typespace?: TypespaceType\n  ): void {\n    for (const element of ty.elements) {\n      AlgebraicType.serializeValue(\n        writer,\n        element.algebraicType,\n        value[element.name!],\n        typespace\n      );\n    }\n  },\n  deserializeValue(\n    reader: BinaryReader,\n    ty: ProductTypeType,\n    typespace?: TypespaceType\n  ): any {\n    const result: { [key: string]: any } = {};\n    if (ty.elements.length === 1) {\n      if (ty.elements[0].name === '__time_duration_micros__') {\n        return new TimeDuration(reader.readI64());\n      }\n\n      if (ty.elements[0].name === '__timestamp_micros_since_unix_epoch__') {\n        return new Timestamp(reader.readI64());\n      }\n\n      if (ty.elements[0].name === '__identity__') {\n        return new Identity(reader.readU256());\n      }\n\n      if (ty.elements[0].name === '__connection_id__') {\n        return new ConnectionId(reader.readU128());\n      }\n\n      if (ty.elements[0].name === '__uuid__') {\n        return new Uuid(reader.readU128());\n      }\n    }\n\n    for (const element of ty.elements) {\n      result[element.name!] = AlgebraicType.deserializeValue(\n        reader,\n        element.algebraicType,\n        typespace\n      );\n    }\n    return result;\n  },\n  intoMapKey(ty: ProductTypeType, value: any): ComparablePrimitive {\n    if (ty.elements.length === 1) {\n      if (ty.elements[0].name === '__time_duration_micros__') {\n        return (value as TimeDuration).__time_duration_micros__;\n      }\n\n      if (ty.elements[0].name === '__timestamp_micros_since_unix_epoch__') {\n        return (value as Timestamp).__timestamp_micros_since_unix_epoch__;\n      }\n\n      if (ty.elements[0].name === '__identity__') {\n        return (value as Identity).__identity__;\n      }\n\n      if (ty.elements[0].name === '__connection_id__') {\n        return (value as ConnectionId).__connection_id__;\n      }\n\n      if (ty.elements[0].name === '__uuid__') {\n        return (value as Uuid).__uuid__;\n      }\n    }\n    // The fallback is to serialize and base64 encode the bytes.\n    const writer = new BinaryWriter(10);\n    AlgebraicType.serializeValue(writer, AlgebraicType.Product(ty), value);\n    return writer.toBase64();\n  },\n};\n\nexport type SumType = SumTypeType;\n\n/**\n * Unlike most languages, sums in SATS are *[structural]* and not nominal.\n * When checking whether two nominal types are the same,\n * their names and/or declaration sites (e.g., module / namespace) are considered.\n * Meanwhile, a structural type system would only check the structure of the type itself,\n * e.g., the names of its variants and their inner data types in the case of a sum.\n *\n * This is also known as a discriminated union (implementation) or disjoint union.\n * Another name is [coproduct (category theory)](https://ncatlab.org/nlab/show/coproduct).\n *\n * These structures are known as sum types because the number of possible values a sum\n * ```ignore\n * { N_0(T_0), N_1(T_1), ..., N_n(T_n) }\n * ```\n * is:\n * ```ignore\n *  (i  0..n). values(T_i)\n * ```\n * so for example, `values({ A(U64), B(Bool) }) = values(U64) + values(Bool)`.\n *\n * See also: https://ncatlab.org/nlab/show/sum+type.\n *\n * [structural]: https://en.wikipedia.org/wiki/Structural_type_system\n */\nexport const SumType = {\n  serializeValue: function (\n    writer: BinaryWriter,\n    ty: SumTypeType,\n    value: any,\n    typespace?: TypespaceType\n  ): void {\n    if (\n      ty.variants.length == 2 &&\n      ty.variants[0].name === 'some' &&\n      ty.variants[1].name === 'none'\n    ) {\n      if (value !== null && value !== undefined) {\n        writer.writeByte(0);\n        AlgebraicType.serializeValue(\n          writer,\n          ty.variants[0].algebraicType,\n          value,\n          typespace\n        );\n      } else {\n        writer.writeByte(1);\n      }\n    } else if (\n      ty.variants.length == 2 &&\n      ty.variants[0].name === 'ok' &&\n      ty.variants[1].name === 'err'\n    ) {\n      let variantName: 'ok' | 'err';\n      let innerValue: any;\n      let index: number;\n      if ('ok' in value) {\n        variantName = 'ok';\n        innerValue = value.ok;\n        index = 0;\n      } else {\n        variantName = 'err';\n        innerValue = value.err;\n        index = 1;\n      }\n\n      if (index < 0) {\n        throw `Result serialization error: variant '${variantName}' not found in ${JSON.stringify(ty)}`;\n      }\n\n      writer.writeU8(index);\n\n      AlgebraicType.serializeValue(\n        writer,\n        ty.variants[index].algebraicType,\n        innerValue,\n        typespace\n      );\n    } else {\n      const variant = value['tag'];\n      const index = ty.variants.findIndex(v => v.name === variant);\n      if (index < 0) {\n        throw `Can't serialize a sum type, couldn't find ${value.tag} tag ${JSON.stringify(value)} in variants ${JSON.stringify(ty)}`;\n      }\n      writer.writeU8(index);\n      AlgebraicType.serializeValue(\n        writer,\n        ty.variants[index].algebraicType,\n        value['value'],\n        typespace\n      );\n    }\n  },\n  deserializeValue: function (\n    reader: BinaryReader,\n    ty: SumTypeType,\n    typespace?: TypespaceType\n  ): any {\n    const tag = reader.readU8();\n    // In TypeScript we handle Option values as a special case\n    // we don't represent the some and none variants, but instead\n    // we represent the value directly.\n    if (\n      ty.variants.length == 2 &&\n      ty.variants[0].name === 'some' &&\n      ty.variants[1].name === 'none'\n    ) {\n      if (tag === 0) {\n        return AlgebraicType.deserializeValue(\n          reader,\n          ty.variants[0].algebraicType,\n          typespace\n        );\n      } else if (tag === 1) {\n        return undefined;\n      } else {\n        throw `Can't deserialize an option type, couldn't find ${tag} tag`;\n      }\n    } else if (\n      ty.variants.length == 2 &&\n      ty.variants[0].name === 'ok' &&\n      ty.variants[1].name === 'err'\n    ) {\n      if (tag === 0) {\n        const value = AlgebraicType.deserializeValue(\n          reader,\n          ty.variants[0].algebraicType,\n          typespace\n        );\n        return { ok: value };\n      } else if (tag === 1) {\n        const value = AlgebraicType.deserializeValue(\n          reader,\n          ty.variants[1].algebraicType,\n          typespace\n        );\n        return { err: value };\n      } else {\n        throw `Can't deserialize a result type, couldn't find ${tag} tag`;\n      }\n    } else {\n      const variant = ty.variants[tag];\n      const value = AlgebraicType.deserializeValue(\n        reader,\n        variant.algebraicType,\n        typespace\n      );\n      return { tag: variant.name, value };\n    }\n  },\n};\n\nexport type ComparablePrimitive = number | string | boolean | bigint;\n","import { AlgebraicType } from './algebraic_type';\n\nexport type OptionAlgebraicType<T extends AlgebraicType = AlgebraicType> = {\n  tag: 'Sum';\n  value: {\n    variants: [\n      { name: 'some'; algebraicType: T },\n      {\n        name: 'none';\n        algebraicType: { tag: 'Product'; value: { elements: [] } };\n      },\n    ];\n  };\n};\n\nexport const Option: {\n  getAlgebraicType<T extends AlgebraicType = AlgebraicType>(\n    innerType: T\n  ): OptionAlgebraicType<T>;\n} = {\n  getAlgebraicType<T extends AlgebraicType = AlgebraicType>(\n    innerType: T\n  ): OptionAlgebraicType<T> {\n    return AlgebraicType.Sum({\n      variants: [\n        { name: 'some', algebraicType: innerType },\n        {\n          name: 'none',\n          algebraicType: AlgebraicType.Product({ elements: [] }),\n        },\n      ],\n    });\n  },\n};\n","import { AlgebraicType } from './algebraic_type';\n\nexport type ResultAlgebraicType<\n  T extends AlgebraicType = AlgebraicType,\n  E extends AlgebraicType = AlgebraicType,\n> = {\n  tag: 'Sum';\n  value: {\n    variants: [\n      { name: 'ok'; algebraicType: T },\n      { name: 'err'; algebraicType: E },\n    ];\n  };\n};\n\nexport const Result: {\n  getAlgebraicType<\n    T extends AlgebraicType = AlgebraicType,\n    E extends AlgebraicType = AlgebraicType,\n  >(\n    okType: T,\n    errType: E\n  ): ResultAlgebraicType<T, E>;\n} = {\n  getAlgebraicType<\n    T extends AlgebraicType = AlgebraicType,\n    E extends AlgebraicType = AlgebraicType,\n  >(okType: T, errType: E): ResultAlgebraicType<T, E> {\n    return AlgebraicType.Sum({\n      variants: [\n        { name: 'ok', algebraicType: okType },\n        { name: 'err', algebraicType: errType },\n      ],\n    });\n  },\n};\n","import { AlgebraicType } from './algebraic_type';\nimport { TimeDuration, type TimeDurationAlgebraicType } from './time_duration';\nimport { Timestamp, type TimestampAlgebraicType } from './timestamp';\n\nexport type ScheduleAtAlgebraicType = {\n  tag: 'Sum';\n  value: {\n    variants: [\n      { name: 'Interval'; algebraicType: TimeDurationAlgebraicType },\n      { name: 'Time'; algebraicType: TimestampAlgebraicType },\n    ];\n  };\n};\n\ntype ScheduleAtType = Interval | Time;\n\nexport const ScheduleAt: {\n  interval: (micros: bigint) => ScheduleAtType;\n  time: (microsSinceUnixEpoch: bigint) => ScheduleAtType;\n  /**\n   * Get the algebraic type representation of the {@link ScheduleAt} type.\n   * @returns The algebraic type representation of the type.\n   */\n  getAlgebraicType(): ScheduleAtAlgebraicType;\n  isScheduleAt(\n    algebraicType: AlgebraicType\n  ): algebraicType is ScheduleAtAlgebraicType;\n} = {\n  interval(value: bigint): ScheduleAtType {\n    return Interval(value);\n  },\n  time(value: bigint): ScheduleAtType {\n    return Time(value);\n  },\n  getAlgebraicType(): ScheduleAtAlgebraicType {\n    return AlgebraicType.Sum({\n      variants: [\n        {\n          name: 'Interval',\n          algebraicType: TimeDuration.getAlgebraicType(),\n        },\n        { name: 'Time', algebraicType: Timestamp.getAlgebraicType() },\n      ],\n    });\n  },\n  isScheduleAt(\n    algebraicType: AlgebraicType\n  ): algebraicType is ScheduleAtAlgebraicType {\n    if (algebraicType.tag !== 'Sum') {\n      return false;\n    }\n    const variants = algebraicType.value.variants;\n    if (variants.length !== 2) {\n      return false;\n    }\n    const intervalVariant = variants.find(v => v.name === 'Interval');\n    const timeVariant = variants.find(v => v.name === 'Time');\n    if (!intervalVariant || !timeVariant) {\n      return false;\n    }\n    return (\n      TimeDuration.isTimeDuration(intervalVariant.algebraicType) &&\n      Timestamp.isTimestamp(timeVariant.algebraicType)\n    );\n  },\n};\n\nexport type Interval = {\n  tag: 'Interval';\n  value: TimeDuration;\n};\nexport const Interval = (micros: bigint): Interval => ({\n  tag: 'Interval',\n  value: new TimeDuration(micros),\n});\nexport type Time = {\n  tag: 'Time';\n  value: Timestamp;\n};\nexport const Time = (microsSinceUnixEpoch: bigint): Time => ({\n  tag: 'Time',\n  value: new Timestamp(microsSinceUnixEpoch),\n});\n\nexport default ScheduleAt;\nexport type ScheduleAt = ScheduleAtType;\n","import type { ConnectionId } from './connection_id';\nimport type { Identity } from './identity';\nimport type { ScheduleAt } from './schedule_at';\nimport type { TimeDuration } from './time_duration';\nimport type { Timestamp } from './timestamp';\n\ntype DoNotPrettify =\n  | Identity\n  | ConnectionId\n  | Timestamp\n  | TimeDuration\n  | ScheduleAt;\n\n/**\n * Utility to make TS show cleaner types by flattening intersections.\n */\nexport type Prettify<T> = T extends DoNotPrettify\n  ? T\n  : { [K in keyof T]: T[K] } & {};\n\n/**\n * Helper function to sets a field in an object\n */\nexport type SetField<T, F extends string, V> = Prettify<\n  Omit<T, F> & { [K in F]: V }\n>;\n\n/**\n * Sets a field in an object\n * @param x The original object\n * @param t The object containing the field to set\n * @returns A new object with the field set\n */\nexport function set<T, F extends string, V>(\n  x: T,\n  t: { [k in F]: V }\n): SetField<T, F, V> {\n  return { ...x, ...t } as SetField<T, F, V>;\n}\n\n/**\n * Helper to extract the value types from an object type\n */\nexport type Values<T> = T[keyof T];\n\n/**\n * A helper type to collapse a tuple into a single type if it has only one element.\n */\nexport type CollapseTuple<A extends any[]> = A extends [infer T] ? T : A;\n\ntype CamelCaseImpl<S extends string> = S extends `${infer Head}_${infer Tail}`\n  ? `${Head}${Capitalize<CamelCaseImpl<Tail>>}`\n  : S extends `${infer Head}-${infer Tail}`\n    ? `${Head}${Capitalize<CamelCaseImpl<Tail>>}`\n    : S;\n\n/**\n * Convert \"Some_identifier-name\" -> \"someIdentifierName\"\n * - No spaces; allowed separators: \"_\" and \"-\"\n * - Normalizes the *first* character to lowercase (e.g. \"User_Name\" -> \"userName\")\n */\nexport type CamelCase<S extends string> = Uncapitalize<CamelCaseImpl<S>>;\n\n/** Type safe conversion from \"some_identifier-name\" to \"some_identifier_name\"\n * - No spaces; allowed separators: \"_\" and \"-\"\n * - Normalizes the *first* character to lowercase (e.g. \"User_Name\" -> \"user_name\")\n */\nexport type SnakeCase<S extends string> = S extends `${infer Head}${infer Tail}`\n  ? Tail extends Uncapitalize<Tail>\n    ? `${Lowercase<Head>}${SnakeCase<Tail>}`\n    : `${Lowercase<Head>}_${SnakeCase<Tail>}`\n  : Lowercase<S>;\n\ntype PascalCaseImpl<S extends string> = S extends `${infer Head}_${infer Tail}`\n  ? `${Capitalize<Head>}${PascalCaseImpl<Tail>}`\n  : S extends `${infer Head}-${infer Tail}`\n    ? `${Capitalize<Head>}${PascalCaseImpl<Tail>}`\n    : Capitalize<S>;\n\n/**\n * Convert \"some_identifier-name\" -> \"SomeIdentifierName\"\n * - No spaces; allowed separators: \"_\" and \"-\"\n * - Normalizes the *first* character to uppercase (e.g. \"user_name\" -> \"UserName\")\n */\nexport type PascalCase<S extends string> = PascalCaseImpl<S>;\n","import { AlgebraicType, type AlgebraicTypeVariants } from './algebraic_type';\nimport type BinaryReader from './binary_reader';\nimport type BinaryWriter from './binary_writer';\nimport { ConnectionId, type ConnectionIdAlgebraicType } from './connection_id';\nimport { Identity, type IdentityAlgebraicType } from './identity';\nimport { Option, type OptionAlgebraicType } from './option';\nimport { Result, type ResultAlgebraicType } from './result';\nimport ScheduleAt, { type ScheduleAtAlgebraicType } from './schedule_at';\nimport type { CoerceRow } from './table';\nimport { TimeDuration, type TimeDurationAlgebraicType } from './time_duration';\nimport { Timestamp, type TimestampAlgebraicType } from './timestamp';\nimport { set, type Prettify, type SetField } from './type_util';\nimport { Uuid, type UuidAlgebraicType } from './uuid';\n\n// Used in codegen files\nexport { type AlgebraicTypeType } from './algebraic_type';\n\n/**\n * Helper type to extract the TypeScript type from a TypeBuilder\n */\nexport type InferTypeOfTypeBuilder<T extends TypeBuilder<any, any>> =\n  T extends TypeBuilder<infer U, any> ? Prettify<U> : never;\n\n/**\n * Helper type to extract the Spacetime type from a TypeBuilder\n */\nexport type InferSpacetimeTypeOfTypeBuilder<T extends TypeBuilder<any, any>> =\n  T extends TypeBuilder<any, infer U> ? U : never;\n\n/**\n * Helper type to extract the TypeScript type from a TypeBuilder\n */\nexport type Infer<T> = T extends RowObj\n  ? InferTypeOfRow<T>\n  : T extends TypeBuilder<any, any>\n    ? InferTypeOfTypeBuilder<T>\n    : never;\n\n/**\n * Helper type to extract the type of a row from an object.\n */\nexport type InferTypeOfRow<T extends RowObj> = {\n  [K in keyof T & string]: InferTypeOfTypeBuilder<CollapseColumn<T[K]>>;\n};\n\n/**\n * Helper type to extract the type of a row from an object.\n */\nexport type InferSpacetimeTypeOfRow<T extends RowObj> = {\n  [K in keyof T & string]: InferSpacetimeTypeOfTypeBuilder<\n    CollapseColumn<T[K]>\n  >;\n};\n\n/**\n * Helper type to extract the Spacetime type from a row object.\n */\ntype CollapseColumn<\n  T extends TypeBuilder<any, any> | ColumnBuilder<any, any, any>,\n> = T extends ColumnBuilder<any, any, any> ? T['typeBuilder'] : T;\n\n/**\n * A type representing an object which is used to define the type of\n * a row in a table.\n */\nexport type RowObj = Record<\n  string,\n  TypeBuilder<any, any> | ColumnBuilder<any, any, ColumnMetadata<any>>\n>;\n\n/**\n * Type which converts the elements of RowObj to a ProductType elements array\n */\ntype ElementsArrayFromRowObj<Obj extends RowObj> = Array<\n  {\n    [N in keyof Obj & string]: {\n      name: N;\n      algebraicType: InferSpacetimeTypeOfTypeBuilder<CollapseColumn<Obj[N]>>;\n    };\n  }[keyof Obj & string]\n>;\n\n/**\n * A type which converts the elements of RowObj to a TypeScript object type.\n * It works by `Infer`ing the types of the column builders which are the values of\n * the keys in the object passed in.\n *\n * e.g. { a: I32TypeBuilder, b: StringBuilder } -> { a: number, b: string }\n */\ntype RowType<Row extends RowObj> = {\n  [K in keyof Row]: InferTypeOfTypeBuilder<CollapseColumn<Row[K]>>;\n};\n\n/**\n * Type which represents a valid argument to the ProductColumnBuilder\n */\nexport type ElementsObj = Record<string, TypeBuilder<any, any>>;\n\n/**\n * Type which converts the elements of ElementsObj to a ProductType elements array\n */\ntype ElementsArrayFromElementsObj<Obj extends ElementsObj> = Array<\n  {\n    [N in keyof Obj & string]: {\n      name: N;\n      algebraicType: InferSpacetimeTypeOfTypeBuilder<Obj[N]>;\n    };\n  }[keyof Obj & string]\n>;\n\n/**\n * A type which converts the elements of ElementsObj to a TypeScript object type.\n * It works by `Infer`ing the types of the column builders which are the values of\n * the keys in the object passed in.\n *\n * e.g. { a: I32TypeBuilder, b: StringBuilder } -> { a: number, b: string }\n */\ntype ObjectType<Elements extends ElementsObj> = {\n  [K in keyof Elements]: InferTypeOfTypeBuilder<Elements[K]>;\n};\n\nexport type VariantsObj = Record<string, TypeBuilder<any, any>>;\ntype SimpleVariantsObj = Record<string, UnitBuilder>;\n\ntype IsUnit<B> = B extends UnitBuilder ? true : false;\n\n/**\n * A type which converts the elements of ElementsObj to a TypeScript object type.\n * It works by `Infer`ing the types of the column builders which are the values of\n * the keys in the object passed in.\n *\n * e.g. { A: I32TypeBuilder, B: StringBuilder } -> { tag: \"A\", value: number } | { tag: \"B\", value: string }\n */\ntype EnumType<Variants extends VariantsObj> = {\n  [K in keyof Variants & string]: IsUnit<Variants[K]> extends true\n    ? { tag: K }\n    : { tag: K; value: InferTypeOfTypeBuilder<Variants[K]> };\n}[keyof Variants & string];\n\n/**\n * Type which converts the elements of VariantsObj to a SumType variants array\n */\ntype VariantsArrayFromVariantsObj<Obj extends VariantsObj> = {\n  name: keyof Obj & string;\n  algebraicType: InferSpacetimeTypeOfTypeBuilder<Obj[keyof Obj & string]>;\n}[];\n\n/**\n * A generic type builder that captures both the TypeScript type\n * and the corresponding `AlgebraicType`.\n */\nexport class TypeBuilder<Type, SpacetimeType extends AlgebraicType>\n  implements Optional<Type, SpacetimeType>\n{\n  /**\n   * The TypeScript phantom type. This is not stored at runtime,\n   * but is visible to the compiler\n   */\n  readonly type!: Type;\n\n  /**\n   * The SpacetimeDB algebraic type (runtime value). In addition to storing\n   * the runtime representation of the `AlgebraicType`, it also captures\n   * the TypeScript type information of the `AlgebraicType`. That is to say\n   * the value is not merely an `AlgebraicType`, but is constructed to be\n   * the corresponding concrete `AlgebraicType` for the TypeScript type `Type`.\n   *\n   * e.g. `string` corresponds to `AlgebraicType.String`\n   */\n  readonly algebraicType: SpacetimeType;\n\n  constructor(algebraicType: SpacetimeType) {\n    this.algebraicType = algebraicType;\n  }\n\n  optional(): OptionBuilder<typeof this> {\n    return new OptionBuilder(this);\n  }\n\n  serialize(writer: BinaryWriter, value: Type): void {\n    AlgebraicType.serializeValue(writer, this.algebraicType, value);\n  }\n\n  deserialize(reader: BinaryReader): Type {\n    return AlgebraicType.deserializeValue(reader, this.algebraicType);\n  }\n}\n\n/**\n * Interface for types that can be converted into a column builder with primary key metadata.\n *\n * Implementing this interface allows a type to be marked as the primary key of a table column\n * in a type-safe manner. The `primaryKey()` method returns a new `ColumnBuilder` instance\n * with the metadata updated to indicate that the column is a primary key.\n *\n * @typeParam Type - The TypeScript type of the column's value.\n * @typeParam SpacetimeType - The corresponding SpacetimeDB algebraic type.\n * @typeParam M - The metadata type for the column, defaulting to `DefaultMetadata`.\n *\n * @remarks\n * - This interface is typically implemented by type builders for primitive and complex types.\n * - The returned `ColumnBuilder` will have its metadata extended with `{ isPrimaryKey: true }`.\n * - Marking a column as a primary key is mutually exclusive with certain other metadata flags,\n *   such as `isAutoIncrement` or `isUnique`, depending on the database schema rules.\n */\ninterface PrimaryKeyable<\n  Type,\n  SpacetimeType extends AlgebraicType,\n  M extends ColumnMetadata<Type> = DefaultMetadata,\n> {\n  /**\n   * Specify this column as primary key\n   */\n  primaryKey(): ColumnBuilder<\n    Type,\n    SpacetimeType,\n    SetField<M, 'isPrimaryKey', true>\n  >;\n}\n\n/**\n * Interface for types that can be converted into a column builder with unique metadata.\n *\n * Implementing this interface allows a type to be marked as unique in a table column\n * in a type-safe manner. The `unique()` method returns a new `ColumnBuilder` instance\n * with the metadata updated to indicate that the column is unique.\n *\n * @typeParam Type - The TypeScript type of the column's value.\n * @typeParam SpacetimeType - The corresponding SpacetimeDB algebraic type.\n * @typeParam M - The metadata type for the column, defaulting to `DefaultMetadata`.\n *\n * @remarks\n * - This interface is typically implemented by type builders for primitive and complex types.\n * - The returned `ColumnBuilder` will have its metadata extended with `{ isUnique: true }`.\n * - Marking a column as unique is mutually exclusive with certain other metadata flags,\n *   such as `isAutoIncrement` or `isPrimaryKey`, depending on the database schema rules.\n */\ninterface Uniqueable<\n  Type,\n  SpacetimeType extends AlgebraicType,\n  M extends ColumnMetadata<Type> = DefaultMetadata,\n> {\n  /**\n   * Specify this column as unique\n   */\n  unique(): ColumnBuilder<Type, SpacetimeType, SetField<M, 'isUnique', true>>;\n}\n\n/**\n * Interface for types that can be converted into a column builder with index metadata.\n *\n * Implementing this interface allows a type to be indexed in a table column\n * in a type-safe manner. The `index()` method returns a new `ColumnBuilder` instance\n * with the metadata updated to indicate the index type.\n *\n * @typeParam Type - The TypeScript type of the column's value.\n * @typeParam SpacetimeType - The corresponding SpacetimeDB algebraic type.\n * @typeParam M - The metadata type for the column, defaulting to `DefaultMetadata`.\n *\n * @remarks\n * - This interface is typically implemented by type builders for primitive and complex types.\n * - The returned `ColumnBuilder` will have its metadata extended with `{ indexType: N }`.\n * - Indexing a column may have implications for performance and query optimization.\n */\ninterface Indexable<\n  Type,\n  SpacetimeType extends AlgebraicType,\n  M extends ColumnMetadata<Type> = DefaultMetadata,\n> {\n  /**\n   * Specify the index type for this column\n   * @param algorithm The index algorithm to use\n   */\n  index(): ColumnBuilder<\n    Type,\n    SpacetimeType,\n    SetField<M, 'indexType', 'btree'>\n  >;\n  index<N extends NonNullable<IndexTypes>>(\n    algorithm: N\n  ): ColumnBuilder<Type, SpacetimeType, SetField<M, 'indexType', N>>;\n}\n\n/**\n * Interface for types that can be converted into a column builder with auto-increment metadata.\n *\n * Implementing this interface allows a type to be marked as auto-incrementing in a table column\n * in a type-safe manner. The `autoInc()` method returns a new `ColumnBuilder` instance\n * with the metadata updated to indicate that the column is auto-incrementing.\n *\n * @typeParam Type - The TypeScript type of the column's value.\n * @typeParam SpacetimeType - The corresponding SpacetimeDB algebraic type.\n * @typeParam M - The metadata type for the column, defaulting to `DefaultMetadata`.\n *\n * @remarks\n * - This interface is typically implemented by type builders for primitive and complex types.\n * - The returned `ColumnBuilder` will have its metadata extended with `{ isAutoIncrement: true }`.\n * - Marking a column as auto-incrementing is mutually exclusive with certain other metadata flags,\n *   such as `isUnique` or `isPrimaryKey`, depending on the database schema rules.\n */\ninterface AutoIncrementable<\n  Type,\n  SpacetimeType extends AlgebraicType,\n  M extends ColumnMetadata<Type> = DefaultMetadata,\n> {\n  /**\n   * Specify this column as auto-incrementing\n   */\n  autoInc(): ColumnBuilder<\n    Type,\n    SpacetimeType,\n    SetField<M, 'isAutoIncrement', true>\n  >;\n}\n\n/**\n * Interface for types that can be converted into an optional type.\n * All {@link TypeBuilder}s implement this interface, however since the `optional()` method\n * returns an {@link OptionBuilder}, {@link OptionBuilder} controls what metadata is allowed\n * to be configured for the column. This allows us to restrict whether things like indexes\n * or unique constraints can be applied to optional columns.\n *\n * For this reason {@link ColumnBuilder} does not implement this interface.\n */\ninterface Optional<Type, SpacetimeType extends AlgebraicType> {\n  /**\n   * Specify this column as optional\n   */\n  optional(this: TypeBuilder<Type, SpacetimeType>): OptionBuilder<typeof this>;\n}\n\n/**\n * Interface for types that can be converted into a column builder with default value metadata.\n * Implementing this interface allows a type to have a default value specified in a table column\n * in a type-safe manner. The `default()` method returns a new `ColumnBuilder` instance\n * with the metadata updated to include the specified default value.\n *\n * @typeParam Type - The TypeScript type of the column's value.\n * @typeParam SpacetimeType - The corresponding SpacetimeDB algebraic type.\n * @typeParam M - The metadata type for the column, defaulting to `DefaultMetadata`.\n *\n * @remarks\n * - This interface is typically implemented by type builders for primitive and complex types.\n * - The returned `ColumnBuilder` will have its metadata extended with `{ default: value }`.\n * - The default value must be of the same type as the column's TypeScript type.\n * - This method can be called multiple times; the last call takes precedence.\n */\ninterface Defaultable<\n  Type,\n  SpacetimeType extends AlgebraicType,\n  M extends ColumnMetadata<Type> = DefaultMetadata,\n> {\n  /**\n   * Specify a default value for this column\n   * @param value The default value for the column\n   * @example\n   * ```typescript\n   * const col = t.i32().default(42);\n   * ```\n   * @remarks\n   * - This method can be called multiple times; the last call takes precedence.\n   * - The default value must be of the same type as the column's TypeScript type.\n   */\n  default(\n    value: Type\n  ): ColumnBuilder<Type, SpacetimeType, SetField<M, 'defaultValue', Type>>;\n}\n\ninterface Nameable<\n  Type,\n  SpacetimeType extends AlgebraicType,\n  M extends ColumnMetadata<Type> = DefaultMetadata,\n> {\n  /**\n   * Specify the in-database name for this column.\n   */\n  name<const Name extends string>(\n    name: Name\n  ): Nameable<Type, SpacetimeType, SetField<M, 'name', Name>>;\n}\n\nexport class U8Builder\n  extends TypeBuilder<number, AlgebraicTypeVariants.U8>\n  implements\n    Indexable<number, AlgebraicTypeVariants.U8>,\n    Uniqueable<number, AlgebraicTypeVariants.U8>,\n    PrimaryKeyable<number, AlgebraicTypeVariants.U8>,\n    AutoIncrementable<number, AlgebraicTypeVariants.U8>,\n    Defaultable<number, AlgebraicTypeVariants.U8>,\n    Nameable<number, AlgebraicTypeVariants.U8>\n{\n  constructor() {\n    super(AlgebraicType.U8);\n  }\n  index(): U8ColumnBuilder<SetField<DefaultMetadata, 'indexType', 'btree'>>;\n  index<N extends NonNullable<IndexTypes>>(\n    algorithm: N\n  ): U8ColumnBuilder<SetField<DefaultMetadata, 'indexType', N>>;\n  index(\n    algorithm: IndexTypes = 'btree'\n  ): U8ColumnBuilder<SetField<DefaultMetadata, 'indexType', IndexTypes>> {\n    return new U8ColumnBuilder(\n      this,\n      set(defaultMetadata, { indexType: algorithm })\n    );\n  }\n  unique(): U8ColumnBuilder<SetField<DefaultMetadata, 'isUnique', true>> {\n    return new U8ColumnBuilder(this, set(defaultMetadata, { isUnique: true }));\n  }\n  primaryKey(): U8ColumnBuilder<\n    SetField<DefaultMetadata, 'isPrimaryKey', true>\n  > {\n    return new U8ColumnBuilder(\n      this,\n      set(defaultMetadata, { isPrimaryKey: true })\n    );\n  }\n  autoInc(): U8ColumnBuilder<\n    SetField<DefaultMetadata, 'isAutoIncrement', true>\n  > {\n    return new U8ColumnBuilder(\n      this,\n      set(defaultMetadata, { isAutoIncrement: true })\n    );\n  }\n  default(\n    value: number\n  ): U8ColumnBuilder<SetField<DefaultMetadata, 'defaultValue', number>> {\n    return new U8ColumnBuilder(\n      this,\n      set(defaultMetadata, { defaultValue: value })\n    );\n  }\n  name<const Name extends string>(\n    name: Name\n  ): U8ColumnBuilder<SetField<DefaultMetadata, 'name', Name>> {\n    return new U8ColumnBuilder(this, set(defaultMetadata, { name }));\n  }\n}\n\nexport class U16Builder\n  extends TypeBuilder<number, AlgebraicTypeVariants.U16>\n  implements\n    Indexable<number, AlgebraicTypeVariants.U16>,\n    Uniqueable<number, AlgebraicTypeVariants.U16>,\n    PrimaryKeyable<number, AlgebraicTypeVariants.U16>,\n    AutoIncrementable<number, AlgebraicTypeVariants.U16>,\n    Defaultable<number, AlgebraicTypeVariants.U16>,\n    Nameable<number, AlgebraicTypeVariants.U16>\n{\n  constructor() {\n    super(AlgebraicType.U16);\n  }\n  index(): U16ColumnBuilder<SetField<DefaultMetadata, 'indexType', 'btree'>>;\n  index<N extends NonNullable<IndexTypes>>(\n    algorithm: N\n  ): U16ColumnBuilder<SetField<DefaultMetadata, 'indexType', N>>;\n  index(\n    algorithm: IndexTypes = 'btree'\n  ): U16ColumnBuilder<SetField<DefaultMetadata, 'indexType', IndexTypes>> {\n    return new U16ColumnBuilder(\n      this,\n      set(defaultMetadata, { indexType: algorithm })\n    );\n  }\n  unique(): U16ColumnBuilder<SetField<DefaultMetadata, 'isUnique', true>> {\n    return new U16ColumnBuilder(this, set(defaultMetadata, { isUnique: true }));\n  }\n  primaryKey(): U16ColumnBuilder<\n    SetField<DefaultMetadata, 'isPrimaryKey', true>\n  > {\n    return new U16ColumnBuilder(\n      this,\n      set(defaultMetadata, { isPrimaryKey: true })\n    );\n  }\n  autoInc(): U16ColumnBuilder<\n    SetField<DefaultMetadata, 'isAutoIncrement', true>\n  > {\n    return new U16ColumnBuilder(\n      this,\n      set(defaultMetadata, { isAutoIncrement: true })\n    );\n  }\n  default(\n    value: number\n  ): U16ColumnBuilder<SetField<DefaultMetadata, 'defaultValue', number>> {\n    return new U16ColumnBuilder(\n      this,\n      set(defaultMetadata, { defaultValue: value })\n    );\n  }\n  name<const Name extends string>(\n    name: Name\n  ): U16ColumnBuilder<SetField<DefaultMetadata, 'name', Name>> {\n    return new U16ColumnBuilder(this, set(defaultMetadata, { name }));\n  }\n}\n\nexport class U32Builder\n  extends TypeBuilder<number, AlgebraicTypeVariants.U32>\n  implements\n    Indexable<number, AlgebraicTypeVariants.U32>,\n    Uniqueable<number, AlgebraicTypeVariants.U32>,\n    PrimaryKeyable<number, AlgebraicTypeVariants.U32>,\n    AutoIncrementable<number, AlgebraicTypeVariants.U32>,\n    Defaultable<number, AlgebraicTypeVariants.U32>,\n    Nameable<number, AlgebraicTypeVariants.U32>\n{\n  constructor() {\n    super(AlgebraicType.U32);\n  }\n  index(): U32ColumnBuilder<SetField<DefaultMetadata, 'indexType', 'btree'>>;\n  index<N extends NonNullable<IndexTypes>>(\n    algorithm: N\n  ): U32ColumnBuilder<SetField<DefaultMetadata, 'indexType', N>>;\n  index(\n    algorithm: IndexTypes = 'btree'\n  ): U32ColumnBuilder<SetField<DefaultMetadata, 'indexType', IndexTypes>> {\n    return new U32ColumnBuilder(\n      this,\n      set(defaultMetadata, { indexType: algorithm })\n    );\n  }\n  unique(): U32ColumnBuilder<SetField<DefaultMetadata, 'isUnique', true>> {\n    return new U32ColumnBuilder(this, set(defaultMetadata, { isUnique: true }));\n  }\n  primaryKey(): U32ColumnBuilder<\n    SetField<DefaultMetadata, 'isPrimaryKey', true>\n  > {\n    return new U32ColumnBuilder(\n      this,\n      set(defaultMetadata, { isPrimaryKey: true })\n    );\n  }\n  autoInc(): U32ColumnBuilder<\n    SetField<DefaultMetadata, 'isAutoIncrement', true>\n  > {\n    return new U32ColumnBuilder(\n      this,\n      set(defaultMetadata, { isAutoIncrement: true })\n    );\n  }\n  default(\n    value: number\n  ): U32ColumnBuilder<SetField<DefaultMetadata, 'defaultValue', number>> {\n    return new U32ColumnBuilder(\n      this,\n      set(defaultMetadata, { defaultValue: value })\n    );\n  }\n  name<const Name extends string>(\n    name: Name\n  ): U32ColumnBuilder<SetField<DefaultMetadata, 'name', Name>> {\n    return new U32ColumnBuilder(this, set(defaultMetadata, { name }));\n  }\n}\n\nexport class U64Builder\n  extends TypeBuilder<bigint, AlgebraicTypeVariants.U64>\n  implements\n    Indexable<bigint, AlgebraicTypeVariants.U64>,\n    Uniqueable<bigint, AlgebraicTypeVariants.U64>,\n    PrimaryKeyable<bigint, AlgebraicTypeVariants.U64>,\n    AutoIncrementable<bigint, AlgebraicTypeVariants.U64>,\n    Defaultable<bigint, AlgebraicTypeVariants.U64>,\n    Nameable<bigint, AlgebraicTypeVariants.U64>\n{\n  constructor() {\n    super(AlgebraicType.U64);\n  }\n  index(): U64ColumnBuilder<SetField<DefaultMetadata, 'indexType', 'btree'>>;\n  index<N extends NonNullable<IndexTypes>>(\n    algorithm: N\n  ): U64ColumnBuilder<SetField<DefaultMetadata, 'indexType', N>>;\n  index(\n    algorithm: IndexTypes = 'btree'\n  ): U64ColumnBuilder<SetField<DefaultMetadata, 'indexType', IndexTypes>> {\n    return new U64ColumnBuilder(\n      this,\n      set(defaultMetadata, { indexType: algorithm })\n    );\n  }\n  unique(): U64ColumnBuilder<SetField<DefaultMetadata, 'isUnique', true>> {\n    return new U64ColumnBuilder(this, set(defaultMetadata, { isUnique: true }));\n  }\n  primaryKey(): U64ColumnBuilder<\n    SetField<DefaultMetadata, 'isPrimaryKey', true>\n  > {\n    return new U64ColumnBuilder(\n      this,\n      set(defaultMetadata, { isPrimaryKey: true })\n    );\n  }\n  autoInc(): U64ColumnBuilder<\n    SetField<DefaultMetadata, 'isAutoIncrement', true>\n  > {\n    return new U64ColumnBuilder(\n      this,\n      set(defaultMetadata, { isAutoIncrement: true })\n    );\n  }\n  default(\n    value: bigint\n  ): U64ColumnBuilder<SetField<DefaultMetadata, 'defaultValue', bigint>> {\n    return new U64ColumnBuilder(\n      this,\n      set(defaultMetadata, { defaultValue: value })\n    );\n  }\n  name<const Name extends string>(\n    name: Name\n  ): U64ColumnBuilder<SetField<DefaultMetadata, 'name', Name>> {\n    return new U64ColumnBuilder(this, set(defaultMetadata, { name }));\n  }\n}\n\nexport class U128Builder\n  extends TypeBuilder<bigint, AlgebraicTypeVariants.U128>\n  implements\n    Indexable<bigint, AlgebraicTypeVariants.U128>,\n    Uniqueable<bigint, AlgebraicTypeVariants.U128>,\n    PrimaryKeyable<bigint, AlgebraicTypeVariants.U128>,\n    AutoIncrementable<bigint, AlgebraicTypeVariants.U128>,\n    Defaultable<bigint, AlgebraicTypeVariants.U128>,\n    Nameable<bigint, AlgebraicTypeVariants.U128>\n{\n  constructor() {\n    super(AlgebraicType.U128);\n  }\n  index(): U128ColumnBuilder<SetField<DefaultMetadata, 'indexType', 'btree'>>;\n  index<N extends NonNullable<IndexTypes>>(\n    algorithm: N\n  ): U128ColumnBuilder<SetField<DefaultMetadata, 'indexType', N>>;\n  index(\n    algorithm: IndexTypes = 'btree'\n  ): U128ColumnBuilder<SetField<DefaultMetadata, 'indexType', IndexTypes>> {\n    return new U128ColumnBuilder(\n      this,\n      set(defaultMetadata, { indexType: algorithm })\n    );\n  }\n  unique(): U128ColumnBuilder<SetField<DefaultMetadata, 'isUnique', true>> {\n    return new U128ColumnBuilder(\n      this,\n      set(defaultMetadata, { isUnique: true })\n    );\n  }\n  primaryKey(): U128ColumnBuilder<\n    SetField<DefaultMetadata, 'isPrimaryKey', true>\n  > {\n    return new U128ColumnBuilder(\n      this,\n      set(defaultMetadata, { isPrimaryKey: true })\n    );\n  }\n  autoInc(): U128ColumnBuilder<\n    SetField<DefaultMetadata, 'isAutoIncrement', true>\n  > {\n    return new U128ColumnBuilder(\n      this,\n      set(defaultMetadata, { isAutoIncrement: true })\n    );\n  }\n  default(\n    value: bigint\n  ): U128ColumnBuilder<SetField<DefaultMetadata, 'defaultValue', bigint>> {\n    return new U128ColumnBuilder(\n      this,\n      set(defaultMetadata, { defaultValue: value })\n    );\n  }\n  name<const Name extends string>(\n    name: Name\n  ): U128ColumnBuilder<SetField<DefaultMetadata, 'name', Name>> {\n    return new U128ColumnBuilder(this, set(defaultMetadata, { name }));\n  }\n}\n\nexport class U256Builder\n  extends TypeBuilder<bigint, AlgebraicTypeVariants.U256>\n  implements\n    Indexable<bigint, AlgebraicTypeVariants.U256>,\n    Uniqueable<bigint, AlgebraicTypeVariants.U256>,\n    PrimaryKeyable<bigint, AlgebraicTypeVariants.U256>,\n    AutoIncrementable<bigint, AlgebraicTypeVariants.U256>,\n    Defaultable<bigint, AlgebraicTypeVariants.U256>,\n    Nameable<bigint, AlgebraicTypeVariants.U256>\n{\n  constructor() {\n    super(AlgebraicType.U256);\n  }\n  index(): U256ColumnBuilder<SetField<DefaultMetadata, 'indexType', 'btree'>>;\n  index<N extends NonNullable<IndexTypes>>(\n    algorithm: N\n  ): U256ColumnBuilder<SetField<DefaultMetadata, 'indexType', N>>;\n  index(\n    algorithm: IndexTypes = 'btree'\n  ): U256ColumnBuilder<SetField<DefaultMetadata, 'indexType', IndexTypes>> {\n    return new U256ColumnBuilder(\n      this,\n      set(defaultMetadata, { indexType: algorithm })\n    );\n  }\n  unique(): U256ColumnBuilder<SetField<DefaultMetadata, 'isUnique', true>> {\n    return new U256ColumnBuilder(\n      this,\n      set(defaultMetadata, { isUnique: true })\n    );\n  }\n  primaryKey(): U256ColumnBuilder<\n    SetField<DefaultMetadata, 'isPrimaryKey', true>\n  > {\n    return new U256ColumnBuilder(\n      this,\n      set(defaultMetadata, { isPrimaryKey: true })\n    );\n  }\n  autoInc(): U256ColumnBuilder<\n    SetField<DefaultMetadata, 'isAutoIncrement', true>\n  > {\n    return new U256ColumnBuilder(\n      this,\n      set(defaultMetadata, { isAutoIncrement: true })\n    );\n  }\n  default(\n    value: bigint\n  ): U256ColumnBuilder<SetField<DefaultMetadata, 'defaultValue', bigint>> {\n    return new U256ColumnBuilder(\n      this,\n      set(defaultMetadata, { defaultValue: value })\n    );\n  }\n  name<const Name extends string>(\n    name: Name\n  ): U256ColumnBuilder<SetField<DefaultMetadata, 'name', Name>> {\n    return new U256ColumnBuilder(this, set(defaultMetadata, { name }));\n  }\n}\n\nexport class I8Builder\n  extends TypeBuilder<number, AlgebraicTypeVariants.I8>\n  implements\n    Indexable<number, AlgebraicTypeVariants.I8>,\n    Uniqueable<number, AlgebraicTypeVariants.I8>,\n    PrimaryKeyable<number, AlgebraicTypeVariants.I8>,\n    AutoIncrementable<number, AlgebraicTypeVariants.I8>,\n    Defaultable<number, AlgebraicTypeVariants.I8>,\n    Nameable<number, AlgebraicTypeVariants.I8>\n{\n  constructor() {\n    super(AlgebraicType.I8);\n  }\n  index(): I8ColumnBuilder<SetField<DefaultMetadata, 'indexType', 'btree'>>;\n  index<N extends NonNullable<IndexTypes>>(\n    algorithm: N\n  ): I8ColumnBuilder<SetField<DefaultMetadata, 'indexType', N>>;\n  index(\n    algorithm: IndexTypes = 'btree'\n  ): I8ColumnBuilder<SetField<DefaultMetadata, 'indexType', IndexTypes>> {\n    return new I8ColumnBuilder(\n      this,\n      set(defaultMetadata, { indexType: algorithm })\n    );\n  }\n  unique(): I8ColumnBuilder<SetField<DefaultMetadata, 'isUnique', true>> {\n    return new I8ColumnBuilder(this, set(defaultMetadata, { isUnique: true }));\n  }\n  primaryKey(): I8ColumnBuilder<\n    SetField<DefaultMetadata, 'isPrimaryKey', true>\n  > {\n    return new I8ColumnBuilder(\n      this,\n      set(defaultMetadata, { isPrimaryKey: true })\n    );\n  }\n  autoInc(): I8ColumnBuilder<\n    SetField<DefaultMetadata, 'isAutoIncrement', true>\n  > {\n    return new I8ColumnBuilder(\n      this,\n      set(defaultMetadata, { isAutoIncrement: true })\n    );\n  }\n  default(\n    value: number\n  ): I8ColumnBuilder<SetField<DefaultMetadata, 'defaultValue', number>> {\n    return new I8ColumnBuilder(\n      this,\n      set(defaultMetadata, { defaultValue: value })\n    );\n  }\n  name<const Name extends string>(\n    name: Name\n  ): I8ColumnBuilder<SetField<DefaultMetadata, 'name', Name>> {\n    return new I8ColumnBuilder(this, set(defaultMetadata, { name }));\n  }\n}\n\nexport class I16Builder\n  extends TypeBuilder<number, AlgebraicTypeVariants.I16>\n  implements\n    Indexable<number, AlgebraicTypeVariants.I16>,\n    Uniqueable<number, AlgebraicTypeVariants.I16>,\n    PrimaryKeyable<number, AlgebraicTypeVariants.I16>,\n    AutoIncrementable<number, AlgebraicTypeVariants.I16>,\n    Defaultable<number, AlgebraicTypeVariants.I16>,\n    Nameable<number, AlgebraicTypeVariants.I16>\n{\n  constructor() {\n    super(AlgebraicType.I16);\n  }\n  index(): I16ColumnBuilder<SetField<DefaultMetadata, 'indexType', 'btree'>>;\n  index<N extends NonNullable<IndexTypes>>(\n    algorithm: N\n  ): I16ColumnBuilder<SetField<DefaultMetadata, 'indexType', N>>;\n  index(\n    algorithm: IndexTypes = 'btree'\n  ): I16ColumnBuilder<SetField<DefaultMetadata, 'indexType', IndexTypes>> {\n    return new I16ColumnBuilder(\n      this,\n      set(defaultMetadata, { indexType: algorithm })\n    );\n  }\n  unique(): I16ColumnBuilder<SetField<DefaultMetadata, 'isUnique', true>> {\n    return new I16ColumnBuilder(this, set(defaultMetadata, { isUnique: true }));\n  }\n  primaryKey(): I16ColumnBuilder<\n    SetField<DefaultMetadata, 'isPrimaryKey', true>\n  > {\n    return new I16ColumnBuilder(\n      this,\n      set(defaultMetadata, { isPrimaryKey: true })\n    );\n  }\n  autoInc(): I16ColumnBuilder<\n    SetField<DefaultMetadata, 'isAutoIncrement', true>\n  > {\n    return new I16ColumnBuilder(\n      this,\n      set(defaultMetadata, { isAutoIncrement: true })\n    );\n  }\n  default(\n    value: number\n  ): I16ColumnBuilder<SetField<DefaultMetadata, 'defaultValue', number>> {\n    return new I16ColumnBuilder(\n      this,\n      set(defaultMetadata, { defaultValue: value })\n    );\n  }\n  name<const Name extends string>(\n    name: Name\n  ): I16ColumnBuilder<SetField<DefaultMetadata, 'name', Name>> {\n    return new I16ColumnBuilder(this, set(defaultMetadata, { name }));\n  }\n}\n\nexport class I32Builder\n  extends TypeBuilder<number, AlgebraicTypeVariants.I32>\n  implements\n    TypeBuilder<number, AlgebraicTypeVariants.I32>,\n    Indexable<number, AlgebraicTypeVariants.I32>,\n    Uniqueable<number, AlgebraicTypeVariants.I32>,\n    PrimaryKeyable<number, AlgebraicTypeVariants.I32>,\n    AutoIncrementable<number, AlgebraicTypeVariants.I32>,\n    Defaultable<number, AlgebraicTypeVariants.I32>,\n    Nameable<number, AlgebraicTypeVariants.I32>\n{\n  constructor() {\n    super(AlgebraicType.I32);\n  }\n  index(): I32ColumnBuilder<SetField<DefaultMetadata, 'indexType', 'btree'>>;\n  index<N extends NonNullable<IndexTypes>>(\n    algorithm: N\n  ): I32ColumnBuilder<SetField<DefaultMetadata, 'indexType', N>>;\n  index(\n    algorithm: IndexTypes = 'btree'\n  ): I32ColumnBuilder<SetField<DefaultMetadata, 'indexType', IndexTypes>> {\n    return new I32ColumnBuilder(\n      this,\n      set(defaultMetadata, { indexType: algorithm })\n    );\n  }\n  unique(): I32ColumnBuilder<SetField<DefaultMetadata, 'isUnique', true>> {\n    return new I32ColumnBuilder(this, set(defaultMetadata, { isUnique: true }));\n  }\n  primaryKey(): I32ColumnBuilder<\n    SetField<DefaultMetadata, 'isPrimaryKey', true>\n  > {\n    return new I32ColumnBuilder(\n      this,\n      set(defaultMetadata, { isPrimaryKey: true })\n    );\n  }\n  autoInc(): I32ColumnBuilder<\n    SetField<DefaultMetadata, 'isAutoIncrement', true>\n  > {\n    return new I32ColumnBuilder(\n      this,\n      set(defaultMetadata, { isAutoIncrement: true })\n    );\n  }\n  default(\n    value: number\n  ): I32ColumnBuilder<SetField<DefaultMetadata, 'defaultValue', number>> {\n    return new I32ColumnBuilder(\n      this,\n      set(defaultMetadata, { defaultValue: value })\n    );\n  }\n  name<const Name extends string>(\n    name: Name\n  ): I32ColumnBuilder<SetField<DefaultMetadata, 'name', Name>> {\n    return new I32ColumnBuilder(this, set(defaultMetadata, { name }));\n  }\n}\n\nexport class I64Builder\n  extends TypeBuilder<bigint, AlgebraicTypeVariants.I64>\n  implements\n    Indexable<bigint, AlgebraicTypeVariants.I64>,\n    Uniqueable<bigint, AlgebraicTypeVariants.I64>,\n    PrimaryKeyable<bigint, AlgebraicTypeVariants.I64>,\n    AutoIncrementable<bigint, AlgebraicTypeVariants.I64>,\n    Defaultable<bigint, AlgebraicTypeVariants.I64>,\n    Nameable<bigint, AlgebraicTypeVariants.I64>\n{\n  constructor() {\n    super(AlgebraicType.I64);\n  }\n  index(): I64ColumnBuilder<SetField<DefaultMetadata, 'indexType', 'btree'>>;\n  index<N extends NonNullable<IndexTypes>>(\n    algorithm: N\n  ): I64ColumnBuilder<SetField<DefaultMetadata, 'indexType', N>>;\n  index(\n    algorithm: IndexTypes = 'btree'\n  ): I64ColumnBuilder<SetField<DefaultMetadata, 'indexType', IndexTypes>> {\n    return new I64ColumnBuilder(\n      this,\n      set(defaultMetadata, { indexType: algorithm })\n    );\n  }\n  unique(): I64ColumnBuilder<SetField<DefaultMetadata, 'isUnique', true>> {\n    return new I64ColumnBuilder(this, set(defaultMetadata, { isUnique: true }));\n  }\n  primaryKey(): I64ColumnBuilder<\n    SetField<DefaultMetadata, 'isPrimaryKey', true>\n  > {\n    return new I64ColumnBuilder(\n      this,\n      set(defaultMetadata, { isPrimaryKey: true })\n    );\n  }\n  autoInc(): I64ColumnBuilder<\n    SetField<DefaultMetadata, 'isAutoIncrement', true>\n  > {\n    return new I64ColumnBuilder(\n      this,\n      set(defaultMetadata, { isAutoIncrement: true })\n    );\n  }\n  default(\n    value: bigint\n  ): I64ColumnBuilder<SetField<DefaultMetadata, 'defaultValue', bigint>> {\n    return new I64ColumnBuilder(\n      this,\n      set(defaultMetadata, { defaultValue: value })\n    );\n  }\n  name<const Name extends string>(\n    name: Name\n  ): I64ColumnBuilder<SetField<DefaultMetadata, 'name', Name>> {\n    return new I64ColumnBuilder(this, set(defaultMetadata, { name }));\n  }\n}\n\nexport class I128Builder\n  extends TypeBuilder<bigint, AlgebraicTypeVariants.I128>\n  implements\n    Indexable<bigint, AlgebraicTypeVariants.I128>,\n    Uniqueable<bigint, AlgebraicTypeVariants.I128>,\n    PrimaryKeyable<bigint, AlgebraicTypeVariants.I128>,\n    AutoIncrementable<bigint, AlgebraicTypeVariants.I128>,\n    Defaultable<bigint, AlgebraicTypeVariants.I128>,\n    Nameable<bigint, AlgebraicTypeVariants.I128>\n{\n  constructor() {\n    super(AlgebraicType.I128);\n  }\n  index(): I128ColumnBuilder<SetField<DefaultMetadata, 'indexType', 'btree'>>;\n  index<N extends NonNullable<IndexTypes>>(\n    algorithm: N\n  ): I128ColumnBuilder<SetField<DefaultMetadata, 'indexType', N>>;\n  index(\n    algorithm: IndexTypes = 'btree'\n  ): I128ColumnBuilder<SetField<DefaultMetadata, 'indexType', IndexTypes>> {\n    return new I128ColumnBuilder(\n      this,\n      set(defaultMetadata, { indexType: algorithm })\n    );\n  }\n  unique(): I128ColumnBuilder<SetField<DefaultMetadata, 'isUnique', true>> {\n    return new I128ColumnBuilder(\n      this,\n      set(defaultMetadata, { isUnique: true })\n    );\n  }\n  primaryKey(): I128ColumnBuilder<\n    SetField<DefaultMetadata, 'isPrimaryKey', true>\n  > {\n    return new I128ColumnBuilder(\n      this,\n      set(defaultMetadata, { isPrimaryKey: true })\n    );\n  }\n  autoInc(): I128ColumnBuilder<\n    SetField<DefaultMetadata, 'isAutoIncrement', true>\n  > {\n    return new I128ColumnBuilder(\n      this,\n      set(defaultMetadata, { isAutoIncrement: true })\n    );\n  }\n  default(\n    value: bigint\n  ): I128ColumnBuilder<SetField<DefaultMetadata, 'defaultValue', bigint>> {\n    return new I128ColumnBuilder(\n      this,\n      set(defaultMetadata, { defaultValue: value })\n    );\n  }\n  name<const Name extends string>(\n    name: Name\n  ): I128ColumnBuilder<SetField<DefaultMetadata, 'name', Name>> {\n    return new I128ColumnBuilder(this, set(defaultMetadata, { name }));\n  }\n}\n\nexport class I256Builder\n  extends TypeBuilder<bigint, AlgebraicTypeVariants.I256>\n  implements\n    Indexable<bigint, AlgebraicTypeVariants.I256>,\n    Uniqueable<bigint, AlgebraicTypeVariants.I256>,\n    PrimaryKeyable<bigint, AlgebraicTypeVariants.I256>,\n    AutoIncrementable<bigint, AlgebraicTypeVariants.I256>,\n    Defaultable<bigint, AlgebraicTypeVariants.I256>,\n    Nameable<bigint, AlgebraicTypeVariants.I256>\n{\n  constructor() {\n    super(AlgebraicType.I256);\n  }\n  index(): I256ColumnBuilder<SetField<DefaultMetadata, 'indexType', 'btree'>>;\n  index<N extends NonNullable<IndexTypes>>(\n    algorithm: N\n  ): I256ColumnBuilder<SetField<DefaultMetadata, 'indexType', N>>;\n  index(\n    algorithm: IndexTypes = 'btree'\n  ): I256ColumnBuilder<SetField<DefaultMetadata, 'indexType', IndexTypes>> {\n    return new I256ColumnBuilder(\n      this,\n      set(defaultMetadata, { indexType: algorithm })\n    );\n  }\n  unique(): I256ColumnBuilder<SetField<DefaultMetadata, 'isUnique', true>> {\n    return new I256ColumnBuilder(\n      this,\n      set(defaultMetadata, { isUnique: true })\n    );\n  }\n  primaryKey(): I256ColumnBuilder<\n    SetField<DefaultMetadata, 'isPrimaryKey', true>\n  > {\n    return new I256ColumnBuilder(\n      this,\n      set(defaultMetadata, { isPrimaryKey: true })\n    );\n  }\n  autoInc(): I256ColumnBuilder<\n    SetField<DefaultMetadata, 'isAutoIncrement', true>\n  > {\n    return new I256ColumnBuilder(\n      this,\n      set(defaultMetadata, { isAutoIncrement: true })\n    );\n  }\n  default(\n    value: bigint\n  ): I256ColumnBuilder<SetField<DefaultMetadata, 'defaultValue', bigint>> {\n    return new I256ColumnBuilder(\n      this,\n      set(defaultMetadata, { defaultValue: value })\n    );\n  }\n  name<const Name extends string>(\n    name: Name\n  ): I256ColumnBuilder<SetField<DefaultMetadata, 'name', Name>> {\n    return new I256ColumnBuilder(this, set(defaultMetadata, { name }));\n  }\n}\n\nexport class F32Builder\n  extends TypeBuilder<number, AlgebraicTypeVariants.F32>\n  implements\n    Defaultable<number, AlgebraicTypeVariants.F32>,\n    Nameable<number, AlgebraicTypeVariants.F32>\n{\n  constructor() {\n    super(AlgebraicType.F32);\n  }\n  default(\n    value: number\n  ): F32ColumnBuilder<SetField<DefaultMetadata, 'defaultValue', number>> {\n    return new F32ColumnBuilder(\n      this,\n      set(defaultMetadata, { defaultValue: value })\n    );\n  }\n  name<const Name extends string>(\n    name: Name\n  ): F32ColumnBuilder<SetField<DefaultMetadata, 'name', Name>> {\n    return new F32ColumnBuilder(this, set(defaultMetadata, { name }));\n  }\n}\n\nexport class F64Builder\n  extends TypeBuilder<number, AlgebraicTypeVariants.F64>\n  implements\n    Defaultable<number, AlgebraicTypeVariants.F64>,\n    Nameable<number, AlgebraicTypeVariants.F64>\n{\n  constructor() {\n    super(AlgebraicType.F64);\n  }\n  default(\n    value: number\n  ): F64ColumnBuilder<SetField<DefaultMetadata, 'defaultValue', number>> {\n    return new F64ColumnBuilder(\n      this,\n      set(defaultMetadata, { defaultValue: value })\n    );\n  }\n  name<const Name extends string>(\n    name: Name\n  ): F64ColumnBuilder<SetField<DefaultMetadata, 'name', Name>> {\n    return new F64ColumnBuilder(this, set(defaultMetadata, { name }));\n  }\n}\n\nexport class BoolBuilder\n  extends TypeBuilder<boolean, AlgebraicTypeVariants.Bool>\n  implements\n    Indexable<boolean, AlgebraicTypeVariants.Bool>,\n    Uniqueable<boolean, AlgebraicTypeVariants.Bool>,\n    PrimaryKeyable<boolean, AlgebraicTypeVariants.Bool>,\n    Defaultable<boolean, AlgebraicTypeVariants.Bool>,\n    Nameable<boolean, AlgebraicTypeVariants.Bool>\n{\n  constructor() {\n    super(AlgebraicType.Bool);\n  }\n  index(): BoolColumnBuilder<SetField<DefaultMetadata, 'indexType', 'btree'>>;\n  index<N extends NonNullable<IndexTypes>>(\n    algorithm: N\n  ): BoolColumnBuilder<SetField<DefaultMetadata, 'indexType', N>>;\n  index(\n    algorithm: IndexTypes = 'btree'\n  ): BoolColumnBuilder<SetField<DefaultMetadata, 'indexType', IndexTypes>> {\n    return new BoolColumnBuilder(\n      this,\n      set(defaultMetadata, { indexType: algorithm })\n    );\n  }\n  unique(): BoolColumnBuilder<SetField<DefaultMetadata, 'isUnique', true>> {\n    return new BoolColumnBuilder(\n      this,\n      set(defaultMetadata, { isUnique: true })\n    );\n  }\n  primaryKey(): BoolColumnBuilder<\n    SetField<DefaultMetadata, 'isPrimaryKey', true>\n  > {\n    return new BoolColumnBuilder(\n      this,\n      set(defaultMetadata, { isPrimaryKey: true })\n    );\n  }\n  default(\n    value: boolean\n  ): BoolColumnBuilder<SetField<DefaultMetadata, 'defaultValue', boolean>> {\n    return new BoolColumnBuilder(\n      this,\n      set(defaultMetadata, { defaultValue: value })\n    );\n  }\n  name<const Name extends string>(\n    name: Name\n  ): BoolColumnBuilder<SetField<DefaultMetadata, 'name', Name>> {\n    return new BoolColumnBuilder(this, set(defaultMetadata, { name }));\n  }\n}\n\nexport class StringBuilder\n  extends TypeBuilder<string, AlgebraicTypeVariants.String>\n  implements\n    Indexable<string, AlgebraicTypeVariants.String>,\n    Uniqueable<string, AlgebraicTypeVariants.String>,\n    PrimaryKeyable<string, AlgebraicTypeVariants.String>,\n    Defaultable<string, AlgebraicTypeVariants.String>,\n    Nameable<string, AlgebraicTypeVariants.String>\n{\n  constructor() {\n    super(AlgebraicType.String);\n  }\n  index(): StringColumnBuilder<SetField<DefaultMetadata, 'indexType', 'btree'>>;\n  index<N extends NonNullable<IndexTypes>>(\n    algorithm: N\n  ): StringColumnBuilder<SetField<DefaultMetadata, 'indexType', N>>;\n  index(\n    algorithm: IndexTypes = 'btree'\n  ): StringColumnBuilder<SetField<DefaultMetadata, 'indexType', IndexTypes>> {\n    return new StringColumnBuilder(\n      this,\n      set(defaultMetadata, { indexType: algorithm })\n    );\n  }\n  unique(): StringColumnBuilder<SetField<DefaultMetadata, 'isUnique', true>> {\n    return new StringColumnBuilder(\n      this,\n      set(defaultMetadata, { isUnique: true })\n    );\n  }\n  primaryKey(): StringColumnBuilder<\n    SetField<DefaultMetadata, 'isPrimaryKey', true>\n  > {\n    return new StringColumnBuilder(\n      this,\n      set(defaultMetadata, { isPrimaryKey: true })\n    );\n  }\n  default(\n    value: string\n  ): StringColumnBuilder<SetField<DefaultMetadata, 'defaultValue', string>> {\n    return new StringColumnBuilder(\n      this,\n      set(defaultMetadata, { defaultValue: value })\n    );\n  }\n  name<const Name extends string>(\n    name: Name\n  ): StringColumnBuilder<SetField<DefaultMetadata, 'name', Name>> {\n    return new StringColumnBuilder(this, set(defaultMetadata, { name }));\n  }\n}\n\nexport class ArrayBuilder<Element extends TypeBuilder<any, any>>\n  extends TypeBuilder<\n    Array<InferTypeOfTypeBuilder<Element>>,\n    { tag: 'Array'; value: InferSpacetimeTypeOfTypeBuilder<Element> }\n  >\n  implements\n    Defaultable<Array<InferTypeOfTypeBuilder<Element>>, any>,\n    Nameable<Array<InferTypeOfTypeBuilder<Element>>, any>\n{\n  element: Element;\n\n  constructor(element: Element) {\n    super(AlgebraicType.Array(element.algebraicType));\n    this.element = element;\n  }\n  default(\n    value: Array<InferTypeOfTypeBuilder<Element>>\n  ): ArrayColumnBuilder<\n    Element,\n    SetField<DefaultMetadata, 'defaultValue', any>\n  > {\n    return new ArrayColumnBuilder(\n      this.element,\n      set(defaultMetadata, { defaultValue: value })\n    );\n  }\n  name<const Name extends string>(\n    name: Name\n  ): ArrayColumnBuilder<Element, SetField<DefaultMetadata, 'name', Name>> {\n    return new ArrayColumnBuilder(this.element, set(defaultMetadata, { name }));\n  }\n}\n\nexport class ByteArrayBuilder\n  extends TypeBuilder<\n    Uint8Array,\n    { tag: 'Array'; value: AlgebraicTypeVariants.U8 }\n  >\n  implements Defaultable<Uint8Array, any>, Nameable<Uint8Array, any>\n{\n  constructor() {\n    super(AlgebraicType.Array(AlgebraicType.U8));\n  }\n  default(\n    value: Uint8Array\n  ): ByteArrayColumnBuilder<SetField<DefaultMetadata, 'defaultValue', any>> {\n    return new ByteArrayColumnBuilder(\n      set(defaultMetadata, { defaultValue: value })\n    );\n  }\n  name<const Name extends string>(\n    name: Name\n  ): ByteArrayColumnBuilder<SetField<DefaultMetadata, 'name', Name>> {\n    return new ByteArrayColumnBuilder(set(defaultMetadata, { name }));\n  }\n}\n\nexport class OptionBuilder<Value extends TypeBuilder<any, any>>\n  extends TypeBuilder<\n    InferTypeOfTypeBuilder<Value> | undefined,\n    OptionAlgebraicType<InferSpacetimeTypeOfTypeBuilder<Value>>\n  >\n  implements\n    Defaultable<\n      InferTypeOfTypeBuilder<Value> | undefined,\n      OptionAlgebraicType<InferSpacetimeTypeOfTypeBuilder<Value>>\n    >,\n    Nameable<\n      InferTypeOfTypeBuilder<Value> | undefined,\n      OptionAlgebraicType<InferSpacetimeTypeOfTypeBuilder<Value>>\n    >\n{\n  value: Value;\n\n  constructor(value: Value) {\n    super(Option.getAlgebraicType(value.algebraicType));\n    this.value = value;\n  }\n  default(\n    value: InferTypeOfTypeBuilder<Value> | undefined\n  ): OptionColumnBuilder<\n    Value,\n    SetField<\n      DefaultMetadata,\n      'defaultValue',\n      InferTypeOfTypeBuilder<Value> | undefined\n    >\n  > {\n    return new OptionColumnBuilder(\n      this,\n      set(defaultMetadata, { defaultValue: value })\n    );\n  }\n  name<const Name extends string>(\n    name: Name\n  ): OptionColumnBuilder<Value, SetField<DefaultMetadata, 'name', Name>> {\n    return new OptionColumnBuilder(this, set(defaultMetadata, { name }));\n  }\n}\n\ntype ElementsToProductType<Elements extends ElementsObj> = {\n  tag: 'Product';\n  value: { elements: ElementsArrayFromElementsObj<Elements> };\n};\n\nexport class ProductBuilder<Elements extends ElementsObj>\n  extends TypeBuilder<ObjectType<Elements>, ElementsToProductType<Elements>>\n  implements\n    Defaultable<ObjectType<Elements>, ElementsToProductType<Elements>>,\n    Nameable<ObjectType<Elements>, ElementsToProductType<Elements>>\n{\n  readonly typeName: string | undefined;\n  readonly elements: Elements;\n  constructor(elements: Elements, name?: string) {\n    function elementsArrayFromElementsObj<Obj extends ElementsObj>(obj: Obj) {\n      return Object.keys(obj).map(key => ({\n        name: key,\n        // Lazily resolve the underlying object's algebraicType.\n        // This will call obj[key].algebraicType only when someone\n        // actually reads this property.\n        get algebraicType() {\n          return obj[key].algebraicType;\n        },\n      }));\n    }\n    super(\n      AlgebraicType.Product({\n        elements: elementsArrayFromElementsObj(elements),\n      })\n    );\n    this.typeName = name;\n    this.elements = elements;\n  }\n  default(\n    value: ObjectType<Elements>\n  ): ProductColumnBuilder<\n    Elements,\n    SetField<DefaultMetadata, 'defaultValue', any>\n  > {\n    return new ProductColumnBuilder(\n      this,\n      set(defaultMetadata, { defaultValue: value })\n    );\n  }\n  name<const Name extends string>(\n    name: Name\n  ): ProductColumnBuilder<Elements, SetField<DefaultMetadata, 'name', Name>> {\n    return new ProductColumnBuilder(this, set(defaultMetadata, { name }));\n  }\n}\n\nexport class ResultBuilder<\n    Ok extends TypeBuilder<any, any>,\n    Err extends TypeBuilder<any, any>,\n  >\n  extends TypeBuilder<\n    InferTypeOfTypeBuilder<Ok> | InferTypeOfTypeBuilder<Err>,\n    ResultAlgebraicType<\n      InferSpacetimeTypeOfTypeBuilder<Ok>,\n      InferSpacetimeTypeOfTypeBuilder<Err>\n    >\n  >\n  implements\n    Defaultable<\n      InferTypeOfTypeBuilder<Ok> | InferTypeOfTypeBuilder<Err>,\n      ResultAlgebraicType<\n        InferSpacetimeTypeOfTypeBuilder<Ok>,\n        InferSpacetimeTypeOfTypeBuilder<Err>\n      >\n    >\n{\n  ok: Ok;\n  err: Err;\n\n  constructor(ok: Ok, err: Err) {\n    super(Result.getAlgebraicType(ok.algebraicType, err.algebraicType));\n    this.ok = ok;\n    this.err = err;\n  }\n  default(\n    value: InferTypeOfTypeBuilder<Ok> | InferTypeOfTypeBuilder<Err>\n  ): ResultColumnBuilder<\n    Ok,\n    Err,\n    SetField<\n      DefaultMetadata,\n      'defaultValue',\n      InferTypeOfTypeBuilder<Ok> | InferTypeOfTypeBuilder<Err>\n    >\n  > {\n    return new ResultColumnBuilder<\n      Ok,\n      Err,\n      SetField<\n        DefaultMetadata,\n        'defaultValue',\n        InferTypeOfTypeBuilder<Ok> | InferTypeOfTypeBuilder<Err>\n      >\n    >(this, set(defaultMetadata, { defaultValue: value }));\n  }\n}\n\nclass UnitBuilder extends TypeBuilder<\n  {},\n  { tag: 'Product'; value: { elements: [] } }\n> {\n  constructor() {\n    super({ tag: 'Product', value: { elements: [] } });\n  }\n}\n\nexport class RowBuilder<Row extends RowObj> extends TypeBuilder<\n  RowType<CoerceRow<Row>>,\n  {\n    tag: 'Product';\n    value: { elements: ElementsArrayFromRowObj<CoerceRow<Row>> };\n  }\n> {\n  readonly row: CoerceRow<Row>;\n  typeName: string | undefined;\n  constructor(row: Row, name?: string) {\n    const mappedRow = Object.fromEntries(\n      Object.entries(row).map(([colName, builder]) => [\n        colName,\n        builder instanceof ColumnBuilder\n          ? builder\n          : new ColumnBuilder(builder, {}),\n      ])\n    ) as CoerceRow<Row>;\n\n    const elements = Object.keys(mappedRow).map(name => ({\n      name,\n      get algebraicType() {\n        return mappedRow[name].typeBuilder.algebraicType;\n      },\n    }));\n\n    super(AlgebraicType.Product({ elements }));\n    this.row = mappedRow;\n    this.typeName = name;\n  }\n}\n\n// Value type produced for a given variant key + builder\ntype EnumValue<K extends string, B extends TypeBuilder<any, any>> =\n  IsUnit<B> extends true\n    ? { tag: K }\n    : { tag: K; value: InferTypeOfTypeBuilder<B> };\n\ntype VariantConstructor<K extends string, V extends TypeBuilder<any, any>> =\n  IsUnit<V> extends true\n    ? EnumValue<K, V>\n    : (value: InferTypeOfTypeBuilder<V>) => EnumValue<K, V>;\n\ntype SumBuilderVariantConstructors<Variants extends VariantsObj> = {\n  [K in keyof Variants & string]: VariantConstructor<K, Variants[K]>;\n};\n\nexport type SumBuilder<Variants extends VariantsObj> =\n  SumBuilderImpl<Variants> & SumBuilderVariantConstructors<Variants>;\n\ntype VariantsToSumType<Variants extends VariantsObj> = {\n  tag: 'Sum';\n  value: { variants: VariantsArrayFromVariantsObj<Variants> };\n};\n\nclass SumBuilderImpl<Variants extends VariantsObj>\n  extends TypeBuilder<EnumType<Variants>, VariantsToSumType<Variants>>\n  implements\n    Defaultable<EnumType<Variants>, VariantsToSumType<Variants>>,\n    Nameable<EnumType<Variants>, VariantsToSumType<Variants>>\n{\n  readonly variants: Variants;\n  readonly typeName: string | undefined;\n\n  constructor(variants: Variants, name?: string) {\n    function variantsArrayFromVariantsObj<Variants extends VariantsObj>(\n      variants: Variants\n    ) {\n      return (Object.keys(variants) as Array<keyof Variants>).map(key => ({\n        name: key as string,\n        // Lazily resolve the underlying object's algebraicType.\n        // This will call obj[key].algebraicType only when someone\n        // actually reads this property.\n        get algebraicType() {\n          return variants[key].algebraicType;\n        },\n      }));\n    }\n    super(\n      AlgebraicType.Sum({\n        variants: variantsArrayFromVariantsObj(variants),\n      })\n    );\n\n    this.variants = variants;\n    this.typeName = name;\n\n    for (const key of Object.keys(variants) as Array<keyof Variants & string>) {\n      const desc = Object.getOwnPropertyDescriptor(variants, key);\n\n      const isAccessor =\n        !!desc &&\n        (typeof desc.get === 'function' || typeof desc.set === 'function');\n\n      let isUnit = false;\n\n      if (!isAccessor) {\n        // Only read variants[key] if it's a *data* property\n        // otherwise assume non-unit because it's a getter\n        const variant = variants[key];\n        isUnit = variant instanceof UnitBuilder;\n      }\n\n      if (isUnit) {\n        // Unit: expose a read-only VALUE (no call)\n        const constant = this.create(key as any) as EnumValue<\n          typeof key,\n          Variants[typeof key]\n        >;\n        Object.defineProperty(this, key, {\n          value: constant,\n          writable: false,\n          enumerable: true,\n          configurable: false,\n        });\n      } else {\n        const fn = ((value: any) =>\n          this.create(key as any, value)) as VariantConstructor<\n          typeof key & string,\n          Variants[typeof key]\n        >;\n\n        Object.defineProperty(this, key, {\n          value: fn,\n          writable: false,\n          enumerable: true,\n          configurable: false,\n        });\n      }\n    }\n  }\n\n  /**\n   * Create a value of this sum type.\n   * - Unit variants: create('bar')\n   * - Payload variants: create('foo', value)\n   */\n  private create<K extends keyof Variants & string>(\n    tag: K\n  ): EnumValue<K, Variants[K]>;\n  private create<K extends keyof Variants & string>(\n    tag: K,\n    value: InferTypeOfTypeBuilder<Variants[K]>\n  ): EnumValue<K, Variants[K]>;\n  private create(tag: string, value?: unknown) {\n    return value === undefined ? { tag } : { tag, value };\n  }\n\n  default(\n    value: EnumType<Variants>\n  ): SumColumnBuilder<\n    Variants,\n    SetField<DefaultMetadata, 'defaultValue', any>\n  > {\n    return new SumColumnBuilder(\n      this,\n      set(defaultMetadata, { defaultValue: value })\n    );\n  }\n  name<const Name extends string>(\n    name: Name\n  ): SumColumnBuilder<Variants, SetField<DefaultMetadata, 'name', Name>> {\n    return new SumColumnBuilder(this, set(defaultMetadata, { name }));\n  }\n}\n\nexport const SumBuilder: {\n  new <Variants extends VariantsObj>(\n    variants: Variants,\n    name?: string\n  ): SumBuilder<Variants>;\n  [Symbol.hasInstance](x: any): x is SumBuilder<VariantsObj>;\n} = SumBuilderImpl as any;\n\nclass SimpleSumBuilderImpl<Variants extends SimpleVariantsObj>\n  extends SumBuilderImpl<Variants>\n  implements\n    Indexable<\n      EnumType<Variants>,\n      {\n        tag: 'Sum';\n        value: { variants: VariantsArrayFromVariantsObj<Variants> };\n      }\n    >,\n    PrimaryKeyable<\n      EnumType<Variants>,\n      {\n        tag: 'Sum';\n        value: { variants: VariantsArrayFromVariantsObj<Variants> };\n      }\n    >\n{\n  index(): SimpleSumColumnBuilder<\n    Variants,\n    SetField<DefaultMetadata, 'indexType', 'btree'>\n  >;\n  index<N extends NonNullable<IndexTypes>>(\n    algorithm: N\n  ): SimpleSumColumnBuilder<\n    Variants,\n    SetField<DefaultMetadata, 'indexType', N>\n  >;\n  index(\n    algorithm: IndexTypes = 'btree'\n  ): SimpleSumColumnBuilder<\n    Variants,\n    SetField<DefaultMetadata, 'indexType', IndexTypes>\n  > {\n    return new SimpleSumColumnBuilder(\n      this,\n      set(defaultMetadata, { indexType: algorithm })\n    );\n  }\n  primaryKey(): SimpleSumColumnBuilder<\n    Variants,\n    SetField<DefaultMetadata, 'isPrimaryKey', true>\n  > {\n    return new SimpleSumColumnBuilder(\n      this,\n      set(defaultMetadata, { isPrimaryKey: true })\n    );\n  }\n}\n\nexport const SimpleSumBuilder: {\n  new <Variants extends SimpleVariantsObj>(\n    variants: Variants,\n    name?: string\n  ): SimpleSumBuilderImpl<Variants> & SumBuilderVariantConstructors<Variants>;\n} = SimpleSumBuilderImpl as any;\n\nexport type SimpleSumBuilder<Variants extends SimpleVariantsObj> =\n  SimpleSumBuilderImpl<Variants> & SumBuilderVariantConstructors<Variants>;\n\nexport class ScheduleAtBuilder\n  extends TypeBuilder<ScheduleAt, ScheduleAtAlgebraicType>\n  implements\n    Defaultable<ScheduleAt, ScheduleAtAlgebraicType>,\n    Nameable<ScheduleAt, ScheduleAtAlgebraicType>\n{\n  constructor() {\n    super(ScheduleAt.getAlgebraicType());\n  }\n  default(\n    value: ScheduleAt\n  ): ScheduleAtColumnBuilder<\n    SetField<DefaultMetadata, 'defaultValue', ScheduleAt>\n  > {\n    return new ScheduleAtColumnBuilder(\n      this,\n      set(defaultMetadata, { defaultValue: value })\n    );\n  }\n  name<const Name extends string>(\n    name: Name\n  ): ScheduleAtColumnBuilder<SetField<DefaultMetadata, 'name', Name>> {\n    return new ScheduleAtColumnBuilder(this, set(defaultMetadata, { name }));\n  }\n}\n\nexport class IdentityBuilder\n  extends TypeBuilder<Identity, IdentityAlgebraicType>\n  implements\n    Indexable<Identity, IdentityAlgebraicType>,\n    Uniqueable<Identity, IdentityAlgebraicType>,\n    PrimaryKeyable<Identity, IdentityAlgebraicType>,\n    Defaultable<Identity, IdentityAlgebraicType>,\n    Nameable<Identity, IdentityAlgebraicType>\n{\n  constructor() {\n    super(Identity.getAlgebraicType());\n  }\n  index(): IdentityColumnBuilder<\n    SetField<DefaultMetadata, 'indexType', 'btree'>\n  >;\n  index<N extends NonNullable<IndexTypes>>(\n    algorithm: N\n  ): IdentityColumnBuilder<SetField<DefaultMetadata, 'indexType', N>>;\n  index(\n    algorithm: IndexTypes = 'btree'\n  ): IdentityColumnBuilder<SetField<DefaultMetadata, 'indexType', IndexTypes>> {\n    return new IdentityColumnBuilder(\n      this,\n      set(defaultMetadata, { indexType: algorithm })\n    );\n  }\n  unique(): IdentityColumnBuilder<SetField<DefaultMetadata, 'isUnique', true>> {\n    return new IdentityColumnBuilder(\n      this,\n      set(defaultMetadata, { isUnique: true })\n    );\n  }\n  primaryKey(): IdentityColumnBuilder<\n    SetField<DefaultMetadata, 'isPrimaryKey', true>\n  > {\n    return new IdentityColumnBuilder(\n      this,\n      set(defaultMetadata, { isPrimaryKey: true })\n    );\n  }\n  autoInc(): IdentityColumnBuilder<\n    SetField<DefaultMetadata, 'isAutoIncrement', true>\n  > {\n    return new IdentityColumnBuilder(\n      this,\n      set(defaultMetadata, { isAutoIncrement: true })\n    );\n  }\n  default(\n    value: Identity\n  ): IdentityColumnBuilder<\n    SetField<DefaultMetadata, 'defaultValue', Identity>\n  > {\n    return new IdentityColumnBuilder(\n      this,\n      set(defaultMetadata, { defaultValue: value })\n    );\n  }\n  name<const Name extends string>(\n    name: Name\n  ): IdentityColumnBuilder<SetField<DefaultMetadata, 'name', Name>> {\n    return new IdentityColumnBuilder(this, set(defaultMetadata, { name }));\n  }\n}\n\nexport class ConnectionIdBuilder\n  extends TypeBuilder<ConnectionId, ConnectionIdAlgebraicType>\n  implements\n    Indexable<ConnectionId, ConnectionIdAlgebraicType>,\n    Uniqueable<ConnectionId, ConnectionIdAlgebraicType>,\n    PrimaryKeyable<ConnectionId, ConnectionIdAlgebraicType>,\n    Defaultable<ConnectionId, ConnectionIdAlgebraicType>,\n    Nameable<ConnectionId, ConnectionIdAlgebraicType>\n{\n  constructor() {\n    super(ConnectionId.getAlgebraicType());\n  }\n  index(): ConnectionIdColumnBuilder<\n    SetField<DefaultMetadata, 'indexType', 'btree'>\n  >;\n  index<N extends NonNullable<IndexTypes>>(\n    algorithm: N\n  ): ConnectionIdColumnBuilder<SetField<DefaultMetadata, 'indexType', N>>;\n  index(\n    algorithm: IndexTypes = 'btree'\n  ): ConnectionIdColumnBuilder<\n    SetField<DefaultMetadata, 'indexType', IndexTypes>\n  > {\n    return new ConnectionIdColumnBuilder(\n      this,\n      set(defaultMetadata, { indexType: algorithm })\n    );\n  }\n  unique(): ConnectionIdColumnBuilder<\n    SetField<DefaultMetadata, 'isUnique', true>\n  > {\n    return new ConnectionIdColumnBuilder(\n      this,\n      set(defaultMetadata, { isUnique: true })\n    );\n  }\n  primaryKey(): ConnectionIdColumnBuilder<\n    SetField<DefaultMetadata, 'isPrimaryKey', true>\n  > {\n    return new ConnectionIdColumnBuilder(\n      this,\n      set(defaultMetadata, { isPrimaryKey: true })\n    );\n  }\n  autoInc(): ConnectionIdColumnBuilder<\n    SetField<DefaultMetadata, 'isAutoIncrement', true>\n  > {\n    return new ConnectionIdColumnBuilder(\n      this,\n      set(defaultMetadata, { isAutoIncrement: true })\n    );\n  }\n  default(\n    value: ConnectionId\n  ): ConnectionIdColumnBuilder<\n    SetField<DefaultMetadata, 'defaultValue', ConnectionId>\n  > {\n    return new ConnectionIdColumnBuilder(\n      this,\n      set(defaultMetadata, { defaultValue: value })\n    );\n  }\n  name<const Name extends string>(\n    name: Name\n  ): ConnectionIdColumnBuilder<SetField<DefaultMetadata, 'name', Name>> {\n    return new ConnectionIdColumnBuilder(this, set(defaultMetadata, { name }));\n  }\n}\n\nexport class TimestampBuilder\n  extends TypeBuilder<Timestamp, TimestampAlgebraicType>\n  implements\n    Indexable<Timestamp, TimestampAlgebraicType>,\n    Uniqueable<Timestamp, TimestampAlgebraicType>,\n    PrimaryKeyable<Timestamp, TimestampAlgebraicType>,\n    Defaultable<Timestamp, TimestampAlgebraicType>,\n    Nameable<Timestamp, TimestampAlgebraicType>\n{\n  constructor() {\n    super(Timestamp.getAlgebraicType());\n  }\n  index(): TimestampColumnBuilder<\n    SetField<DefaultMetadata, 'indexType', 'btree'>\n  >;\n  index<N extends NonNullable<IndexTypes>>(\n    algorithm: N\n  ): TimestampColumnBuilder<SetField<DefaultMetadata, 'indexType', N>>;\n  index(\n    algorithm: IndexTypes = 'btree'\n  ): TimestampColumnBuilder<\n    SetField<DefaultMetadata, 'indexType', IndexTypes>\n  > {\n    return new TimestampColumnBuilder(\n      this,\n      set(defaultMetadata, { indexType: algorithm })\n    );\n  }\n  unique(): TimestampColumnBuilder<\n    SetField<DefaultMetadata, 'isUnique', true>\n  > {\n    return new TimestampColumnBuilder(\n      this,\n      set(defaultMetadata, { isUnique: true })\n    );\n  }\n  primaryKey(): TimestampColumnBuilder<\n    SetField<DefaultMetadata, 'isPrimaryKey', true>\n  > {\n    return new TimestampColumnBuilder(\n      this,\n      set(defaultMetadata, { isPrimaryKey: true })\n    );\n  }\n  autoInc(): TimestampColumnBuilder<\n    SetField<DefaultMetadata, 'isAutoIncrement', true>\n  > {\n    return new TimestampColumnBuilder(\n      this,\n      set(defaultMetadata, { isAutoIncrement: true })\n    );\n  }\n  default(\n    value: Timestamp\n  ): TimestampColumnBuilder<\n    SetField<DefaultMetadata, 'defaultValue', Timestamp>\n  > {\n    return new TimestampColumnBuilder(\n      this,\n      set(defaultMetadata, { defaultValue: value })\n    );\n  }\n  name<const Name extends string>(\n    name: Name\n  ): TimestampColumnBuilder<SetField<DefaultMetadata, 'name', Name>> {\n    return new TimestampColumnBuilder(this, set(defaultMetadata, { name }));\n  }\n}\n\nexport class TimeDurationBuilder\n  extends TypeBuilder<TimeDuration, TimeDurationAlgebraicType>\n  implements\n    Indexable<TimeDuration, TimeDurationAlgebraicType>,\n    Uniqueable<TimeDuration, TimeDurationAlgebraicType>,\n    PrimaryKeyable<TimeDuration, TimeDurationAlgebraicType>,\n    Defaultable<TimeDuration, TimeDurationAlgebraicType>,\n    Nameable<TimeDuration, TimeDurationAlgebraicType>\n{\n  constructor() {\n    super(TimeDuration.getAlgebraicType());\n  }\n  index(): TimeDurationColumnBuilder<\n    SetField<DefaultMetadata, 'indexType', 'btree'>\n  >;\n  index<N extends NonNullable<IndexTypes>>(\n    algorithm: N\n  ): TimeDurationColumnBuilder<SetField<DefaultMetadata, 'indexType', N>>;\n  index(\n    algorithm: IndexTypes = 'btree'\n  ): TimeDurationColumnBuilder<\n    SetField<DefaultMetadata, 'indexType', IndexTypes>\n  > {\n    return new TimeDurationColumnBuilder(\n      this,\n      set(defaultMetadata, { indexType: algorithm })\n    );\n  }\n  unique(): TimeDurationColumnBuilder<\n    SetField<DefaultMetadata, 'isUnique', true>\n  > {\n    return new TimeDurationColumnBuilder(\n      this,\n      set(defaultMetadata, { isUnique: true })\n    );\n  }\n  primaryKey(): TimeDurationColumnBuilder<\n    SetField<DefaultMetadata, 'isPrimaryKey', true>\n  > {\n    return new TimeDurationColumnBuilder(\n      this,\n      set(defaultMetadata, { isPrimaryKey: true })\n    );\n  }\n  autoInc(): TimeDurationColumnBuilder<\n    SetField<DefaultMetadata, 'isAutoIncrement', true>\n  > {\n    return new TimeDurationColumnBuilder(\n      this,\n      set(defaultMetadata, { isAutoIncrement: true })\n    );\n  }\n  default(\n    value: TimeDuration\n  ): TimeDurationColumnBuilder<\n    SetField<DefaultMetadata, 'defaultValue', TimeDuration>\n  > {\n    return new TimeDurationColumnBuilder(\n      this,\n      set(defaultMetadata, { defaultValue: value })\n    );\n  }\n  name<const Name extends string>(\n    name: Name\n  ): TimeDurationColumnBuilder<SetField<DefaultMetadata, 'name', Name>> {\n    return new TimeDurationColumnBuilder(this, set(defaultMetadata, { name }));\n  }\n}\n\nexport class UuidBuilder\n  extends TypeBuilder<Uuid, UuidAlgebraicType>\n  implements\n    Indexable<Uuid, UuidAlgebraicType>,\n    Uniqueable<Uuid, UuidAlgebraicType>,\n    PrimaryKeyable<Uuid, UuidAlgebraicType>,\n    Defaultable<Uuid, UuidAlgebraicType>\n{\n  constructor() {\n    super(Uuid.getAlgebraicType());\n  }\n  index(): UuidColumnBuilder<SetField<DefaultMetadata, 'indexType', 'btree'>>;\n  index<N extends NonNullable<IndexTypes>>(\n    algorithm: N\n  ): UuidColumnBuilder<SetField<DefaultMetadata, 'indexType', N>>;\n  index(\n    algorithm: IndexTypes = 'btree'\n  ): UuidColumnBuilder<SetField<DefaultMetadata, 'indexType', IndexTypes>> {\n    return new UuidColumnBuilder(\n      this,\n      set(defaultMetadata, { indexType: algorithm })\n    );\n  }\n  unique(): UuidColumnBuilder<SetField<DefaultMetadata, 'isUnique', true>> {\n    return new UuidColumnBuilder(\n      this,\n      set(defaultMetadata, { isUnique: true })\n    );\n  }\n  primaryKey(): UuidColumnBuilder<\n    SetField<DefaultMetadata, 'isPrimaryKey', true>\n  > {\n    return new UuidColumnBuilder(\n      this,\n      set(defaultMetadata, { isPrimaryKey: true })\n    );\n  }\n  autoInc(): UuidColumnBuilder<\n    SetField<DefaultMetadata, 'isAutoIncrement', true>\n  > {\n    return new UuidColumnBuilder(\n      this,\n      set(defaultMetadata, { isAutoIncrement: true })\n    );\n  }\n  default(\n    value: Uuid\n  ): UuidColumnBuilder<SetField<DefaultMetadata, 'defaultValue', Uuid>> {\n    return new UuidColumnBuilder(\n      this,\n      set(defaultMetadata, { defaultValue: value })\n    );\n  }\n}\n\n/**\n * The type of index types that can be applied to a column.\n * `undefined` is the default\n */\nexport type IndexTypes = 'btree' | 'direct' | undefined;\n\n/**\n * Metadata describing column constraints and index type\n */\nexport type ColumnMetadata<Type = any> = {\n  isPrimaryKey?: true;\n  isUnique?: true;\n  isAutoIncrement?: true;\n  indexType?: IndexTypes;\n  defaultValue?: Type;\n  name?: string;\n};\n\n/**\n * Default metadata state type for a newly created column\n */\ntype DefaultMetadata = object;\n\n/**\n * Default metadata state value for a newly created column\n */\nconst defaultMetadata: ColumnMetadata<never> = {};\n\n/**\n * A column builder allows you to incrementally specify constraints\n * and metadata for a column in a type-safe way.\n *\n * It carries both a phantom TypeScript type (the `Type`) and\n * runtime algebraic type information.\n *\n * IMPORTANT! We have deliberately chosen to not have {@link ColumnBuilder}\n * extend {@link TypeBuilder} so that you cannot pass a {@link ColumnBuilder}\n * where a {@link TypeBuilder} is expected. i.e. We want to maintain\n * contravariance for functions that accept {@link TypeBuilder} parameters.\n */\nexport class ColumnBuilder<\n  Type,\n  SpacetimeType extends AlgebraicType,\n  M extends ColumnMetadata<Type> = DefaultMetadata,\n> {\n  typeBuilder: TypeBuilder<Type, SpacetimeType>;\n  columnMetadata: M;\n\n  constructor(typeBuilder: TypeBuilder<Type, SpacetimeType>, metadata: M) {\n    this.typeBuilder = typeBuilder;\n    this.columnMetadata = metadata;\n  }\n\n  serialize(writer: BinaryWriter, value: Type): void {\n    AlgebraicType.serializeValue(writer, this.typeBuilder.algebraicType, value);\n  }\n\n  deserialize(reader: BinaryReader): Type {\n    return AlgebraicType.deserializeValue(\n      reader,\n      this.typeBuilder.algebraicType\n    );\n  }\n}\n\nexport class U8ColumnBuilder<M extends ColumnMetadata<number> = DefaultMetadata>\n  extends ColumnBuilder<number, AlgebraicTypeVariants.U8, M>\n  implements\n    Indexable<number, AlgebraicTypeVariants.U8>,\n    Uniqueable<number, AlgebraicTypeVariants.U8>,\n    PrimaryKeyable<number, AlgebraicTypeVariants.U8>,\n    AutoIncrementable<number, AlgebraicTypeVariants.U8>,\n    Defaultable<number, AlgebraicTypeVariants.U8>,\n    Nameable<number, AlgebraicTypeVariants.U8>\n{\n  index(): U8ColumnBuilder<SetField<M, 'indexType', 'btree'>>;\n  index<N extends NonNullable<IndexTypes>>(\n    algorithm: N\n  ): U8ColumnBuilder<SetField<M, 'indexType', N>>;\n  index(\n    algorithm: IndexTypes = 'btree'\n  ): U8ColumnBuilder<SetField<M, 'indexType', IndexTypes>> {\n    return new U8ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { indexType: algorithm })\n    );\n  }\n  unique(): U8ColumnBuilder<SetField<M, 'isUnique', true>> {\n    return new U8ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { isUnique: true })\n    );\n  }\n  primaryKey(): U8ColumnBuilder<SetField<M, 'isPrimaryKey', true>> {\n    return new U8ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { isPrimaryKey: true })\n    );\n  }\n  autoInc(): U8ColumnBuilder<SetField<M, 'isAutoIncrement', true>> {\n    return new U8ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { isAutoIncrement: true as const })\n    );\n  }\n  default(value: number): U8ColumnBuilder<SetField<M, 'defaultValue', number>> {\n    return new U8ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, {\n        defaultValue: value,\n      })\n    );\n  }\n  name<const Name extends string>(\n    name: Name\n  ): U8ColumnBuilder<SetField<M, 'name', Name>> {\n    return new U8ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { name })\n    );\n  }\n}\n\nexport class U16ColumnBuilder<\n    M extends ColumnMetadata<number> = DefaultMetadata,\n  >\n  extends ColumnBuilder<number, AlgebraicTypeVariants.U16, M>\n  implements\n    Indexable<number, AlgebraicTypeVariants.U16>,\n    Uniqueable<number, AlgebraicTypeVariants.U16>,\n    PrimaryKeyable<number, AlgebraicTypeVariants.U16>,\n    AutoIncrementable<number, AlgebraicTypeVariants.U16>,\n    Defaultable<number, AlgebraicTypeVariants.U16>,\n    Nameable<number, AlgebraicTypeVariants.U16>\n{\n  index(): U16ColumnBuilder<SetField<M, 'indexType', 'btree'>>;\n  index<N extends NonNullable<IndexTypes>>(\n    algorithm: N\n  ): U16ColumnBuilder<SetField<M, 'indexType', N>>;\n  index(\n    algorithm: IndexTypes = 'btree'\n  ): U16ColumnBuilder<SetField<M, 'indexType', IndexTypes>> {\n    return new U16ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { indexType: algorithm })\n    );\n  }\n  unique(): U16ColumnBuilder<SetField<M, 'isUnique', true>> {\n    return new U16ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { isUnique: true })\n    );\n  }\n  primaryKey(): U16ColumnBuilder<SetField<M, 'isPrimaryKey', true>> {\n    return new U16ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { isPrimaryKey: true })\n    );\n  }\n  autoInc(): U16ColumnBuilder<SetField<M, 'isAutoIncrement', true>> {\n    return new U16ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { isAutoIncrement: true })\n    );\n  }\n  default(\n    value: number\n  ): U16ColumnBuilder<SetField<M, 'defaultValue', number>> {\n    return new U16ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, {\n        defaultValue: value,\n      })\n    );\n  }\n  name<const Name extends string>(\n    name: Name\n  ): U16ColumnBuilder<SetField<M, 'name', Name>> {\n    return new U16ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { name })\n    );\n  }\n}\n\nexport class U32ColumnBuilder<\n    M extends ColumnMetadata<number> = DefaultMetadata,\n  >\n  extends ColumnBuilder<number, AlgebraicTypeVariants.U32, M>\n  implements\n    Indexable<number, AlgebraicTypeVariants.U32>,\n    Uniqueable<number, AlgebraicTypeVariants.U32>,\n    PrimaryKeyable<number, AlgebraicTypeVariants.U32>,\n    AutoIncrementable<number, AlgebraicTypeVariants.U32>,\n    Defaultable<number, AlgebraicTypeVariants.U32>,\n    Nameable<number, AlgebraicTypeVariants.U32>\n{\n  index(): U32ColumnBuilder<SetField<M, 'indexType', 'btree'>>;\n  index<N extends NonNullable<IndexTypes>>(\n    algorithm: N\n  ): U32ColumnBuilder<SetField<M, 'indexType', N>>;\n  index(\n    algorithm: IndexTypes = 'btree'\n  ): U32ColumnBuilder<SetField<M, 'indexType', IndexTypes>> {\n    return new U32ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { indexType: algorithm })\n    );\n  }\n  unique(): U32ColumnBuilder<SetField<M, 'isUnique', true>> {\n    return new U32ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { isUnique: true })\n    );\n  }\n  primaryKey(): U32ColumnBuilder<SetField<M, 'isPrimaryKey', true>> {\n    return new U32ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { isPrimaryKey: true })\n    );\n  }\n  autoInc(): U32ColumnBuilder<SetField<M, 'isAutoIncrement', true>> {\n    return new U32ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { isAutoIncrement: true })\n    );\n  }\n  default(\n    value: number\n  ): U32ColumnBuilder<SetField<M, 'defaultValue', number>> {\n    return new U32ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, {\n        defaultValue: value,\n      })\n    );\n  }\n  name<const Name extends string>(\n    name: Name\n  ): U32ColumnBuilder<SetField<M, 'name', Name>> {\n    return new U32ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { name })\n    );\n  }\n}\n\nexport class U64ColumnBuilder<\n    M extends ColumnMetadata<bigint> = DefaultMetadata,\n  >\n  extends ColumnBuilder<bigint, AlgebraicTypeVariants.U64, M>\n  implements\n    Indexable<bigint, AlgebraicTypeVariants.U64>,\n    Uniqueable<bigint, AlgebraicTypeVariants.U64>,\n    PrimaryKeyable<bigint, AlgebraicTypeVariants.U64>,\n    AutoIncrementable<bigint, AlgebraicTypeVariants.U64>,\n    Defaultable<bigint, AlgebraicTypeVariants.U64>,\n    Nameable<bigint, AlgebraicTypeVariants.U64>\n{\n  index(): U64ColumnBuilder<SetField<M, 'indexType', 'btree'>>;\n  index<N extends NonNullable<IndexTypes>>(\n    algorithm: N\n  ): U64ColumnBuilder<SetField<M, 'indexType', N>>;\n  index(\n    algorithm: IndexTypes = 'btree'\n  ): U64ColumnBuilder<SetField<M, 'indexType', IndexTypes>> {\n    return new U64ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { indexType: algorithm })\n    );\n  }\n  unique(): U64ColumnBuilder<SetField<M, 'isUnique', true>> {\n    return new U64ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { isUnique: true })\n    );\n  }\n  primaryKey(): U64ColumnBuilder<SetField<M, 'isPrimaryKey', true>> {\n    return new U64ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { isPrimaryKey: true })\n    );\n  }\n  autoInc(): U64ColumnBuilder<SetField<M, 'isAutoIncrement', true>> {\n    return new U64ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { isAutoIncrement: true })\n    );\n  }\n  default(\n    value: bigint\n  ): U64ColumnBuilder<SetField<M, 'defaultValue', bigint>> {\n    return new U64ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, {\n        defaultValue: value,\n      })\n    );\n  }\n  name<const Name extends string>(\n    name: Name\n  ): U64ColumnBuilder<SetField<M, 'name', Name>> {\n    return new U64ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { name })\n    );\n  }\n}\n\nexport class U128ColumnBuilder<\n    M extends ColumnMetadata<bigint> = DefaultMetadata,\n  >\n  extends ColumnBuilder<bigint, AlgebraicTypeVariants.U128, M>\n  implements\n    Indexable<bigint, AlgebraicTypeVariants.U128>,\n    Uniqueable<bigint, AlgebraicTypeVariants.U128>,\n    PrimaryKeyable<bigint, AlgebraicTypeVariants.U128>,\n    AutoIncrementable<bigint, AlgebraicTypeVariants.U128>,\n    Defaultable<bigint, AlgebraicTypeVariants.U128>,\n    Nameable<bigint, AlgebraicTypeVariants.U128>\n{\n  index(): U128ColumnBuilder<SetField<M, 'indexType', 'btree'>>;\n  index<N extends NonNullable<IndexTypes>>(\n    algorithm: N\n  ): U128ColumnBuilder<SetField<M, 'indexType', N>>;\n  index(\n    algorithm: IndexTypes = 'btree'\n  ): U128ColumnBuilder<SetField<M, 'indexType', IndexTypes>> {\n    return new U128ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { indexType: algorithm })\n    );\n  }\n  unique(): U128ColumnBuilder<SetField<M, 'isUnique', true>> {\n    return new U128ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { isUnique: true })\n    );\n  }\n  primaryKey(): U128ColumnBuilder<SetField<M, 'isPrimaryKey', true>> {\n    return new U128ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { isPrimaryKey: true })\n    );\n  }\n  autoInc(): U128ColumnBuilder<SetField<M, 'isAutoIncrement', true>> {\n    return new U128ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { isAutoIncrement: true })\n    );\n  }\n  default(\n    value: bigint\n  ): U128ColumnBuilder<SetField<M, 'defaultValue', bigint>> {\n    return new U128ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, {\n        defaultValue: value,\n      })\n    );\n  }\n  name<const Name extends string>(\n    name: Name\n  ): U128ColumnBuilder<SetField<M, 'name', Name>> {\n    return new U128ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { name })\n    );\n  }\n}\n\nexport class U256ColumnBuilder<\n    M extends ColumnMetadata<bigint> = DefaultMetadata,\n  >\n  extends ColumnBuilder<bigint, AlgebraicTypeVariants.U256, M>\n  implements\n    Indexable<bigint, AlgebraicTypeVariants.U256>,\n    Uniqueable<bigint, AlgebraicTypeVariants.U256>,\n    PrimaryKeyable<bigint, AlgebraicTypeVariants.U256>,\n    AutoIncrementable<bigint, AlgebraicTypeVariants.U256>,\n    Defaultable<bigint, AlgebraicTypeVariants.U256>,\n    Nameable<bigint, AlgebraicTypeVariants.U256>\n{\n  index(): U256ColumnBuilder<SetField<M, 'indexType', 'btree'>>;\n  index<N extends NonNullable<IndexTypes>>(\n    algorithm: N\n  ): U256ColumnBuilder<SetField<M, 'indexType', N>>;\n  index(\n    algorithm: IndexTypes = 'btree'\n  ): U256ColumnBuilder<SetField<M, 'indexType', IndexTypes>> {\n    return new U256ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { indexType: algorithm })\n    );\n  }\n  unique(): U256ColumnBuilder<SetField<M, 'isUnique', true>> {\n    return new U256ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { isUnique: true })\n    );\n  }\n  primaryKey(): U256ColumnBuilder<SetField<M, 'isPrimaryKey', true>> {\n    return new U256ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { isPrimaryKey: true })\n    );\n  }\n  autoInc(): U256ColumnBuilder<SetField<M, 'isAutoIncrement', true>> {\n    return new U256ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { isAutoIncrement: true })\n    );\n  }\n  default(\n    value: bigint\n  ): U256ColumnBuilder<SetField<M, 'defaultValue', bigint>> {\n    return new U256ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, {\n        defaultValue: value,\n      })\n    );\n  }\n  name<const Name extends string>(\n    name: Name\n  ): U256ColumnBuilder<SetField<M, 'name', Name>> {\n    return new U256ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { name })\n    );\n  }\n}\n\nexport class I8ColumnBuilder<M extends ColumnMetadata<number> = DefaultMetadata>\n  extends ColumnBuilder<number, AlgebraicTypeVariants.I8, M>\n  implements\n    Indexable<number, AlgebraicTypeVariants.I8>,\n    Uniqueable<number, AlgebraicTypeVariants.I8>,\n    PrimaryKeyable<number, AlgebraicTypeVariants.I8>,\n    AutoIncrementable<number, AlgebraicTypeVariants.I8>,\n    Defaultable<number, AlgebraicTypeVariants.I8>,\n    Nameable<number, AlgebraicTypeVariants.I8>\n{\n  index(): I8ColumnBuilder<SetField<M, 'indexType', 'btree'>>;\n  index<N extends NonNullable<IndexTypes>>(\n    algorithm: N\n  ): I8ColumnBuilder<SetField<M, 'indexType', N>>;\n  index(\n    algorithm: IndexTypes = 'btree'\n  ): I8ColumnBuilder<SetField<M, 'indexType', IndexTypes>> {\n    return new I8ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { indexType: algorithm })\n    );\n  }\n  unique(): I8ColumnBuilder<SetField<M, 'isUnique', true>> {\n    return new I8ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { isUnique: true })\n    );\n  }\n  primaryKey(): I8ColumnBuilder<SetField<M, 'isPrimaryKey', true>> {\n    return new I8ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { isPrimaryKey: true })\n    );\n  }\n  autoInc(): I8ColumnBuilder<SetField<M, 'isAutoIncrement', true>> {\n    return new I8ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { isAutoIncrement: true })\n    );\n  }\n  default(value: number): I8ColumnBuilder<SetField<M, 'defaultValue', number>> {\n    return new I8ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, {\n        defaultValue: value,\n      })\n    );\n  }\n  name<const Name extends string>(\n    name: Name\n  ): I8ColumnBuilder<SetField<M, 'name', Name>> {\n    return new I8ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { name })\n    );\n  }\n}\n\nexport class I16ColumnBuilder<\n    M extends ColumnMetadata<number> = DefaultMetadata,\n  >\n  extends ColumnBuilder<number, AlgebraicTypeVariants.I16, M>\n  implements\n    Indexable<number, AlgebraicTypeVariants.I16>,\n    Uniqueable<number, AlgebraicTypeVariants.I16>,\n    PrimaryKeyable<number, AlgebraicTypeVariants.I16>,\n    AutoIncrementable<number, AlgebraicTypeVariants.I16>,\n    Defaultable<number, AlgebraicTypeVariants.I16>,\n    Nameable<number, AlgebraicTypeVariants.I16>\n{\n  index(): I16ColumnBuilder<SetField<M, 'indexType', 'btree'>>;\n  index<N extends NonNullable<IndexTypes>>(\n    algorithm: N\n  ): I16ColumnBuilder<SetField<M, 'indexType', N>>;\n  index(\n    algorithm: IndexTypes = 'btree'\n  ): I16ColumnBuilder<SetField<M, 'indexType', IndexTypes>> {\n    return new I16ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { indexType: algorithm })\n    );\n  }\n  unique(): I16ColumnBuilder<SetField<M, 'isUnique', true>> {\n    return new I16ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { isUnique: true })\n    );\n  }\n  primaryKey(): I16ColumnBuilder<SetField<M, 'isPrimaryKey', true>> {\n    return new I16ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { isPrimaryKey: true })\n    );\n  }\n  autoInc(): I16ColumnBuilder<SetField<M, 'isAutoIncrement', true>> {\n    return new I16ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { isAutoIncrement: true })\n    );\n  }\n  default(\n    value: number\n  ): I16ColumnBuilder<SetField<M, 'defaultValue', number>> {\n    return new I16ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, {\n        defaultValue: value,\n      })\n    );\n  }\n  name<const Name extends string>(\n    name: Name\n  ): I16ColumnBuilder<SetField<M, 'name', Name>> {\n    return new I16ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { name })\n    );\n  }\n}\n\nexport class I32ColumnBuilder<\n    M extends ColumnMetadata<number> = DefaultMetadata,\n  >\n  extends ColumnBuilder<number, AlgebraicTypeVariants.I32, M>\n  implements\n    Indexable<number, AlgebraicTypeVariants.I32>,\n    Uniqueable<number, AlgebraicTypeVariants.I32>,\n    PrimaryKeyable<number, AlgebraicTypeVariants.I32>,\n    AutoIncrementable<number, AlgebraicTypeVariants.I32>,\n    Defaultable<number, AlgebraicTypeVariants.I32>,\n    Nameable<number, AlgebraicTypeVariants.I32>\n{\n  index(): I32ColumnBuilder<SetField<M, 'indexType', 'btree'>>;\n  index<N extends NonNullable<IndexTypes>>(\n    algorithm: N\n  ): I32ColumnBuilder<SetField<M, 'indexType', N>>;\n  index(\n    algorithm: IndexTypes = 'btree'\n  ): I32ColumnBuilder<SetField<M, 'indexType', IndexTypes>> {\n    return new I32ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { indexType: algorithm })\n    );\n  }\n  unique(): I32ColumnBuilder<SetField<M, 'isUnique', true>> {\n    return new I32ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { isUnique: true })\n    );\n  }\n  primaryKey(): I32ColumnBuilder<SetField<M, 'isPrimaryKey', true>> {\n    return new I32ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { isPrimaryKey: true })\n    );\n  }\n  autoInc(): I32ColumnBuilder<SetField<M, 'isAutoIncrement', true>> {\n    return new I32ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { isAutoIncrement: true })\n    );\n  }\n  default(\n    value: number\n  ): I32ColumnBuilder<SetField<M, 'defaultValue', number>> {\n    return new I32ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, {\n        defaultValue: value,\n      })\n    );\n  }\n  name<const Name extends string>(\n    name: Name\n  ): I32ColumnBuilder<SetField<M, 'name', Name>> {\n    return new I32ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { name })\n    );\n  }\n}\n\nexport class I64ColumnBuilder<\n    M extends ColumnMetadata<bigint> = DefaultMetadata,\n  >\n  extends ColumnBuilder<bigint, AlgebraicTypeVariants.I64, M>\n  implements\n    Indexable<bigint, AlgebraicTypeVariants.I64>,\n    Uniqueable<bigint, AlgebraicTypeVariants.I64>,\n    PrimaryKeyable<bigint, AlgebraicTypeVariants.I64>,\n    AutoIncrementable<bigint, AlgebraicTypeVariants.I64>,\n    Defaultable<bigint, AlgebraicTypeVariants.I64>,\n    Nameable<bigint, AlgebraicTypeVariants.I64>\n{\n  index(): I64ColumnBuilder<SetField<M, 'indexType', 'btree'>>;\n  index<N extends NonNullable<IndexTypes>>(\n    algorithm: N\n  ): I64ColumnBuilder<SetField<M, 'indexType', N>>;\n  index(\n    algorithm: IndexTypes = 'btree'\n  ): I64ColumnBuilder<SetField<M, 'indexType', IndexTypes>> {\n    return new I64ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { indexType: algorithm })\n    );\n  }\n  unique(): I64ColumnBuilder<SetField<M, 'isUnique', true>> {\n    return new I64ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { isUnique: true })\n    );\n  }\n  primaryKey(): I64ColumnBuilder<SetField<M, 'isPrimaryKey', true>> {\n    return new I64ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { isPrimaryKey: true })\n    );\n  }\n  autoInc(): I64ColumnBuilder<SetField<M, 'isAutoIncrement', true>> {\n    return new I64ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { isAutoIncrement: true })\n    );\n  }\n  default(\n    value: bigint\n  ): I64ColumnBuilder<SetField<M, 'defaultValue', bigint>> {\n    return new I64ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, {\n        defaultValue: value,\n      })\n    );\n  }\n  name<const Name extends string>(\n    name: Name\n  ): I64ColumnBuilder<SetField<M, 'name', Name>> {\n    return new I64ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { name })\n    );\n  }\n}\n\nexport class I128ColumnBuilder<\n    M extends ColumnMetadata<bigint> = DefaultMetadata,\n  >\n  extends ColumnBuilder<bigint, AlgebraicTypeVariants.I128, M>\n  implements\n    Indexable<bigint, AlgebraicTypeVariants.I128>,\n    Uniqueable<bigint, AlgebraicTypeVariants.I128>,\n    PrimaryKeyable<bigint, AlgebraicTypeVariants.I128>,\n    AutoIncrementable<bigint, AlgebraicTypeVariants.I128>,\n    Defaultable<bigint, AlgebraicTypeVariants.I128>,\n    Nameable<bigint, AlgebraicTypeVariants.I128>\n{\n  index(): I128ColumnBuilder<SetField<M, 'indexType', 'btree'>>;\n  index<N extends NonNullable<IndexTypes>>(\n    algorithm: N\n  ): I128ColumnBuilder<SetField<M, 'indexType', N>>;\n  index(\n    algorithm: IndexTypes = 'btree'\n  ): I128ColumnBuilder<SetField<M, 'indexType', IndexTypes>> {\n    return new I128ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { indexType: algorithm })\n    );\n  }\n  unique(): I128ColumnBuilder<SetField<M, 'isUnique', true>> {\n    return new I128ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { isUnique: true })\n    );\n  }\n  primaryKey(): I128ColumnBuilder<SetField<M, 'isPrimaryKey', true>> {\n    return new I128ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { isPrimaryKey: true })\n    );\n  }\n  autoInc(): I128ColumnBuilder<SetField<M, 'isAutoIncrement', true>> {\n    return new I128ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { isAutoIncrement: true })\n    );\n  }\n  default(\n    value: bigint\n  ): I128ColumnBuilder<SetField<M, 'defaultValue', bigint>> {\n    return new I128ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, {\n        defaultValue: value,\n      })\n    );\n  }\n  name<const Name extends string>(\n    name: Name\n  ): I128ColumnBuilder<SetField<M, 'name', Name>> {\n    return new I128ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { name })\n    );\n  }\n}\n\nexport class I256ColumnBuilder<\n    M extends ColumnMetadata<bigint> = DefaultMetadata,\n  >\n  extends ColumnBuilder<bigint, AlgebraicTypeVariants.I256, M>\n  implements\n    Indexable<bigint, AlgebraicTypeVariants.I256>,\n    Uniqueable<bigint, AlgebraicTypeVariants.I256>,\n    PrimaryKeyable<bigint, AlgebraicTypeVariants.I256>,\n    AutoIncrementable<bigint, AlgebraicTypeVariants.I256>,\n    Defaultable<bigint, AlgebraicTypeVariants.I256>,\n    Nameable<bigint, AlgebraicTypeVariants.I256>\n{\n  index(): I256ColumnBuilder<SetField<M, 'indexType', 'btree'>>;\n  index<N extends NonNullable<IndexTypes>>(\n    algorithm: N\n  ): I256ColumnBuilder<SetField<M, 'indexType', N>>;\n  index(\n    algorithm: IndexTypes = 'btree'\n  ): I256ColumnBuilder<SetField<M, 'indexType', IndexTypes>> {\n    return new I256ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { indexType: algorithm })\n    );\n  }\n  unique(): I256ColumnBuilder<SetField<M, 'isUnique', true>> {\n    return new I256ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { isUnique: true })\n    );\n  }\n  primaryKey(): I256ColumnBuilder<SetField<M, 'isPrimaryKey', true>> {\n    return new I256ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { isPrimaryKey: true })\n    );\n  }\n  autoInc(): I256ColumnBuilder<SetField<M, 'isAutoIncrement', true>> {\n    return new I256ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { isAutoIncrement: true })\n    );\n  }\n  default(\n    value: bigint\n  ): I256ColumnBuilder<SetField<M, 'defaultValue', bigint>> {\n    return new I256ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, {\n        defaultValue: value,\n      })\n    );\n  }\n  name<const Name extends string>(\n    name: Name\n  ): I256ColumnBuilder<SetField<M, 'name', Name>> {\n    return new I256ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { name })\n    );\n  }\n}\n\nexport class F32ColumnBuilder<\n    M extends ColumnMetadata<number> = DefaultMetadata,\n  >\n  extends ColumnBuilder<number, AlgebraicTypeVariants.F32, M>\n  implements\n    Defaultable<number, AlgebraicTypeVariants.F32>,\n    Nameable<number, AlgebraicTypeVariants.F32>\n{\n  default(\n    value: number\n  ): F32ColumnBuilder<SetField<M, 'defaultValue', number>> {\n    return new F32ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, {\n        defaultValue: value,\n      })\n    );\n  }\n  name<const Name extends string>(\n    name: Name\n  ): F32ColumnBuilder<SetField<M, 'name', Name>> {\n    return new F32ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { name })\n    );\n  }\n}\n\nexport class F64ColumnBuilder<\n    M extends ColumnMetadata<number> = DefaultMetadata,\n  >\n  extends ColumnBuilder<number, AlgebraicTypeVariants.F64, M>\n  implements\n    Defaultable<number, AlgebraicTypeVariants.F64>,\n    Nameable<number, AlgebraicTypeVariants.F64>\n{\n  default(\n    value: number\n  ): F64ColumnBuilder<SetField<M, 'defaultValue', number>> {\n    return new F64ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, {\n        defaultValue: value,\n      })\n    );\n  }\n  name<const Name extends string>(\n    name: Name\n  ): F64ColumnBuilder<SetField<M, 'name', Name>> {\n    return new F64ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { name })\n    );\n  }\n}\n\nexport class BoolColumnBuilder<\n    M extends ColumnMetadata<boolean> = DefaultMetadata,\n  >\n  extends ColumnBuilder<boolean, AlgebraicTypeVariants.Bool, M>\n  implements\n    Indexable<boolean, AlgebraicTypeVariants.Bool>,\n    Uniqueable<boolean, AlgebraicTypeVariants.Bool>,\n    PrimaryKeyable<boolean, AlgebraicTypeVariants.Bool>,\n    Defaultable<boolean, AlgebraicTypeVariants.Bool>,\n    Nameable<boolean, AlgebraicTypeVariants.Bool>\n{\n  index(): BoolColumnBuilder<SetField<M, 'indexType', 'btree'>>;\n  index<N extends NonNullable<IndexTypes>>(\n    algorithm: N\n  ): BoolColumnBuilder<SetField<M, 'indexType', N>>;\n  index(\n    algorithm: IndexTypes = 'btree'\n  ): BoolColumnBuilder<SetField<M, 'indexType', IndexTypes>> {\n    return new BoolColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { indexType: algorithm })\n    );\n  }\n  unique(): BoolColumnBuilder<SetField<M, 'isUnique', true>> {\n    return new BoolColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { isUnique: true })\n    );\n  }\n  primaryKey(): BoolColumnBuilder<SetField<M, 'isPrimaryKey', true>> {\n    return new BoolColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { isPrimaryKey: true })\n    );\n  }\n  default(\n    value: boolean\n  ): BoolColumnBuilder<SetField<M, 'defaultValue', boolean>> {\n    return new BoolColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, {\n        defaultValue: value,\n      })\n    );\n  }\n  name<const Name extends string>(\n    name: Name\n  ): BoolColumnBuilder<SetField<M, 'name', Name>> {\n    return new BoolColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { name })\n    );\n  }\n}\n\nexport class StringColumnBuilder<\n    M extends ColumnMetadata<string> = DefaultMetadata,\n  >\n  extends ColumnBuilder<string, AlgebraicTypeVariants.String, M>\n  implements\n    Indexable<string, AlgebraicTypeVariants.String>,\n    Uniqueable<string, AlgebraicTypeVariants.String>,\n    PrimaryKeyable<string, AlgebraicTypeVariants.String>,\n    Defaultable<string, AlgebraicTypeVariants.String>,\n    Nameable<string, AlgebraicTypeVariants.String>\n{\n  index(): StringColumnBuilder<SetField<M, 'indexType', 'btree'>>;\n  index<N extends NonNullable<IndexTypes>>(\n    algorithm: N\n  ): StringColumnBuilder<SetField<M, 'indexType', N>>;\n  index(\n    algorithm: IndexTypes = 'btree'\n  ): StringColumnBuilder<SetField<M, 'indexType', IndexTypes>> {\n    return new StringColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { indexType: algorithm })\n    );\n  }\n  unique(): StringColumnBuilder<SetField<M, 'isUnique', true>> {\n    return new StringColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { isUnique: true })\n    );\n  }\n  primaryKey(): StringColumnBuilder<SetField<M, 'isPrimaryKey', true>> {\n    return new StringColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { isPrimaryKey: true })\n    );\n  }\n  default(\n    value: string\n  ): StringColumnBuilder<SetField<M, 'defaultValue', string>> {\n    return new StringColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, {\n        defaultValue: value,\n      })\n    );\n  }\n  name<const Name extends string>(\n    name: Name\n  ): StringColumnBuilder<SetField<M, 'name', Name>> {\n    return new StringColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { name })\n    );\n  }\n}\n\nexport class ArrayColumnBuilder<\n    Element extends TypeBuilder<any, any>,\n    M extends ColumnMetadata<\n      Array<InferTypeOfTypeBuilder<Element>>\n    > = DefaultMetadata,\n  >\n  extends ColumnBuilder<\n    Array<InferTypeOfTypeBuilder<Element>>,\n    { tag: 'Array'; value: InferSpacetimeTypeOfTypeBuilder<Element> },\n    M\n  >\n  implements\n    Defaultable<\n      Array<InferTypeOfTypeBuilder<Element>>,\n      AlgebraicTypeVariants.Array\n    >,\n    Nameable<\n      Array<InferTypeOfTypeBuilder<Element>>,\n      AlgebraicTypeVariants.Array\n    >\n{\n  default(\n    value: Array<InferTypeOfTypeBuilder<Element>>\n  ): ArrayColumnBuilder<\n    Element,\n    SetField<M, 'defaultValue', Array<InferTypeOfTypeBuilder<Element>>>\n  > {\n    return new ArrayColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, {\n        defaultValue: value,\n      })\n    );\n  }\n  name<const Name extends string>(\n    name: Name\n  ): ArrayColumnBuilder<Element, SetField<M, 'name', Name>> {\n    return new ArrayColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { name })\n    );\n  }\n}\n\ntype ByteArrayType = {\n  tag: 'Array';\n  value: AlgebraicTypeVariants.U8;\n};\n\nexport class ByteArrayColumnBuilder<\n    M extends ColumnMetadata<Uint8Array> = DefaultMetadata,\n  >\n  extends ColumnBuilder<Uint8Array, ByteArrayType, M>\n  implements\n    Defaultable<Uint8Array, ByteArrayType, M>,\n    Nameable<Uint8Array, ByteArrayType, M>\n{\n  constructor(metadata: M) {\n    super(new TypeBuilder(AlgebraicType.Array(AlgebraicType.U8)), metadata);\n  }\n  default(\n    value: Uint8Array\n  ): ByteArrayColumnBuilder<SetField<M, 'defaultValue', Uint8Array>> {\n    return new ByteArrayColumnBuilder(\n      set(this.columnMetadata, { defaultValue: value })\n    );\n  }\n  name<const Name extends string>(\n    name: Name\n  ): ByteArrayColumnBuilder<SetField<M, 'name', Name>> {\n    return new ByteArrayColumnBuilder(set(this.columnMetadata, { name }));\n  }\n}\n\nexport class OptionColumnBuilder<\n    Value extends TypeBuilder<any, any>,\n    M extends ColumnMetadata<\n      InferTypeOfTypeBuilder<Value> | undefined\n    > = DefaultMetadata,\n  >\n  extends ColumnBuilder<\n    InferTypeOfTypeBuilder<Value> | undefined,\n    OptionAlgebraicType<InferSpacetimeTypeOfTypeBuilder<Value>>,\n    M\n  >\n  implements\n    Defaultable<\n      InferTypeOfTypeBuilder<Value> | undefined,\n      OptionAlgebraicType<InferSpacetimeTypeOfTypeBuilder<Value>>\n    >,\n    Nameable<\n      InferTypeOfTypeBuilder<Value> | undefined,\n      OptionAlgebraicType<InferSpacetimeTypeOfTypeBuilder<Value>>\n    >\n{\n  default(\n    value: InferTypeOfTypeBuilder<Value> | undefined\n  ): OptionColumnBuilder<\n    Value,\n    SetField<M, 'defaultValue', InferTypeOfTypeBuilder<Value> | undefined>\n  > {\n    return new OptionColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, {\n        defaultValue: value,\n      })\n    );\n  }\n  name<const Name extends string>(\n    name: Name\n  ): OptionColumnBuilder<Value, SetField<M, 'name', Name>> {\n    return new OptionColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { name })\n    );\n  }\n}\n\nexport class ResultColumnBuilder<\n    Ok extends TypeBuilder<any, any>,\n    Err extends TypeBuilder<any, any>,\n    M extends ColumnMetadata<\n      InferTypeOfTypeBuilder<Ok> | InferTypeOfTypeBuilder<Err>\n    > = DefaultMetadata,\n  >\n  extends ColumnBuilder<\n    InferTypeOfTypeBuilder<Ok> | InferTypeOfTypeBuilder<Err>,\n    ResultAlgebraicType<\n      InferSpacetimeTypeOfTypeBuilder<Ok>,\n      InferSpacetimeTypeOfTypeBuilder<Err>\n    >,\n    M\n  >\n  implements\n    Defaultable<\n      InferTypeOfTypeBuilder<Ok> | InferTypeOfTypeBuilder<Err>,\n      ResultAlgebraicType<\n        InferSpacetimeTypeOfTypeBuilder<Ok>,\n        InferSpacetimeTypeOfTypeBuilder<Err>\n      >\n    >\n{\n  constructor(typeBuilder: TypeBuilder<any, any>, metadata: M) {\n    super(typeBuilder, metadata);\n  }\n\n  default(\n    value: InferTypeOfTypeBuilder<Ok> | InferTypeOfTypeBuilder<Err>\n  ): ResultColumnBuilder<\n    Ok,\n    Err,\n    SetField<\n      M,\n      'defaultValue',\n      InferTypeOfTypeBuilder<Ok> | InferTypeOfTypeBuilder<Err>\n    >\n  > {\n    return new ResultColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, {\n        defaultValue: value,\n      })\n    );\n  }\n}\n\nexport class ProductColumnBuilder<\n    Elements extends ElementsObj,\n    M extends ColumnMetadata<ObjectType<Elements>> = DefaultMetadata,\n  >\n  extends ColumnBuilder<\n    ObjectType<Elements>,\n    ElementsToProductType<Elements>,\n    M\n  >\n  implements\n    Defaultable<ObjectType<Elements>, ElementsToProductType<Elements>>,\n    Nameable<ObjectType<Elements>, ElementsToProductType<Elements>>\n{\n  default(\n    value: ObjectType<Elements>\n  ): ProductColumnBuilder<\n    Elements,\n    SetField<DefaultMetadata, 'defaultValue', any>\n  > {\n    return new ProductColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { defaultValue: value })\n    );\n  }\n  name<const Name extends string>(\n    name: Name\n  ): ProductColumnBuilder<Elements, SetField<DefaultMetadata, 'name', Name>> {\n    return new ProductColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { name })\n    );\n  }\n}\n\nexport class SumColumnBuilder<\n    Variants extends VariantsObj,\n    M extends ColumnMetadata<EnumType<Variants>> = DefaultMetadata,\n  >\n  extends ColumnBuilder<EnumType<Variants>, VariantsToSumType<Variants>, M>\n  implements\n    Defaultable<EnumType<Variants>, VariantsToSumType<Variants>>,\n    Nameable<EnumType<Variants>, VariantsToSumType<Variants>>\n{\n  default(\n    value: EnumType<Variants>\n  ): SumColumnBuilder<\n    Variants,\n    SetField<DefaultMetadata, 'defaultValue', any>\n  > {\n    return new SumColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { defaultValue: value })\n    );\n  }\n  name<const Name extends string>(\n    name: Name\n  ): SumColumnBuilder<Variants, SetField<DefaultMetadata, 'name', Name>> {\n    return new SumColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { name })\n    );\n  }\n}\n\nexport class SimpleSumColumnBuilder<\n    Variants extends VariantsObj,\n    M extends ColumnMetadata<EnumType<Variants>> = DefaultMetadata,\n  >\n  extends SumColumnBuilder<Variants, M>\n  implements\n    Indexable<EnumType<Variants>, AlgebraicTypeVariants.Sum>,\n    PrimaryKeyable<EnumType<Variants>, AlgebraicTypeVariants.Sum>\n{\n  index(): SimpleSumColumnBuilder<\n    Variants,\n    SetField<DefaultMetadata, 'indexType', 'btree'>\n  >;\n  index<N extends NonNullable<IndexTypes>>(\n    algorithm: N\n  ): SimpleSumColumnBuilder<\n    Variants,\n    SetField<DefaultMetadata, 'indexType', N>\n  >;\n  index(\n    algorithm: IndexTypes = 'btree'\n  ): SimpleSumColumnBuilder<\n    Variants,\n    SetField<DefaultMetadata, 'indexType', IndexTypes>\n  > {\n    return new SimpleSumColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { indexType: algorithm })\n    );\n  }\n  primaryKey(): SimpleSumColumnBuilder<\n    Variants,\n    SetField<DefaultMetadata, 'isPrimaryKey', true>\n  > {\n    return new SimpleSumColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { isPrimaryKey: true })\n    );\n  }\n}\n\nexport class ScheduleAtColumnBuilder<\n    M extends ColumnMetadata<ScheduleAt> = DefaultMetadata,\n  >\n  extends ColumnBuilder<ScheduleAt, ScheduleAtAlgebraicType, M>\n  implements\n    Defaultable<ScheduleAt, ScheduleAtAlgebraicType>,\n    Nameable<ScheduleAt, ScheduleAtAlgebraicType>\n{\n  default(\n    value: ScheduleAt\n  ): ScheduleAtColumnBuilder<SetField<M, 'defaultValue', ScheduleAt>> {\n    return new ScheduleAtColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { defaultValue: value })\n    );\n  }\n  name<const Name extends string>(\n    name: Name\n  ): ScheduleAtColumnBuilder<SetField<M, 'name', Name>> {\n    return new ScheduleAtColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { name })\n    );\n  }\n}\n\nexport class IdentityColumnBuilder<\n    M extends ColumnMetadata<Identity> = DefaultMetadata,\n  >\n  extends ColumnBuilder<Identity, IdentityAlgebraicType, M>\n  implements\n    Indexable<Identity, IdentityAlgebraicType>,\n    Uniqueable<Identity, IdentityAlgebraicType>,\n    PrimaryKeyable<Identity, IdentityAlgebraicType>,\n    Defaultable<Identity, IdentityAlgebraicType>,\n    Nameable<Identity, IdentityAlgebraicType>\n{\n  index(): IdentityColumnBuilder<SetField<M, 'indexType', 'btree'>>;\n  index<N extends NonNullable<IndexTypes>>(\n    algorithm: N\n  ): IdentityColumnBuilder<SetField<M, 'indexType', N>>;\n  index(\n    algorithm: IndexTypes = 'btree'\n  ): IdentityColumnBuilder<SetField<M, 'indexType', IndexTypes>> {\n    return new IdentityColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { indexType: algorithm })\n    );\n  }\n  unique(): IdentityColumnBuilder<SetField<M, 'isUnique', true>> {\n    return new IdentityColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { isUnique: true })\n    );\n  }\n  primaryKey(): IdentityColumnBuilder<SetField<M, 'isPrimaryKey', true>> {\n    return new IdentityColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { isPrimaryKey: true })\n    );\n  }\n  default(\n    value: Identity\n  ): IdentityColumnBuilder<SetField<M, 'defaultValue', Identity>> {\n    return new IdentityColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { defaultValue: value })\n    );\n  }\n  name<const Name extends string>(\n    name: Name\n  ): IdentityColumnBuilder<SetField<M, 'name', Name>> {\n    return new IdentityColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { name })\n    );\n  }\n}\n\nexport class ConnectionIdColumnBuilder<\n    M extends ColumnMetadata<ConnectionId> = DefaultMetadata,\n  >\n  extends ColumnBuilder<ConnectionId, ConnectionIdAlgebraicType, M>\n  implements\n    Indexable<ConnectionId, ConnectionIdAlgebraicType>,\n    Uniqueable<ConnectionId, ConnectionIdAlgebraicType>,\n    PrimaryKeyable<ConnectionId, ConnectionIdAlgebraicType>,\n    Defaultable<ConnectionId, ConnectionIdAlgebraicType>,\n    Nameable<ConnectionId, ConnectionIdAlgebraicType>\n{\n  index(): ConnectionIdColumnBuilder<SetField<M, 'indexType', 'btree'>>;\n  index<N extends NonNullable<IndexTypes>>(\n    algorithm: N\n  ): ConnectionIdColumnBuilder<SetField<M, 'indexType', N>>;\n  index(\n    algorithm: IndexTypes = 'btree'\n  ): ConnectionIdColumnBuilder<SetField<M, 'indexType', IndexTypes>> {\n    return new ConnectionIdColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { indexType: algorithm })\n    );\n  }\n  unique(): ConnectionIdColumnBuilder<SetField<M, 'isUnique', true>> {\n    return new ConnectionIdColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { isUnique: true })\n    );\n  }\n  primaryKey(): ConnectionIdColumnBuilder<SetField<M, 'isPrimaryKey', true>> {\n    return new ConnectionIdColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { isPrimaryKey: true })\n    );\n  }\n  default(\n    value: ConnectionId\n  ): ConnectionIdColumnBuilder<SetField<M, 'defaultValue', ConnectionId>> {\n    return new ConnectionIdColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { defaultValue: value })\n    );\n  }\n  name<const Name extends string>(\n    name: Name\n  ): ConnectionIdColumnBuilder<SetField<M, 'name', Name>> {\n    return new ConnectionIdColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { name })\n    );\n  }\n}\n\nexport class TimestampColumnBuilder<\n    M extends ColumnMetadata<Timestamp> = DefaultMetadata,\n  >\n  extends ColumnBuilder<Timestamp, TimestampAlgebraicType, M>\n  implements\n    Indexable<Timestamp, TimestampAlgebraicType>,\n    Uniqueable<Timestamp, TimestampAlgebraicType>,\n    PrimaryKeyable<Timestamp, TimestampAlgebraicType>,\n    Defaultable<Timestamp, TimestampAlgebraicType>,\n    Nameable<Timestamp, TimestampAlgebraicType>\n{\n  index(): TimestampColumnBuilder<SetField<M, 'indexType', 'btree'>>;\n  index<N extends NonNullable<IndexTypes>>(\n    algorithm: N\n  ): TimestampColumnBuilder<SetField<M, 'indexType', N>>;\n  index(\n    algorithm: IndexTypes = 'btree'\n  ): TimestampColumnBuilder<SetField<M, 'indexType', IndexTypes>> {\n    return new TimestampColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { indexType: algorithm })\n    );\n  }\n  unique(): TimestampColumnBuilder<SetField<M, 'isUnique', true>> {\n    return new TimestampColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { isUnique: true })\n    );\n  }\n  primaryKey(): TimestampColumnBuilder<SetField<M, 'isPrimaryKey', true>> {\n    return new TimestampColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { isPrimaryKey: true })\n    );\n  }\n  default(\n    value: Timestamp\n  ): TimestampColumnBuilder<SetField<M, 'defaultValue', Timestamp>> {\n    return new TimestampColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { defaultValue: value })\n    );\n  }\n  name<const Name extends string>(\n    name: Name\n  ): TimestampColumnBuilder<SetField<M, 'name', Name>> {\n    return new TimestampColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { name })\n    );\n  }\n}\n\nexport class TimeDurationColumnBuilder<\n    M extends ColumnMetadata<TimeDuration> = DefaultMetadata,\n  >\n  extends ColumnBuilder<TimeDuration, TimeDurationAlgebraicType, M>\n  implements\n    Indexable<TimeDuration, TimeDurationAlgebraicType>,\n    Uniqueable<TimeDuration, TimeDurationAlgebraicType>,\n    PrimaryKeyable<TimeDuration, TimeDurationAlgebraicType>,\n    Defaultable<TimeDuration, TimeDurationAlgebraicType>,\n    Nameable<TimeDuration, TimeDurationAlgebraicType>\n{\n  index(): TimeDurationColumnBuilder<SetField<M, 'indexType', 'btree'>>;\n  index<N extends NonNullable<IndexTypes>>(\n    algorithm: N\n  ): TimeDurationColumnBuilder<SetField<M, 'indexType', N>>;\n  index(\n    algorithm: IndexTypes = 'btree'\n  ): TimeDurationColumnBuilder<SetField<M, 'indexType', IndexTypes>> {\n    return new TimeDurationColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { indexType: algorithm })\n    );\n  }\n  unique(): TimeDurationColumnBuilder<SetField<M, 'isUnique', true>> {\n    return new TimeDurationColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { isUnique: true })\n    );\n  }\n  primaryKey(): TimeDurationColumnBuilder<SetField<M, 'isPrimaryKey', true>> {\n    return new TimeDurationColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { isPrimaryKey: true })\n    );\n  }\n  default(\n    value: TimeDuration\n  ): TimeDurationColumnBuilder<SetField<M, 'defaultValue', TimeDuration>> {\n    return new TimeDurationColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { defaultValue: value })\n    );\n  }\n  name<const Name extends string>(\n    name: Name\n  ): TimeDurationColumnBuilder<SetField<M, 'name', Name>> {\n    return new TimeDurationColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { name })\n    );\n  }\n}\n\nexport class UuidColumnBuilder<M extends ColumnMetadata<Uuid> = DefaultMetadata>\n  extends ColumnBuilder<Uuid, UuidAlgebraicType, M>\n  implements\n    Indexable<Uuid, UuidAlgebraicType>,\n    Uniqueable<Uuid, UuidAlgebraicType>,\n    PrimaryKeyable<Uuid, UuidAlgebraicType>,\n    Defaultable<Uuid, UuidAlgebraicType>\n{\n  index(): UuidColumnBuilder<SetField<M, 'indexType', 'btree'>>;\n  index<N extends NonNullable<IndexTypes>>(\n    algorithm: N\n  ): UuidColumnBuilder<SetField<M, 'indexType', N>>;\n  index(\n    algorithm: IndexTypes = 'btree'\n  ): UuidColumnBuilder<SetField<M, 'indexType', IndexTypes>> {\n    return new UuidColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { indexType: algorithm })\n    );\n  }\n  unique(): UuidColumnBuilder<SetField<M, 'isUnique', true>> {\n    return new UuidColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { isUnique: true })\n    );\n  }\n  primaryKey(): UuidColumnBuilder<SetField<M, 'isPrimaryKey', true>> {\n    return new UuidColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { isPrimaryKey: true })\n    );\n  }\n  default(value: Uuid): UuidColumnBuilder<SetField<M, 'defaultValue', Uuid>> {\n    return new UuidColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { defaultValue: value })\n    );\n  }\n}\n\nexport class RefBuilder<Type, SpacetimeType> extends TypeBuilder<\n  Type,\n  AlgebraicTypeVariants.Ref\n> {\n  readonly ref: number;\n  /** The phantom type of the pointee of this ref. */\n  private readonly __spacetimeType!: SpacetimeType;\n  constructor(ref: number) {\n    super(AlgebraicType.Ref(ref));\n    this.ref = ref;\n  }\n}\n\ninterface EnumFn {\n  /**\n   * Creates a simple sum type whose cases are all unit variants.\n   * Each string in the array becomes a case of the enum.\n   *\n   * Example:\n   * ```ts\n   * t.enum(\"Color\", [\"red\", \"green\", \"blue\"]);\n   * ```\n   */\n  <Case extends string>(\n    name: string,\n    cases: readonly [Case, ...Case[]]\n  ): SimpleSumBuilderImpl<Record<Case, UnitBuilder>>;\n\n  /**\n   * Creates an empty simple sum type (no cases, equivalent to `never`).\n   * This can be useful for code generation or placeholder types.\n   * Example:\n   * ```ts\n   * t.enum(\"Never\", []);\n   * ```\n   */\n  (name: string, cases: []): SimpleSumBuilderImpl<Record<never, UnitBuilder>>;\n\n  /**\n   * Creates a full sum type, where each case can have a payload.\n   * Each value in the object must be a {@link TypeBuilder}.\n   *\n   * Example:\n   * ```ts\n   * t.enum(\"Result\", { Ok: t.unit(), Err: t.string() });\n   * ```\n   */\n  <Obj extends VariantsObj>(name: string, obj: Obj): SumBuilder<Obj>;\n}\n\nconst enumImpl = ((nameOrObj: any, maybeObj?: any) => {\n  let obj: any = nameOrObj;\n  let name: string | undefined = undefined;\n\n  if (typeof nameOrObj === 'string') {\n    if (!maybeObj) {\n      throw new TypeError(\n        'When providing a name, you must also provide the variants object or array.'\n      );\n    }\n    obj = maybeObj;\n    name = nameOrObj;\n  }\n\n  // Simple sum (array form)\n  if (Array.isArray(obj)) {\n    const simpleVariantsObj: Record<string, UnitBuilder> = {};\n    for (const variant of obj) {\n      simpleVariantsObj[variant] = new UnitBuilder();\n    }\n    return new SimpleSumBuilderImpl(simpleVariantsObj, name);\n  }\n\n  // Regular sum (object form)\n  return new SumBuilder(obj, name);\n}) as EnumFn;\n\n/**\n * A collection of factory functions for creating various SpacetimeDB algebraic types\n * to be used in table definitions. Each function returns a corresponding builder\n * for a specific type, such as `BoolBuilder`, `StringBuilder`, or `F64Builder`.\n *\n * These builders are used to define the schema of tables in SpacetimeDB, and each\n * builder implements the {@link TypeBuilder} interface, allowing for type-safe\n * schema construction in TypeScript.\n *\n * @remarks\n * - Primitive types (e.g., `bool`, `string`, `number`) map to their respective TypeScript types.\n * - Integer and floating-point types (e.g., `i8`, `u64`, `f32`) are represented as `number` or `bigint` in TypeScript.\n * - Complex types such as `object`, `array`, and `enum` allow for nested and structured schemas.\n * - The `scheduleAt` builder is a special column type for scheduling.\n *\n * @see {@link TypeBuilder}\n */\nexport const t = {\n  /**\n   * Creates a new `Bool` {@link AlgebraicType} to be used in table definitions\n   * Represented as `boolean` in TypeScript.\n   * @returns A new {@link BoolBuilder} instance\n   */\n  bool: (): BoolBuilder => new BoolBuilder(),\n\n  /**\n   * Creates a new `String` {@link AlgebraicType} to be used in table definitions\n   * Represented as `string` in TypeScript.\n   * @returns A new {@link StringBuilder} instance\n   */\n  string: (): StringBuilder => new StringBuilder(),\n\n  /**\n   * Creates a new `F64` {@link AlgebraicType} to be used in table definitions\n   * Represented as `number` in TypeScript.\n   * @returns A new {@link F64Builder} instance\n   */\n  number: (): F64Builder => new F64Builder(),\n\n  /**\n   * Creates a new `I8` {@link AlgebraicType} to be used in table definitions\n   * Represented as `number` in TypeScript.\n   * @returns A new {@link I8Builder} instance\n   */\n  i8: (): I8Builder => new I8Builder(),\n\n  /**\n   * Creates a new `U8` {@link AlgebraicType} to be used in table definitions\n   * Represented as `number` in TypeScript.\n   * @returns A new {@link U8Builder} instance\n   */\n  u8: (): U8Builder => new U8Builder(),\n\n  /**\n   * Creates a new `I16` {@link AlgebraicType} to be used in table definitions\n   * Represented as `number` in TypeScript.\n   * @returns A new {@link I16Builder} instance\n   */\n  i16: (): I16Builder => new I16Builder(),\n\n  /**\n   * Creates a new `U16` {@link AlgebraicType} to be used in table definitions\n   * Represented as `number` in TypeScript.\n   * @returns A new {@link U16Builder} instance\n   */\n  u16: (): U16Builder => new U16Builder(),\n\n  /**\n   * Creates a new `I32` {@link AlgebraicType} to be used in table definitions\n   * Represented as `number` in TypeScript.\n   * @returns A new {@link I32Builder} instance\n   */\n  i32: (): I32Builder => new I32Builder(),\n\n  /**\n   * Creates a new `U32` {@link AlgebraicType} to be used in table definitions\n   * Represented as `number` in TypeScript.\n   * @returns A new {@link U32Builder} instance\n   */\n  u32: (): U32Builder => new U32Builder(),\n\n  /**\n   * Creates a new `I64` {@link AlgebraicType} to be used in table definitions\n   * Represented as `bigint` in TypeScript.\n   * @returns A new {@link I64Builder} instance\n   */\n  i64: (): I64Builder => new I64Builder(),\n\n  /**\n   * Creates a new `U64` {@link AlgebraicType} to be used in table definitions\n   * Represented as `bigint` in TypeScript.\n   * @returns A new {@link U64Builder} instance\n   */\n  u64: (): U64Builder => new U64Builder(),\n\n  /**\n   * Creates a new `I128` {@link AlgebraicType} to be used in table definitions\n   * Represented as `bigint` in TypeScript.\n   * @returns A new {@link I128Builder} instance\n   */\n  i128: (): I128Builder => new I128Builder(),\n\n  /**\n   * Creates a new `U128` {@link AlgebraicType} to be used in table definitions\n   * Represented as `bigint` in TypeScript.\n   * @returns A new {@link U128Builder} instance\n   */\n  u128: (): U128Builder => new U128Builder(),\n\n  /**\n   * Creates a new `I256` {@link AlgebraicType} to be used in table definitions\n   * Represented as `bigint` in TypeScript.\n   * @returns A new {@link I256Builder} instance\n   */\n  i256: (): I256Builder => new I256Builder(),\n\n  /**\n   * Creates a new `U256` {@link AlgebraicType} to be used in table definitions\n   * Represented as `bigint` in TypeScript.\n   * @returns A new {@link U256Builder} instance\n   */\n  u256: (): U256Builder => new U256Builder(),\n\n  /**\n   * Creates a new `F32` {@link AlgebraicType} to be used in table definitions\n   * Represented as `number` in TypeScript.\n   * @returns A new {@link F32Builder} instance\n   */\n  f32: (): F32Builder => new F32Builder(),\n\n  /**\n   * Creates a new `F64` {@link AlgebraicType} to be used in table definitions\n   * Represented as `number` in TypeScript.\n   * @returns A new {@link F64Builder} instance\n   */\n  f64: (): F64Builder => new F64Builder(),\n\n  /**\n   * Creates a new `Product` {@link AlgebraicType} to be used in table definitions. Product types in SpacetimeDB\n   * are essentially the same as objects in JavaScript/TypeScript.\n   * Properties of the object must also be {@link TypeBuilder}s.\n   * Represented as an object with specific properties in TypeScript.\n   *\n   * @param name (optional) A display name for the product type. If omitted, an anonymous product type is created.\n   * @param obj The object defining the properties of the type, whose property\n   * values must be {@link TypeBuilder}s.\n   * @returns A new {@link ProductBuilder} instance.\n   */\n  object: ((nameOrObj: any, maybeObj?: any) => {\n    if (typeof nameOrObj === 'string') {\n      if (!maybeObj) {\n        throw new TypeError(\n          'When providing a name, you must also provide the object.'\n        );\n      }\n      return new ProductBuilder(maybeObj, nameOrObj);\n    }\n    return new ProductBuilder(nameOrObj, undefined);\n  }) as {\n    <Obj extends ElementsObj>(name: string, obj: Obj): ProductBuilder<Obj>;\n    // TODO: Currently names are not optional\n    // <Obj extends ElementsObj>(obj: Obj): ProductBuilder<Obj>;\n  },\n\n  /**\n   * Creates a new `Row` {@link AlgebraicType} to be used in table definitions. Row types in SpacetimeDB\n   * are similar to `Product` types, but are specifically used to define the schema of a table row.\n   * Properties of the object must also be {@link TypeBuilder} or {@link ColumnBuilder}s.\n   *\n   * You can represent a `Row` as either a {@link RowObj} or an {@link RowBuilder} type when\n   * defining a table schema.\n   *\n   * The {@link RowBuilder} type is useful when you want to create a type which can be used anywhere\n   * a {@link TypeBuilder} is accepted, such as in nested objects or arrays, or as the argument\n   * to a scheduled function.\n   *\n   * @param obj The object defining the properties of the row, whose property\n   * values must be {@link TypeBuilder}s or {@link ColumnBuilder}s.\n   * @returns A new {@link RowBuilder} instance\n   */\n  row: (<Obj extends RowObj>(\n    nameOrObj: string | Obj,\n    maybeObj?: Obj\n  ): RowBuilder<Obj> => {\n    const [obj, name] =\n      typeof nameOrObj === 'string'\n        ? [maybeObj!, nameOrObj]\n        : [nameOrObj, undefined];\n    return new RowBuilder(obj, name);\n  }) as {\n    <Obj extends RowObj>(obj: Obj): RowBuilder<Obj>;\n    <Obj extends RowObj>(name: string, obj: Obj): RowBuilder<Obj>;\n  },\n\n  /**\n   * Creates a new `Array` {@link AlgebraicType} to be used in table definitions.\n   * Represented as an array in TypeScript.\n   * @param element The element type of the array, which must be a `TypeBuilder`.\n   * @returns A new {@link ArrayBuilder} instance\n   */\n  array<Element extends TypeBuilder<any, any>>(\n    e: Element\n  ): ArrayBuilder<Element> {\n    return new ArrayBuilder(e);\n  },\n\n  enum: enumImpl,\n\n  /**\n   * This is a special helper function for conveniently creating {@link Product} type columns with no fields.\n   *\n   * @returns A new {@link ProductBuilder} instance with no fields.\n   */\n  unit(): UnitBuilder {\n    return new UnitBuilder();\n  },\n\n  /**\n   * Creates a lazily-evaluated {@link TypeBuilder}. This is useful for creating\n   * recursive types, such as a tree or linked list.\n   * @param thunk A function that returns a {@link TypeBuilder}.\n   * @returns A proxy {@link TypeBuilder} that evaluates the thunk on first access.\n   */\n  lazy<Build extends () => TypeBuilder<any, any>>(\n    thunk: Build\n  ): ReturnType<Build> {\n    type B = ReturnType<Build>;\n    let cached: B | null = null;\n    const get = (): B => (cached ??= thunk() as B);\n\n    const proxy = new Proxy({} as unknown as B, {\n      get(_t, prop, recv) {\n        const target = get() as any;\n        const val = Reflect.get(target, prop, recv);\n        return typeof val === 'function' ? val.bind(target) : val;\n      },\n      set(_t, prop, value, recv) {\n        return Reflect.set(get() as any, prop, value, recv);\n      },\n      has(_t, prop) {\n        return prop in (get() as any);\n      },\n      ownKeys() {\n        return Reflect.ownKeys(get() as any);\n      },\n      getOwnPropertyDescriptor(_t, prop) {\n        return Object.getOwnPropertyDescriptor(get() as any, prop);\n      },\n      getPrototypeOf() {\n        // makes `instanceof TypeBuilder` work if you care about it\n        return Object.getPrototypeOf(get() as any);\n      },\n    }) as B;\n\n    return proxy;\n  },\n\n  /**\n   * This is a special helper function for conveniently creating {@link ScheduleAt} type columns.\n   * @returns A new ColumnBuilder instance with the {@link ScheduleAt} type.\n   */\n  scheduleAt: (): ScheduleAtBuilder => {\n    return new ScheduleAtBuilder();\n  },\n\n  /**\n   * This is a convenience method for creating a column with the {@link Option} type.\n   * You can create a column of the same type by constructing an enum with a `some` and `none` variant.\n   * @param value The type of the value contained in the `some` variant of the `Option`.\n   * @returns A new {@link OptionBuilder} instance with the {@link Option} type.\n   */\n  option<Value extends TypeBuilder<any, any>>(\n    value: Value\n  ): OptionBuilder<Value> {\n    return new OptionBuilder(value);\n  },\n\n  /**\n   * This is a convenience method for creating a column with the {@link Result} type.\n   * You can create a column of the same type by constructing an enum with an `ok` and `err` variant.\n   * @param ok The type of the value contained in the `ok` variant of the `Result`.\n   * @param err The type of the value contained in the `err` variant of the `Result`.\n   * @returns A new {@link ResultBuilder} instance with the {@link Result} type.\n   */\n  result<Ok extends TypeBuilder<any, any>, Err extends TypeBuilder<any, any>>(\n    ok: Ok,\n    err: Err\n  ): ResultBuilder<Ok, Err> {\n    return new ResultBuilder(ok, err);\n  },\n\n  /**\n   * This is a convenience method for creating a column with the {@link Identity} type.\n   * You can create a column of the same type by constructing an `object` with a single `__identity__` element.\n   * @returns A new {@link TypeBuilder} instance with the {@link Identity} type.\n   */\n  identity: (): IdentityBuilder => {\n    return new IdentityBuilder();\n  },\n\n  /**\n   * This is a convenience method for creating a column with the {@link ConnectionId} type.\n   * You can create a column of the same type by constructing an `object` with a single `__connection_id__` element.\n   * @returns A new {@link TypeBuilder} instance with the {@link ConnectionId} type.\n   */\n  connectionId: (): ConnectionIdBuilder => {\n    return new ConnectionIdBuilder();\n  },\n\n  /**\n   * This is a convenience method for creating a column with the {@link Timestamp} type.\n   * You can create a column of the same type by constructing an `object` with a single `__timestamp_micros_since_unix_epoch__` element.\n   * @returns A new {@link TypeBuilder} instance with the {@link Timestamp} type.\n   */\n  timestamp: (): TimestampBuilder => {\n    return new TimestampBuilder();\n  },\n\n  /**\n   * This is a convenience method for creating a column with the {@link TimeDuration} type.\n   * You can create a column of the same type by constructing an `object` with a single `__time_duration_micros__` element.\n   * @returns A new {@link TypeBuilder} instance with the {@link TimeDuration} type.\n   */\n  timeDuration: (): TimeDurationBuilder => {\n    return new TimeDurationBuilder();\n  },\n\n  /**\n   * This is a convenience method for creating a column with the {@link Uuid} type.\n   * You can create a column of the same type by constructing an `object` with a single `__uuid__` element.\n   * @returns A new {@link TypeBuilder} instance with the {@link Uuid} type.\n   */\n  uuid: (): UuidBuilder => {\n    return new UuidBuilder();\n  },\n\n  /**\n   * This is a convenience method for creating a column with the {@link ByteArray} type.\n   * You can create a column of the same type by constructing an `array` of `u8`.\n   * The TypeScript representation is {@link Uint8Array}.\n   * @returns A new {@link ByteArrayBuilder} instance with the {@link ByteArray} type.\n   */\n  byteArray: (): ByteArrayBuilder => {\n    return new ByteArrayBuilder();\n  },\n} as const;\nexport default t;\n","// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE\n// WILL NOT BE SAVED. MODIFY TABLES IN YOUR MODULE SOURCE CODE INSTEAD.\n\n/* eslint-disable */\n/* tslint:disable */\nimport {\n  TypeBuilder as __TypeBuilder,\n  t as __t,\n  type AlgebraicTypeType as __AlgebraicTypeType,\n  type Infer as __Infer,\n} from '../../lib/type_builders';\n\n// The tagged union or sum type for the algebraic type `Lifecycle`.\nconst Lifecycle = __t.enum('Lifecycle', {\n  Init: __t.unit(),\n  OnConnect: __t.unit(),\n  OnDisconnect: __t.unit(),\n});\n\nexport default Lifecycle;\n","import { ProductType } from './algebraic_type';\nimport Lifecycle from './autogen/lifecycle_type';\nimport type RawReducerDefV9 from './autogen/raw_reducer_def_v_9_type';\nimport type { ConnectionId } from './connection_id';\nimport type { Identity } from './identity';\nimport { type Timestamp } from './timestamp';\nimport type { UntypedReducersDef } from '../sdk/reducers';\nimport type { DbView } from '../server/db_view';\nimport {\n  MODULE_DEF,\n  registerTypesRecursively,\n  resolveType,\n  type UntypedSchemaDef,\n} from './schema';\nimport {\n  ColumnBuilder,\n  RowBuilder,\n  type Infer,\n  type InferTypeOfRow,\n  type RowObj,\n  type TypeBuilder,\n} from './type_builders';\nimport type { ReducerSchema } from './reducer_schema';\nimport { toCamelCase, toPascalCase } from './util';\nimport type { CamelCase } from './type_util';\nimport { Uuid } from './uuid.ts';\n\n/**\n * Helper to extract the parameter types from an object type\n */\nexport type ParamsObj = Record<\n  string,\n  TypeBuilder<any, any> | ColumnBuilder<any, any, any>\n>;\n\n/**\n * Helper to convert a ParamsObj or RowObj into an object type\n */\ntype ParamsAsObject<ParamDef extends ParamsObj> = InferTypeOfRow<ParamDef>;\n\n/**\n * Defines a SpacetimeDB reducer function.\n * Reducers are the primary way to modify the state of your SpacetimeDB application.\n * They are atomic, meaning that either all operations within a reducer succeed,\n * or none of them do.\n * @template S - The inferred schema type of the SpacetimeDB module.\n * @template Params - The type of the parameters object expected by the reducer.\n * @param ctx - The reducer context, providing access to `sender`, `timestamp`, `connection_id`, and `db`.\n * @param payload - An object containing the arguments passed to the reducer, typed according to `params`.\n * @example\n * ```typescript\n * // Define a reducer named 'create_user' that takes 'username' (string) and 'email' (string)\n * reducer(\n *   'create_user',\n *   {\n *    username: t.string(),\n *    email: t.string(),\n *   },\n *   (ctx, { username, email }) => {\n *     // Access the 'user' table from the database view in the context\n *     ctx.db.user.insert({ username, email, created_at: ctx.timestamp });\n *     console.log(`User ${username} created by ${ctx.sender.identityId}`);\n *   }\n * );\n * ```\n */\nexport type Reducer<S extends UntypedSchemaDef, Params extends ParamsObj> = (\n  ctx: ReducerCtx<S>,\n  payload: ParamsAsObject<Params>\n) => void | { tag: 'ok' } | { tag: 'err'; value: string };\n\n/**\n * Authentication information for the caller of a reducer.\n */\nexport type AuthCtx = Readonly<{\n  /** Whether the caller is an internal system process. */\n  isInternal: boolean;\n  /** Whether the caller has authenticated with a JWT token. */\n  hasJWT: boolean;\n  /** The JWT claims associated with the caller, or null if hasJWT == false. */\n  jwt: JwtClaims | null;\n}>;\n\nexport type JsonValue =\n  | string\n  | number\n  | boolean\n  | null\n  | Array<JsonValue>\n  | JsonObject;\n\nexport interface JsonObject {\n  [key: string]: JsonValue;\n}\n\n/**\n * Auth Claims extracted from the payload of a JWT token\n */\nexport interface JwtClaims {\n  /** The full payload as a JSON string */\n  readonly rawPayload: string;\n  /** The subject of the JWT token ('sub') */\n  readonly subject: string;\n  /** The issuer of the JWT token ('iss') */\n  readonly issuer: string;\n  /** The audience of the JWT token ('aud') */\n  readonly audience: readonly string[];\n  /** The identity associated with the JWT token, which is based on the sub and iss */\n  readonly identity: Identity;\n  /** The full payload as a JsonObject */\n  readonly fullPayload: JsonObject;\n}\n\n/**\n * Reducer context parametrized by the inferred Schema\n */\nexport type ReducerCtx<SchemaDef extends UntypedSchemaDef> = Readonly<{\n  sender: Identity;\n  identity: Identity;\n  timestamp: Timestamp;\n  connectionId: ConnectionId | null;\n  db: DbView<SchemaDef>;\n  senderAuth: AuthCtx;\n  newUuidV4(): Uuid;\n  newUuidV7(): Uuid;\n}>;\n\n/**\n * internal: pushReducer() helper used by reducer() and lifecycle wrappers\n *\n * @param name - The name of the reducer.\n * @param params - The parameters for the reducer.\n * @param fn - The reducer function.\n * @param lifecycle - Optional lifecycle hooks for the reducer.\n */\nexport function pushReducer(\n  name: string,\n  params: RowObj | RowBuilder<RowObj>,\n  fn: Reducer<any, any>,\n  lifecycle?: Infer<typeof RawReducerDefV9>['lifecycle']\n): void {\n  if (existingReducers.has(name)) {\n    throw new TypeError(`There is already a reducer with the name '${name}'`);\n  }\n  existingReducers.add(name);\n\n  if (!(params instanceof RowBuilder)) {\n    params = new RowBuilder(params);\n  }\n\n  if (params.typeName === undefined) {\n    params.typeName = toPascalCase(name);\n  }\n\n  const ref = registerTypesRecursively(params);\n  const paramsType = resolveType(MODULE_DEF.typespace, ref).value;\n\n  MODULE_DEF.reducers.push({\n    name,\n    params: paramsType,\n    lifecycle, // <- lifecycle flag lands here\n  });\n\n  // If the function isn't named (e.g. `function foobar() {}`), give it the same\n  // name as the reducer so that it's clear what it is in in backtraces.\n  if (!fn.name) {\n    Object.defineProperty(fn, 'name', { value: name, writable: false });\n  }\n\n  REDUCERS.push(fn);\n}\n\nconst existingReducers = new Set<string>();\nexport const REDUCERS: Reducer<any, any>[] = [];\n\n/**\n * Defines a SpacetimeDB reducer function.\n *\n * Reducers are the primary way to modify the state of your SpacetimeDB application.\n * They are atomic, meaning that either all operations within a reducer succeed,\n * or none of them do.\n *\n * @template S - The inferred schema type of the SpacetimeDB module.\n * @template Params - The type of the parameters object expected by the reducer.\n *\n * @param {string} name - The name of the reducer. This name will be used to call the reducer from clients.\n * @param {Params} params - An object defining the parameters that the reducer accepts.\n *                          Each key-value pair represents a parameter name and its corresponding\n *                          {@link TypeBuilder} or {@link ColumnBuilder}.\n * @param {(ctx: ReducerCtx<S>, payload: ParamsAsObject<Params>) => void} fn - The reducer function itself.\n *   - `ctx`: The reducer context, providing access to `sender`, `timestamp`, `connection_id`, and `db`.\n *   - `payload`: An object containing the arguments passed to the reducer, typed according to `params`.\n *\n * @example\n * ```typescript\n * // Define a reducer named 'create_user' that takes 'username' (string) and 'email' (string)\n * reducer(\n *   'create_user',\n *   {\n *     username: t.string(),\n *     email: t.string(),\n *   },\n *   (ctx, { username, email }) => {\n *     // Access the 'user' table from the database view in the context\n *     ctx.db.user.insert({ username, email, created_at: ctx.timestamp });\n *     console.log(`User ${username} created by ${ctx.sender.identityId}`);\n *   }\n * );\n * ```\n */\nexport function reducer<S extends UntypedSchemaDef, Params extends ParamsObj>(\n  name: string,\n  params: Params,\n  fn: (ctx: ReducerCtx<S>, payload: ParamsAsObject<Params>) => void\n): void {\n  pushReducer(name, params, fn);\n}\n\n/**\n * Registers an initialization reducer that runs when the SpacetimeDB module is published\n * for the first time.\n * This function is useful to set up any initial state of your database that is guaranteed\n * to run only once, and before any other reducers or client connections.\n * @template S - The inferred schema type of the SpacetimeDB module.\n * @template Params - The type of the parameters object expected by the initialization reducer.\n *\n * @param params - The parameters object defining the expected input for the initialization reducer.\n * @param fn - The initialization reducer function.\n * - `ctx`: The reducer context, providing access to `sender`, `timestamp`, `connection_id`, and `db`.\n */\nexport function init<S extends UntypedSchemaDef, Params extends ParamsObj>(\n  name: string,\n  params: Params,\n  fn: Reducer<S, Params>\n): void {\n  pushReducer(name, params, fn, Lifecycle.Init);\n}\n\n/**\n * Registers a reducer to be called when a client connects to the SpacetimeDB module.\n * This function allows you to define custom logic that should execute\n * whenever a new client establishes a connection.\n * @template S - The inferred schema type of the SpacetimeDB module.\n * @template Params - The type of the parameters object expected by the connection reducer.\n * @param params - The parameters object defining the expected input for the connection reducer.\n * @param fn - The connection reducer function itself.\n */\nexport function clientConnected<\n  S extends UntypedSchemaDef,\n  Params extends ParamsObj,\n>(name: string, params: Params, fn: Reducer<S, Params>): void {\n  pushReducer(name, params, fn, Lifecycle.OnConnect);\n}\n\n/**\n * Registers a reducer to be called when a client disconnects from the SpacetimeDB module.\n * This function allows you to define custom logic that should execute\n * whenever a client disconnects.\n *\n * @template S - The inferred schema type of the SpacetimeDB module.\n * @template Params - The type of the parameters object expected by the disconnection reducer.\n * @param params - The parameters object defining the expected input for the disconnection reducer.\n * @param fn - The disconnection reducer function itself.\n * @example\n * ```typescript\n * spacetime.clientDisconnected(\n *   { reason: t.string() },\n *   (ctx, { reason }) => {\n *      console.log(`Client ${ctx.connection_id} disconnected: ${reason}`);\n *   }\n * );\n * ```\n */\nexport function clientDisconnected<\n  S extends UntypedSchemaDef,\n  Params extends ParamsObj,\n>(name: string, params: Params, fn: Reducer<S, Params>): void {\n  pushReducer(name, params, fn, Lifecycle.OnDisconnect);\n}\n\nclass Reducers<ReducersDef extends UntypedReducersDef> {\n  reducersType: ReducersDef;\n\n  constructor(handles: readonly ReducerSchema<any, any>[]) {\n    this.reducersType = reducersToSchema(handles) as ReducersDef;\n  }\n}\n\n/**\n * Helper type to convert an array of TableSchema into a schema definition\n */\ntype ReducersToSchema<T extends readonly ReducerSchema<any, any>[]> = {\n  reducers: {\n    /** @type {UntypedReducerDef} */\n    readonly [i in keyof T]: {\n      name: T[i]['reducerName'];\n      accessorName: CamelCase<T[i]['accessorName']>;\n      params: T[i]['params']['row'];\n      paramsType: T[i]['paramsSpacetimeType'];\n    };\n  };\n};\n\nexport function reducersToSchema<\n  const T extends readonly ReducerSchema<any, any>[],\n>(reducers: T): ReducersToSchema<T> {\n  const mapped = reducers.map(r => {\n    const paramsRow = r.params.row;\n\n    return {\n      name: r.reducerName,\n      // Prefer the schema's own accessorName if present at runtime; otherwise derive it.\n      accessorName: r.accessorName,\n      params: paramsRow,\n      paramsType: r.paramsSpacetimeType,\n    } as const;\n  }) as {\n    readonly [I in keyof T]: {\n      name: T[I]['reducerName'];\n      accessorName: T[I]['accessorName'];\n      params: T[I]['params']['row'];\n      paramsType: T[I]['paramsSpacetimeType'];\n    };\n  };\n\n  const result = { reducers: mapped } satisfies ReducersToSchema<T>;\n  return result;\n}\n\n/**\n * Creates a schema from table definitions\n * @param handles - Array of table handles created by table() function\n * @returns ColumnBuilder representing the complete database schema\n * @example\n * ```ts\n * const s = schema(\n *   table({ name: 'user' }, userType),\n *   table({ name: 'post' }, postType)\n * );\n * ```\n */\nexport function reducers<const H extends readonly ReducerSchema<any, any>[]>(\n  ...handles: H\n): Reducers<ReducersToSchema<H>>;\n\n/**\n * Creates a schema from table definitions (array overload)\n * @param handles - Array of table handles created by table() function\n * @returns ColumnBuilder representing the complete database schema\n */\nexport function reducers<const H extends readonly ReducerSchema<any, any>[]>(\n  handles: H\n): Reducers<ReducersToSchema<H>>;\n\nexport function reducers<const H extends readonly ReducerSchema<any, any>[]>(\n  ...args: [H] | H\n): Reducers<ReducersToSchema<H>> {\n  const handles = (\n    args.length === 1 && Array.isArray(args[0]) ? args[0] : args\n  ) as H;\n  return new Reducers(handles);\n}\n\nexport function reducerSchema<\n  ReducerName extends string,\n  Params extends ParamsObj,\n>(name: ReducerName, params: Params): ReducerSchema<ReducerName, Params> {\n  const paramType: ProductType = {\n    elements: Object.entries(params).map(([n, c]) => ({\n      name: n,\n      algebraicType:\n        'typeBuilder' in c ? c.typeBuilder.algebraicType : c.algebraicType,\n    })),\n  };\n  return {\n    reducerName: name,\n    accessorName: toCamelCase(name),\n    params: new RowBuilder<Params>(params),\n    paramsSpacetimeType: paramType,\n    reducerDef: {\n      name,\n      params: paramType,\n      lifecycle: undefined,\n    },\n  };\n}\n","import { ConnectionId } from '../lib/connection_id';\nimport { Identity } from '../lib/identity';\nimport type { ColumnIndex, IndexColumns, IndexOpts } from '../lib/indexes';\nimport type { UntypedSchemaDef } from '../lib/schema';\nimport type { TableSchema } from '../lib/table_schema';\nimport type {\n  ColumnBuilder,\n  ColumnMetadata,\n  RowBuilder,\n  TypeBuilder,\n} from '../lib/type_builders';\n\n/**\n * Helper to get the set of table names.\n */\nexport type TableNames<SchemaDef extends UntypedSchemaDef> =\n  SchemaDef['tables'][number]['name'] & string;\n\n/** helper: pick the table def object from the schema by its name */\nexport type TableDefByName<\n  SchemaDef extends UntypedSchemaDef,\n  Name extends TableNames<SchemaDef>,\n> = Extract<SchemaDef['tables'][number], { name: Name }>;\n\n// internal only  NOT exported.\n// This is how we make sure queries are only created with our helpers.\nconst QueryBrand = Symbol('QueryBrand');\n\nexport interface TableTypedQuery<TableDef extends TypedTableDef> {\n  readonly [QueryBrand]: true;\n  readonly __table?: TableDef;\n}\n\nexport interface RowTypedQuery<Row, ST> {\n  readonly [QueryBrand]: true;\n  // Phantom type to track the row type.\n  readonly __row?: Row;\n  readonly __algebraicType?: ST;\n}\n\nexport type Query<TableDef extends TypedTableDef> = RowTypedQuery<\n  RowType<TableDef>,\n  TableDef['rowType']\n>;\n\nexport const isRowTypedQuery = (val: unknown): val is RowTypedQuery<any, any> =>\n  !!val && typeof val === 'object' && QueryBrand in (val as object);\n\nexport const isTypedQuery = (val: unknown): val is TableTypedQuery<any> =>\n  !!val && typeof val === 'object' && QueryBrand in (val as object);\n\nexport function toSql(q: Query<any>): string {\n  return (q as unknown as { toSql(): string }).toSql();\n}\n\n// A query builder with a single table.\ntype From<TableDef extends TypedTableDef> = Readonly<{\n  where(\n    predicate: (row: RowExpr<TableDef>) => BooleanExpr<TableDef>\n  ): From<TableDef>;\n  rightSemijoin<RightTable extends TypedTableDef>(\n    other: TableRef<RightTable>,\n    on: (\n      left: IndexedRowExpr<TableDef>,\n      right: IndexedRowExpr<RightTable>\n    ) => EqExpr<TableDef | RightTable>\n  ): SemijoinBuilder<RightTable>;\n  leftSemijoin<RightTable extends TypedTableDef>(\n    other: TableRef<RightTable>,\n    on: (\n      left: IndexedRowExpr<TableDef>,\n      right: IndexedRowExpr<RightTable>\n    ) => EqExpr<TableDef | RightTable>\n  ): SemijoinBuilder<TableDef>;\n  build(): Query<TableDef>;\n}>;\n\n// A query builder with a semijoin.\ntype SemijoinBuilder<TableDef extends TypedTableDef> = Readonly<{\n  where(\n    predicate: (row: RowExpr<TableDef>) => BooleanExpr<TableDef>\n  ): SemijoinBuilder<TableDef>;\n  build(): Query<TableDef>;\n}>;\n\nclass SemijoinImpl<TableDef extends TypedTableDef>\n  implements SemijoinBuilder<TableDef>, TableTypedQuery<TableDef>\n{\n  readonly [QueryBrand] = true;\n  readonly type = 'semijoin' as const;\n  constructor(\n    readonly sourceQuery: FromBuilder<TableDef>,\n    readonly filterQuery: FromBuilder<any>,\n    readonly joinCondition: EqExpr<any>\n  ) {\n    if (sourceQuery.table.name === filterQuery.table.name) {\n      // TODO: Handle aliasing properly instead of just forbidding it.\n      throw new Error('Cannot semijoin a table to itself');\n    }\n  }\n\n  build(): Query<TableDef> {\n    return this as Query<TableDef>;\n  }\n\n  where(\n    predicate: (row: RowExpr<TableDef>) => BooleanExpr<TableDef>\n  ): SemijoinImpl<TableDef> {\n    const nextSourceQuery = this.sourceQuery.where(predicate);\n    return new SemijoinImpl<TableDef>(\n      nextSourceQuery,\n      this.filterQuery,\n      this.joinCondition\n    );\n  }\n\n  toSql(): string {\n    const left = this.filterQuery;\n    const right = this.sourceQuery;\n    const leftTable = quoteIdentifier(left.table.name);\n    const rightTable = quoteIdentifier(right.table.name);\n    let sql = `SELECT ${rightTable}.* FROM ${leftTable} JOIN ${rightTable} ON ${booleanExprToSql(this.joinCondition)}`;\n\n    const clauses: string[] = [];\n    if (left.whereClause) {\n      clauses.push(booleanExprToSql(left.whereClause));\n    }\n    if (right.whereClause) {\n      clauses.push(booleanExprToSql(right.whereClause));\n    }\n\n    if (clauses.length > 0) {\n      const whereSql =\n        clauses.length === 1\n          ? clauses[0]\n          : clauses.map(wrapInParens).join(' AND ');\n      sql += ` WHERE ${whereSql}`;\n    }\n\n    return sql;\n  }\n}\n\nclass FromBuilder<TableDef extends TypedTableDef>\n  implements From<TableDef>, TableTypedQuery<TableDef>\n{\n  readonly [QueryBrand] = true;\n  constructor(\n    readonly table: TableRef<TableDef>,\n    readonly whereClause?: BooleanExpr<TableDef>\n  ) {}\n\n  where(\n    predicate: (row: RowExpr<TableDef>) => BooleanExpr<TableDef>\n  ): FromBuilder<TableDef> {\n    const newCondition = predicate(this.table.cols);\n    const nextWhere = this.whereClause\n      ? and(this.whereClause, newCondition)\n      : newCondition;\n    return new FromBuilder<TableDef>(this.table, nextWhere);\n  }\n\n  rightSemijoin<OtherTable extends TypedTableDef>(\n    right: TableRef<OtherTable>,\n    on: (\n      left: IndexedRowExpr<TableDef>,\n      right: IndexedRowExpr<OtherTable>\n    ) => EqExpr<TableDef | OtherTable>\n  ): SemijoinBuilder<OtherTable> {\n    const sourceQuery = new FromBuilder(right);\n    const joinCondition = on(\n      this.table.indexedCols,\n      right.indexedCols\n    ) as EqExpr<any>;\n    return new SemijoinImpl<OtherTable>(sourceQuery, this, joinCondition);\n  }\n\n  leftSemijoin<OtherTable extends TypedTableDef>(\n    right: TableRef<OtherTable>,\n    on: (\n      left: IndexedRowExpr<TableDef>,\n      right: IndexedRowExpr<OtherTable>\n    ) => EqExpr<TableDef | OtherTable>\n  ): SemijoinBuilder<TableDef> {\n    const filterQuery = new FromBuilder(right);\n    const joinCondition = on(\n      this.table.indexedCols,\n      right.indexedCols\n    ) as EqExpr<any>;\n    return new SemijoinImpl<TableDef>(this, filterQuery, joinCondition);\n  }\n\n  toSql(): string {\n    return renderSelectSqlWithJoins(this.table, this.whereClause);\n  }\n\n  build(): Query<TableDef> {\n    return this as Query<TableDef>;\n  }\n}\n\nexport type QueryBuilder<SchemaDef extends UntypedSchemaDef> = {\n  readonly [Tbl in SchemaDef['tables'][number] as Tbl['name']]: TableRef<Tbl> &\n    From<Tbl>;\n} & {};\n\n/**\n * A runtime reference to a table. This materializes the RowExpr for us.\n * TODO: Maybe add the full SchemaDef to the type signature depending on how joins will work.\n */\nexport type TableRef<TableDef extends TypedTableDef> = Readonly<{\n  type: 'table';\n  name: TableDef['name'];\n  cols: RowExpr<TableDef>;\n  indexedCols: IndexedRowExpr<TableDef>;\n  // Maybe redundant.\n  tableDef: TableDef;\n}>;\n\nclass TableRefImpl<TableDef extends TypedTableDef>\n  implements TableRef<TableDef>, From<TableDef>\n{\n  readonly type = 'table' as const;\n  name: string;\n  cols: RowExpr<TableDef>;\n  indexedCols: IndexedRowExpr<TableDef>;\n  tableDef: TableDef;\n  constructor(tableDef: TableDef) {\n    this.name = tableDef.name;\n    this.cols = createRowExpr(tableDef);\n    // this.indexedCols = createIndexedRowExpr(tableDef, this.cols);\n    // TODO: we could create an indexedRowExpr to avoid having the extra columns.\n    // Right now, the objects we pass will actually have all the columns, but the\n    // type system will consider it an error.\n    this.indexedCols = this.cols;\n    this.tableDef = tableDef;\n    Object.freeze(this);\n  }\n\n  asFrom(): FromBuilder<TableDef> {\n    return new FromBuilder<TableDef>(this);\n  }\n\n  rightSemijoin<RightTable extends TypedTableDef>(\n    other: TableRef<RightTable>,\n    on: (\n      left: IndexedRowExpr<TableDef>,\n      right: IndexedRowExpr<RightTable>\n    ) => EqExpr<TableDef | RightTable>\n  ): SemijoinBuilder<RightTable> {\n    return this.asFrom().rightSemijoin(other, on);\n  }\n\n  leftSemijoin<RightTable extends TypedTableDef>(\n    other: TableRef<RightTable>,\n    on: (\n      left: IndexedRowExpr<TableDef>,\n      right: IndexedRowExpr<RightTable>\n    ) => EqExpr<TableDef | RightTable>\n  ): SemijoinBuilder<TableDef> {\n    return this.asFrom().leftSemijoin(other, on);\n  }\n\n  build(): Query<TableDef> {\n    return this.asFrom().build();\n  }\n\n  toSql(): string {\n    return this.asFrom().toSql();\n  }\n\n  where(\n    predicate: (row: RowExpr<TableDef>) => BooleanExpr<TableDef>\n  ): FromBuilder<TableDef> {\n    return this.asFrom().where(predicate);\n  }\n}\n\nexport type RefSource<TableDef extends TypedTableDef> =\n  | TableRef<TableDef>\n  | { ref(): TableRef<TableDef> };\n\nexport function createTableRefFromDef<TableDef extends TypedTableDef>(\n  tableDef: TableDef\n): TableRef<TableDef> {\n  return new TableRefImpl<TableDef>(tableDef);\n}\n\nexport function makeQueryBuilder<SchemaDef extends UntypedSchemaDef>(\n  schema: SchemaDef\n): QueryBuilder<SchemaDef> {\n  const qb = Object.create(null) as QueryBuilder<SchemaDef>;\n  for (const table of schema.tables) {\n    const ref = createTableRefFromDef(\n      table as TableDefByName<SchemaDef, TableNames<SchemaDef>>\n    );\n    (qb as Record<string, TableRef<any>>)[table.name] = ref;\n  }\n  return Object.freeze(qb) as QueryBuilder<SchemaDef>;\n}\n\nfunction createRowExpr<TableDef extends TypedTableDef>(\n  tableDef: TableDef\n): RowExpr<TableDef> {\n  const row: Record<string, ColumnExpr<TableDef, any>> = {};\n  for (const columnName of Object.keys(tableDef.columns) as Array<\n    keyof TableDef['columns'] & string\n  >) {\n    const columnBuilder = tableDef.columns[columnName];\n    const column = new ColumnExpression<TableDef, typeof columnName>(\n      tableDef.name,\n      columnName,\n      columnBuilder.typeBuilder.algebraicType as InferSpacetimeTypeOfColumn<\n        TableDef,\n        typeof columnName\n      >\n    );\n    row[columnName] = Object.freeze(column);\n  }\n  return Object.freeze(row) as RowExpr<TableDef>;\n}\n\nexport function from<TableDef extends TypedTableDef>(\n  source: RefSource<TableDef>\n): From<TableDef> {\n  return new FromBuilder(resolveTableRef(source));\n}\n\nfunction resolveTableRef<TableDef extends TypedTableDef>(\n  source: RefSource<TableDef>\n): TableRef<TableDef> {\n  if (typeof (source as { ref?: unknown }).ref === 'function') {\n    return (source as { ref(): TableRef<TableDef> }).ref();\n  }\n  return source as TableRef<TableDef>;\n}\n\nfunction renderSelectSqlWithJoins<Table extends TypedTableDef>(\n  table: TableRef<Table>,\n  where?: BooleanExpr<Table>,\n  extraClauses: readonly string[] = []\n): string {\n  const quotedTable = quoteIdentifier(table.name);\n  const sql = `SELECT * FROM ${quotedTable}`;\n  const clauses: string[] = [];\n  if (where) clauses.push(booleanExprToSql(where));\n  clauses.push(...extraClauses);\n  if (clauses.length === 0) return sql;\n  const whereSql =\n    clauses.length === 1 ? clauses[0] : clauses.map(wrapInParens).join(' AND ');\n  return `${sql} WHERE ${whereSql}`;\n}\n\n// TODO: Just use UntypedTableDef if they end up being the same.\nexport type TypedTableDef<\n  Columns extends Record<\n    string,\n    ColumnBuilder<any, any, ColumnMetadata<any>>\n  > = Record<string, ColumnBuilder<any, any, ColumnMetadata<any>>>,\n> = {\n  name: string;\n  columns: Columns;\n  indexes: readonly IndexOpts<any>[];\n  rowType: RowBuilder<Columns>['algebraicType']['value'];\n};\n\nexport type TableSchemaAsTableDef<\n  TSchema extends TableSchema<any, any, readonly any[]>,\n> = {\n  name: TSchema['tableName'];\n  columns: TSchema['rowType']['row'];\n  indexes: TSchema['idxs'];\n};\n\ntype RowType<TableDef extends TypedTableDef> = {\n  [K in keyof TableDef['columns']]: TableDef['columns'][K] extends ColumnBuilder<\n    infer T,\n    any,\n    any\n  >\n    ? T\n    : never;\n};\n\n// TODO: Consider making a smaller version of these types that doesn't expose the internals.\n// Restricting it later should not break anyone in practice.\nexport type ColumnExpr<\n  TableDef extends TypedTableDef,\n  ColumnName extends ColumnNames<TableDef>,\n> = ColumnExpression<TableDef, ColumnName>;\n\ntype ColumnSpacetimeType<Col extends ColumnExpr<any, any>> =\n  Col extends ColumnExpr<infer T, infer N>\n    ? InferSpacetimeTypeOfColumn<T, N>\n    : never;\n\n// TODO: This checks that they match, but we also need to make sure that they are comparable types,\n// since you can use product types at all.\ntype ColumnSameSpacetime<\n  ThisTable extends TypedTableDef,\n  ThisCol extends ColumnNames<ThisTable>,\n  OtherCol extends ColumnExpr<any, any>,\n> = [InferSpacetimeTypeOfColumn<ThisTable, ThisCol>] extends [\n  ColumnSpacetimeType<OtherCol>,\n]\n  ? [ColumnSpacetimeType<OtherCol>] extends [\n      InferSpacetimeTypeOfColumn<ThisTable, ThisCol>,\n    ]\n    ? OtherCol\n    : never\n  : never;\n\n// Helper to get the table back from a column.\ntype ExtractTable<Col extends ColumnExpr<any, any>> =\n  Col extends ColumnExpr<infer T, any> ? T : never;\n\nexport class ColumnExpression<\n  TableDef extends TypedTableDef,\n  ColumnName extends ColumnNames<TableDef>,\n> {\n  readonly type = 'column' as const;\n  readonly column: ColumnName;\n  readonly table: TableDef['name'];\n  // phantom: actual runtime value is undefined\n  readonly tsValueType?: RowType<TableDef>[ColumnName];\n  readonly spacetimeType: InferSpacetimeTypeOfColumn<TableDef, ColumnName>;\n\n  constructor(\n    table: TableDef['name'],\n    column: ColumnName,\n    spacetimeType: InferSpacetimeTypeOfColumn<TableDef, ColumnName>\n  ) {\n    this.table = table;\n    this.column = column;\n    this.spacetimeType = spacetimeType;\n  }\n\n  eq(literal: LiteralValue & RowType<TableDef>[ColumnName]): EqExpr<TableDef>;\n  eq<OtherCol extends ColumnExpr<any, any>>(\n    value: ColumnSameSpacetime<TableDef, ColumnName, OtherCol>\n  ): EqExpr<TableDef | ExtractTable<OtherCol>>;\n\n  // These types could be tighted, but since we declare the overloads above, it doesn't weaken the API surface.\n  eq(x: any): any {\n    return {\n      type: 'eq',\n      left: this as unknown as ValueExpr<TableDef, any>,\n      right: normalizeValue(x) as ValueExpr<TableDef, any>,\n    } as EqExpr<TableDef>;\n  }\n\n  lt(\n    literal: LiteralValue & RowType<TableDef>[ColumnName]\n  ): BooleanExpr<TableDef>;\n  lt<OtherCol extends ColumnExpr<any, any>>(\n    value: ColumnSameSpacetime<TableDef, ColumnName, OtherCol>\n  ): BooleanExpr<TableDef | ExtractTable<OtherCol>>;\n\n  // These types could be tighted, but since we declare the overloads above, it doesn't weaken the API surface.\n  lt(x: any): any {\n    return {\n      type: 'lt',\n      left: this as unknown as ValueExpr<TableDef, any>,\n      right: normalizeValue(x) as ValueExpr<TableDef, any>,\n    } as BooleanExpr<TableDef>;\n  }\n  lte(\n    literal: LiteralValue & RowType<TableDef>[ColumnName]\n  ): BooleanExpr<TableDef>;\n  lte<OtherCol extends ColumnExpr<any, any>>(\n    value: ColumnSameSpacetime<TableDef, ColumnName, OtherCol>\n  ): BooleanExpr<TableDef | ExtractTable<OtherCol>>;\n\n  // These types could be tighted, but since we declare the overloads above, it doesn't weaken the API surface.\n  lte(x: any): any {\n    return {\n      type: 'lte',\n      left: this as unknown as ValueExpr<TableDef, any>,\n      right: normalizeValue(x) as ValueExpr<TableDef, any>,\n    } as BooleanExpr<TableDef>;\n  }\n\n  gt(\n    literal: LiteralValue & RowType<TableDef>[ColumnName]\n  ): BooleanExpr<TableDef>;\n  gt<OtherCol extends ColumnExpr<any, any>>(\n    value: ColumnSameSpacetime<TableDef, ColumnName, OtherCol>\n  ): BooleanExpr<TableDef | ExtractTable<OtherCol>>;\n\n  // These types could be tighted, but since we declare the overloads above, it doesn't weaken the API surface.\n  gt(x: any): any {\n    return {\n      type: 'gt',\n      left: this as unknown as ValueExpr<TableDef, any>,\n      right: normalizeValue(x) as ValueExpr<TableDef, any>,\n    } as BooleanExpr<TableDef>;\n  }\n  gte(\n    literal: LiteralValue & RowType<TableDef>[ColumnName]\n  ): BooleanExpr<TableDef>;\n  gte<OtherCol extends ColumnExpr<any, any>>(\n    value: ColumnSameSpacetime<TableDef, ColumnName, OtherCol>\n  ): BooleanExpr<TableDef | ExtractTable<OtherCol>>;\n\n  // These types could be tighted, but since we declare the overloads above, it doesn't weaken the API surface.\n  gte(x: any): any {\n    return {\n      type: 'gte',\n      left: this as unknown as ValueExpr<TableDef, any>,\n      right: normalizeValue(x) as ValueExpr<TableDef, any>,\n    } as BooleanExpr<TableDef>;\n  }\n}\n\n/**\n * Helper to get the spacetime type of a column.\n */\ntype InferSpacetimeTypeOfColumn<\n  TableDef extends TypedTableDef,\n  ColumnName extends ColumnNames<TableDef>,\n> =\n  TableDef['columns'][ColumnName]['typeBuilder'] extends TypeBuilder<\n    any,\n    infer U\n  >\n    ? U\n    : never;\n\ntype ColumnNames<TableDef extends TypedTableDef> = keyof RowType<TableDef> &\n  string;\n\n// For composite indexes, we only consider it as an index over the first column in the index.\ntype FirstIndexColumn<I extends IndexOpts<any>> =\n  IndexColumns<I> extends readonly [infer Head extends string, ...infer _Rest]\n    ? Head\n    : never;\n\n// Columns that are indexed by something in the indexes: [...] part.\ntype ExplicitIndexedColumns<TableDef extends TypedTableDef> =\n  TableDef['indexes'][number] extends infer I\n    ? I extends IndexOpts<ColumnNames<TableDef>>\n      ? FirstIndexColumn<I> & ColumnNames<TableDef>\n      : never\n    : never;\n\n// Columns with an index defined on the column definition.\ntype MetadataIndexedColumns<TableDef extends TypedTableDef> = {\n  [K in ColumnNames<TableDef>]: ColumnIndex<\n    K,\n    TableDef['columns'][K]['columnMetadata']\n  > extends never\n    ? never\n    : K;\n}[ColumnNames<TableDef>];\n\nexport type IndexedColumnNames<TableDef extends TypedTableDef> =\n  | ExplicitIndexedColumns<TableDef>\n  | MetadataIndexedColumns<TableDef>;\n\nexport type IndexedRowExpr<TableDef extends TypedTableDef> = Readonly<{\n  readonly [C in IndexedColumnNames<TableDef>]: ColumnExpr<TableDef, C>;\n}>;\n\n/**\n * Acts as a row when writing filters for queries. It is a way to get column references.\n */\nexport type RowExpr<TableDef extends TypedTableDef> = Readonly<{\n  readonly [C in ColumnNames<TableDef>]: ColumnExpr<TableDef, C>;\n}>;\n\n/**\n * Union of ColumnExprs from Table whose spacetimeType is compatible with Value\n * (produces a union of ColumnExpr<Table, C> for matching columns).\n */\nexport type ColumnExprForValue<Table extends TypedTableDef, Value> = {\n  [C in ColumnNames<Table>]: InferSpacetimeTypeOfColumn<Table, C> extends Value\n    ? ColumnExpr<Table, C>\n    : never;\n}[ColumnNames<Table>];\n\ntype LiteralValue =\n  | string\n  | number\n  | bigint\n  | boolean\n  | Identity\n  | ConnectionId;\n\ntype ValueLike = LiteralValue | ColumnExpr<any, any> | LiteralExpr<any>;\ntype ValueInput<TableDef extends TypedTableDef> =\n  | ValueLike\n  | ValueExpr<TableDef, any>;\n\nexport type ValueExpr<TableDef extends TypedTableDef, Value> =\n  | LiteralExpr<Value & LiteralValue>\n  | ColumnExprForValue<TableDef, Value>;\n\ntype LiteralExpr<Value> = {\n  type: 'literal';\n  value: Value;\n};\n\nexport function literal<Value extends LiteralValue>(\n  value: Value\n): ValueExpr<never, Value> {\n  return { type: 'literal', value };\n}\n\n// This is here to take literal values and wrap them in an AST node.\nfunction normalizeValue(val: ValueInput<any>): ValueExpr<any, any> {\n  if ((val as LiteralExpr<any>).type === 'literal')\n    return val as LiteralExpr<any>;\n  if (\n    typeof val === 'object' &&\n    val != null &&\n    'type' in (val as any) &&\n    (val as any).type === 'column'\n  ) {\n    return val as ColumnExpr<any, any>;\n  }\n  return literal(val as LiteralValue);\n}\n\ntype EqExpr<Table extends TypedTableDef = any> = {\n  type: 'eq';\n  left: ValueExpr<Table, any>;\n  right: ValueExpr<Table, any>;\n} & {\n  _tableType?: Table;\n};\n\ntype BooleanExpr<Table extends TypedTableDef> = (\n  | {\n      type: 'eq' | 'ne' | 'gt' | 'lt' | 'gte' | 'lte';\n      left: ValueExpr<Table, any>;\n      right: ValueExpr<Table, any>;\n    }\n  | {\n      type: 'and';\n      clauses: readonly [\n        BooleanExpr<Table>,\n        BooleanExpr<Table>,\n        ...BooleanExpr<Table>[],\n      ];\n    }\n  | {\n      type: 'or';\n      clauses: readonly [\n        BooleanExpr<Table>,\n        BooleanExpr<Table>,\n        ...BooleanExpr<Table>[],\n      ];\n    }\n  | {\n      type: 'not';\n      clause: BooleanExpr<Table>;\n    }\n) & {\n  _tableType?: Table;\n  // readonly [BooleanExprBrand]: Table?;\n};\n\nexport function not<T extends TypedTableDef>(\n  clause: BooleanExpr<T>\n): BooleanExpr<T> {\n  return { type: 'not', clause };\n}\n\nexport function and<T extends TypedTableDef>(\n  ...clauses: readonly [BooleanExpr<T>, BooleanExpr<T>, ...BooleanExpr<T>[]]\n): BooleanExpr<T> {\n  return { type: 'and', clauses };\n}\n\nexport function or<T extends TypedTableDef>(\n  ...clauses: readonly [BooleanExpr<T>, BooleanExpr<T>, ...BooleanExpr<T>[]]\n): BooleanExpr<T> {\n  return { type: 'or', clauses };\n}\n\nfunction booleanExprToSql<Table extends TypedTableDef>(\n  expr: BooleanExpr<Table>,\n  tableAlias?: string\n): string {\n  switch (expr.type) {\n    case 'eq':\n      return `${valueExprToSql(expr.left, tableAlias)} = ${valueExprToSql(expr.right, tableAlias)}`;\n    case 'ne':\n      return `${valueExprToSql(expr.left, tableAlias)} <> ${valueExprToSql(expr.right, tableAlias)}`;\n    case 'gt':\n      return `${valueExprToSql(expr.left, tableAlias)} > ${valueExprToSql(expr.right, tableAlias)}`;\n    case 'gte':\n      return `${valueExprToSql(expr.left, tableAlias)} >= ${valueExprToSql(expr.right, tableAlias)}`;\n    case 'lt':\n      return `${valueExprToSql(expr.left, tableAlias)} < ${valueExprToSql(expr.right, tableAlias)}`;\n    case 'lte':\n      return `${valueExprToSql(expr.left, tableAlias)} <= ${valueExprToSql(expr.right, tableAlias)}`;\n    case 'and':\n      return expr.clauses\n        .map(c => booleanExprToSql(c, tableAlias))\n        .map(wrapInParens)\n        .join(' AND ');\n    case 'or':\n      return expr.clauses\n        .map(c => booleanExprToSql(c, tableAlias))\n        .map(wrapInParens)\n        .join(' OR ');\n    case 'not':\n      return `NOT ${wrapInParens(booleanExprToSql(expr.clause, tableAlias))}`;\n  }\n}\n\nfunction wrapInParens(sql: string): string {\n  return `(${sql})`;\n}\n\nfunction valueExprToSql<Table extends TypedTableDef>(\n  expr: ValueExpr<Table, any>,\n  tableAlias?: string\n): string {\n  if (isLiteralExpr(expr)) {\n    return literalValueToSql(expr.value);\n  }\n  const table = tableAlias ?? expr.table;\n  return `${quoteIdentifier(table)}.${quoteIdentifier(expr.column)}`;\n}\n\nfunction literalValueToSql(value: unknown): string {\n  if (value === null || value === undefined) {\n    return 'NULL';\n  }\n  if (value instanceof Identity || value instanceof ConnectionId) {\n    // We use this hex string syntax.\n    return `0x${value.toHexString()}`;\n  }\n  switch (typeof value) {\n    case 'number':\n    case 'bigint':\n      return String(value);\n    case 'boolean':\n      return value ? 'TRUE' : 'FALSE';\n    case 'string':\n      return `'${value.replace(/'/g, \"''\")}'`;\n    default:\n      // It might be safer to error here?\n      return `'${JSON.stringify(value).replace(/'/g, \"''\")}'`;\n  }\n}\n\nfunction quoteIdentifier(name: string): string {\n  return `\"${name.replace(/\"/g, '\"\"')}\"`;\n}\n\nfunction isLiteralExpr<Value>(\n  expr: ValueExpr<any, Value>\n): expr is LiteralExpr<Value & LiteralValue> {\n  return (expr as LiteralExpr<Value>).type === 'literal';\n}\n\n// TODO: Fix this.\nfunction _createIndexedRowExpr<TableDef extends TypedTableDef>(\n  tableDef: TableDef,\n  cols: RowExpr<TableDef>\n): IndexedRowExpr<TableDef> {\n  const indexed = new Set<ColumnNames<TableDef>>();\n  for (const idx of tableDef.indexes) {\n    if ('columns' in idx) {\n      const [first] = idx.columns;\n      if (first) indexed.add(first);\n    } else if ('column' in idx) {\n      indexed.add(idx.column);\n    }\n  }\n  const pickedEntries = [...indexed].map(name => [name, cols[name]]);\n  return Object.freeze(\n    Object.fromEntries(pickedEntries)\n  ) as IndexedRowExpr<TableDef>;\n}\n","import {\n  AlgebraicType,\n  type AlgebraicTypeVariants,\n  type ProductType,\n} from '../lib/algebraic_type';\nimport type { Identity } from '../lib/identity';\nimport type { OptionAlgebraicType } from '../lib/option';\nimport type { ParamsObj } from './reducers';\nimport {\n  MODULE_DEF,\n  registerTypesRecursively,\n  resolveType,\n  type UntypedSchemaDef,\n} from './schema';\nimport type { ReadonlyTable } from './table';\nimport {\n  RowBuilder,\n  type Infer,\n  type InferSpacetimeTypeOfTypeBuilder,\n  type InferTypeOfRow,\n  type TypeBuilder,\n} from './type_builders';\nimport { bsatnBaseSize, toPascalCase } from './util';\nimport { type QueryBuilder, type RowTypedQuery } from '../server/query';\n\nexport type ViewCtx<S extends UntypedSchemaDef> = Readonly<{\n  sender: Identity;\n  db: ReadonlyDbView<S>;\n  from: QueryBuilder<S>;\n}>;\n\nexport type AnonymousViewCtx<S extends UntypedSchemaDef> = Readonly<{\n  db: ReadonlyDbView<S>;\n  from: QueryBuilder<S>;\n}>;\n\nexport type ReadonlyDbView<SchemaDef extends UntypedSchemaDef> = {\n  readonly [Tbl in SchemaDef['tables'][number] as Tbl['name']]: ReadonlyTable<Tbl>;\n};\n\nexport type ViewOpts = {\n  name: string;\n  public: true;\n};\n\ntype FlattenedArray<T> = T extends readonly (infer E)[] ? E : never;\n\n// // If we allowed functions to return either.\n// type ViewReturn<Ret extends ViewReturnTypeBuilder> =\n//   | Infer<Ret>\n//   | RowTypedQuery<FlattenedArray<Infer<Ret>>>;\n\nexport type ViewFn<\n  S extends UntypedSchemaDef,\n  Params extends ParamsObj,\n  Ret extends ViewReturnTypeBuilder,\n> =\n  | ((ctx: ViewCtx<S>, params: InferTypeOfRow<Params>) => Infer<Ret>)\n  | ((\n      ctx: ViewCtx<S>,\n      params: InferTypeOfRow<Params>\n    ) => RowTypedQuery<FlattenedArray<Infer<Ret>>, ExtractArrayProduct<Ret>>);\n\nexport type AnonymousViewFn<\n  S extends UntypedSchemaDef,\n  Params extends ParamsObj,\n  Ret extends ViewReturnTypeBuilder,\n> =\n  | ((ctx: AnonymousViewCtx<S>, params: InferTypeOfRow<Params>) => Infer<Ret>)\n  | ((\n      ctx: AnonymousViewCtx<S>,\n      params: InferTypeOfRow<Params>\n    ) => RowTypedQuery<FlattenedArray<Infer<Ret>>, ExtractArrayProduct<Ret>>);\n\nexport type ViewReturnTypeBuilder =\n  | TypeBuilder<\n      readonly object[],\n      { tag: 'Array'; value: AlgebraicTypeVariants.Product }\n    >\n  | TypeBuilder<\n      object | undefined,\n      OptionAlgebraicType<AlgebraicTypeVariants.Product>\n    >;\n\nexport function defineView<\n  S extends UntypedSchemaDef,\n  const Anonymous extends boolean,\n  Params extends ParamsObj,\n  Ret extends ViewReturnTypeBuilder,\n>(\n  opts: ViewOpts,\n  anon: Anonymous,\n  params: Params,\n  ret: Ret,\n  fn: Anonymous extends true\n    ? AnonymousViewFn<S, Params, Ret>\n    : ViewFn<S, Params, Ret>\n) {\n  const paramsBuilder = new RowBuilder(params, toPascalCase(opts.name));\n\n  // Register return types if they are product types\n  let returnType = registerTypesRecursively(ret).algebraicType;\n\n  const { value: paramType } = resolveType(\n    MODULE_DEF.typespace,\n    registerTypesRecursively(paramsBuilder)\n  );\n\n  MODULE_DEF.miscExports.push({\n    tag: 'View',\n    value: {\n      name: opts.name,\n      index: (anon ? ANON_VIEWS : VIEWS).length,\n      isPublic: opts.public,\n      isAnonymous: anon,\n      params: paramType,\n      returnType,\n    },\n  });\n\n  // If it is an option, we wrap the function to make the return look like an array.\n  if (returnType.tag == 'Sum') {\n    const originalFn = fn;\n    fn = ((ctx: ViewCtx<S>, args: InferTypeOfRow<Params>) => {\n      const ret = originalFn(ctx, args);\n      return ret == null ? [] : [ret];\n    }) as any;\n    returnType = AlgebraicType.Array(\n      returnType.value.variants[0].algebraicType\n    );\n  }\n\n  (anon ? ANON_VIEWS : VIEWS).push({\n    fn,\n    params: paramType,\n    returnType,\n    returnTypeBaseSize: bsatnBaseSize(MODULE_DEF.typespace, returnType),\n  });\n}\n\ntype ViewInfo<F> = {\n  fn: F;\n  params: ProductType;\n  returnType: AlgebraicType;\n  returnTypeBaseSize: number;\n};\n\nexport const VIEWS: ViewInfo<ViewFn<any, any, any>>[] = [];\nexport const ANON_VIEWS: ViewInfo<AnonymousViewFn<any, any, any>>[] = [];\n\n// A helper to get the product type out of a type builder.\n// This is only non-never if the type builder is an array.\ntype ExtractArrayProduct<T extends TypeBuilder<any, any>> =\n  InferSpacetimeTypeOfTypeBuilder<T> extends { tag: 'Array'; value: infer V }\n    ? V extends { tag: 'Product'; value: infer P }\n      ? P\n      : never\n    : never;\n","import { AlgebraicType, ProductType } from '../lib/algebraic_type';\nimport type { ConnectionId } from '../lib/connection_id';\nimport type { Identity } from '../lib/identity';\nimport type { Timestamp } from '../lib/timestamp';\nimport type { HttpClient } from '../server/http_internal';\nimport type { ParamsObj, ReducerCtx } from './reducers';\nimport {\n  MODULE_DEF,\n  registerTypesRecursively,\n  type UntypedSchemaDef,\n} from './schema';\nimport {\n  type Infer,\n  type InferTypeOfRow,\n  type TypeBuilder,\n} from './type_builders';\nimport type { CamelCase } from './type_util';\nimport {\n  bsatnBaseSize,\n  coerceParams,\n  toCamelCase,\n  type CoerceParams,\n} from './util';\nimport type { Uuid } from './uuid';\n\nexport type ProcedureFn<\n  S extends UntypedSchemaDef,\n  Params extends ParamsObj,\n  Ret extends TypeBuilder<any, any>,\n> = (ctx: ProcedureCtx<S>, args: InferTypeOfRow<Params>) => Infer<Ret>;\n\nexport interface ProcedureCtx<S extends UntypedSchemaDef> {\n  readonly sender: Identity;\n  readonly identity: Identity;\n  readonly timestamp: Timestamp;\n  readonly connectionId: ConnectionId | null;\n  readonly http: HttpClient;\n  readonly counter_uuid: { value: number };\n  withTx<T>(body: (ctx: TransactionCtx<S>) => T): T;\n  newUuidV4(): Uuid;\n  newUuidV7(): Uuid;\n}\n\n// eslint-disable-next-line @typescript-eslint/no-empty-object-type\nexport interface TransactionCtx<S extends UntypedSchemaDef>\n  extends ReducerCtx<S> {}\n\nexport function procedure<\n  S extends UntypedSchemaDef,\n  Params extends ParamsObj,\n  Ret extends TypeBuilder<any, any>,\n>(name: string, params: Params, ret: Ret, fn: ProcedureFn<S, Params, Ret>) {\n  const paramsType: ProductType = {\n    elements: Object.entries(params).map(([n, c]) => ({\n      name: n,\n      algebraicType: registerTypesRecursively(\n        'typeBuilder' in c ? c.typeBuilder : c\n      ).algebraicType,\n    })),\n  };\n  const returnType = registerTypesRecursively(ret).algebraicType;\n\n  MODULE_DEF.miscExports.push({\n    tag: 'Procedure',\n    value: {\n      name,\n      params: paramsType,\n      returnType,\n    },\n  });\n\n  PROCEDURES.push({\n    fn,\n    paramsType,\n    returnType,\n    returnTypeBaseSize: bsatnBaseSize(MODULE_DEF.typespace, returnType),\n  });\n}\n\nexport const PROCEDURES: Array<{\n  fn: ProcedureFn<any, any, any>;\n  paramsType: ProductType;\n  returnType: AlgebraicType;\n  returnTypeBaseSize: number;\n}> = [];\n\nexport type UntypedProcedureDef = {\n  name: string;\n  accessorName: string;\n  params: CoerceParams<ParamsObj>;\n  returnType: TypeBuilder<any, any>;\n};\n\nexport type UntypedProceduresDef = {\n  procedures: readonly UntypedProcedureDef[];\n};\n\nexport function procedures<const H extends readonly UntypedProcedureDef[]>(\n  ...handles: H\n): { procedures: H };\n\nexport function procedures<const H extends readonly UntypedProcedureDef[]>(\n  handles: H\n): { procedures: H };\n\nexport function procedures<const H extends readonly UntypedProcedureDef[]>(\n  ...args: [H] | H\n): { procedures: H } {\n  const procedures = (\n    args.length === 1 && Array.isArray(args[0]) ? args[0] : args\n  ) as H;\n  return { procedures };\n}\n\ntype ProcedureDef<\n  Name extends string,\n  Params extends ParamsObj,\n  ReturnType extends TypeBuilder<any, any>,\n> = {\n  name: Name;\n  accessorName: CamelCase<Name>;\n  params: CoerceParams<Params>;\n  returnType: ReturnType;\n};\n\nexport function procedureSchema<\n  ProcedureName extends string,\n  Params extends ParamsObj,\n  ReturnType extends TypeBuilder<any, any>,\n>(\n  name: ProcedureName,\n  params: Params,\n  returnType: ReturnType\n): ProcedureDef<ProcedureName, Params, ReturnType> {\n  return {\n    name,\n    accessorName: toCamelCase(name),\n    params: coerceParams(params),\n    returnType,\n  };\n}\n","import type RawTableDefV9 from './autogen/raw_table_def_v_9_type';\nimport type Typespace from './autogen/typespace_type';\nimport {\n  ArrayBuilder,\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  ColumnBuilder,\n  OptionBuilder,\n  ProductBuilder,\n  RefBuilder,\n  RowBuilder,\n  SumBuilder,\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  TypeBuilder,\n  type ElementsObj,\n  type Infer,\n  type InferSpacetimeTypeOfTypeBuilder,\n  type RowObj,\n  type VariantsObj,\n  ResultBuilder,\n} from './type_builders';\nimport type { UntypedTableDef } from './table';\nimport {\n  clientConnected,\n  clientDisconnected,\n  init,\n  reducer,\n  type ParamsObj,\n  type Reducer,\n} from './reducers';\nimport type RawModuleDefV9 from './autogen/raw_module_def_v_9_type';\nimport {\n  AlgebraicType,\n  ProductType,\n  SumType,\n  type AlgebraicTypeType,\n  type AlgebraicTypeVariants,\n} from './algebraic_type';\nimport type RawScopedTypeNameV9 from './autogen/raw_scoped_type_name_v_9_type';\nimport type { CamelCase } from './type_util';\nimport type { UntypedTableSchema } from './table_schema';\nimport { toCamelCase } from './util';\nimport {\n  defineView,\n  type AnonymousViewFn,\n  type ViewFn,\n  type ViewOpts,\n  type ViewReturnTypeBuilder,\n} from './views';\nimport type { UntypedIndex } from './indexes';\nimport { procedure, type ProcedureFn } from './procedures';\n\nexport type TableNamesOf<S extends UntypedSchemaDef> =\n  S['tables'][number]['name'];\n\n/**\n * An untyped representation of the database schema.\n */\nexport type UntypedSchemaDef = {\n  tables: readonly UntypedTableDef[];\n};\n\nlet REGISTERED_SCHEMA: UntypedSchemaDef | null = null;\n\nexport function getRegisteredSchema(): UntypedSchemaDef {\n  if (REGISTERED_SCHEMA == null) {\n    throw new Error('Schema has not been registered yet. Call schema() first.');\n  }\n  return REGISTERED_SCHEMA;\n}\n\n/**\n * Helper type to convert an array of TableSchema into a schema definition\n */\ntype TablesToSchema<T extends readonly UntypedTableSchema[]> = {\n  tables: {\n    readonly [i in keyof T]: TableToSchema<T[i]>;\n  };\n};\n\ninterface TableToSchema<T extends UntypedTableSchema> extends UntypedTableDef {\n  name: T['tableName'];\n  accessorName: CamelCase<T['tableName']>;\n  columns: T['rowType']['row'];\n  rowType: T['rowSpacetimeType'];\n  indexes: T['idxs'];\n  constraints: T['constraints'];\n}\n\nexport function tablesToSchema<const T extends readonly UntypedTableSchema[]>(\n  tables: T\n): TablesToSchema<T> {\n  return { tables: tables.map(tableToSchema) as TablesToSchema<T>['tables'] };\n}\n\nfunction tableToSchema<T extends UntypedTableSchema>(\n  schema: T\n): TableToSchema<T> {\n  const getColName = (i: number) =>\n    schema.rowType.algebraicType.value.elements[i].name;\n\n  type AllowedCol = keyof T['rowType']['row'] & string;\n  return {\n    name: schema.tableName,\n    accessorName: toCamelCase(schema.tableName as T['tableName']),\n    columns: schema.rowType.row, // typed as T[i]['rowType']['row'] under TablesToSchema<T>\n    rowType: schema.rowSpacetimeType,\n    constraints: schema.tableDef.constraints.map(c => ({\n      name: c.name,\n      constraint: 'unique',\n      columns: c.data.value.columns.map(getColName) as [string],\n    })),\n    // TODO: horrible horrible horrible. we smuggle this `Array<UntypedIndex>`\n    // by casting it to an `Array<IndexOpts>` as `TableToSchema` expects.\n    // This is then used in `TableCacheImpl.constructor` and who knows where else.\n    // We should stop lying about our types.\n    indexes: schema.tableDef.indexes.map((idx): UntypedIndex<AllowedCol> => {\n      const columnIds =\n        idx.algorithm.tag === 'Direct'\n          ? [idx.algorithm.value]\n          : idx.algorithm.value;\n      return {\n        name: idx.accessorName!,\n        unique: schema.tableDef.constraints.some(c =>\n          c.data.value.columns.every(col => columnIds.includes(col))\n        ),\n        algorithm: idx.algorithm.tag.toLowerCase() as 'btree',\n        columns: columnIds.map(getColName),\n      };\n    }) as T['idxs'],\n  };\n}\n\n/**\n * The global module definition that gets populated by calls to `reducer()` and lifecycle hooks.\n */\nexport const MODULE_DEF: Infer<typeof RawModuleDefV9> = {\n  typespace: { types: [] },\n  tables: [],\n  reducers: [],\n  types: [],\n  miscExports: [],\n  rowLevelSecurity: [],\n};\n\nconst COMPOUND_TYPES = new Map<\n  AlgebraicTypeVariants.Product | AlgebraicTypeVariants.Sum,\n  RefBuilder<any, any>\n>();\n\n/**\n * Resolves the actual type of a TypeBuilder by following its references until it reaches a non-ref type.\n * @param typespace The typespace to resolve types against.\n * @param typeBuilder The TypeBuilder to resolve.\n * @returns The resolved algebraic type.\n */\nexport function resolveType<AT extends AlgebraicTypeType>(\n  typespace: Infer<typeof Typespace>,\n  typeBuilder: RefBuilder<any, AT>\n): AT {\n  let ty: AlgebraicType = typeBuilder.algebraicType;\n  while (ty.tag === 'Ref') {\n    ty = typespace.types[ty.value];\n  }\n  return ty as AT;\n}\n\n/**\n * Adds a type to the module definition's typespace as a `Ref` if it is a named compound type (Product or Sum).\n * Otherwise, returns the type as is.\n * @param name\n * @param ty\n * @returns\n */\nexport function registerTypesRecursively<\n  T extends TypeBuilder<any, AlgebraicType>,\n>(\n  typeBuilder: T\n): T extends SumBuilder<any> | ProductBuilder<any> | RowBuilder<any>\n  ? RefBuilder<Infer<T>, InferSpacetimeTypeOfTypeBuilder<T>>\n  : T {\n  if (\n    (typeBuilder instanceof ProductBuilder && !isUnit(typeBuilder)) ||\n    typeBuilder instanceof SumBuilder ||\n    typeBuilder instanceof RowBuilder\n  ) {\n    return registerCompoundTypeRecursively(typeBuilder) as any;\n  } else if (typeBuilder instanceof OptionBuilder) {\n    return new OptionBuilder(\n      registerTypesRecursively(typeBuilder.value)\n    ) as any;\n  } else if (typeBuilder instanceof ResultBuilder) {\n    return new ResultBuilder(\n      registerTypesRecursively(typeBuilder.ok),\n      registerTypesRecursively(typeBuilder.err)\n    ) as any;\n  } else if (typeBuilder instanceof ArrayBuilder) {\n    return new ArrayBuilder(\n      registerTypesRecursively(typeBuilder.element)\n    ) as any;\n  } else {\n    return typeBuilder as any;\n  }\n}\n\nfunction registerCompoundTypeRecursively<\n  T extends\n    | SumBuilder<VariantsObj>\n    | ProductBuilder<ElementsObj>\n    | RowBuilder<RowObj>,\n>(typeBuilder: T): RefBuilder<Infer<T>, InferSpacetimeTypeOfTypeBuilder<T>> {\n  const ty = typeBuilder.algebraicType;\n  // NB! You must ensure that all TypeBuilder passed into this function\n  // have a name. This function ensures that nested types always have a\n  // name by assigning them one if they are missing it.\n  const name = typeBuilder.typeName;\n  if (name === undefined) {\n    throw new Error(\n      `Missing type name for ${typeBuilder.constructor.name ?? 'TypeBuilder'} ${JSON.stringify(typeBuilder)}`\n    );\n  }\n\n  let r = COMPOUND_TYPES.get(ty);\n  if (r != null) {\n    // Already added to typespace\n    return r;\n  }\n\n  // Recursively register nested compound types\n  const newTy =\n    typeBuilder instanceof RowBuilder || typeBuilder instanceof ProductBuilder\n      ? ({\n          tag: 'Product',\n          value: { elements: [] },\n        } as AlgebraicTypeVariants.Product)\n      : ({ tag: 'Sum', value: { variants: [] } } as AlgebraicTypeVariants.Sum);\n\n  r = new RefBuilder(MODULE_DEF.typespace.types.length);\n  MODULE_DEF.typespace.types.push(newTy);\n\n  COMPOUND_TYPES.set(ty, r);\n\n  if (typeBuilder instanceof RowBuilder) {\n    for (const [name, elem] of Object.entries(typeBuilder.row)) {\n      (newTy.value as ProductType).elements.push({\n        name,\n        algebraicType: registerTypesRecursively(elem.typeBuilder).algebraicType,\n      });\n    }\n  } else if (typeBuilder instanceof ProductBuilder) {\n    for (const [name, elem] of Object.entries(typeBuilder.elements)) {\n      (newTy.value as ProductType).elements.push({\n        name,\n        algebraicType: registerTypesRecursively(elem).algebraicType,\n      });\n    }\n  } else if (typeBuilder instanceof SumBuilder) {\n    for (const [name, variant] of Object.entries(typeBuilder.variants)) {\n      (newTy.value as SumType).variants.push({\n        name,\n        algebraicType: registerTypesRecursively(variant).algebraicType,\n      });\n    }\n  }\n\n  MODULE_DEF.types.push({\n    name: splitName(name),\n    ty: r.ref,\n    customOrdering: true,\n  });\n\n  return r;\n}\n\nfunction isUnit(typeBuilder: ProductBuilder<ElementsObj>): boolean {\n  return (\n    typeBuilder.typeName == null &&\n    typeBuilder.algebraicType.value.elements.length === 0\n  );\n}\n\nexport function splitName(name: string): Infer<typeof RawScopedTypeNameV9> {\n  const scope = name.split('.');\n  return { name: scope.pop()!, scope };\n}\n\n/**\n * The Schema class represents the database schema for a SpacetimeDB application.\n * It encapsulates the table definitions and typespace, and provides methods to define\n * reducers and lifecycle hooks.\n *\n * Schema has a generic parameter S which represents the inferred schema type. This type\n * is automatically inferred when creating a schema using the `schema()` function and is\n * used to type the database view in reducer contexts.\n *\n * The methods on this class are used to register reducers and lifecycle hooks\n * with the SpacetimeDB runtime. Theey forward to free functions that handle the actual\n * registration logic, but having them as methods on the Schema class helps with type inference.\n *\n * @template S - The inferred schema type of the SpacetimeDB module.\n *\n * @example\n * ```typescript\n * const spacetime = schema(\n *   table({ name: 'user' }, userType),\n *   table({ name: 'post' }, postType)\n * );\n * spacetime.reducer(\n *   'create_user',\n *   {  username: t.string(), email: t.string() },\n *   (ctx, { username, email }) => {\n *     ctx.db.user.insert({ username, email, created_at: ctx.timestamp });\n *     console.log(`User ${username} created by ${ctx.sender.identityId}`);\n *   }\n * );\n * ```\n */\n// TODO(cloutiertyler): It might be nice to have a way to access the types\n// for the tables from the schema object, e.g. `spacetimedb.user.type` would\n// be the type of the user table.\nclass Schema<S extends UntypedSchemaDef> {\n  readonly tablesDef: { tables: Infer<typeof RawTableDefV9>[] };\n  readonly typespace: Infer<typeof Typespace>;\n  readonly schemaType: S;\n\n  constructor(\n    tables: Infer<typeof RawTableDefV9>[],\n    typespace: Infer<typeof Typespace>,\n    handles: readonly UntypedTableSchema[]\n  ) {\n    this.tablesDef = { tables };\n    this.typespace = typespace;\n    // TODO: TableSchema and TableDef should really be unified\n    this.schemaType = tablesToSchema(handles) as S;\n  }\n\n  /**\n   * Defines a SpacetimeDB reducer function.\n   *\n   * Reducers are the primary way to modify the state of your SpacetimeDB application.\n   * They are atomic, meaning that either all operations within a reducer succeed,\n   * or none of them do.\n   *\n   * @template S - The inferred schema type of the SpacetimeDB module.\n   * @template Params - The type of the parameters object expected by the reducer.\n   *\n   * @param {string} name - The name of the reducer. This name will be used to call the reducer from clients.\n   * @param {Params} params - An object defining the parameters that the reducer accepts.\n   *                          Each key-value pair represents a parameter name and its corresponding\n   *                          {@link TypeBuilder} or {@link ColumnBuilder}.\n   * @param {(ctx: ReducerCtx<S>, payload: ParamsAsObject<Params>) => void} fn - The reducer function itself.\n   *   - `ctx`: The reducer context, providing access to `sender`, `timestamp`, `connection_id`, and `db`.\n   *   - `payload`: An object containing the arguments passed to the reducer, typed according to `params`.\n   *\n   * @example\n   * ```typescript\n   * // Define a reducer named 'create_user' that takes 'username' (string) and 'email' (string)\n   * spacetime.reducer(\n   *   'create_user',\n   *   {\n   *     username: t.string(),\n   *     email: t.string(),\n   *   },\n   *   (ctx, { username, email }) => {\n   *     // Access the 'user' table from the database view in the context\n   *     ctx.db.user.insert({ username, email, created_at: ctx.timestamp });\n   *     console.log(`User ${username} created by ${ctx.sender.identityId}`);\n   *   }\n   * );\n   * ```\n   */\n  reducer<Params extends ParamsObj>(\n    name: string,\n    params: Params,\n    fn: Reducer<S, Params>\n  ): Reducer<S, Params>;\n  reducer(name: string, fn: Reducer<S, {}>): Reducer<S, {}>;\n  reducer<Params extends ParamsObj>(\n    name: string,\n    paramsOrFn: Params | Reducer<S, any>,\n    fn?: Reducer<S, Params>\n  ): Reducer<S, Params> {\n    if (typeof paramsOrFn === 'function') {\n      // This is the case where params are omitted.\n      // The second argument is the reducer function.\n      // We pass an empty object for the params.\n      reducer(name, {}, paramsOrFn);\n      return paramsOrFn;\n    } else {\n      // This is the case where params are provided.\n      // The second argument is the params object, and the third is the function.\n      // The `fn` parameter is guaranteed to be defined here.\n      reducer(name, paramsOrFn, fn!);\n      return fn!;\n    }\n  }\n\n  /**\n   * Registers an initialization reducer that runs when the SpacetimeDB module is published\n   * for the first time.\n   *\n   * This function is useful to set up any initial state of your database that is guaranteed\n   * to run only once, and before any other reducers or client connections.\n   *\n   * @template S - The inferred schema type of the SpacetimeDB module.\n   * @param {Reducer<S, {}>} fn - The initialization reducer function.\n   *  - `ctx`: The reducer context, providing access to `sender`, `timestamp`, `connection_id`, and `db`.\n   * @example\n   * ```typescript\n   * spacetime.init((ctx) => {\n   *   ctx.db.user.insert({ username: 'admin', email: 'admin@example.com' });\n   * });\n   * ```\n   */\n  init(fn: Reducer<S, {}>): void;\n  init(name: string, fn: Reducer<S, {}>): void;\n  init(nameOrFn: any, maybeFn?: Reducer<S, {}>): void {\n    const [name, fn] =\n      typeof nameOrFn === 'string' ? [nameOrFn, maybeFn] : ['init', nameOrFn];\n    init(name, {}, fn);\n  }\n\n  /**\n   * Registers a reducer to be called when a client connects to the SpacetimeDB module.\n   * This function allows you to define custom logic that should execute\n   * whenever a new client establishes a connection.\n   * @template S - The inferred schema type of the SpacetimeDB module.\n   *\n   * @param fn - The reducer function to execute on client connection.\n   *\n   * @example\n   * ```typescript\n   * spacetime.clientConnected(\n   *   (ctx) => {\n   *     console.log(`Client ${ctx.connectionId} connected`);\n   *   }\n   * );\n   */\n  clientConnected(fn: Reducer<S, {}>): void;\n  clientConnected(name: string, fn: Reducer<S, {}>): void;\n  clientConnected(nameOrFn: any, maybeFn?: Reducer<S, {}>): void {\n    const [name, fn] =\n      typeof nameOrFn === 'string'\n        ? [nameOrFn, maybeFn]\n        : ['on_connect', nameOrFn];\n    clientConnected(name, {}, fn);\n  }\n\n  /**\n   * Registers a reducer to be called when a client disconnects from the SpacetimeDB module.\n   * This function allows you to define custom logic that should execute\n   * whenever a client disconnects.\n   * @template S - The inferred schema type of the SpacetimeDB module.\n   *\n   * @param fn - The reducer function to execute on client disconnection.\n   *\n   * @example\n   * ```typescript\n   * spacetime.clientDisconnected(\n   *   (ctx) => {\n   *     console.log(`Client ${ctx.connectionId} disconnected`);\n   *   }\n   * );\n   * ```\n   */\n  clientDisconnected(fn: Reducer<S, {}>): void;\n  clientDisconnected(name: string, fn: Reducer<S, {}>): void;\n  clientDisconnected(nameOrFn: any, maybeFn?: Reducer<S, {}>): void {\n    const [name, fn] =\n      typeof nameOrFn === 'string'\n        ? [nameOrFn, maybeFn]\n        : ['on_disconnect', nameOrFn];\n    clientDisconnected(name, {}, fn);\n  }\n\n  view<Ret extends ViewReturnTypeBuilder>(\n    opts: ViewOpts,\n    ret: Ret,\n    fn: ViewFn<S, {}, Ret>\n  ): void {\n    defineView(opts, false, {}, ret, fn);\n  }\n\n  // TODO: re-enable once parameterized views are supported in SQL\n  // view<Ret extends ViewReturnTypeBuilder>(\n  //   opts: ViewOpts,\n  //   ret: Ret,\n  //   fn: ViewFn<S, {}, Ret>\n  // ): void;\n  // view<Params extends ParamsObj, Ret extends ViewReturnTypeBuilder>(\n  //   opts: ViewOpts,\n  //   params: Params,\n  //   ret: Ret,\n  //   fn: ViewFn<S, {}, Ret>\n  // ): void;\n  // view<Params extends ParamsObj, Ret extends ViewReturnTypeBuilder>(\n  //   opts: ViewOpts,\n  //   paramsOrRet: Ret | Params,\n  //   retOrFn: ViewFn<S, {}, Ret> | Ret,\n  //   maybeFn?: ViewFn<S, Params, Ret>\n  // ): void {\n  //   if (typeof retOrFn === 'function') {\n  //     defineView(name, false, {}, paramsOrRet as Ret, retOrFn);\n  //   } else {\n  //     defineView(name, false, paramsOrRet as Params, retOrFn, maybeFn!);\n  //   }\n  // }\n\n  anonymousView<Ret extends ViewReturnTypeBuilder>(\n    opts: ViewOpts,\n    ret: Ret,\n    fn: AnonymousViewFn<S, {}, Ret>\n  ): void {\n    defineView(opts, true, {}, ret, fn);\n  }\n\n  // TODO: re-enable once parameterized views are supported in SQL\n  // anonymousView<Ret extends ViewReturnTypeBuilder>(\n  //   opts: ViewOpts,\n  //   ret: Ret,\n  //   fn: AnonymousViewFn<S, {}, Ret>\n  // ): void;\n  // anonymousView<Params extends ParamsObj, Ret extends ViewReturnTypeBuilder>(\n  //   opts: ViewOpts,\n  //   params: Params,\n  //   ret: Ret,\n  //   fn: AnonymousViewFn<S, {}, Ret>\n  // ): void;\n  // anonymousView<Params extends ParamsObj, Ret extends ViewReturnTypeBuilder>(\n  //   opts: ViewOpts,\n  //   paramsOrRet: Ret | Params,\n  //   retOrFn: AnonymousViewFn<S, {}, Ret> | Ret,\n  //   maybeFn?: AnonymousViewFn<S, Params, Ret>\n  // ): void {\n  //   if (typeof retOrFn === 'function') {\n  //     defineView(name, true, {}, paramsOrRet as Ret, retOrFn);\n  //   } else {\n  //     defineView(name, true, paramsOrRet as Params, retOrFn, maybeFn!);\n  //   }\n  // }\n\n  procedure<Params extends ParamsObj, Ret extends TypeBuilder<any, any>>(\n    name: string,\n    params: Params,\n    ret: Ret,\n    fn: ProcedureFn<S, Params, Ret>\n  ): ProcedureFn<S, Params, Ret>;\n  procedure<Ret extends TypeBuilder<any, any>>(\n    name: string,\n    ret: Ret,\n    fn: ProcedureFn<S, {}, Ret>\n  ): ProcedureFn<S, {}, Ret>;\n  procedure<Params extends ParamsObj, Ret extends TypeBuilder<any, any>>(\n    name: string,\n    paramsOrRet: Ret | Params,\n    retOrFn: ProcedureFn<S, {}, Ret> | Ret,\n    maybeFn?: ProcedureFn<S, Params, Ret>\n  ): ProcedureFn<S, Params, Ret> {\n    if (typeof retOrFn === 'function') {\n      procedure(name, {}, paramsOrRet as Ret, retOrFn);\n      return retOrFn;\n    } else {\n      procedure(name, paramsOrRet as Params, retOrFn, maybeFn!);\n      return maybeFn!;\n    }\n  }\n\n  clientVisibilityFilter = {\n    sql(filter: string): void {\n      MODULE_DEF.rowLevelSecurity.push({ sql: filter });\n    },\n  };\n}\n\n/**\n * Extracts the inferred schema type from a Schema instance\n */\nexport type InferSchema<SchemaDef extends Schema<any>> =\n  SchemaDef extends Schema<infer S> ? S : never;\n\n/**\n * Creates a schema from table definitions\n * @param handles - Array of table handles created by table() function\n * @returns ColumnBuilder representing the complete database schema\n * @example\n * ```ts\n * const s = schema(\n *   table({ name: 'user' }, userType),\n *   table({ name: 'post' }, postType)\n * );\n * ```\n */\nexport function schema<const H extends readonly UntypedTableSchema[]>(\n  ...handles: H\n): Schema<TablesToSchema<H>>;\n\n/**\n * Creates a schema from table definitions (array overload)\n * @param handles - Array of table handles created by table() function\n * @returns ColumnBuilder representing the complete database schema\n */\nexport function schema<const H extends readonly UntypedTableSchema[]>(\n  handles: H\n): Schema<TablesToSchema<H>>;\n\n/**\n * Creates a schema from table definitions\n * @param args - Either an array of table handles or a variadic list of table handles\n * @returns ColumnBuilder representing the complete database schema\n * @example\n * ```ts\n * const s = schema(\n *  table({ name: 'user' }, userType),\n *  table({ name: 'post' }, postType)\n * );\n * ```\n */\nexport function schema<const H extends readonly UntypedTableSchema[]>(\n  ...args: [H] | H\n): Schema<TablesToSchema<H>> {\n  const handles = (\n    args.length === 1 && Array.isArray(args[0]) ? args[0] : args\n  ) as H;\n  const tableDefs = handles.map(h => h.tableDef);\n\n  // Side-effect:\n  // Modify the `MODULE_DEF` which will be read by\n  // __describe_module__\n  MODULE_DEF.tables.push(...tableDefs);\n  REGISTERED_SCHEMA = {\n    tables: handles.map(handle => ({\n      name: handle.tableName,\n      accessorName: handle.tableName,\n      columns: handle.rowType.row,\n      rowType: handle.rowSpacetimeType,\n      indexes: handle.idxs,\n      constraints: handle.constraints,\n    })),\n  };\n  // MODULE_DEF.typespace = typespace;\n  // throw new Error(\n  //   MODULE_DEF.tables\n  //     .map(t => {\n  //       const p = MODULE_DEF.typespace.types[t.productTypeRef];\n  //       return `${t.name}: ${t.productTypeRef} ${p && (p as AlgebraicTypeVariants.Product).value.elements.map(x => x.name)}`;\n  //     })\n  //     .join('\\n')\n  // );\n\n  return new Schema(tableDefs, MODULE_DEF.typespace, handles);\n}\n\ntype HasAccessor = { accessorName: PropertyKey };\n\nexport type ConvertToAccessorMap<TableDefs extends readonly HasAccessor[]> = {\n  [Tbl in TableDefs[number] as Tbl['accessorName']]: Tbl;\n};\n\nexport function convertToAccessorMap<T extends readonly HasAccessor[]>(\n  arr: T\n): ConvertToAccessorMap<T> {\n  return Object.fromEntries(\n    arr.map(v => [v.accessorName, v])\n  ) as ConvertToAccessorMap<T>;\n}\n","// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE\n// WILL NOT BE SAVED. MODIFY TABLES IN YOUR MODULE SOURCE CODE INSTEAD.\n\n/* eslint-disable */\n/* tslint:disable */\nimport {\n  TypeBuilder as __TypeBuilder,\n  t as __t,\n  type AlgebraicTypeType as __AlgebraicTypeType,\n  type Infer as __Infer,\n} from '../../lib/type_builders';\n\n// The tagged union or sum type for the algebraic type `RawIndexAlgorithm`.\nconst RawIndexAlgorithm = __t.enum('RawIndexAlgorithm', {\n  BTree: __t.array(__t.u16()),\n  Hash: __t.array(__t.u16()),\n  Direct: __t.u16(),\n});\n\nexport default RawIndexAlgorithm;\n","import type RawConstraintDefV9 from './autogen/raw_constraint_def_v_9_type';\nimport RawIndexAlgorithm from './autogen/raw_index_algorithm_type';\nimport type RawIndexDefV9 from './autogen/raw_index_def_v_9_type';\nimport type RawSequenceDefV9 from './autogen/raw_sequence_def_v_9_type';\nimport type RawTableDefV9 from './autogen/raw_table_def_v_9_type';\nimport type { AllUnique, ConstraintOpts } from './constraints';\nimport type {\n  ColumnIndex,\n  IndexColumns,\n  Indexes,\n  IndexOpts,\n  ReadonlyIndexes,\n} from './indexes';\nimport ScheduleAt from './schedule_at';\nimport { registerTypesRecursively } from './schema';\nimport type { TableSchema } from './table_schema';\nimport {\n  RowBuilder,\n  type ColumnBuilder,\n  type ColumnMetadata,\n  type Infer,\n  type InferTypeOfRow,\n  type RowObj,\n  type TypeBuilder,\n} from './type_builders';\nimport type { Prettify } from './type_util';\nimport { toPascalCase } from './util';\n\nexport type AlgebraicTypeRef = number;\ntype ColId = number;\ntype ColList = ColId[];\n\n/**\n * A helper type to extract the row type from a TableDef\n */\nexport type RowType<TableDef extends Pick<UntypedTableDef, 'columns'>> =\n  InferTypeOfRow<TableDef['columns']>;\n\n/**\n * Coerces a column which may be a TypeBuilder or ColumnBuilder into a ColumnBuilder\n */\nexport type CoerceColumn<\n  Col extends TypeBuilder<any, any> | ColumnBuilder<any, any, any>,\n> =\n  Col extends TypeBuilder<infer T, infer U>\n    ? ColumnBuilder<T, U, ColumnMetadata<any>>\n    : Col;\n\n/**\n * Coerces a RowObj where TypeBuilders are replaced with ColumnBuilders\n */\nexport type CoerceRow<Row extends RowObj> = {\n  [k in keyof Row & string]: CoerceColumn<Row[k]>;\n};\n\n/**\n * Helper type to coerce an array of IndexOpts\n */\ntype CoerceArray<X extends IndexOpts<any>[]> = X;\n\n/**\n * An untyped representation of a table's schema.\n */\nexport type UntypedTableDef = {\n  name: string;\n  accessorName: string;\n  columns: Record<string, ColumnBuilder<any, any, ColumnMetadata<any>>>;\n  // This is really just a ProductType where all the elements have names.\n  rowType: RowBuilder<RowObj>['algebraicType']['value'];\n  indexes: readonly IndexOpts<any>[];\n  constraints: readonly ConstraintOpts<any>[];\n};\n\n/**\n * A type representing the indexes defined on a table.\n */\nexport type TableIndexes<TableDef extends UntypedTableDef> = {\n  [K in keyof TableDef['columns'] & string as ColumnIndex<\n    K,\n    TableDef['columns'][K]['columnMetadata']\n  > extends never\n    ? never\n    : K]: ColumnIndex<K, TableDef['columns'][K]['columnMetadata']>;\n} & {\n  [I in TableDef['indexes'][number] as I['name'] & {}]: TableIndexFromDef<\n    TableDef,\n    I\n  >;\n};\n\ntype TableIndexFromDef<\n  TableDef extends UntypedTableDef,\n  I extends IndexOpts<keyof TableDef['columns'] & string>,\n> =\n  NormalizeIndexColumns<TableDef, I> extends infer Cols extends ReadonlyArray<\n    keyof TableDef['columns'] & string\n  >\n    ? {\n        name: I['name'];\n        unique: AllUnique<TableDef, Cols>;\n        algorithm: Lowercase<I['algorithm']>;\n        columns: Cols;\n      }\n    : never;\n\ntype NormalizeIndexColumns<\n  TableDef extends UntypedTableDef,\n  I extends IndexOpts<keyof TableDef['columns'] & string>,\n> =\n  IndexColumns<I> extends ReadonlyArray<keyof TableDef['columns'] & string>\n    ? IndexColumns<I>\n    : never;\n\n/**\n * Options for configuring a database table.\n * - `name`: The name of the table.\n * - `public`: Whether the table is publicly accessible. Defaults to `false`.\n * - `indexes`: An array of index configurations for the table.\n * - `constraints`: An array of constraint configurations for the table.\n * - `scheduled`: The name of the reducer to be executed based on the scheduled rows in this table.\n */\nexport type TableOpts<Row extends RowObj> = {\n  name: string;\n  public?: boolean;\n  indexes?: IndexOpts<keyof Row & string>[]; // declarative multicolumn indexes\n  constraints?: ConstraintOpts<keyof Row & string>[];\n  scheduled?: string;\n};\n\n/**\n * Extracts the indices from TableOpts, defaulting to an empty array if none are provided.\n */\ntype OptsIndices<Opts extends TableOpts<any>> = Opts extends {\n  indexes: infer Ixs extends NonNullable<any[]>;\n}\n  ? Ixs\n  : CoerceArray<[]>;\n\n/**\n * Extracts the constraints from TableOpts, defaulting to an empty array if none are provided.\n */\ntype OptsConstraints<Opts extends TableOpts<any>> = Opts extends {\n  constraints: infer Constraints extends NonNullable<any[]>;\n}\n  ? Constraints\n  : CoerceArray<[]>;\n\n/**\n * Table<Row, UniqueConstraintViolation = never, AutoIncOverflow = never>\n *\n * - Row: row shape\n * - UCV: unique-constraint violation error type (never if none)\n * - AIO: auto-increment overflow error type (never if none)\n */\nexport type Table<TableDef extends UntypedTableDef> = Prettify<\n  TableMethods<TableDef> & Indexes<TableDef, TableIndexes<TableDef>>\n>;\n\nexport type ReadonlyTable<TableDef extends UntypedTableDef> = Prettify<\n  ReadonlyTableMethods<TableDef> &\n    ReadonlyIndexes<TableDef, TableIndexes<TableDef>>\n>;\n\nexport interface ReadonlyTableMethods<TableDef extends UntypedTableDef> {\n  /** Returns the number of rows in the TX state. */\n  count(): bigint;\n\n  /** Iterate over all rows in the TX state. Rust Iterator<Item=Row>  TS IterableIterator<Row>. */\n  iter(): IteratorObject<Prettify<RowType<TableDef>>, undefined>;\n  [Symbol.iterator](): IteratorObject<Prettify<RowType<TableDef>>, undefined>;\n}\n\n/**\n * A type representing the methods available on a table.\n */\nexport interface TableMethods<TableDef extends UntypedTableDef>\n  extends ReadonlyTableMethods<TableDef> {\n  /**\n   * Insert and return the inserted row (auto-increment fields filled).\n   *\n   * May throw on error:\n   * * If there are any unique or primary key columns in this table, may throw {@link UniqueAlreadyExists}.\n   * * If there are any auto-incrementing columns in this table, may throw {@link AutoIncOverflow}.\n   * */\n  insert(row: Prettify<RowType<TableDef>>): Prettify<RowType<TableDef>>;\n\n  /** Delete a row equal to `row`. Returns true if something was deleted. */\n  delete(row: Prettify<RowType<TableDef>>): boolean;\n}\n\n/**\n * Defines a database table with schema and options\n * @param opts - Table configuration including name, indexes, and access control\n * @param row - Product type defining the table's row structure\n * @returns Table handle for use in schema() function\n * @example\n * ```ts\n * const playerTable = table(\n *   { name: 'player', public: true },\n *   t.object({\n *     id: t.u32().primaryKey(),\n *     name: t.string().index('btree')\n *   })\n * );\n * ```\n */\nexport function table<Row extends RowObj, const Opts extends TableOpts<Row>>(\n  opts: Opts,\n  row: Row | RowBuilder<Row>\n): TableSchema<Opts['name'], CoerceRow<Row>, OptsIndices<Opts>> {\n  const {\n    name,\n    public: isPublic = false,\n    indexes: userIndexes = [],\n    scheduled,\n  } = opts;\n\n  // 1. column catalogue + helpers\n  const colIds = new Map<keyof Row & string, ColId>();\n  const colNameList: string[] = [];\n\n  if (!(row instanceof RowBuilder)) {\n    row = new RowBuilder(row);\n  }\n\n  if (row.typeName === undefined) {\n    row.typeName = toPascalCase(name);\n  }\n\n  const rowTypeRef = registerTypesRecursively(row);\n\n  row.algebraicType.value.elements.forEach((elem, i) => {\n    colIds.set(elem.name, i);\n    colNameList.push(elem.name);\n  });\n\n  // gather primary keys, percolumn indexes, uniques, sequences\n  const pk: ColList = [];\n  const indexes: Infer<typeof RawIndexDefV9>[] = [];\n  const constraints: Infer<typeof RawConstraintDefV9>[] = [];\n  const sequences: Infer<typeof RawSequenceDefV9>[] = [];\n\n  let scheduleAtCol: ColId | undefined;\n\n  for (const [name, builder] of Object.entries(row.row)) {\n    const meta: ColumnMetadata<any> = builder.columnMetadata;\n\n    if (meta.isPrimaryKey) {\n      pk.push(colIds.get(name)!);\n    }\n\n    const isUnique = meta.isUnique || meta.isPrimaryKey;\n\n    // implicit 1column indexes\n    if (meta.indexType || isUnique) {\n      const algo = meta.indexType ?? 'btree';\n      const id = colIds.get(name)!;\n      let algorithm: Infer<typeof RawIndexAlgorithm>;\n      switch (algo) {\n        case 'btree':\n          algorithm = RawIndexAlgorithm.BTree([id]);\n          break;\n        case 'direct':\n          algorithm = RawIndexAlgorithm.Direct(id);\n          break;\n      }\n      indexes.push({\n        name: undefined, // Unnamed indexes will be assigned a globally unique name\n        accessorName: name, // The name of this column will be used as the accessor name\n        algorithm,\n      });\n    }\n\n    if (isUnique) {\n      constraints.push({\n        name: undefined,\n        data: { tag: 'Unique', value: { columns: [colIds.get(name)!] } },\n      });\n    }\n\n    if (meta.isAutoIncrement) {\n      sequences.push({\n        name: undefined,\n        start: undefined,\n        minValue: undefined,\n        maxValue: undefined,\n        column: colIds.get(name)!,\n        increment: 1n,\n      });\n    }\n\n    // If this column is shaped like ScheduleAtAlgebraicType, mark it as the scheduleat column\n    if (scheduled) {\n      const algebraicType = builder.typeBuilder.algebraicType;\n      if (ScheduleAt.isScheduleAt(algebraicType)) {\n        scheduleAtCol = colIds.get(name)!;\n      }\n    }\n  }\n\n  // convert explicit multicolumn indexes coming from options.indexes\n  for (const indexOpts of userIndexes ?? []) {\n    let algorithm: Infer<typeof RawIndexAlgorithm>;\n    switch (indexOpts.algorithm) {\n      case 'btree':\n        algorithm = {\n          tag: 'BTree',\n          value: indexOpts.columns.map(c => colIds.get(c)!),\n        };\n        break;\n      case 'direct':\n        algorithm = { tag: 'Direct', value: colIds.get(indexOpts.column)! };\n        break;\n    }\n    // unnamed indexes will be assigned a globally unique name\n    // The name users supply is actually the accessor name which will be used\n    // in TypeScript to access the index. This will be used verbatim.\n    // This is confusing because it is not the index name and there is\n    // no actual way for the user to set the actual index name.\n    // I think we should standardize: name and accessorName as the way to set\n    // the name and accessor name of an index across all SDKs.\n    indexes.push({ name: undefined, accessorName: indexOpts.name, algorithm });\n  }\n\n  // add explicit constraints from options.constraints\n  for (const constraintOpts of opts.constraints ?? []) {\n    if (constraintOpts.constraint === 'unique') {\n      const data: Infer<typeof RawConstraintDefV9>['data'] = {\n        tag: 'Unique',\n        value: { columns: constraintOpts.columns.map(c => colIds.get(c)!) },\n      };\n      constraints.push({ name: constraintOpts.name, data });\n      continue;\n    }\n  }\n\n  for (const index of indexes) {\n    const cols =\n      index.algorithm.tag === 'Direct'\n        ? [index.algorithm.value]\n        : index.algorithm.value;\n    const colS = cols.map(i => colNameList[i]).join('_');\n    index.name = `${name}_${colS}_idx_${index.algorithm.tag.toLowerCase()}`;\n  }\n\n  // Temporarily set the type ref to 0. We will set this later\n  // in the schema function.\n\n  const tableDef: Infer<typeof RawTableDefV9> = {\n    name,\n    productTypeRef: rowTypeRef.ref,\n    primaryKey: pk,\n    indexes,\n    constraints,\n    sequences,\n    schedule:\n      scheduled && scheduleAtCol !== undefined\n        ? {\n            name: undefined,\n            reducerName: scheduled,\n            scheduledAtColumn: scheduleAtCol,\n          }\n        : undefined,\n    tableType: { tag: 'User' },\n    tableAccess: { tag: isPublic ? 'Public' : 'Private' },\n  };\n\n  const productType = row.algebraicType.value as RowBuilder<\n    CoerceRow<Row>\n  >['algebraicType']['value'];\n\n  return {\n    rowType: row as RowBuilder<CoerceRow<Row>>,\n    tableName: name,\n    rowSpacetimeType: productType,\n    tableDef,\n    idxs: {} as OptsIndices<Opts>,\n    constraints: constraints as OptsConstraints<Opts>,\n  };\n}\n","/**\n * Base class for all Spacetime host errors (i.e. errors that may be thrown\n * by database functions).\n *\n * Instances of SpacetimeError can be created with just an error code,\n * which will return the appropriate subclass instance.\n */\nexport class SpacetimeHostError extends Error {\n  public readonly code: number;\n  public readonly message: string;\n  constructor(code: number, message?: string) {\n    super();\n    const proto = Object.getPrototypeOf(this);\n    let cls;\n    if (errorProtoypes.has(proto)) {\n      cls = proto.constructor;\n      if (code !== cls.CODE)\n        throw new TypeError(`invalid error code for ${cls.name}`);\n    } else if (proto === SpacetimeHostError.prototype) {\n      cls = errnoToClass.get(code);\n      if (!cls) throw new RangeError(`unknown error code ${code}`);\n    } else {\n      throw new TypeError('cannot subclass SpacetimeError');\n    }\n    Object.setPrototypeOf(this, cls.prototype);\n    this.code = cls.CODE;\n    this.message = message ?? cls.MESSAGE;\n  }\n  get name(): string {\n    return errnoToClass.get(this.code)?.name ?? 'SpacetimeHostError';\n  }\n}\n\n/**\n * An error thrown by a reducer that indicates a problem to the sender.\n *\n * When this error is thrown by a reducer, the sender will be notified\n * that the reducer failed gracefully with the given message.\n */\nexport class SenderError extends Error {\n  constructor(message: string) {\n    super(message);\n  }\n  get name() {\n    return 'SenderError';\n  }\n}\n\nconst errorData = {\n  /**\n   * A generic error class for unknown error codes.\n   */\n  HostCallFailure: [1, 'ABI called by host returned an error'],\n\n  /**\n   * Error indicating that an ABI call was made outside of a transaction.\n   */\n  NotInTransaction: [2, 'ABI call can only be made while in a transaction'],\n\n  /**\n   * Error indicating that BSATN decoding failed.\n   * This typically means that the data could not be decoded to the expected type.\n   */\n  BsatnDecodeError: [3, \"Couldn't decode the BSATN to the expected type\"],\n\n  /**\n   * Error indicating that a specified table does not exist.\n   */\n  NoSuchTable: [4, 'No such table'],\n\n  /**\n   * Error indicating that a specified index does not exist.\n   */\n  NoSuchIndex: [5, 'No such index'],\n\n  /**\n   * Error indicating that a specified row iterator is not valid.\n   */\n  NoSuchIter: [6, 'The provided row iterator is not valid'],\n\n  /**\n   * Error indicating that a specified console timer does not exist.\n   */\n  NoSuchConsoleTimer: [7, 'The provided console timer does not exist'],\n\n  /**\n   * Error indicating that a specified bytes source or sink is not valid.\n   */\n  NoSuchBytes: [8, 'The provided bytes source or sink is not valid'],\n\n  /**\n   * Error indicating that a provided sink has no more space left.\n   */\n  NoSpace: [9, 'The provided sink has no more space left'],\n\n  /**\n   * Error indicating that there is no more space in the database.\n   */\n  BufferTooSmall: [\n    11,\n    'The provided buffer is not large enough to store the data',\n  ],\n\n  /**\n   * Error indicating that a value with a given unique identifier already exists.\n   */\n  UniqueAlreadyExists: [\n    12,\n    'Value with given unique identifier already exists',\n  ],\n\n  /**\n   * Error indicating that the specified delay in scheduling a row was too long.\n   */\n  ScheduleAtDelayTooLong: [\n    13,\n    'Specified delay in scheduling row was too long',\n  ],\n\n  /**\n   * Error indicating that an index was not unique when it was expected to be.\n   */\n  IndexNotUnique: [14, 'The index was not unique'],\n\n  /**\n   * Error indicating that an index was not unique when it was expected to be.\n   */\n  NoSuchRow: [15, 'The row was not found, e.g., in an update call'],\n\n  /**\n   * Error indicating that an auto-increment sequence has overflowed.\n   */\n  AutoIncOverflow: [16, 'The auto-increment sequence overflowed'],\n\n  WouldBlockTransaction: [\n    17,\n    'Attempted async or blocking op while holding open a transaction',\n  ],\n\n  TransactionNotAnonymous: [\n    18,\n    'Not in an anonymous transaction. Called by a reducer?',\n  ],\n\n  TransactionIsReadOnly: [\n    19,\n    'ABI call can only be made while within a mutable transaction',\n  ],\n\n  TransactionIsMut: [\n    20,\n    'ABI call can only be made while within a read-only transaction',\n  ],\n\n  HttpError: [21, 'The HTTP request failed'],\n} as const;\n\nfunction mapEntries<const T extends Record<string, any>, U>(\n  x: T,\n  f: (key: keyof T, value: T[keyof T]) => U\n): { [k in keyof T]: U } {\n  return Object.fromEntries(\n    Object.entries(x).map(([k, v]) => [k, f(k, v)])\n  ) as any;\n}\n\nexport const errors = Object.freeze(\n  mapEntries(errorData, (name, [code, message]) =>\n    Object.defineProperty(\n      class extends SpacetimeHostError {\n        static CODE = code;\n        static MESSAGE = message;\n        constructor() {\n          super(code);\n        }\n      },\n      'name',\n      { value: name, writable: false }\n    )\n  )\n);\n\n/**\n * Set of prototypes of all SpacetimeError subclasses for quick lookup.\n */\nconst errorProtoypes = new Set(Object.values(errors).map(cls => cls.prototype));\n\n/**\n * Map from error codes to their corresponding SpacetimeError subclass.\n */\nconst errnoToClass = new Map(\n  Object.values(errors).map(cls => [cls.CODE as number, cls])\n);\n","import 'fast-text-encoding';\nimport 'url-polyfill';\n","// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE\n// WILL NOT BE SAVED. MODIFY TABLES IN YOUR MODULE SOURCE CODE INSTEAD.\n\n/* eslint-disable */\n/* tslint:disable */\nimport {\n  TypeBuilder as __TypeBuilder,\n  t as __t,\n  type AlgebraicTypeType as __AlgebraicTypeType,\n  type Infer as __Infer,\n} from '../../lib/type_builders';\nimport AlgebraicType from './algebraic_type_type';\n\nexport default __t.object('SumTypeVariant', {\n  name: __t.option(__t.string()),\n  get algebraicType() {\n    return AlgebraicType;\n  },\n});\n","// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE\n// WILL NOT BE SAVED. MODIFY TABLES IN YOUR MODULE SOURCE CODE INSTEAD.\n\n/* eslint-disable */\n/* tslint:disable */\nimport {\n  TypeBuilder as __TypeBuilder,\n  t as __t,\n  type AlgebraicTypeType as __AlgebraicTypeType,\n  type Infer as __Infer,\n} from '../../lib/type_builders';\nimport SumTypeVariant from './sum_type_variant_type';\n\nexport default __t.object('SumType', {\n  get variants() {\n    return __t.array(SumTypeVariant);\n  },\n});\n","// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE\n// WILL NOT BE SAVED. MODIFY TABLES IN YOUR MODULE SOURCE CODE INSTEAD.\n\n/* eslint-disable */\n/* tslint:disable */\nimport {\n  TypeBuilder as __TypeBuilder,\n  t as __t,\n  type AlgebraicTypeType as __AlgebraicTypeType,\n  type Infer as __Infer,\n} from '../../lib/type_builders';\nimport AlgebraicType from './algebraic_type_type';\n\nexport default __t.object('ProductTypeElement', {\n  name: __t.option(__t.string()),\n  get algebraicType() {\n    return AlgebraicType;\n  },\n});\n","// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE\n// WILL NOT BE SAVED. MODIFY TABLES IN YOUR MODULE SOURCE CODE INSTEAD.\n\n/* eslint-disable */\n/* tslint:disable */\nimport {\n  TypeBuilder as __TypeBuilder,\n  t as __t,\n  type AlgebraicTypeType as __AlgebraicTypeType,\n  type Infer as __Infer,\n} from '../../lib/type_builders';\nimport ProductTypeElement from './product_type_element_type';\n\nexport default __t.object('ProductType', {\n  get elements() {\n    return __t.array(ProductTypeElement);\n  },\n});\n","// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE\n// WILL NOT BE SAVED. MODIFY TABLES IN YOUR MODULE SOURCE CODE INSTEAD.\n\n/* eslint-disable */\n/* tslint:disable */\nimport {\n  TypeBuilder as __TypeBuilder,\n  t as __t,\n  type AlgebraicTypeType as __AlgebraicTypeType,\n  type Infer as __Infer,\n} from '../../lib/type_builders';\nimport SumType from './sum_type_type';\nimport ProductType from './product_type_type';\n\n// The tagged union or sum type for the algebraic type `AlgebraicType`.\nconst AlgebraicType: __TypeBuilder<__AlgebraicTypeType, __AlgebraicTypeType> =\n  __t.enum('AlgebraicType', {\n    Ref: __t.u32(),\n    get Sum() {\n      return SumType;\n    },\n    get Product() {\n      return ProductType;\n    },\n    get Array() {\n      return AlgebraicType;\n    },\n    String: __t.unit(),\n    Bool: __t.unit(),\n    I8: __t.unit(),\n    U8: __t.unit(),\n    I16: __t.unit(),\n    U16: __t.unit(),\n    I32: __t.unit(),\n    U32: __t.unit(),\n    I64: __t.unit(),\n    U64: __t.unit(),\n    I128: __t.unit(),\n    U128: __t.unit(),\n    I256: __t.unit(),\n    U256: __t.unit(),\n    F32: __t.unit(),\n    F64: __t.unit(),\n  });\n\nexport default AlgebraicType;\n","// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE\n// WILL NOT BE SAVED. MODIFY TABLES IN YOUR MODULE SOURCE CODE INSTEAD.\n\n/* eslint-disable */\n/* tslint:disable */\nimport {\n  TypeBuilder as __TypeBuilder,\n  t as __t,\n  type AlgebraicTypeType as __AlgebraicTypeType,\n  type Infer as __Infer,\n} from '../../lib/type_builders';\nimport AlgebraicType from './algebraic_type_type';\n\nexport default __t.object('Typespace', {\n  get types() {\n    return __t.array(AlgebraicType);\n  },\n});\n","// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE\n// WILL NOT BE SAVED. MODIFY TABLES IN YOUR MODULE SOURCE CODE INSTEAD.\n\n/* eslint-disable */\n/* tslint:disable */\nimport {\n  TypeBuilder as __TypeBuilder,\n  t as __t,\n  type AlgebraicTypeType as __AlgebraicTypeType,\n  type Infer as __Infer,\n} from '../../lib/type_builders';\nimport AlgebraicType from './algebraic_type_type';\n\nexport default __t.object('RawColumnDefV8', {\n  colName: __t.string(),\n  get colType() {\n    return AlgebraicType;\n  },\n});\n","// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE\n// WILL NOT BE SAVED. MODIFY TABLES IN YOUR MODULE SOURCE CODE INSTEAD.\n\n/* eslint-disable */\n/* tslint:disable */\nimport {\n  TypeBuilder as __TypeBuilder,\n  t as __t,\n  type AlgebraicTypeType as __AlgebraicTypeType,\n  type Infer as __Infer,\n} from '../../lib/type_builders';\n\n// The tagged union or sum type for the algebraic type `IndexType`.\nconst IndexType = __t.enum('IndexType', {\n  BTree: __t.unit(),\n  Hash: __t.unit(),\n});\n\nexport default IndexType;\n","// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE\n// WILL NOT BE SAVED. MODIFY TABLES IN YOUR MODULE SOURCE CODE INSTEAD.\n\n/* eslint-disable */\n/* tslint:disable */\nimport {\n  TypeBuilder as __TypeBuilder,\n  t as __t,\n  type AlgebraicTypeType as __AlgebraicTypeType,\n  type Infer as __Infer,\n} from '../../lib/type_builders';\nimport IndexType from './index_type_type';\n\nexport default __t.object('RawIndexDefV8', {\n  indexName: __t.string(),\n  isUnique: __t.bool(),\n  get indexType() {\n    return IndexType;\n  },\n  columns: __t.array(__t.u16()),\n});\n","// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE\n// WILL NOT BE SAVED. MODIFY TABLES IN YOUR MODULE SOURCE CODE INSTEAD.\n\n/* eslint-disable */\n/* tslint:disable */\nimport {\n  TypeBuilder as __TypeBuilder,\n  t as __t,\n  type AlgebraicTypeType as __AlgebraicTypeType,\n  type Infer as __Infer,\n} from '../../lib/type_builders';\n\nexport default __t.object('RawConstraintDefV8', {\n  constraintName: __t.string(),\n  constraints: __t.u8(),\n  columns: __t.array(__t.u16()),\n});\n","// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE\n// WILL NOT BE SAVED. MODIFY TABLES IN YOUR MODULE SOURCE CODE INSTEAD.\n\n/* eslint-disable */\n/* tslint:disable */\nimport {\n  TypeBuilder as __TypeBuilder,\n  t as __t,\n  type AlgebraicTypeType as __AlgebraicTypeType,\n  type Infer as __Infer,\n} from '../../lib/type_builders';\n\nexport default __t.object('RawSequenceDefV8', {\n  sequenceName: __t.string(),\n  colPos: __t.u16(),\n  increment: __t.i128(),\n  start: __t.option(__t.i128()),\n  minValue: __t.option(__t.i128()),\n  maxValue: __t.option(__t.i128()),\n  allocated: __t.i128(),\n});\n","// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE\n// WILL NOT BE SAVED. MODIFY TABLES IN YOUR MODULE SOURCE CODE INSTEAD.\n\n/* eslint-disable */\n/* tslint:disable */\nimport {\n  TypeBuilder as __TypeBuilder,\n  t as __t,\n  type AlgebraicTypeType as __AlgebraicTypeType,\n  type Infer as __Infer,\n} from '../../lib/type_builders';\nimport RawColumnDefV8 from './raw_column_def_v_8_type';\nimport RawIndexDefV8 from './raw_index_def_v_8_type';\nimport RawConstraintDefV8 from './raw_constraint_def_v_8_type';\nimport RawSequenceDefV8 from './raw_sequence_def_v_8_type';\n\nexport default __t.object('RawTableDefV8', {\n  tableName: __t.string(),\n  get columns() {\n    return __t.array(RawColumnDefV8);\n  },\n  get indexes() {\n    return __t.array(RawIndexDefV8);\n  },\n  get constraints() {\n    return __t.array(RawConstraintDefV8);\n  },\n  get sequences() {\n    return __t.array(RawSequenceDefV8);\n  },\n  tableType: __t.string(),\n  tableAccess: __t.string(),\n  scheduled: __t.option(__t.string()),\n});\n","// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE\n// WILL NOT BE SAVED. MODIFY TABLES IN YOUR MODULE SOURCE CODE INSTEAD.\n\n/* eslint-disable */\n/* tslint:disable */\nimport {\n  TypeBuilder as __TypeBuilder,\n  t as __t,\n  type AlgebraicTypeType as __AlgebraicTypeType,\n  type Infer as __Infer,\n} from '../../lib/type_builders';\nimport RawTableDefV8 from './raw_table_def_v_8_type';\n\nexport default __t.object('TableDesc', {\n  get schema() {\n    return RawTableDefV8;\n  },\n  data: __t.u32(),\n});\n","// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE\n// WILL NOT BE SAVED. MODIFY TABLES IN YOUR MODULE SOURCE CODE INSTEAD.\n\n/* eslint-disable */\n/* tslint:disable */\nimport {\n  TypeBuilder as __TypeBuilder,\n  t as __t,\n  type AlgebraicTypeType as __AlgebraicTypeType,\n  type Infer as __Infer,\n} from '../../lib/type_builders';\nimport ProductTypeElement from './product_type_element_type';\n\nexport default __t.object('ReducerDef', {\n  name: __t.string(),\n  get args() {\n    return __t.array(ProductTypeElement);\n  },\n});\n","// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE\n// WILL NOT BE SAVED. MODIFY TABLES IN YOUR MODULE SOURCE CODE INSTEAD.\n\n/* eslint-disable */\n/* tslint:disable */\nimport {\n  TypeBuilder as __TypeBuilder,\n  t as __t,\n  type AlgebraicTypeType as __AlgebraicTypeType,\n  type Infer as __Infer,\n} from '../../lib/type_builders';\n\nexport default __t.object('TypeAlias', {\n  name: __t.string(),\n  ty: __t.u32(),\n});\n","// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE\n// WILL NOT BE SAVED. MODIFY TABLES IN YOUR MODULE SOURCE CODE INSTEAD.\n\n/* eslint-disable */\n/* tslint:disable */\nimport {\n  TypeBuilder as __TypeBuilder,\n  t as __t,\n  type AlgebraicTypeType as __AlgebraicTypeType,\n  type Infer as __Infer,\n} from '../../lib/type_builders';\nimport TypeAlias from './type_alias_type';\n\n// The tagged union or sum type for the algebraic type `MiscModuleExport`.\nconst MiscModuleExport = __t.enum('MiscModuleExport', {\n  get TypeAlias() {\n    return TypeAlias;\n  },\n});\n\nexport default MiscModuleExport;\n","// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE\n// WILL NOT BE SAVED. MODIFY TABLES IN YOUR MODULE SOURCE CODE INSTEAD.\n\n/* eslint-disable */\n/* tslint:disable */\nimport {\n  TypeBuilder as __TypeBuilder,\n  t as __t,\n  type AlgebraicTypeType as __AlgebraicTypeType,\n  type Infer as __Infer,\n} from '../../lib/type_builders';\nimport Typespace from './typespace_type';\nimport TableDesc from './table_desc_type';\nimport ReducerDef from './reducer_def_type';\nimport MiscModuleExport from './misc_module_export_type';\n\nexport default __t.object('RawModuleDefV8', {\n  get typespace() {\n    return Typespace;\n  },\n  get tables() {\n    return __t.array(TableDesc);\n  },\n  get reducers() {\n    return __t.array(ReducerDef);\n  },\n  get miscExports() {\n    return __t.array(MiscModuleExport);\n  },\n});\n","// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE\n// WILL NOT BE SAVED. MODIFY TABLES IN YOUR MODULE SOURCE CODE INSTEAD.\n\n/* eslint-disable */\n/* tslint:disable */\nimport {\n  TypeBuilder as __TypeBuilder,\n  t as __t,\n  type AlgebraicTypeType as __AlgebraicTypeType,\n  type Infer as __Infer,\n} from '../../lib/type_builders';\nimport RawIndexAlgorithm from './raw_index_algorithm_type';\n\nexport default __t.object('RawIndexDefV9', {\n  name: __t.option(__t.string()),\n  accessorName: __t.option(__t.string()),\n  get algorithm() {\n    return RawIndexAlgorithm;\n  },\n});\n","// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE\n// WILL NOT BE SAVED. MODIFY TABLES IN YOUR MODULE SOURCE CODE INSTEAD.\n\n/* eslint-disable */\n/* tslint:disable */\nimport {\n  TypeBuilder as __TypeBuilder,\n  t as __t,\n  type AlgebraicTypeType as __AlgebraicTypeType,\n  type Infer as __Infer,\n} from '../../lib/type_builders';\n\nexport default __t.object('RawUniqueConstraintDataV9', {\n  columns: __t.array(__t.u16()),\n});\n","// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE\n// WILL NOT BE SAVED. MODIFY TABLES IN YOUR MODULE SOURCE CODE INSTEAD.\n\n/* eslint-disable */\n/* tslint:disable */\nimport {\n  TypeBuilder as __TypeBuilder,\n  t as __t,\n  type AlgebraicTypeType as __AlgebraicTypeType,\n  type Infer as __Infer,\n} from '../../lib/type_builders';\nimport RawUniqueConstraintDataV9 from './raw_unique_constraint_data_v_9_type';\n\n// The tagged union or sum type for the algebraic type `RawConstraintDataV9`.\nconst RawConstraintDataV9 = __t.enum('RawConstraintDataV9', {\n  get Unique() {\n    return RawUniqueConstraintDataV9;\n  },\n});\n\nexport default RawConstraintDataV9;\n","// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE\n// WILL NOT BE SAVED. MODIFY TABLES IN YOUR MODULE SOURCE CODE INSTEAD.\n\n/* eslint-disable */\n/* tslint:disable */\nimport {\n  TypeBuilder as __TypeBuilder,\n  t as __t,\n  type AlgebraicTypeType as __AlgebraicTypeType,\n  type Infer as __Infer,\n} from '../../lib/type_builders';\nimport RawConstraintDataV9 from './raw_constraint_data_v_9_type';\n\nexport default __t.object('RawConstraintDefV9', {\n  name: __t.option(__t.string()),\n  get data() {\n    return RawConstraintDataV9;\n  },\n});\n","// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE\n// WILL NOT BE SAVED. MODIFY TABLES IN YOUR MODULE SOURCE CODE INSTEAD.\n\n/* eslint-disable */\n/* tslint:disable */\nimport {\n  TypeBuilder as __TypeBuilder,\n  t as __t,\n  type AlgebraicTypeType as __AlgebraicTypeType,\n  type Infer as __Infer,\n} from '../../lib/type_builders';\n\nexport default __t.object('RawSequenceDefV9', {\n  name: __t.option(__t.string()),\n  column: __t.u16(),\n  start: __t.option(__t.i128()),\n  minValue: __t.option(__t.i128()),\n  maxValue: __t.option(__t.i128()),\n  increment: __t.i128(),\n});\n","// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE\n// WILL NOT BE SAVED. MODIFY TABLES IN YOUR MODULE SOURCE CODE INSTEAD.\n\n/* eslint-disable */\n/* tslint:disable */\nimport {\n  TypeBuilder as __TypeBuilder,\n  t as __t,\n  type AlgebraicTypeType as __AlgebraicTypeType,\n  type Infer as __Infer,\n} from '../../lib/type_builders';\n\nexport default __t.object('RawScheduleDefV9', {\n  name: __t.option(__t.string()),\n  reducerName: __t.string(),\n  scheduledAtColumn: __t.u16(),\n});\n","// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE\n// WILL NOT BE SAVED. MODIFY TABLES IN YOUR MODULE SOURCE CODE INSTEAD.\n\n/* eslint-disable */\n/* tslint:disable */\nimport {\n  TypeBuilder as __TypeBuilder,\n  t as __t,\n  type AlgebraicTypeType as __AlgebraicTypeType,\n  type Infer as __Infer,\n} from '../../lib/type_builders';\n\n// The tagged union or sum type for the algebraic type `TableType`.\nconst TableType = __t.enum('TableType', {\n  System: __t.unit(),\n  User: __t.unit(),\n});\n\nexport default TableType;\n","// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE\n// WILL NOT BE SAVED. MODIFY TABLES IN YOUR MODULE SOURCE CODE INSTEAD.\n\n/* eslint-disable */\n/* tslint:disable */\nimport {\n  TypeBuilder as __TypeBuilder,\n  t as __t,\n  type AlgebraicTypeType as __AlgebraicTypeType,\n  type Infer as __Infer,\n} from '../../lib/type_builders';\n\n// The tagged union or sum type for the algebraic type `TableAccess`.\nconst TableAccess = __t.enum('TableAccess', {\n  Public: __t.unit(),\n  Private: __t.unit(),\n});\n\nexport default TableAccess;\n","// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE\n// WILL NOT BE SAVED. MODIFY TABLES IN YOUR MODULE SOURCE CODE INSTEAD.\n\n/* eslint-disable */\n/* tslint:disable */\nimport {\n  TypeBuilder as __TypeBuilder,\n  t as __t,\n  type AlgebraicTypeType as __AlgebraicTypeType,\n  type Infer as __Infer,\n} from '../../lib/type_builders';\nimport RawIndexDefV9 from './raw_index_def_v_9_type';\nimport RawConstraintDefV9 from './raw_constraint_def_v_9_type';\nimport RawSequenceDefV9 from './raw_sequence_def_v_9_type';\nimport RawScheduleDefV9 from './raw_schedule_def_v_9_type';\nimport TableType from './table_type_type';\nimport TableAccess from './table_access_type';\n\nexport default __t.object('RawTableDefV9', {\n  name: __t.string(),\n  productTypeRef: __t.u32(),\n  primaryKey: __t.array(__t.u16()),\n  get indexes() {\n    return __t.array(RawIndexDefV9);\n  },\n  get constraints() {\n    return __t.array(RawConstraintDefV9);\n  },\n  get sequences() {\n    return __t.array(RawSequenceDefV9);\n  },\n  get schedule() {\n    return __t.option(RawScheduleDefV9);\n  },\n  get tableType() {\n    return TableType;\n  },\n  get tableAccess() {\n    return TableAccess;\n  },\n});\n","// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE\n// WILL NOT BE SAVED. MODIFY TABLES IN YOUR MODULE SOURCE CODE INSTEAD.\n\n/* eslint-disable */\n/* tslint:disable */\nimport {\n  TypeBuilder as __TypeBuilder,\n  t as __t,\n  type AlgebraicTypeType as __AlgebraicTypeType,\n  type Infer as __Infer,\n} from '../../lib/type_builders';\nimport ProductType from './product_type_type';\nimport Lifecycle from './lifecycle_type';\n\nexport default __t.object('RawReducerDefV9', {\n  name: __t.string(),\n  get params() {\n    return ProductType;\n  },\n  get lifecycle() {\n    return __t.option(Lifecycle);\n  },\n});\n","// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE\n// WILL NOT BE SAVED. MODIFY TABLES IN YOUR MODULE SOURCE CODE INSTEAD.\n\n/* eslint-disable */\n/* tslint:disable */\nimport {\n  TypeBuilder as __TypeBuilder,\n  t as __t,\n  type AlgebraicTypeType as __AlgebraicTypeType,\n  type Infer as __Infer,\n} from '../../lib/type_builders';\n\nexport default __t.object('RawScopedTypeNameV9', {\n  scope: __t.array(__t.string()),\n  name: __t.string(),\n});\n","// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE\n// WILL NOT BE SAVED. MODIFY TABLES IN YOUR MODULE SOURCE CODE INSTEAD.\n\n/* eslint-disable */\n/* tslint:disable */\nimport {\n  TypeBuilder as __TypeBuilder,\n  t as __t,\n  type AlgebraicTypeType as __AlgebraicTypeType,\n  type Infer as __Infer,\n} from '../../lib/type_builders';\nimport RawScopedTypeNameV9 from './raw_scoped_type_name_v_9_type';\n\nexport default __t.object('RawTypeDefV9', {\n  get name() {\n    return RawScopedTypeNameV9;\n  },\n  ty: __t.u32(),\n  customOrdering: __t.bool(),\n});\n","// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE\n// WILL NOT BE SAVED. MODIFY TABLES IN YOUR MODULE SOURCE CODE INSTEAD.\n\n/* eslint-disable */\n/* tslint:disable */\nimport {\n  TypeBuilder as __TypeBuilder,\n  t as __t,\n  type AlgebraicTypeType as __AlgebraicTypeType,\n  type Infer as __Infer,\n} from '../../lib/type_builders';\n\nexport default __t.object('RawColumnDefaultValueV9', {\n  table: __t.string(),\n  colId: __t.u16(),\n  value: __t.byteArray(),\n});\n","// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE\n// WILL NOT BE SAVED. MODIFY TABLES IN YOUR MODULE SOURCE CODE INSTEAD.\n\n/* eslint-disable */\n/* tslint:disable */\nimport {\n  TypeBuilder as __TypeBuilder,\n  t as __t,\n  type AlgebraicTypeType as __AlgebraicTypeType,\n  type Infer as __Infer,\n} from '../../lib/type_builders';\nimport AlgebraicType from './algebraic_type_type';\nimport ProductType from './product_type_type';\n\nexport default __t.object('RawProcedureDefV9', {\n  name: __t.string(),\n  get params() {\n    return ProductType;\n  },\n  get returnType() {\n    return AlgebraicType;\n  },\n});\n","// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE\n// WILL NOT BE SAVED. MODIFY TABLES IN YOUR MODULE SOURCE CODE INSTEAD.\n\n/* eslint-disable */\n/* tslint:disable */\nimport {\n  TypeBuilder as __TypeBuilder,\n  t as __t,\n  type AlgebraicTypeType as __AlgebraicTypeType,\n  type Infer as __Infer,\n} from '../../lib/type_builders';\nimport AlgebraicType from './algebraic_type_type';\nimport ProductType from './product_type_type';\n\nexport default __t.object('RawViewDefV9', {\n  name: __t.string(),\n  index: __t.u32(),\n  isPublic: __t.bool(),\n  isAnonymous: __t.bool(),\n  get params() {\n    return ProductType;\n  },\n  get returnType() {\n    return AlgebraicType;\n  },\n});\n","// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE\n// WILL NOT BE SAVED. MODIFY TABLES IN YOUR MODULE SOURCE CODE INSTEAD.\n\n/* eslint-disable */\n/* tslint:disable */\nimport {\n  TypeBuilder as __TypeBuilder,\n  t as __t,\n  type AlgebraicTypeType as __AlgebraicTypeType,\n  type Infer as __Infer,\n} from '../../lib/type_builders';\nimport RawColumnDefaultValueV9 from './raw_column_default_value_v_9_type';\nimport RawProcedureDefV9 from './raw_procedure_def_v_9_type';\nimport RawViewDefV9 from './raw_view_def_v_9_type';\n\n// The tagged union or sum type for the algebraic type `RawMiscModuleExportV9`.\nconst RawMiscModuleExportV9 = __t.enum('RawMiscModuleExportV9', {\n  get ColumnDefaultValue() {\n    return RawColumnDefaultValueV9;\n  },\n  get Procedure() {\n    return RawProcedureDefV9;\n  },\n  get View() {\n    return RawViewDefV9;\n  },\n});\n\nexport default RawMiscModuleExportV9;\n","// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE\n// WILL NOT BE SAVED. MODIFY TABLES IN YOUR MODULE SOURCE CODE INSTEAD.\n\n/* eslint-disable */\n/* tslint:disable */\nimport {\n  TypeBuilder as __TypeBuilder,\n  t as __t,\n  type AlgebraicTypeType as __AlgebraicTypeType,\n  type Infer as __Infer,\n} from '../../lib/type_builders';\n\nexport default __t.object('RawRowLevelSecurityDefV9', {\n  sql: __t.string(),\n});\n","// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE\n// WILL NOT BE SAVED. MODIFY TABLES IN YOUR MODULE SOURCE CODE INSTEAD.\n\n/* eslint-disable */\n/* tslint:disable */\nimport {\n  TypeBuilder as __TypeBuilder,\n  t as __t,\n  type AlgebraicTypeType as __AlgebraicTypeType,\n  type Infer as __Infer,\n} from '../../lib/type_builders';\nimport Typespace from './typespace_type';\nimport RawTableDefV9 from './raw_table_def_v_9_type';\nimport RawReducerDefV9 from './raw_reducer_def_v_9_type';\nimport RawTypeDefV9 from './raw_type_def_v_9_type';\nimport RawMiscModuleExportV9 from './raw_misc_module_export_v_9_type';\nimport RawRowLevelSecurityDefV9 from './raw_row_level_security_def_v_9_type';\n\nexport default __t.object('RawModuleDefV9', {\n  get typespace() {\n    return Typespace;\n  },\n  get tables() {\n    return __t.array(RawTableDefV9);\n  },\n  get reducers() {\n    return __t.array(RawReducerDefV9);\n  },\n  get types() {\n    return __t.array(RawTypeDefV9);\n  },\n  get miscExports() {\n    return __t.array(RawMiscModuleExportV9);\n  },\n  get rowLevelSecurity() {\n    return __t.array(RawRowLevelSecurityDefV9);\n  },\n});\n","// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE\n// WILL NOT BE SAVED. MODIFY TABLES IN YOUR MODULE SOURCE CODE INSTEAD.\n\n/* eslint-disable */\n/* tslint:disable */\nimport {\n  TypeBuilder as __TypeBuilder,\n  t as __t,\n  type AlgebraicTypeType as __AlgebraicTypeType,\n  type Infer as __Infer,\n} from '../../lib/type_builders';\nimport RawModuleDefV8 from './raw_module_def_v_8_type';\nimport RawModuleDefV9 from './raw_module_def_v_9_type';\n\n// The tagged union or sum type for the algebraic type `RawModuleDef`.\nconst RawModuleDef = __t.enum('RawModuleDef', {\n  get V8BackCompat() {\n    return RawModuleDefV8;\n  },\n  get V9() {\n    return RawModuleDefV9;\n  },\n});\n\nexport default RawModuleDef;\n","/**\n * A class representing a range with optional lower and upper bounds.\n * This class is used to specify ranges for index scans in SpacetimeDB.\n *\n * The range can be defined with inclusive or exclusive bounds, or can be unbounded on either side.\n * @template T - The type of the values in the range.\n * @example\n * ```typescript\n * // Create a range from 10 (inclusive) to 20 (exclusive)\n * const range = new Range(\n *   { tag: 'included', value: 10 },\n *   { tag: 'excluded', value: 20 }\n * );\n * // Create an unbounded range\n * const unboundedRange = new Range();\n * ```\n */\nexport class Range<T> {\n  #from: Bound<T>;\n  #to: Bound<T>;\n  public constructor(from?: Bound<T> | null, to?: Bound<T> | null) {\n    this.#from = from ?? { tag: 'unbounded' };\n    this.#to = to ?? { tag: 'unbounded' };\n  }\n\n  public get from(): Bound<T> {\n    return this.#from;\n  }\n  public get to(): Bound<T> {\n    return this.#to;\n  }\n}\n\n/**\n * A type representing a bound in a range, which can be inclusive, exclusive, or unbounded.\n * - `included`: The bound is inclusive, meaning the value is part of the range.\n * - `excluded`: The bound is exclusive, meaning the value is not part of the range.\n * - `unbounded`: The bound is unbounded, meaning there is no limit in that direction.\n * @template T - The type of the value for the bound.\n * @example\n * ```typescript\n * // Inclusive bound\n * const inclusiveBound: Bound<number> = { tag: 'included', value: 10 };\n * // Exclusive bound\n * const exclusiveBound: Bound<number> = { tag: 'excluded', value: 20 };\n * // Unbounded bound\n * const unbounded: Bound<number> = { tag: 'unbounded' };\n * ```\n */\nexport type Bound<T> =\n  | { tag: 'included'; value: T }\n  | { tag: 'excluded'; value: T }\n  | { tag: 'unbounded' };\n","import { Headers, headersToList } from 'headers-polyfill';\nimport status from 'statuses';\nimport BinaryReader from '../lib/binary_reader';\nimport BinaryWriter from '../lib/binary_writer';\nimport {\n  HttpHeaders,\n  HttpMethod,\n  HttpRequest,\n  HttpResponse,\n} from '../lib/http_types';\nimport type { TimeDuration } from '../lib/time_duration';\nimport { bsatnBaseSize } from '../lib/util';\nimport type { Infer } from '../sdk';\nimport { sys } from './runtime';\n\nexport { Headers };\n\nconst { freeze } = Object;\n\nexport type BodyInit = ArrayBuffer | ArrayBufferView | string;\nexport type HeadersInit = [string, string][] | Record<string, string> | Headers;\nexport interface ResponseInit {\n  headers?: HeadersInit;\n  status?: number;\n  statusText?: string;\n}\n\nconst textEncoder = new TextEncoder();\nconst textDecoder = new TextDecoder('utf-8' /* { fatal: true } */);\n\nconst makeResponse = Symbol('makeResponse');\n\n// based on deno's type of the same name\ninterface InnerResponse {\n  type: 'basic' | 'cors' | 'default' | 'error' | 'opaque' | 'opaqueredirect';\n  url: string | null;\n  status: number;\n  statusText: string;\n  headers: Headers;\n  aborted: boolean;\n}\n\nexport class SyncResponse {\n  #body: string | ArrayBuffer | null;\n  #inner: InnerResponse;\n\n  constructor(body?: BodyInit | null, init?: ResponseInit) {\n    if (body == null) {\n      this.#body = null;\n    } else if (typeof body === 'string') {\n      this.#body = body;\n    } else {\n      // this call is fine, the typings are just weird\n      this.#body = new Uint8Array<ArrayBuffer>(body as any).buffer;\n    }\n\n    // there's a type mismatch - headers-polyfill's typing doesn't expect its\n    // own `Headers` type, even though the actual code handles it correctly.\n    this.#inner = {\n      headers: new Headers(init?.headers as any),\n      status: init?.status ?? 200,\n      statusText: init?.statusText ?? '',\n      type: 'default',\n      url: null,\n      aborted: false,\n    };\n  }\n\n  static [makeResponse](body: BodyInit | null, inner: InnerResponse) {\n    const me = new SyncResponse(body);\n    me.#inner = inner;\n    return me;\n  }\n\n  get headers(): Headers {\n    return this.#inner.headers;\n  }\n  get status(): number {\n    return this.#inner.status;\n  }\n  get statusText() {\n    return this.#inner.statusText;\n  }\n  get ok(): boolean {\n    return 200 <= this.#inner.status && this.#inner.status <= 299;\n  }\n  get url(): string {\n    return this.#inner.url ?? '';\n  }\n  get type() {\n    return this.#inner.type;\n  }\n\n  arrayBuffer(): ArrayBuffer {\n    return this.bytes().buffer;\n  }\n\n  bytes(): Uint8Array<ArrayBuffer> {\n    if (this.#body == null) {\n      return new Uint8Array();\n    } else if (typeof this.#body === 'string') {\n      return textEncoder.encode(this.#body);\n    } else {\n      return new Uint8Array(this.#body);\n    }\n  }\n\n  json(): any {\n    return JSON.parse(this.text());\n  }\n\n  text(): string {\n    if (this.#body == null) {\n      return '';\n    } else if (typeof this.#body === 'string') {\n      return this.#body;\n    } else {\n      return textDecoder.decode(this.#body);\n    }\n  }\n}\n\nexport interface RequestOptions {\n  /** A BodyInit object or null to set request's body. */\n  body?: BodyInit | null;\n  /** A Headers object, an object literal, or an array of two-item arrays to set request's headers. */\n  headers?: HeadersInit;\n  /** A string to set request's method. */\n  method?: string;\n  /** A duration, after which the request will timeout */\n  timeout?: TimeDuration;\n  // /** A string indicating whether request follows redirects, results in an error upon encountering a redirect, or returns the redirect (in an opaque fashion). Sets request's redirect. */\n  // redirect?: RequestRedirect;\n}\n\nexport interface HttpClient {\n  fetch(url: URL | string, init?: RequestOptions): SyncResponse;\n}\n\nconst requestBaseSize = bsatnBaseSize({ types: [] }, HttpRequest.algebraicType);\n\nconst methods = new Map<string, Infer<typeof HttpMethod>>([\n  ['GET', { tag: 'Get' }],\n  ['HEAD', { tag: 'Head' }],\n  ['POST', { tag: 'Post' }],\n  ['PUT', { tag: 'Put' }],\n  ['DELETE', { tag: 'Delete' }],\n  ['CONNECT', { tag: 'Connect' }],\n  ['OPTIONS', { tag: 'Options' }],\n  ['TRACE', { tag: 'Trace' }],\n  ['PATCH', { tag: 'Patch' }],\n]);\n\nfunction fetch(url: URL | string, init: RequestOptions = {}) {\n  const method = methods.get(init.method?.toUpperCase() ?? 'GET') ?? {\n    tag: 'Extension',\n    value: init.method!,\n  };\n  const headers: Infer<typeof HttpHeaders> = {\n    // anys because the typings are wonky - see comment in SyncResponse.constructor\n    entries: headersToList(new Headers(init.headers as any) as any)\n      .flatMap(([k, v]) => (Array.isArray(v) ? v.map(v => [k, v]) : [[k, v]]))\n      .map(([name, value]) => ({ name, value: textEncoder.encode(value) })),\n  };\n  const uri = '' + url;\n  const request: Infer<typeof HttpRequest> = freeze({\n    method,\n    headers,\n    timeout: init.timeout,\n    uri,\n    version: { tag: 'Http11' } as const,\n  });\n  const requestBuf = new BinaryWriter(requestBaseSize);\n  HttpRequest.serialize(requestBuf, request);\n  const body =\n    init.body == null\n      ? new Uint8Array()\n      : typeof init.body === 'string'\n        ? init.body\n        : new Uint8Array<ArrayBuffer>(init.body as any);\n  const [responseBuf, responseBody] = sys.procedure_http_request(\n    requestBuf.getBuffer(),\n    body\n  );\n  const response = HttpResponse.deserialize(new BinaryReader(responseBuf));\n  return SyncResponse[makeResponse](responseBody, {\n    type: 'basic',\n    url: uri,\n    status: response.code,\n    statusText: status(response.code),\n    headers: new Headers(),\n    aborted: false,\n  });\n}\n\nfreeze(fetch);\n\nexport const httpClient: HttpClient = freeze({ fetch });\n","// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE\n// WILL NOT BE SAVED. MODIFY TABLES IN YOUR MODULE SOURCE CODE INSTEAD.\n\n/* eslint-disable */\n/* tslint:disable */\nimport {\n  TypeBuilder as __TypeBuilder,\n  t as __t,\n  type AlgebraicTypeType as __AlgebraicTypeType,\n  type Infer as __Infer,\n} from '../../lib/type_builders';\n\nexport default __t.object('HttpHeaderPair', {\n  name: __t.string(),\n  value: __t.byteArray(),\n});\n","// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE\n// WILL NOT BE SAVED. MODIFY TABLES IN YOUR MODULE SOURCE CODE INSTEAD.\n\n/* eslint-disable */\n/* tslint:disable */\nimport {\n  TypeBuilder as __TypeBuilder,\n  t as __t,\n  type AlgebraicTypeType as __AlgebraicTypeType,\n  type Infer as __Infer,\n} from '../../lib/type_builders';\nimport HttpHeaderPair from './http_header_pair_type';\n\nexport default __t.object('HttpHeaders', {\n  get entries() {\n    return __t.array(HttpHeaderPair);\n  },\n});\n","// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE\n// WILL NOT BE SAVED. MODIFY TABLES IN YOUR MODULE SOURCE CODE INSTEAD.\n\n/* eslint-disable */\n/* tslint:disable */\nimport {\n  TypeBuilder as __TypeBuilder,\n  t as __t,\n  type AlgebraicTypeType as __AlgebraicTypeType,\n  type Infer as __Infer,\n} from '../../lib/type_builders';\n\n// The tagged union or sum type for the algebraic type `HttpMethod`.\nconst HttpMethod = __t.enum('HttpMethod', {\n  Get: __t.unit(),\n  Head: __t.unit(),\n  Post: __t.unit(),\n  Put: __t.unit(),\n  Delete: __t.unit(),\n  Connect: __t.unit(),\n  Options: __t.unit(),\n  Trace: __t.unit(),\n  Patch: __t.unit(),\n  Extension: __t.string(),\n});\n\nexport default HttpMethod;\n","// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE\n// WILL NOT BE SAVED. MODIFY TABLES IN YOUR MODULE SOURCE CODE INSTEAD.\n\n/* eslint-disable */\n/* tslint:disable */\nimport {\n  TypeBuilder as __TypeBuilder,\n  t as __t,\n  type AlgebraicTypeType as __AlgebraicTypeType,\n  type Infer as __Infer,\n} from '../../lib/type_builders';\n\n// The tagged union or sum type for the algebraic type `HttpVersion`.\nconst HttpVersion = __t.enum('HttpVersion', {\n  Http09: __t.unit(),\n  Http10: __t.unit(),\n  Http11: __t.unit(),\n  Http2: __t.unit(),\n  Http3: __t.unit(),\n});\n\nexport default HttpVersion;\n","// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE\n// WILL NOT BE SAVED. MODIFY TABLES IN YOUR MODULE SOURCE CODE INSTEAD.\n\n/* eslint-disable */\n/* tslint:disable */\nimport {\n  TypeBuilder as __TypeBuilder,\n  t as __t,\n  type AlgebraicTypeType as __AlgebraicTypeType,\n  type Infer as __Infer,\n} from '../../lib/type_builders';\nimport HttpMethod from './http_method_type';\nimport HttpHeaders from './http_headers_type';\nimport HttpVersion from './http_version_type';\n\nexport default __t.object('HttpRequest', {\n  get method() {\n    return HttpMethod;\n  },\n  get headers() {\n    return HttpHeaders;\n  },\n  timeout: __t.option(__t.timeDuration()),\n  uri: __t.string(),\n  get version() {\n    return HttpVersion;\n  },\n});\n","// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE\n// WILL NOT BE SAVED. MODIFY TABLES IN YOUR MODULE SOURCE CODE INSTEAD.\n\n/* eslint-disable */\n/* tslint:disable */\nimport {\n  TypeBuilder as __TypeBuilder,\n  t as __t,\n  type AlgebraicTypeType as __AlgebraicTypeType,\n  type Infer as __Infer,\n} from '../../lib/type_builders';\nimport HttpHeaders from './http_headers_type';\nimport HttpVersion from './http_version_type';\n\nexport default __t.object('HttpResponse', {\n  get headers() {\n    return HttpHeaders;\n  },\n  get version() {\n    return HttpVersion;\n  },\n  code: __t.u16(),\n});\n","import { AlgebraicType, ProductType } from '../lib/algebraic_type';\nimport BinaryReader from '../lib/binary_reader';\nimport BinaryWriter from '../lib/binary_writer';\nimport type { ConnectionId } from '../lib/connection_id';\nimport { Identity } from '../lib/identity';\nimport {\n  PROCEDURES,\n  type ProcedureCtx,\n  type TransactionCtx,\n} from '../lib/procedures';\nimport { MODULE_DEF, type UntypedSchemaDef } from '../lib/schema';\nimport { Timestamp } from '../lib/timestamp';\nimport { Uuid } from '../lib/uuid';\nimport { httpClient } from './http_internal';\nimport { callUserFunction, ReducerCtxImpl, sys } from './runtime';\n\nconst { freeze } = Object;\n\nexport function callProcedure(\n  id: number,\n  sender: Identity,\n  connectionId: ConnectionId | null,\n  timestamp: Timestamp,\n  argsBuf: Uint8Array\n): Uint8Array {\n  const { fn, paramsType, returnType, returnTypeBaseSize } = PROCEDURES[id];\n  const args = ProductType.deserializeValue(\n    new BinaryReader(argsBuf),\n    paramsType,\n    MODULE_DEF.typespace\n  );\n\n  const ctx: ProcedureCtx<UntypedSchemaDef> = {\n    sender,\n    timestamp,\n    connectionId,\n    http: httpClient,\n    // **Note:** must be 0..=u32::MAX\n    counter_uuid: { value: Number(0) },\n    get identity() {\n      return new Identity(sys.identity().__identity__);\n    },\n    withTx(body) {\n      const run = () => {\n        const timestamp = sys.procedure_start_mut_tx();\n\n        try {\n          const ctx: TransactionCtx<UntypedSchemaDef> = new ReducerCtxImpl(\n            sender,\n            new Timestamp(timestamp),\n            connectionId\n          );\n          return body(ctx);\n        } catch (e) {\n          sys.procedure_abort_mut_tx();\n          throw e;\n        }\n      };\n\n      let res = run();\n      try {\n        sys.procedure_commit_mut_tx();\n        return res;\n      } catch {\n        // ignore the commit error\n      }\n      console.warn('committing anonymous transaction failed');\n      res = run();\n      try {\n        sys.procedure_commit_mut_tx();\n        return res;\n      } catch (e) {\n        throw new Error('transaction retry failed again', { cause: e });\n      }\n    },\n    /**\n     * Create a new random {@link Uuid} `v4` using the {@link crypto} RNG.\n     *\n     * WARN: Until we use a spacetime RNG this make calls non-deterministic.\n     */\n    newUuidV4(): Uuid {\n      // TODO: Use a spacetime RNG when available\n      const bytes = crypto.getRandomValues(new Uint8Array(16));\n      return Uuid.fromRandomBytesV4(bytes);\n    },\n\n    /**\n     * Create a new sortable {@link Uuid} `v7` using the {@link crypto} RNG, counter,\n     * and the timestamp.\n     *\n     * WARN: Until we use a spacetime RNG this make calls non-deterministic.\n     */\n    newUuidV7(): Uuid {\n      // TODO: Use a spacetime RNG when available\n      const bytes = crypto.getRandomValues(new Uint8Array(10));\n      return Uuid.fromCounterV7(this.counter_uuid, this.timestamp, bytes);\n    },\n  };\n  freeze(ctx);\n\n  const ret = callUserFunction(fn, ctx, args);\n  const retBuf = new BinaryWriter(returnTypeBaseSize);\n  AlgebraicType.serializeValue(retBuf, returnType, ret, MODULE_DEF.typespace);\n  return retBuf.getBuffer();\n}\n","// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE\n// WILL NOT BE SAVED. MODIFY TABLES IN YOUR MODULE SOURCE CODE INSTEAD.\n\n/* eslint-disable */\n/* tslint:disable */\nimport {\n  TypeBuilder as __TypeBuilder,\n  t as __t,\n  type AlgebraicTypeType as __AlgebraicTypeType,\n  type Infer as __Infer,\n} from '../../lib/type_builders';\n\n// The tagged union or sum type for the algebraic type `ViewResultHeader`.\nconst ViewResultHeader = __t.enum('ViewResultHeader', {\n  RowData: __t.unit(),\n  RawSql: __t.string(),\n});\n\nexport default ViewResultHeader;\n","import * as _syscalls1_0 from 'spacetime:sys@1.0';\nimport * as _syscalls1_2 from 'spacetime:sys@1.2';\n\nimport type { ModuleHooks, u16, u32 } from 'spacetime:sys@1.0';\nimport { AlgebraicType, ProductType } from '../lib/algebraic_type';\nimport RawModuleDef from '../lib/autogen/raw_module_def_type';\nimport type RawModuleDefV9 from '../lib/autogen/raw_module_def_v_9_type';\nimport type RawTableDefV9 from '../lib/autogen/raw_table_def_v_9_type';\nimport type Typespace from '../lib/autogen/typespace_type';\nimport { ConnectionId } from '../lib/connection_id';\nimport { Identity } from '../lib/identity';\nimport { Timestamp } from '../lib/timestamp';\nimport { Uuid } from '../lib/uuid';\nimport BinaryReader from '../lib/binary_reader';\nimport BinaryWriter from '../lib/binary_writer';\nimport {\n  type Index,\n  type IndexVal,\n  type RangedIndex,\n  type UniqueIndex,\n} from '../lib/indexes';\nimport { callProcedure as callProcedure } from './procedures';\nimport {\n  REDUCERS,\n  type AuthCtx,\n  type JsonObject,\n  type JwtClaims,\n  type ReducerCtx,\n  type ReducerCtx as IReducerCtx,\n} from '../lib/reducers';\nimport {\n  MODULE_DEF,\n  getRegisteredSchema,\n  type UntypedSchemaDef,\n} from '../lib/schema';\nimport { type RowType, type Table, type TableMethods } from '../lib/table';\nimport type { Infer } from '../lib/type_builders';\nimport { bsatnBaseSize, toCamelCase } from '../lib/util';\nimport {\n  ANON_VIEWS,\n  VIEWS,\n  type AnonymousViewCtx,\n  type ViewCtx,\n} from '../lib/views';\nimport { isRowTypedQuery, makeQueryBuilder, toSql } from './query';\nimport type { DbView } from './db_view';\nimport { SenderError, SpacetimeHostError } from './errors';\nimport { Range, type Bound } from './range';\nimport ViewResultHeader from '../lib/autogen/view_result_header_type';\n\nconst { freeze } = Object;\n\nexport const sys = freeze(wrapSyscalls(_syscalls1_0, _syscalls1_2));\n\nexport function parseJsonObject(json: string): JsonObject {\n  let value: unknown;\n\n  try {\n    value = JSON.parse(json);\n  } catch {\n    throw new Error('Invalid JSON: failed to parse string');\n  }\n\n  if (value === null || typeof value !== 'object' || Array.isArray(value)) {\n    throw new Error('Expected a JSON object at the top level');\n  }\n\n  // The runtime check above guarantees this cast is safe\n  return value as JsonObject;\n}\n\nclass JwtClaimsImpl implements JwtClaims {\n  readonly fullPayload: JsonObject;\n  private readonly _identity: Identity;\n  /**\n   * Creates a new JwtClaims instance.\n   * @param rawPayload The JWT payload as a raw JSON string.\n   * @param identity The identity for this JWT. We are only taking this because we don't have a blake3 implementation (which we need to compute it).\n   */\n  constructor(\n    public readonly rawPayload: string,\n    identity: Identity\n  ) {\n    this.fullPayload = parseJsonObject(rawPayload);\n    this._identity = identity;\n  }\n  readonly [claim: string]: unknown;\n  get identity(): Identity {\n    return this._identity;\n  }\n  get subject() {\n    return this.fullPayload['sub'] as string;\n  }\n  get issuer() {\n    return this.fullPayload['iss'] as string;\n  }\n  get audience() {\n    const aud = this.fullPayload['aud'];\n    if (aud == null) {\n      return [];\n    }\n    return typeof aud === 'string' ? [aud] : (aud as string[]);\n  }\n}\n\nclass AuthCtxImpl implements AuthCtx {\n  public readonly isInternal: boolean;\n\n  // Source of the JWT payload string, if there is one.\n  private readonly _jwtSource: () => string | null;\n  // Whether we have initialized the JWT claims.\n  private _initializedJWT: boolean = false;\n  private _jwtClaims?: JwtClaims | null;\n  private _senderIdentity: Identity;\n\n  private constructor(opts: {\n    isInternal: boolean;\n    jwtSource: () => string | null;\n    senderIdentity: Identity;\n  }) {\n    this.isInternal = opts.isInternal;\n    this._jwtSource = opts.jwtSource;\n    this._senderIdentity = opts.senderIdentity;\n  }\n\n  private _initializeJWT() {\n    if (this._initializedJWT) return;\n    this._initializedJWT = true;\n\n    const token = this._jwtSource();\n    if (!token) {\n      this._jwtClaims = null;\n    } else {\n      this._jwtClaims = new JwtClaimsImpl(token, this._senderIdentity);\n    }\n    // At this point we can safely freeze the object.\n    Object.freeze(this);\n  }\n\n  /** Lazily compute whether a JWT exists and is parseable. */\n  get hasJWT(): boolean {\n    this._initializeJWT();\n    return this._jwtClaims !== null;\n  }\n\n  /** Lazily parse the JwtClaims only when accessed. */\n  get jwt(): JwtClaims | null {\n    this._initializeJWT();\n    return this._jwtClaims!;\n  }\n\n  /** Create a context representing internal (non-user) requests. */\n  static internal(): AuthCtx {\n    return new AuthCtxImpl({\n      isInternal: true,\n      jwtSource: () => null,\n      senderIdentity: Identity.zero(),\n    });\n  }\n\n  /** If there is a connection id, look up the JWT payload from the system tables. */\n  static fromSystemTables(\n    connectionId: ConnectionId | null,\n    sender: Identity\n  ): AuthCtx {\n    if (connectionId === null) {\n      return new AuthCtxImpl({\n        isInternal: false,\n        jwtSource: () => null,\n        senderIdentity: sender,\n      });\n    }\n    return new AuthCtxImpl({\n      isInternal: false,\n      jwtSource: () => {\n        const payloadBuf = sys.get_jwt_payload(connectionId.__connection_id__);\n        if (payloadBuf.length === 0) return null;\n        const payloadStr = new TextDecoder().decode(payloadBuf);\n        return payloadStr;\n      },\n      senderIdentity: sender,\n    });\n  }\n}\n\n// Using a class expression rather than declaration keeps the class out of the\n// type namespace, so that `ReducerCtx` still refers to the interface.\nexport const ReducerCtxImpl = class ReducerCtx<\n  SchemaDef extends UntypedSchemaDef,\n> implements IReducerCtx<SchemaDef>\n{\n  #identity: Identity | undefined;\n  #senderAuth: AuthCtx | undefined;\n  #uuidCounter: { value: number } | undefined;\n  sender: Identity;\n  timestamp: Timestamp;\n  connectionId: ConnectionId | null;\n  db: DbView<SchemaDef>;\n\n  constructor(\n    sender: Identity,\n    timestamp: Timestamp,\n    connectionId: ConnectionId | null\n  ) {\n    Object.seal(this);\n    this.sender = sender;\n    this.timestamp = timestamp;\n    this.connectionId = connectionId;\n    this.db = getDbView();\n  }\n\n  get identity() {\n    return (this.#identity ??= new Identity(sys.identity().__identity__));\n  }\n\n  get senderAuth() {\n    return (this.#senderAuth ??= AuthCtxImpl.fromSystemTables(\n      this.connectionId,\n      this.sender\n    ));\n  }\n\n  /**\n   * Create a new random {@link Uuid} `v4` using the {@link crypto} RNG.\n   *\n   * WARN: Until we use a spacetime RNG this make calls non-deterministic.\n   */\n  newUuidV4(): Uuid {\n    // TODO: Use a spacetime RNG when available\n    const bytes = crypto.getRandomValues(new Uint8Array(16));\n    return Uuid.fromRandomBytesV4(bytes);\n  }\n\n  /**\n   * Create a new sortable {@link Uuid} `v7` using the {@link crypto} RNG, counter,\n   * and the timestamp.\n   *\n   * WARN: Until we use a spacetime RNG this make calls non-deterministic.\n   */\n  newUuidV7(): Uuid {\n    // TODO: Use a spacetime RNG when available\n    const bytes = crypto.getRandomValues(new Uint8Array(4));\n    const counter = (this.#uuidCounter ??= { value: 0 });\n    return Uuid.fromCounterV7(counter, this.timestamp, bytes);\n  }\n};\n\n/**\n * Call into a user function `fn` - the backtrace from an exception thrown in\n * `fn` or one of its descendants in the callgraph will be stripped by host\n * code in `crates/core/src/host/v8/error.rs` such that `fn` will be shown to\n * be the root of the call stack.\n */\nexport const callUserFunction = function __spacetimedb_end_short_backtrace<\n  Args extends any[],\n  R,\n>(fn: (...args: Args) => R, ...args: Args): R {\n  return fn(...args);\n};\n\nexport const hooks: ModuleHooks = {\n  __describe_module__() {\n    const writer = new BinaryWriter(128);\n    AlgebraicType.serializeValue(\n      writer,\n      RawModuleDef.algebraicType,\n      RawModuleDef.V9(MODULE_DEF)\n    );\n    return writer.getBuffer();\n  },\n  __call_reducer__(reducerId, sender, connId, timestamp, argsBuf) {\n    const argsType = AlgebraicType.Product(\n      MODULE_DEF.reducers[reducerId].params\n    );\n    const args = AlgebraicType.deserializeValue(\n      new BinaryReader(argsBuf),\n      argsType,\n      MODULE_DEF.typespace\n    );\n    const senderIdentity = new Identity(sender);\n    const ctx: ReducerCtx<any> = new ReducerCtxImpl(\n      senderIdentity,\n      new Timestamp(timestamp),\n      ConnectionId.nullIfZero(new ConnectionId(connId))\n    );\n    try {\n      return callUserFunction(REDUCERS[reducerId], ctx, args) ?? { tag: 'ok' };\n    } catch (e) {\n      if (e instanceof SenderError) {\n        return { tag: 'err', value: e.message };\n      }\n      throw e;\n    }\n  },\n};\n\nexport const hooks_v1_1: import('spacetime:sys@1.1').ModuleHooks = {\n  __call_view__(id, sender, argsBuf) {\n    const { fn, params, returnType, returnTypeBaseSize } = VIEWS[id];\n    const ctx: ViewCtx<any> = freeze({\n      sender: new Identity(sender),\n      // this is the non-readonly DbView, but the typing for the user will be\n      // the readonly one, and if they do call mutating functions it will fail\n      // at runtime\n      db: getDbView(),\n      from: makeQueryBuilder(getRegisteredSchema()),\n    });\n    // ViewResultHeader.RawSql\n    const args = ProductType.deserializeValue(\n      new BinaryReader(argsBuf),\n      params,\n      MODULE_DEF.typespace\n    );\n    const ret = callUserFunction(fn, ctx, args);\n    const retBuf = new BinaryWriter(returnTypeBaseSize);\n    if (isRowTypedQuery(ret)) {\n      const query = toSql(ret);\n      const v = ViewResultHeader.RawSql(query);\n      AlgebraicType.serializeValue(\n        retBuf,\n        ViewResultHeader.algebraicType,\n        v,\n        MODULE_DEF.typespace\n      );\n      return {\n        data: retBuf.getBuffer(),\n      };\n    } else {\n      AlgebraicType.serializeValue(\n        retBuf,\n        ViewResultHeader.algebraicType,\n        ViewResultHeader.RowData,\n        MODULE_DEF.typespace\n      );\n      AlgebraicType.serializeValue(\n        retBuf,\n        returnType,\n        ret,\n        MODULE_DEF.typespace\n      );\n      return {\n        data: retBuf.getBuffer(),\n      };\n    }\n  },\n  __call_view_anon__(id, argsBuf) {\n    const { fn, params, returnType, returnTypeBaseSize } = ANON_VIEWS[id];\n    const ctx: AnonymousViewCtx<any> = freeze({\n      // this is the non-readonly DbView, but the typing for the user will be\n      // the readonly one, and if they do call mutating functions it will fail\n      // at runtime\n      db: getDbView(),\n      from: makeQueryBuilder(getRegisteredSchema()),\n    });\n    const args = ProductType.deserializeValue(\n      new BinaryReader(argsBuf),\n      params,\n      MODULE_DEF.typespace\n    );\n    const ret = callUserFunction(fn, ctx, args);\n    const retBuf = new BinaryWriter(returnTypeBaseSize);\n    if (isRowTypedQuery(ret)) {\n      const query = toSql(ret);\n      const v = ViewResultHeader.RawSql(query);\n      AlgebraicType.serializeValue(\n        retBuf,\n        ViewResultHeader.algebraicType,\n        v,\n        MODULE_DEF.typespace\n      );\n      return {\n        data: retBuf.getBuffer(),\n      };\n    } else {\n      AlgebraicType.serializeValue(\n        retBuf,\n        ViewResultHeader.algebraicType,\n        ViewResultHeader.RowData,\n        MODULE_DEF.typespace\n      );\n      AlgebraicType.serializeValue(\n        retBuf,\n        returnType,\n        ret,\n        MODULE_DEF.typespace\n      );\n      return {\n        data: retBuf.getBuffer(),\n      };\n    }\n  },\n};\n\nexport const hooks_v1_2: import('spacetime:sys@1.2').ModuleHooks = {\n  __call_procedure__(id, sender, connection_id, timestamp, args) {\n    return callProcedure(\n      id,\n      new Identity(sender),\n      ConnectionId.nullIfZero(new ConnectionId(connection_id)),\n      new Timestamp(timestamp),\n      args\n    );\n  },\n};\n\nlet DB_VIEW: DbView<any> | null = null;\nfunction getDbView() {\n  DB_VIEW ??= makeDbView(MODULE_DEF);\n  return DB_VIEW;\n}\n\nfunction makeDbView(moduleDef: Infer<typeof RawModuleDefV9>): DbView<any> {\n  return freeze(\n    Object.fromEntries(\n      moduleDef.tables.map(table => [\n        toCamelCase(table.name),\n        makeTableView(moduleDef.typespace, table),\n      ])\n    )\n  );\n}\n\nfunction makeTableView(\n  typespace: Infer<typeof Typespace>,\n  table: Infer<typeof RawTableDefV9>\n): Table<any> {\n  const table_id = sys.table_id_from_name(table.name);\n  const rowType = typespace.types[table.productTypeRef];\n  if (rowType.tag !== 'Product') {\n    throw 'impossible';\n  }\n\n  const baseSize = bsatnBaseSize(typespace, rowType);\n\n  const sequences = table.sequences.map(seq => {\n    const col = rowType.value.elements[seq.column];\n    const colType = col.algebraicType;\n\n    // Determine the sentinel value which users will pass to as a placeholder\n    // to cause the sequence to advance.\n    // For small integer SATS types which fit in V8 `number`s, this is `0: number`,\n    // and for larger integer SATS types it's `0n: BigInt`.\n    let sequenceTrigger: bigint | number;\n    switch (colType.tag) {\n      case 'U8':\n      case 'I8':\n      case 'U16':\n      case 'I16':\n      case 'U32':\n      case 'I32':\n        sequenceTrigger = 0;\n        break;\n      case 'U64':\n      case 'I64':\n      case 'U128':\n      case 'I128':\n      case 'U256':\n      case 'I256':\n        sequenceTrigger = 0n;\n        break;\n      default:\n        throw new TypeError('invalid sequence type');\n    }\n    return {\n      colName: col.name!,\n      sequenceTrigger,\n      read: (reader: BinaryReader) =>\n        AlgebraicType.deserializeValue(reader, colType, typespace),\n    };\n  });\n  const hasAutoIncrement = sequences.length > 0;\n\n  const iter = () =>\n    tableIterator(sys.datastore_table_scan_bsatn(table_id), rowType);\n\n  const integrateGeneratedColumns = hasAutoIncrement\n    ? (row: RowType<any>, ret_buf: Uint8Array) => {\n        const reader = new BinaryReader(ret_buf);\n        for (const { colName, read, sequenceTrigger } of sequences) {\n          if (row[colName] === sequenceTrigger) {\n            row[colName] = read(reader);\n          }\n        }\n      }\n    : null;\n\n  const tableMethods: TableMethods<any> = {\n    count: () => sys.datastore_table_row_count(table_id),\n    iter,\n    [Symbol.iterator]: () => iter(),\n    insert: row => {\n      const writer = new BinaryWriter(baseSize);\n      AlgebraicType.serializeValue(writer, rowType, row, typespace);\n      const ret_buf = sys.datastore_insert_bsatn(table_id, writer.getBuffer());\n      const ret = { ...row };\n      integrateGeneratedColumns?.(ret, ret_buf);\n\n      return ret;\n    },\n    delete: (row: RowType<any>): boolean => {\n      const writer = new BinaryWriter(4 + baseSize);\n      writer.writeU32(1);\n      AlgebraicType.serializeValue(writer, rowType, row, typespace);\n      const count = sys.datastore_delete_all_by_eq_bsatn(\n        table_id,\n        writer.getBuffer()\n      );\n      return count > 0;\n    },\n  };\n\n  const tableView = Object.assign(\n    Object.create(null),\n    tableMethods\n  ) as Table<any>;\n\n  for (const indexDef of table.indexes) {\n    const index_id = sys.index_id_from_name(indexDef.name!);\n\n    let column_ids: number[];\n    switch (indexDef.algorithm.tag) {\n      case 'BTree':\n        column_ids = indexDef.algorithm.value;\n        break;\n      case 'Hash':\n        throw new Error('impossible');\n      case 'Direct':\n        column_ids = [indexDef.algorithm.value];\n        break;\n    }\n    const numColumns = column_ids.length;\n\n    const columnSet = new Set(column_ids);\n    const isUnique = table.constraints\n      .filter(x => x.data.tag === 'Unique')\n      .some(x => columnSet.isSubsetOf(new Set(x.data.value.columns)));\n\n    const indexType = AlgebraicType.Product({\n      elements: column_ids.map(id => rowType.value.elements[id]),\n    });\n\n    const baseSize = bsatnBaseSize(typespace, indexType);\n\n    const serializePrefix = (\n      writer: BinaryWriter,\n      prefix: any[],\n      prefix_elems: number\n    ) => {\n      if (prefix_elems > numColumns - 1)\n        throw new TypeError('too many elements in prefix');\n      for (let i = 0; i < prefix_elems; i++) {\n        const elemType = indexType.value.elements[i].algebraicType;\n        AlgebraicType.serializeValue(writer, elemType, prefix[i], typespace);\n      }\n      return writer;\n    };\n\n    type IndexScanArgs = [\n      prefix: Uint8Array,\n      prefix_elems: u16,\n      rstart: Uint8Array,\n      rend: Uint8Array,\n    ];\n\n    let index: Index<any, any>;\n    if (isUnique) {\n      const serializeBound = (colVal: any[]): IndexScanArgs => {\n        if (colVal.length !== numColumns)\n          throw new TypeError('wrong number of elements');\n\n        const writer = new BinaryWriter(baseSize + 1);\n        const prefix_elems = numColumns - 1;\n        serializePrefix(writer, colVal, prefix_elems);\n        const rstartOffset = writer.offset;\n        writer.writeU8(0);\n        AlgebraicType.serializeValue(\n          writer,\n          indexType.value.elements[numColumns - 1].algebraicType,\n          colVal[numColumns - 1],\n          typespace\n        );\n        const buffer = writer.getBuffer();\n        const prefix = buffer.slice(0, rstartOffset);\n        const rstart = buffer.slice(rstartOffset);\n        return [prefix, prefix_elems, rstart, rstart];\n      };\n      index = {\n        find: (colVal: IndexVal<any, any>): RowType<any> | null => {\n          if (numColumns === 1) colVal = [colVal];\n          const args = serializeBound(colVal);\n          const iter = tableIterator(\n            sys.datastore_index_scan_range_bsatn(index_id, ...args),\n            rowType\n          );\n          const { value, done } = iter.next();\n          if (done) return null;\n          if (!iter.next().done)\n            throw new Error(\n              '`datastore_index_scan_range_bsatn` on unique field cannot return >1 rows'\n            );\n          return value;\n        },\n        delete: (colVal: IndexVal<any, any>): boolean => {\n          if (numColumns === 1) colVal = [colVal];\n          const args = serializeBound(colVal);\n          const num = sys.datastore_delete_by_index_scan_range_bsatn(\n            index_id,\n            ...args\n          );\n          return num > 0;\n        },\n        update: (row: RowType<any>): RowType<any> => {\n          const writer = new BinaryWriter(baseSize);\n          AlgebraicType.serializeValue(writer, rowType, row, typespace);\n          const ret_buf = sys.datastore_update_bsatn(\n            table_id,\n            index_id,\n            writer.getBuffer()\n          );\n          integrateGeneratedColumns?.(row, ret_buf);\n          return row;\n        },\n      } as UniqueIndex<any, any>;\n    } else {\n      const serializeRange = (range: any[]): IndexScanArgs => {\n        if (range.length > numColumns) throw new TypeError('too many elements');\n\n        const writer = new BinaryWriter(baseSize + 1);\n        const prefix_elems = range.length - 1;\n        serializePrefix(writer, range, prefix_elems);\n        const rstartOffset = writer.offset;\n        const term = range[range.length - 1];\n        const termType =\n          indexType.value.elements[range.length - 1].algebraicType;\n        let rstart: Uint8Array, rend: Uint8Array;\n        if (term instanceof Range) {\n          const writeBound = (bound: Bound<any>) => {\n            const tags = { included: 0, excluded: 1, unbounded: 2 };\n            writer.writeU8(tags[bound.tag]);\n            if (bound.tag !== 'unbounded')\n              AlgebraicType.serializeValue(\n                writer,\n                termType,\n                bound.value,\n                typespace\n              );\n          };\n          writeBound(term.from);\n          const rendOffset = writer.offset;\n          writeBound(term.to);\n          rstart = writer.getBuffer().slice(rstartOffset, rendOffset);\n          rend = writer.getBuffer().slice(rendOffset);\n        } else {\n          writer.writeU8(0);\n          AlgebraicType.serializeValue(writer, termType, term, typespace);\n          rstart = rend = writer.getBuffer().slice(rstartOffset);\n        }\n        const buffer = writer.getBuffer();\n        const prefix = buffer.slice(0, rstartOffset);\n        return [prefix, prefix_elems, rstart, rend];\n      };\n      index = {\n        filter: (range: any): IteratorObject<RowType<any>> => {\n          if (numColumns === 1) range = [range];\n          const args = serializeRange(range);\n          return tableIterator(\n            sys.datastore_index_scan_range_bsatn(index_id, ...args),\n            rowType\n          );\n        },\n        delete: (range: any): u32 => {\n          if (numColumns === 1) range = [range];\n          const args = serializeRange(range);\n          return sys.datastore_delete_by_index_scan_range_bsatn(\n            index_id,\n            ...args\n          );\n        },\n      } as RangedIndex<any, any>;\n    }\n\n    if (Object.hasOwn(tableView, indexDef.accessorName!)) {\n      freeze(Object.assign(tableView[indexDef.accessorName!], index));\n    } else {\n      tableView[indexDef.accessorName!] = freeze(index) as any;\n    }\n  }\n\n  return freeze(tableView);\n}\n\nfunction hasOwn<K extends PropertyKey>(\n  o: object,\n  k: K\n): o is K extends PropertyKey ? { [k in K]: unknown } : never {\n  return Object.hasOwn(o, k);\n}\n\nfunction* tableIterator(id: u32, ty: AlgebraicType): Generator<any, undefined> {\n  using iter = new IteratorHandle(id);\n  const { typespace } = MODULE_DEF;\n\n  let buf;\n  while ((buf = advanceIter(iter)) != null) {\n    const reader = new BinaryReader(buf);\n    while (reader.remaining > 0) {\n      yield AlgebraicType.deserializeValue(reader, ty, typespace);\n    }\n  }\n}\n\nfunction advanceIter(iter: IteratorHandle): Uint8Array | null {\n  let buf_max_len = 0x10000;\n  while (true) {\n    try {\n      return iter.advance(buf_max_len);\n    } catch (e) {\n      if (e && typeof e === 'object' && hasOwn(e, '__buffer_too_small__')) {\n        buf_max_len = e.__buffer_too_small__ as number;\n        continue;\n      }\n      throw e;\n    }\n  }\n}\n\n/** A class to manage the lifecycle of an iterator handle. */\nclass IteratorHandle implements Disposable {\n  #id: u32 | -1;\n\n  static #finalizationRegistry = new FinalizationRegistry<u32>(\n    sys.row_iter_bsatn_close\n  );\n\n  constructor(id: u32) {\n    this.#id = id;\n    IteratorHandle.#finalizationRegistry.register(this, id, this);\n  }\n\n  /** Unregister this object with the finalization registry and return the id */\n  #detach() {\n    const id = this.#id;\n    this.#id = -1;\n    IteratorHandle.#finalizationRegistry.unregister(this);\n    return id;\n  }\n\n  /** Call `row_iter_bsatn_advance`, returning null if this iterator was already exhausted. */\n  advance(buf_max_len: u32): Uint8Array | null {\n    if (this.#id === -1) return null;\n    const { 0: done, 1: buf } = sys.row_iter_bsatn_advance(\n      this.#id,\n      buf_max_len\n    );\n    if (done) this.#detach();\n    return buf;\n  }\n\n  [Symbol.dispose]() {\n    if (this.#id >= 0) {\n      const id = this.#detach();\n      sys.row_iter_bsatn_close(id);\n    }\n  }\n}\n\ntype Intersections<Ts extends readonly any[]> = Ts extends [\n  infer T,\n  ...infer Rest,\n]\n  ? T & Intersections<Rest>\n  : unknown;\n\nfunction wrapSyscalls<\n  Modules extends Record<string, (...args: any[]) => any>[],\n>(...modules: Modules): Intersections<Modules> {\n  return Object.fromEntries(\n    modules.flatMap(Object.entries).map(([k, v]) => [k, wrapSyscall(v)])\n  ) as Intersections<Modules>;\n}\n\nfunction wrapSyscall<F extends (...args: any[]) => any>(\n  func: F\n): (...args: Parameters<F>) => ReturnType<F> {\n  const name = func.name;\n  return {\n    [name](...args: Parameters<F>) {\n      try {\n        return func(...args);\n      } catch (e) {\n        if (\n          e !== null &&\n          typeof e === 'object' &&\n          hasOwn(e, '__code_error__') &&\n          typeof e.__code_error__ == 'number'\n        ) {\n          const message =\n            hasOwn(e, '__error_message__') &&\n            typeof e.__error_message__ === 'string'\n              ? e.__error_message__\n              : undefined;\n          throw new SpacetimeHostError(e.__code_error__, message);\n        }\n        throw e;\n      }\n    },\n  }[name];\n}\n\nfunction fmtLog(...data: any[]) {\n  return data.join(' ');\n}\n\nconst console_level_error = 0;\nconst console_level_warn = 1;\nconst console_level_info = 2;\nconst console_level_debug = 3;\nconst console_level_trace = 4;\nconst _console_level_panic = 101;\n\nconst timerMap = new Map<string, u32>();\n\nconst console: Console = {\n  // @ts-expect-error we want a blank prototype, but typescript complains\n  __proto__: {},\n  [Symbol.toStringTag]: 'console',\n  assert: (condition = false, ...data: any[]) => {\n    if (!condition) {\n      sys.console_log(console_level_error, fmtLog(...data));\n    }\n  },\n  clear: () => {},\n  debug: (...data: any[]) => {\n    sys.console_log(console_level_debug, fmtLog(...data));\n  },\n  error: (...data: any[]) => {\n    sys.console_log(console_level_error, fmtLog(...data));\n  },\n  info: (...data: any[]) => {\n    sys.console_log(console_level_info, fmtLog(...data));\n  },\n  log: (...data: any[]) => {\n    sys.console_log(console_level_info, fmtLog(...data));\n  },\n  table: (tabularData: any, _properties: any) => {\n    sys.console_log(console_level_info, fmtLog(tabularData));\n  },\n  trace: (...data: any[]) => {\n    sys.console_log(console_level_trace, fmtLog(...data));\n  },\n  warn: (...data: any[]) => {\n    sys.console_log(console_level_warn, fmtLog(...data));\n  },\n  dir: (_item: any, _options: any) => {},\n  dirxml: (..._data: any[]) => {},\n  // Counting\n  count: (_label = 'default') => {},\n  countReset: (_label = 'default') => {},\n  // Grouping\n  group: (..._data: any[]) => {},\n  groupCollapsed: (..._data: any[]) => {},\n  groupEnd: () => {},\n  // Timing\n  time: (label = 'default') => {\n    if (timerMap.has(label)) {\n      sys.console_log(console_level_warn, `Timer '${label}' already exists.`);\n      return;\n    }\n    timerMap.set(label, sys.console_timer_start(label));\n  },\n  timeLog: (label = 'default', ...data: any[]) => {\n    sys.console_log(console_level_info, fmtLog(label, ...data));\n  },\n  timeEnd: (label = 'default') => {\n    const spanId = timerMap.get(label);\n    if (spanId === undefined) {\n      sys.console_log(console_level_warn, `Timer '${label}' does not exist.`);\n      return;\n    }\n    sys.console_timer_end(spanId);\n    timerMap.delete(label);\n  },\n  // Additional console methods to satisfy the Console interface\n  timeStamp: () => {},\n  profile: () => {},\n  profileEnd: () => {},\n};\n\n(console as any).Console = console;\n\nglobalThis.console = console;\n","import { register_hooks } from 'spacetime:sys@1.0';\nimport { register_hooks as register_hooks_v1_1 } from 'spacetime:sys@1.1';\nimport { register_hooks as register_hooks_v1_2 } from 'spacetime:sys@1.2';\nimport { hooks, hooks_v1_1, hooks_v1_2 } from './runtime';\n\nregister_hooks(hooks);\nregister_hooks_v1_1(hooks_v1_1);\nregister_hooks_v1_2(hooks_v1_2);\n"]}