'use strict';

var _syscalls1_0 = require('spacetime:sys@1.0');
var spacetime_sys_1_1 = require('spacetime:sys@1.1');
var _syscalls1_2 = require('spacetime:sys@1.2');
var headersPolyfill = require('headers-polyfill');

function _interopNamespace(e) {
  if (e && e.__esModule) return e;
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () { return e[k]; }
        });
      }
    });
  }
  n.default = e;
  return Object.freeze(n);
}

var _syscalls1_0__namespace = /*#__PURE__*/_interopNamespace(_syscalls1_0);
var _syscalls1_2__namespace = /*#__PURE__*/_interopNamespace(_syscalls1_2);

typeof globalThis!=="undefined"&&((globalThis.global=globalThis.global||globalThis),(globalThis.window=globalThis.window||globalThis));
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __knownSymbol = (name, symbol) => (symbol = Symbol[name]) ? symbol : Symbol.for("Symbol." + name);
var __typeError = (msg) => {
  throw TypeError(msg);
};
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  __defProp(target, "default", { value: mod, enumerable: true }) ,
  mod
));
var __using = (stack, value, async) => {
  if (value != null) {
    if (typeof value !== "object" && typeof value !== "function") __typeError("Object expected");
    var dispose, inner;
    if (dispose === void 0) {
      dispose = value[__knownSymbol("dispose")];
    }
    if (typeof dispose !== "function") __typeError("Object not disposable");
    if (inner) dispose = function() {
      try {
        inner.call(this);
      } catch (e) {
        return Promise.reject(e);
      }
    };
    stack.push([async, dispose, value]);
  }
  return value;
};
var __callDispose = (stack, error, hasError) => {
  var E = typeof SuppressedError === "function" ? SuppressedError : function(e, s, m, _) {
    return _ = Error(m), _.name = "SuppressedError", _.error = e, _.suppressed = s, _;
  };
  var fail = (e) => error = hasError ? new E(e, error, "An error was suppressed during disposal") : (hasError = true, e);
  var next = (it) => {
    while (it = stack.pop()) {
      try {
        var result = it[1] && it[1].call(it[2]);
        if (it[0]) return Promise.resolve(result).then(next, (e) => (fail(e), next()));
      } catch (e) {
        fail(e);
      }
    }
    if (hasError) throw error;
  };
  return next();
};

// ../../node_modules/.pnpm/base64-js@1.5.1/node_modules/base64-js/index.js
var require_base64_js = __commonJS({
  "../../node_modules/.pnpm/base64-js@1.5.1/node_modules/base64-js/index.js"(exports) {
    exports.byteLength = byteLength;
    exports.toByteArray = toByteArray;
    exports.fromByteArray = fromByteArray2;
    var lookup = [];
    var revLookup = [];
    var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
    var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    for (i = 0, len = code.length; i < len; ++i) {
      lookup[i] = code[i];
      revLookup[code.charCodeAt(i)] = i;
    }
    var i;
    var len;
    revLookup["-".charCodeAt(0)] = 62;
    revLookup["_".charCodeAt(0)] = 63;
    function getLens(b64) {
      var len2 = b64.length;
      if (len2 % 4 > 0) {
        throw new Error("Invalid string. Length must be a multiple of 4");
      }
      var validLen = b64.indexOf("=");
      if (validLen === -1) validLen = len2;
      var placeHoldersLen = validLen === len2 ? 0 : 4 - validLen % 4;
      return [validLen, placeHoldersLen];
    }
    function byteLength(b64) {
      var lens = getLens(b64);
      var validLen = lens[0];
      var placeHoldersLen = lens[1];
      return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
    }
    function _byteLength(b64, validLen, placeHoldersLen) {
      return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
    }
    function toByteArray(b64) {
      var tmp;
      var lens = getLens(b64);
      var validLen = lens[0];
      var placeHoldersLen = lens[1];
      var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
      var curByte = 0;
      var len2 = placeHoldersLen > 0 ? validLen - 4 : validLen;
      var i2;
      for (i2 = 0; i2 < len2; i2 += 4) {
        tmp = revLookup[b64.charCodeAt(i2)] << 18 | revLookup[b64.charCodeAt(i2 + 1)] << 12 | revLookup[b64.charCodeAt(i2 + 2)] << 6 | revLookup[b64.charCodeAt(i2 + 3)];
        arr[curByte++] = tmp >> 16 & 255;
        arr[curByte++] = tmp >> 8 & 255;
        arr[curByte++] = tmp & 255;
      }
      if (placeHoldersLen === 2) {
        tmp = revLookup[b64.charCodeAt(i2)] << 2 | revLookup[b64.charCodeAt(i2 + 1)] >> 4;
        arr[curByte++] = tmp & 255;
      }
      if (placeHoldersLen === 1) {
        tmp = revLookup[b64.charCodeAt(i2)] << 10 | revLookup[b64.charCodeAt(i2 + 1)] << 4 | revLookup[b64.charCodeAt(i2 + 2)] >> 2;
        arr[curByte++] = tmp >> 8 & 255;
        arr[curByte++] = tmp & 255;
      }
      return arr;
    }
    function tripletToBase64(num) {
      return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
    }
    function encodeChunk(uint8, start, end) {
      var tmp;
      var output = [];
      for (var i2 = start; i2 < end; i2 += 3) {
        tmp = (uint8[i2] << 16 & 16711680) + (uint8[i2 + 1] << 8 & 65280) + (uint8[i2 + 2] & 255);
        output.push(tripletToBase64(tmp));
      }
      return output.join("");
    }
    function fromByteArray2(uint8) {
      var tmp;
      var len2 = uint8.length;
      var extraBytes = len2 % 3;
      var parts = [];
      var maxChunkLength = 16383;
      for (var i2 = 0, len22 = len2 - extraBytes; i2 < len22; i2 += maxChunkLength) {
        parts.push(encodeChunk(uint8, i2, i2 + maxChunkLength > len22 ? len22 : i2 + maxChunkLength));
      }
      if (extraBytes === 1) {
        tmp = uint8[len2 - 1];
        parts.push(
          lookup[tmp >> 2] + lookup[tmp << 4 & 63] + "=="
        );
      } else if (extraBytes === 2) {
        tmp = (uint8[len2 - 2] << 8) + uint8[len2 - 1];
        parts.push(
          lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + "="
        );
      }
      return parts.join("");
    }
  }
});

// ../../node_modules/.pnpm/fast-text-encoding@1.0.6/node_modules/fast-text-encoding/text.min.js
var require_text_min = __commonJS({
  "../../node_modules/.pnpm/fast-text-encoding@1.0.6/node_modules/fast-text-encoding/text.min.js"(exports) {
    (function(scope) {
      function B(r, e) {
        var f;
        return r instanceof Buffer ? f = r : f = Buffer.from(r.buffer, r.byteOffset, r.byteLength), f.toString(e);
      }
      var w = function(r) {
        return Buffer.from(r);
      };
      function h(r) {
        for (var e = 0, f = Math.min(256 * 256, r.length + 1), n = new Uint16Array(f), i = [], o = 0; ; ) {
          var t2 = e < r.length;
          if (!t2 || o >= f - 1) {
            var s = n.subarray(0, o), m = s;
            if (i.push(String.fromCharCode.apply(null, m)), !t2) return i.join("");
            r = r.subarray(e), e = 0, o = 0;
          }
          var a = r[e++];
          if ((a & 128) === 0) n[o++] = a;
          else if ((a & 224) === 192) {
            var d = r[e++] & 63;
            n[o++] = (a & 31) << 6 | d;
          } else if ((a & 240) === 224) {
            var d = r[e++] & 63, l = r[e++] & 63;
            n[o++] = (a & 31) << 12 | d << 6 | l;
          } else if ((a & 248) === 240) {
            var d = r[e++] & 63, l = r[e++] & 63, R = r[e++] & 63, c = (a & 7) << 18 | d << 12 | l << 6 | R;
            c > 65535 && (c -= 65536, n[o++] = c >>> 10 & 1023 | 55296, c = 56320 | c & 1023), n[o++] = c;
          }
        }
      }
      function F(r) {
        for (var e = 0, f = r.length, n = 0, i = Math.max(32, f + (f >>> 1) + 7), o = new Uint8Array(i >>> 3 << 3); e < f; ) {
          var t2 = r.charCodeAt(e++);
          if (t2 >= 55296 && t2 <= 56319) {
            if (e < f) {
              var s = r.charCodeAt(e);
              (s & 64512) === 56320 && (++e, t2 = ((t2 & 1023) << 10) + (s & 1023) + 65536);
            }
            if (t2 >= 55296 && t2 <= 56319) continue;
          }
          if (n + 4 > o.length) {
            i += 8, i *= 1 + e / r.length * 2, i = i >>> 3 << 3;
            var m = new Uint8Array(i);
            m.set(o), o = m;
          }
          if ((t2 & 4294967168) === 0) {
            o[n++] = t2;
            continue;
          } else if ((t2 & 4294965248) === 0) o[n++] = t2 >>> 6 & 31 | 192;
          else if ((t2 & 4294901760) === 0) o[n++] = t2 >>> 12 & 15 | 224, o[n++] = t2 >>> 6 & 63 | 128;
          else if ((t2 & 4292870144) === 0) o[n++] = t2 >>> 18 & 7 | 240, o[n++] = t2 >>> 12 & 63 | 128, o[n++] = t2 >>> 6 & 63 | 128;
          else continue;
          o[n++] = t2 & 63 | 128;
        }
        return o.slice ? o.slice(0, n) : o.subarray(0, n);
      }
      var u = "Failed to ", p = function(r, e, f) {
        if (r) throw new Error("".concat(u).concat(e, ": the '").concat(f, "' option is unsupported."));
      };
      var x = typeof Buffer == "function" && Buffer.from;
      var A = x ? w : F;
      function v() {
        this.encoding = "utf-8";
      }
      v.prototype.encode = function(r, e) {
        return p(e && e.stream, "encode", "stream"), A(r);
      };
      function U(r) {
        var e;
        try {
          var f = new Blob([r], { type: "text/plain;charset=UTF-8" });
          e = URL.createObjectURL(f);
          var n = new XMLHttpRequest();
          return n.open("GET", e, false), n.send(), n.responseText;
        } finally {
          e && URL.revokeObjectURL(e);
        }
      }
      var O = !x && typeof Blob == "function" && typeof URL == "function" && typeof URL.createObjectURL == "function", S = ["utf-8", "utf8", "unicode-1-1-utf-8"], T = h;
      x ? T = B : O && (T = function(r) {
        try {
          return U(r);
        } catch (e) {
          return h(r);
        }
      });
      var y = "construct 'TextDecoder'", E = "".concat(u, " ").concat(y, ": the ");
      function g(r, e) {
        p(e && e.fatal, y, "fatal"), r = r || "utf-8";
        var f;
        if (x ? f = Buffer.isEncoding(r) : f = S.indexOf(r.toLowerCase()) !== -1, !f) throw new RangeError("".concat(E, " encoding label provided ('").concat(r, "') is invalid."));
        this.encoding = r, this.fatal = false, this.ignoreBOM = false;
      }
      g.prototype.decode = function(r, e) {
        p(e && e.stream, "decode", "stream");
        var f;
        return r instanceof Uint8Array ? f = r : r.buffer instanceof ArrayBuffer ? f = new Uint8Array(r.buffer) : f = new Uint8Array(r), T(f, this.encoding);
      };
      scope.TextEncoder = scope.TextEncoder || v;
      scope.TextDecoder = scope.TextDecoder || g;
    })(typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : exports);
  }
});

// ../../node_modules/.pnpm/statuses@2.0.2/node_modules/statuses/codes.json
var require_codes = __commonJS({
  "../../node_modules/.pnpm/statuses@2.0.2/node_modules/statuses/codes.json"(exports, module) {
    module.exports = {
      "100": "Continue",
      "101": "Switching Protocols",
      "102": "Processing",
      "103": "Early Hints",
      "200": "OK",
      "201": "Created",
      "202": "Accepted",
      "203": "Non-Authoritative Information",
      "204": "No Content",
      "205": "Reset Content",
      "206": "Partial Content",
      "207": "Multi-Status",
      "208": "Already Reported",
      "226": "IM Used",
      "300": "Multiple Choices",
      "301": "Moved Permanently",
      "302": "Found",
      "303": "See Other",
      "304": "Not Modified",
      "305": "Use Proxy",
      "307": "Temporary Redirect",
      "308": "Permanent Redirect",
      "400": "Bad Request",
      "401": "Unauthorized",
      "402": "Payment Required",
      "403": "Forbidden",
      "404": "Not Found",
      "405": "Method Not Allowed",
      "406": "Not Acceptable",
      "407": "Proxy Authentication Required",
      "408": "Request Timeout",
      "409": "Conflict",
      "410": "Gone",
      "411": "Length Required",
      "412": "Precondition Failed",
      "413": "Payload Too Large",
      "414": "URI Too Long",
      "415": "Unsupported Media Type",
      "416": "Range Not Satisfiable",
      "417": "Expectation Failed",
      "418": "I'm a Teapot",
      "421": "Misdirected Request",
      "422": "Unprocessable Entity",
      "423": "Locked",
      "424": "Failed Dependency",
      "425": "Too Early",
      "426": "Upgrade Required",
      "428": "Precondition Required",
      "429": "Too Many Requests",
      "431": "Request Header Fields Too Large",
      "451": "Unavailable For Legal Reasons",
      "500": "Internal Server Error",
      "501": "Not Implemented",
      "502": "Bad Gateway",
      "503": "Service Unavailable",
      "504": "Gateway Timeout",
      "505": "HTTP Version Not Supported",
      "506": "Variant Also Negotiates",
      "507": "Insufficient Storage",
      "508": "Loop Detected",
      "509": "Bandwidth Limit Exceeded",
      "510": "Not Extended",
      "511": "Network Authentication Required"
    };
  }
});

// ../../node_modules/.pnpm/statuses@2.0.2/node_modules/statuses/index.js
var require_statuses = __commonJS({
  "../../node_modules/.pnpm/statuses@2.0.2/node_modules/statuses/index.js"(exports, module) {
    var codes = require_codes();
    module.exports = status2;
    status2.message = codes;
    status2.code = createMessageToStatusCodeMap(codes);
    status2.codes = createStatusCodeList(codes);
    status2.redirect = {
      300: true,
      301: true,
      302: true,
      303: true,
      305: true,
      307: true,
      308: true
    };
    status2.empty = {
      204: true,
      205: true,
      304: true
    };
    status2.retry = {
      502: true,
      503: true,
      504: true
    };
    function createMessageToStatusCodeMap(codes2) {
      var map = {};
      Object.keys(codes2).forEach(function forEachCode(code) {
        var message = codes2[code];
        var status3 = Number(code);
        map[message.toLowerCase()] = status3;
      });
      return map;
    }
    function createStatusCodeList(codes2) {
      return Object.keys(codes2).map(function mapCode(code) {
        return Number(code);
      });
    }
    function getStatusCode(message) {
      var msg = message.toLowerCase();
      if (!Object.prototype.hasOwnProperty.call(status2.code, msg)) {
        throw new Error('invalid status message: "' + message + '"');
      }
      return status2.code[msg];
    }
    function getStatusMessage(code) {
      if (!Object.prototype.hasOwnProperty.call(status2.message, code)) {
        throw new Error("invalid status code: " + code);
      }
      return status2.message[code];
    }
    function status2(code) {
      if (typeof code === "number") {
        return getStatusMessage(code);
      }
      if (typeof code !== "string") {
        throw new TypeError("code must be a number or string");
      }
      var n = parseInt(code, 10);
      if (!isNaN(n)) {
        return getStatusMessage(n);
      }
      return getStatusCode(code);
    }
  }
});

// src/lib/time_duration.ts
var TimeDuration = class _TimeDuration {
  __time_duration_micros__;
  static MICROS_PER_MILLIS = 1000n;
  /**
   * Get the algebraic type representation of the {@link TimeDuration} type.
   * @returns The algebraic type representation of the type.
   */
  static getAlgebraicType() {
    return AlgebraicType.Product({
      elements: [
        {
          name: "__time_duration_micros__",
          algebraicType: AlgebraicType.I64
        }
      ]
    });
  }
  static isTimeDuration(algebraicType) {
    if (algebraicType.tag !== "Product") {
      return false;
    }
    const elements = algebraicType.value.elements;
    if (elements.length !== 1) {
      return false;
    }
    const microsElement = elements[0];
    return microsElement.name === "__time_duration_micros__" && microsElement.algebraicType.tag === "I64";
  }
  get micros() {
    return this.__time_duration_micros__;
  }
  get millis() {
    return Number(this.micros / _TimeDuration.MICROS_PER_MILLIS);
  }
  constructor(micros) {
    this.__time_duration_micros__ = micros;
  }
  static fromMillis(millis) {
    return new _TimeDuration(BigInt(millis) * _TimeDuration.MICROS_PER_MILLIS);
  }
  /** This outputs the same string format that we use in the host and in Rust modules */
  toString() {
    const micros = this.micros;
    const sign = micros < 0 ? "-" : "+";
    const pos = micros < 0 ? -micros : micros;
    const secs = pos / 1000000n;
    const micros_remaining = pos % 1000000n;
    return `${sign}${secs}.${String(micros_remaining).padStart(6, "0")}`;
  }
};

// src/lib/timestamp.ts
var Timestamp = class _Timestamp {
  __timestamp_micros_since_unix_epoch__;
  static MICROS_PER_MILLIS = 1000n;
  get microsSinceUnixEpoch() {
    return this.__timestamp_micros_since_unix_epoch__;
  }
  constructor(micros) {
    this.__timestamp_micros_since_unix_epoch__ = micros;
  }
  /**
   * Get the algebraic type representation of the {@link Timestamp} type.
   * @returns The algebraic type representation of the type.
   */
  static getAlgebraicType() {
    return AlgebraicType.Product({
      elements: [
        {
          name: "__timestamp_micros_since_unix_epoch__",
          algebraicType: AlgebraicType.I64
        }
      ]
    });
  }
  static isTimestamp(algebraicType) {
    if (algebraicType.tag !== "Product") {
      return false;
    }
    const elements = algebraicType.value.elements;
    if (elements.length !== 1) {
      return false;
    }
    const microsElement = elements[0];
    return microsElement.name === "__timestamp_micros_since_unix_epoch__" && microsElement.algebraicType.tag === "I64";
  }
  /**
   * The Unix epoch, the midnight at the beginning of January 1, 1970, UTC.
   */
  static UNIX_EPOCH = new _Timestamp(0n);
  /**
   * Get a `Timestamp` representing the execution environment's belief of the current moment in time.
   */
  static now() {
    return _Timestamp.fromDate(/* @__PURE__ */ new Date());
  }
  /** Convert to milliseconds since Unix epoch. */
  toMillis() {
    return this.microsSinceUnixEpoch / 1000n;
  }
  /**
   * Get a `Timestamp` representing the same point in time as `date`.
   */
  static fromDate(date) {
    const millis = date.getTime();
    const micros = BigInt(millis) * _Timestamp.MICROS_PER_MILLIS;
    return new _Timestamp(micros);
  }
  /**
   * Get a `Date` representing approximately the same point in time as `this`.
   *
   * This method truncates to millisecond precision,
   * and throws `RangeError` if the `Timestamp` is outside the range representable as a `Date`.
   */
  toDate() {
    const micros = this.__timestamp_micros_since_unix_epoch__;
    const millis = micros / _Timestamp.MICROS_PER_MILLIS;
    if (millis > BigInt(Number.MAX_SAFE_INTEGER) || millis < BigInt(Number.MIN_SAFE_INTEGER)) {
      throw new RangeError(
        "Timestamp is outside of the representable range of JS's Date"
      );
    }
    return new Date(Number(millis));
  }
  since(other) {
    return new TimeDuration(
      this.__timestamp_micros_since_unix_epoch__ - other.__timestamp_micros_since_unix_epoch__
    );
  }
};

// src/lib/uuid.ts
var Uuid = class _Uuid {
  __uuid__;
  /**
   * The nil UUID (all zeros).
   *
   * @example
   * ```ts
   * const uuid = Uuid.NIL;
   * console.assert(
   *   uuid.toString() === "00000000-0000-0000-0000-000000000000"
   * );
   * ```
   */
  static NIL = new _Uuid(0n);
  static MAX_UUID_BIGINT = 0xffffffffffffffffffffffffffffffffn;
  /**
   * The max UUID (all ones).
   *
   * @example
   * ```ts
   * const uuid = Uuid.MAX;
   * console.assert(
   *   uuid.toString() === "ffffffff-ffff-ffff-ffff-ffffffffffff"
   * );
   * ```
   */
  static MAX = new _Uuid(_Uuid.MAX_UUID_BIGINT);
  /**
   * Create a UUID from a raw 128-bit value.
   *
   * @param u - Unsigned 128-bit integer
   * @throws {Error} If the value is outside the valid UUID range
   */
  constructor(u) {
    if (u < 0n || u > _Uuid.MAX_UUID_BIGINT) {
      throw new Error("Invalid UUID: must be between 0 and `MAX_UUID_BIGINT`");
    }
    this.__uuid__ = u;
  }
  /**
   * Create a UUID `v4` from explicit random bytes.
   *
   * This method assumes the bytes are already sufficiently random.
   * It only sets the appropriate bits for the UUID version and variant.
   *
   * @param bytes - Exactly 16 random bytes
   * @returns A UUID `v4`
   * @throws {Error} If `bytes.length !== 16`
   *
   * @example
   * ```ts
   * const randomBytes = new Uint8Array(16);
   * const uuid = Uuid.fromRandomBytesV4(randomBytes);
   *
   * console.assert(
   *   uuid.toString() === "00000000-0000-4000-8000-000000000000"
   * );
   * ```
   */
  static fromRandomBytesV4(bytes) {
    if (bytes.length !== 16) throw new Error("UUID v4 requires 16 bytes");
    const arr = new Uint8Array(bytes);
    arr[6] = arr[6] & 15 | 64;
    arr[8] = arr[8] & 63 | 128;
    return new _Uuid(_Uuid.bytesToBigInt(arr));
  }
  /**
   * Generate a UUID `v7` using a monotonic counter from `0` to `2^31 - 1`,
   * a timestamp, and 4 random bytes.
   *
   * The counter wraps around on overflow.
   *
   * The UUID `v7` is structured as follows:
   *
   * ```ascii
   * ┌───────────────────────────────────────────────┬───────────────────┐
   * | B0  | B1  | B2  | B3  | B4  | B5              |         B6        |
   * ├───────────────────────────────────────────────┼───────────────────┤
   * |                 unix_ts_ms                    |      version 7    |
   * └───────────────────────────────────────────────┴───────────────────┘
   * ┌──────────────┬─────────┬──────────────────┬───────────────────────┐
   * | B7           | B8      | B9  | B10 | B11  | B12 | B13 | B14 | B15 |
   * ├──────────────┼─────────┼──────────────────┼───────────────────────┤
   * | counter_high | variant |    counter_low   |        random         |
   * └──────────────┴─────────┴──────────────────┴───────────────────────┘
   * ```
   *
   * @param counter - Mutable monotonic counter (31-bit)
   * @param now - Timestamp since the Unix epoch
   * @param randomBytes - Exactly 4 random bytes
   * @returns A UUID `v7`
   *
   * @throws {Error} If the `counter` is negative
   * @throws {Error} If the `timestamp` is before the Unix epoch
   * @throws {Error} If `randomBytes.length !== 4`
   *
   * @example
   * ```ts
   * const now = Timestamp.fromMillis(1_686_000_000_000n);
   * const counter = { value: 1 };
   * const randomBytes = new Uint8Array(4);
   *
   * const uuid = Uuid.fromCounterV7(counter, now, randomBytes);
   *
   * console.assert(
   *   uuid.toString() === "0000647e-5180-7000-8000-000200000000"
   * );
   * ```
   */
  static fromCounterV7(counter, now, randomBytes) {
    if (randomBytes.length !== 4) {
      throw new Error("`fromCounterV7` requires `randomBytes.length == 4`");
    }
    if (counter.value < 0) {
      throw new Error("`fromCounterV7` uuid `counter` must be non-negative");
    }
    if (now.__timestamp_micros_since_unix_epoch__ < 0) {
      throw new Error("`fromCounterV7` `timestamp` before unix epoch");
    }
    const counterVal = counter.value;
    counter.value = counterVal + 1 & 2147483647;
    const tsMs = now.toMillis() & 0xffffffffffffn;
    const bytes = new Uint8Array(16);
    bytes[0] = Number(tsMs >> 40n & 0xffn);
    bytes[1] = Number(tsMs >> 32n & 0xffn);
    bytes[2] = Number(tsMs >> 24n & 0xffn);
    bytes[3] = Number(tsMs >> 16n & 0xffn);
    bytes[4] = Number(tsMs >> 8n & 0xffn);
    bytes[5] = Number(tsMs & 0xffn);
    bytes[7] = counterVal >>> 23 & 255;
    bytes[9] = counterVal >>> 15 & 255;
    bytes[10] = counterVal >>> 7 & 255;
    bytes[11] = (counterVal & 127) << 1 & 255;
    bytes[12] |= randomBytes[0] & 127;
    bytes[13] = randomBytes[1];
    bytes[14] = randomBytes[2];
    bytes[15] = randomBytes[3];
    bytes[6] = bytes[6] & 15 | 112;
    bytes[8] = bytes[8] & 63 | 128;
    return new _Uuid(_Uuid.bytesToBigInt(bytes));
  }
  /**
   * Parse a UUID from a string representation.
   *
   * @param s - UUID string
   * @returns Parsed UUID
   * @throws {Error} If the string is not a valid UUID
   *
   * @example
   * ```ts
   * const s = "01888d6e-5c00-7000-8000-000000000000";
   * const uuid = Uuid.parse(s);
   *
   * console.assert(uuid.toString() === s);
   * ```
   */
  static parse(s) {
    const hex = s.replace(/-/g, "");
    if (hex.length !== 32) throw new Error("Invalid hex UUID");
    let v = 0n;
    for (let i = 0; i < 32; i += 2) {
      v = v << 8n | BigInt(parseInt(hex.slice(i, i + 2), 16));
    }
    return new _Uuid(v);
  }
  /** Convert to string (hyphenated form). */
  toString() {
    const bytes = _Uuid.bigIntToBytes(this.__uuid__);
    const hex = [...bytes].map((b) => b.toString(16).padStart(2, "0")).join("");
    return hex.slice(0, 8) + "-" + hex.slice(8, 12) + "-" + hex.slice(12, 16) + "-" + hex.slice(16, 20) + "-" + hex.slice(20);
  }
  /** Convert to bigint (u128). */
  asBigInt() {
    return this.__uuid__;
  }
  /** Return a `Uint8Array` of 16 bytes. */
  toBytes() {
    return _Uuid.bigIntToBytes(this.__uuid__);
  }
  static bytesToBigInt(bytes) {
    let result = 0n;
    for (const b of bytes) result = result << 8n | BigInt(b);
    return result;
  }
  static bigIntToBytes(value) {
    const bytes = new Uint8Array(16);
    for (let i = 15; i >= 0; i--) {
      bytes[i] = Number(value & 0xffn);
      value >>= 8n;
    }
    return bytes;
  }
  /**
   * Returns the version of this UUID.
   *
   * This represents the algorithm used to generate the value.
   *
   * @returns A `UuidVersion`
   * @throws {Error} If the version field is not recognized
   */
  getVersion() {
    const version = this.toBytes()[6] >> 4 & 15;
    switch (version) {
      case 4:
        return "V4";
      case 7:
        return "V7";
      default:
        if (this == _Uuid.NIL) {
          return "Nil";
        }
        if (this == _Uuid.MAX) {
          return "Max";
        }
        throw new Error(`Unsupported UUID version: ${version}`);
    }
  }
  /**
   * Extract the monotonic counter from a UUIDv7.
   *
   * Intended for testing and diagnostics.
   * Behavior is undefined if called on a non-V7 UUID.
   *
   * @returns 31-bit counter value
   */
  getCounter() {
    const bytes = this.toBytes();
    const high = bytes[7];
    const mid1 = bytes[9];
    const mid2 = bytes[10];
    const low = bytes[11] >>> 1;
    return high << 23 | mid1 << 15 | mid2 << 7 | low | 0;
  }
  compareTo(other) {
    if (this.__uuid__ < other.__uuid__) return -1;
    if (this.__uuid__ > other.__uuid__) return 1;
    return 0;
  }
  static getAlgebraicType() {
    return AlgebraicType.Product({
      elements: [
        {
          name: "__uuid__",
          algebraicType: AlgebraicType.U128
        }
      ]
    });
  }
};

// src/lib/binary_reader.ts
var BinaryReader = class {
  /**
   * The DataView used to read values from the binary data.
   *
   * Note: The DataView's `byteOffset` is relative to the beginning of the
   * underlying ArrayBuffer, not the start of the provided Uint8Array input.
   * This `BinaryReader`'s `#offset` field is used to track the current read position
   * relative to the start of the provided Uint8Array input.
   */
  #view;
  /**
   * Represents the offset (in bytes) relative to the start of the DataView
   * and provided Uint8Array input.
   *
   * Note: This is *not* the absolute byte offset within the underlying ArrayBuffer.
   */
  #offset = 0;
  constructor(input) {
    this.#view = new DataView(input.buffer, input.byteOffset, input.byteLength);
    this.#offset = 0;
  }
  get offset() {
    return this.#offset;
  }
  get remaining() {
    return this.#view.byteLength - this.#offset;
  }
  /** Ensure we have at least `n` bytes left to read */
  #ensure(n) {
    if (this.#offset + n > this.#view.byteLength) {
      throw new RangeError(
        `Tried to read ${n} byte(s) at relative offset ${this.#offset}, but only ${this.remaining} byte(s) remain`
      );
    }
  }
  readUInt8Array() {
    const length = this.readU32();
    this.#ensure(length);
    return this.readBytes(length);
  }
  readBool() {
    const value = this.#view.getUint8(this.#offset);
    this.#offset += 1;
    return value !== 0;
  }
  readByte() {
    const value = this.#view.getUint8(this.#offset);
    this.#offset += 1;
    return value;
  }
  readBytes(length) {
    const array = new Uint8Array(
      this.#view.buffer,
      this.#view.byteOffset + this.#offset,
      length
    );
    this.#offset += length;
    return array;
  }
  readI8() {
    const value = this.#view.getInt8(this.#offset);
    this.#offset += 1;
    return value;
  }
  readU8() {
    return this.readByte();
  }
  readI16() {
    const value = this.#view.getInt16(this.#offset, true);
    this.#offset += 2;
    return value;
  }
  readU16() {
    const value = this.#view.getUint16(this.#offset, true);
    this.#offset += 2;
    return value;
  }
  readI32() {
    const value = this.#view.getInt32(this.#offset, true);
    this.#offset += 4;
    return value;
  }
  readU32() {
    const value = this.#view.getUint32(this.#offset, true);
    this.#offset += 4;
    return value;
  }
  readI64() {
    const value = this.#view.getBigInt64(this.#offset, true);
    this.#offset += 8;
    return value;
  }
  readU64() {
    const value = this.#view.getBigUint64(this.#offset, true);
    this.#offset += 8;
    return value;
  }
  readU128() {
    const lowerPart = this.#view.getBigUint64(this.#offset, true);
    const upperPart = this.#view.getBigUint64(this.#offset + 8, true);
    this.#offset += 16;
    return (upperPart << BigInt(64)) + lowerPart;
  }
  readI128() {
    const lowerPart = this.#view.getBigUint64(this.#offset, true);
    const upperPart = this.#view.getBigInt64(this.#offset + 8, true);
    this.#offset += 16;
    return (upperPart << BigInt(64)) + lowerPart;
  }
  readU256() {
    const p0 = this.#view.getBigUint64(this.#offset, true);
    const p1 = this.#view.getBigUint64(this.#offset + 8, true);
    const p2 = this.#view.getBigUint64(this.#offset + 16, true);
    const p3 = this.#view.getBigUint64(this.#offset + 24, true);
    this.#offset += 32;
    return (p3 << BigInt(3 * 64)) + (p2 << BigInt(2 * 64)) + (p1 << BigInt(1 * 64)) + p0;
  }
  readI256() {
    const p0 = this.#view.getBigUint64(this.#offset, true);
    const p1 = this.#view.getBigUint64(this.#offset + 8, true);
    const p2 = this.#view.getBigUint64(this.#offset + 16, true);
    const p3 = this.#view.getBigInt64(this.#offset + 24, true);
    this.#offset += 32;
    return (p3 << BigInt(3 * 64)) + (p2 << BigInt(2 * 64)) + (p1 << BigInt(1 * 64)) + p0;
  }
  readF32() {
    const value = this.#view.getFloat32(this.#offset, true);
    this.#offset += 4;
    return value;
  }
  readF64() {
    const value = this.#view.getFloat64(this.#offset, true);
    this.#offset += 8;
    return value;
  }
  readString() {
    const uint8Array = this.readUInt8Array();
    return new TextDecoder("utf-8").decode(uint8Array);
  }
};

// src/lib/binary_writer.ts
var import_base64_js = __toESM(require_base64_js());
var BinaryWriter = class {
  #buffer;
  #view;
  #offset = 0;
  constructor(size) {
    this.#buffer = new Uint8Array(size);
    this.#view = new DataView(this.#buffer.buffer);
  }
  #expandBuffer(additionalCapacity) {
    const minCapacity = this.#offset + additionalCapacity + 1;
    if (minCapacity <= this.#buffer.length) return;
    let newCapacity = this.#buffer.length * 2;
    if (newCapacity < minCapacity) newCapacity = minCapacity;
    const newBuffer = new Uint8Array(newCapacity);
    newBuffer.set(this.#buffer);
    this.#buffer = newBuffer;
    this.#view = new DataView(this.#buffer.buffer);
  }
  toBase64() {
    return (0, import_base64_js.fromByteArray)(this.#buffer.subarray(0, this.#offset));
  }
  getBuffer() {
    return this.#buffer.slice(0, this.#offset);
  }
  get offset() {
    return this.#offset;
  }
  writeUInt8Array(value) {
    const length = value.length;
    this.#expandBuffer(4 + length);
    this.writeU32(length);
    this.#buffer.set(value, this.#offset);
    this.#offset += value.length;
  }
  writeBool(value) {
    this.#expandBuffer(1);
    this.#view.setUint8(this.#offset, value ? 1 : 0);
    this.#offset += 1;
  }
  writeByte(value) {
    this.#expandBuffer(1);
    this.#view.setUint8(this.#offset, value);
    this.#offset += 1;
  }
  writeI8(value) {
    this.#expandBuffer(1);
    this.#view.setInt8(this.#offset, value);
    this.#offset += 1;
  }
  writeU8(value) {
    this.#expandBuffer(1);
    this.#view.setUint8(this.#offset, value);
    this.#offset += 1;
  }
  writeI16(value) {
    this.#expandBuffer(2);
    this.#view.setInt16(this.#offset, value, true);
    this.#offset += 2;
  }
  writeU16(value) {
    this.#expandBuffer(2);
    this.#view.setUint16(this.#offset, value, true);
    this.#offset += 2;
  }
  writeI32(value) {
    this.#expandBuffer(4);
    this.#view.setInt32(this.#offset, value, true);
    this.#offset += 4;
  }
  writeU32(value) {
    this.#expandBuffer(4);
    this.#view.setUint32(this.#offset, value, true);
    this.#offset += 4;
  }
  writeI64(value) {
    this.#expandBuffer(8);
    this.#view.setBigInt64(this.#offset, value, true);
    this.#offset += 8;
  }
  writeU64(value) {
    this.#expandBuffer(8);
    this.#view.setBigUint64(this.#offset, value, true);
    this.#offset += 8;
  }
  writeU128(value) {
    this.#expandBuffer(16);
    const lowerPart = value & BigInt("0xFFFFFFFFFFFFFFFF");
    const upperPart = value >> BigInt(64);
    this.#view.setBigUint64(this.#offset, lowerPart, true);
    this.#view.setBigUint64(this.#offset + 8, upperPart, true);
    this.#offset += 16;
  }
  writeI128(value) {
    this.#expandBuffer(16);
    const lowerPart = value & BigInt("0xFFFFFFFFFFFFFFFF");
    const upperPart = value >> BigInt(64);
    this.#view.setBigInt64(this.#offset, lowerPart, true);
    this.#view.setBigInt64(this.#offset + 8, upperPart, true);
    this.#offset += 16;
  }
  writeU256(value) {
    this.#expandBuffer(32);
    const low_64_mask = BigInt("0xFFFFFFFFFFFFFFFF");
    const p0 = value & low_64_mask;
    const p1 = value >> BigInt(64 * 1) & low_64_mask;
    const p2 = value >> BigInt(64 * 2) & low_64_mask;
    const p3 = value >> BigInt(64 * 3);
    this.#view.setBigUint64(this.#offset + 8 * 0, p0, true);
    this.#view.setBigUint64(this.#offset + 8 * 1, p1, true);
    this.#view.setBigUint64(this.#offset + 8 * 2, p2, true);
    this.#view.setBigUint64(this.#offset + 8 * 3, p3, true);
    this.#offset += 32;
  }
  writeI256(value) {
    this.#expandBuffer(32);
    const low_64_mask = BigInt("0xFFFFFFFFFFFFFFFF");
    const p0 = value & low_64_mask;
    const p1 = value >> BigInt(64 * 1) & low_64_mask;
    const p2 = value >> BigInt(64 * 2) & low_64_mask;
    const p3 = value >> BigInt(64 * 3);
    this.#view.setBigUint64(this.#offset + 8 * 0, p0, true);
    this.#view.setBigUint64(this.#offset + 8 * 1, p1, true);
    this.#view.setBigUint64(this.#offset + 8 * 2, p2, true);
    this.#view.setBigInt64(this.#offset + 8 * 3, p3, true);
    this.#offset += 32;
  }
  writeF32(value) {
    this.#expandBuffer(4);
    this.#view.setFloat32(this.#offset, value, true);
    this.#offset += 4;
  }
  writeF64(value) {
    this.#expandBuffer(8);
    this.#view.setFloat64(this.#offset, value, true);
    this.#offset += 8;
  }
  writeString(value) {
    const encoder = new TextEncoder();
    const encodedString = encoder.encode(value);
    this.writeU32(encodedString.length);
    this.#expandBuffer(encodedString.length);
    this.#buffer.set(encodedString, this.#offset);
    this.#offset += encodedString.length;
  }
};

// src/lib/util.ts
function toPascalCase(s) {
  const str = s.replace(/([-_][a-z])/gi, ($1) => {
    return $1.toUpperCase().replace("-", "").replace("_", "");
  });
  return str.charAt(0).toUpperCase() + str.slice(1);
}
function uint8ArrayToHexString(array) {
  return Array.prototype.map.call(array.reverse(), (x) => ("00" + x.toString(16)).slice(-2)).join("");
}
function uint8ArrayToU128(array) {
  if (array.length != 16) {
    throw new Error(`Uint8Array is not 16 bytes long: ${array}`);
  }
  return new BinaryReader(array).readU128();
}
function uint8ArrayToU256(array) {
  if (array.length != 32) {
    throw new Error(`Uint8Array is not 32 bytes long: [${array}]`);
  }
  return new BinaryReader(array).readU256();
}
function hexStringToUint8Array(str) {
  if (str.startsWith("0x")) {
    str = str.slice(2);
  }
  const matches = str.match(/.{1,2}/g) || [];
  const data = Uint8Array.from(
    matches.map((byte) => parseInt(byte, 16))
  );
  return data.reverse();
}
function hexStringToU128(str) {
  return uint8ArrayToU128(hexStringToUint8Array(str));
}
function hexStringToU256(str) {
  return uint8ArrayToU256(hexStringToUint8Array(str));
}
function u128ToUint8Array(data) {
  const writer = new BinaryWriter(16);
  writer.writeU128(data);
  return writer.getBuffer();
}
function u128ToHexString(data) {
  return uint8ArrayToHexString(u128ToUint8Array(data));
}
function u256ToUint8Array(data) {
  const writer = new BinaryWriter(32);
  writer.writeU256(data);
  return writer.getBuffer();
}
function u256ToHexString(data) {
  return uint8ArrayToHexString(u256ToUint8Array(data));
}
function toCamelCase(str) {
  return str.replace(/[-_]+/g, "_").replace(/_([a-zA-Z0-9])/g, (_, c) => c.toUpperCase());
}
function bsatnBaseSize(typespace, ty) {
  const assumedArrayLength = 4;
  while (ty.tag === "Ref") ty = typespace.types[ty.value];
  if (ty.tag === "Product") {
    let sum = 0;
    for (const { algebraicType: elem } of ty.value.elements) {
      sum += bsatnBaseSize(typespace, elem);
    }
    return sum;
  } else if (ty.tag === "Sum") {
    let min = Infinity;
    for (const { algebraicType: vari } of ty.value.variants) {
      const vSize = bsatnBaseSize(typespace, vari);
      if (vSize < min) min = vSize;
    }
    if (min === Infinity) min = 0;
    return 4 + min;
  } else if (ty.tag == "Array") {
    return 4 + assumedArrayLength * bsatnBaseSize(typespace, ty.value);
  }
  return {
    String: 4 + assumedArrayLength,
    Sum: 1,
    Bool: 1,
    I8: 1,
    U8: 1,
    I16: 2,
    U16: 2,
    I32: 4,
    U32: 4,
    F32: 4,
    I64: 8,
    U64: 8,
    F64: 8,
    I128: 16,
    U128: 16,
    I256: 32,
    U256: 32
  }[ty.tag];
}

// src/lib/connection_id.ts
var ConnectionId = class _ConnectionId {
  __connection_id__;
  /**
   * Creates a new `ConnectionId`.
   */
  constructor(data) {
    this.__connection_id__ = data;
  }
  /**
   * Get the algebraic type representation of the {@link ConnectionId} type.
   * @returns The algebraic type representation of the type.
   */
  static getAlgebraicType() {
    return AlgebraicType.Product({
      elements: [
        { name: "__connection_id__", algebraicType: AlgebraicType.U128 }
      ]
    });
  }
  isZero() {
    return this.__connection_id__ === BigInt(0);
  }
  static nullIfZero(addr) {
    if (addr.isZero()) {
      return null;
    } else {
      return addr;
    }
  }
  static random() {
    function randomU8() {
      return Math.floor(Math.random() * 255);
    }
    let result = BigInt(0);
    for (let i = 0; i < 16; i++) {
      result = result << BigInt(8) | BigInt(randomU8());
    }
    return new _ConnectionId(result);
  }
  /**
   * Compare two connection IDs for equality.
   */
  isEqual(other) {
    return this.__connection_id__ == other.__connection_id__;
  }
  /**
   * Check if two connection IDs are equal.
   */
  equals(other) {
    return this.isEqual(other);
  }
  /**
   * Print the connection ID as a hexadecimal string.
   */
  toHexString() {
    return u128ToHexString(this.__connection_id__);
  }
  /**
   * Convert the connection ID to a Uint8Array.
   */
  toUint8Array() {
    return u128ToUint8Array(this.__connection_id__);
  }
  /**
   * Parse a connection ID from a hexadecimal string.
   */
  static fromString(str) {
    return new _ConnectionId(hexStringToU128(str));
  }
  static fromStringOrNull(str) {
    const addr = _ConnectionId.fromString(str);
    if (addr.isZero()) {
      return null;
    } else {
      return addr;
    }
  }
};

// src/lib/identity.ts
var Identity = class _Identity {
  __identity__;
  /**
   * Creates a new `Identity`.
   *
   * `data` can be a hexadecimal string or a `bigint`.
   */
  constructor(data) {
    this.__identity__ = typeof data === "string" ? hexStringToU256(data) : data;
  }
  /**
   * Get the algebraic type representation of the {@link Identity} type.
   * @returns The algebraic type representation of the type.
   */
  static getAlgebraicType() {
    return AlgebraicType.Product({
      elements: [{ name: "__identity__", algebraicType: AlgebraicType.U256 }]
    });
  }
  /**
   * Check if two identities are equal.
   */
  isEqual(other) {
    return this.toHexString() === other.toHexString();
  }
  /**
   * Check if two identities are equal.
   */
  equals(other) {
    return this.isEqual(other);
  }
  /**
   * Print the identity as a hexadecimal string.
   */
  toHexString() {
    return u256ToHexString(this.__identity__);
  }
  /**
   * Convert the address to a Uint8Array.
   */
  toUint8Array() {
    return u256ToUint8Array(this.__identity__);
  }
  /**
   * Parse an Identity from a hexadecimal string.
   */
  static fromString(str) {
    return new _Identity(str);
  }
  /**
   * Zero identity (0x0000000000000000000000000000000000000000000000000000000000000000)
   */
  static zero() {
    return new _Identity(0n);
  }
  toString() {
    return this.toHexString();
  }
};

// src/lib/algebraic_type.ts
var AlgebraicType = {
  Ref: (value) => ({ tag: "Ref", value }),
  Sum: (value) => ({
    tag: "Sum",
    value
  }),
  Product: (value) => ({
    tag: "Product",
    value
  }),
  Array: (value) => ({
    tag: "Array",
    value
  }),
  String: { tag: "String" },
  Bool: { tag: "Bool" },
  I8: { tag: "I8" },
  U8: { tag: "U8" },
  I16: { tag: "I16" },
  U16: { tag: "U16" },
  I32: { tag: "I32" },
  U32: { tag: "U32" },
  I64: { tag: "I64" },
  U64: { tag: "U64" },
  I128: { tag: "I128" },
  U128: { tag: "U128" },
  I256: { tag: "I256" },
  U256: { tag: "U256" },
  F32: { tag: "F32" },
  F64: { tag: "F64" },
  serializeValue(writer, ty, value, typespace) {
    if (ty.tag === "Ref") {
      if (!typespace)
        throw new Error("cannot serialize refs without a typespace");
      while (ty.tag === "Ref") ty = typespace.types[ty.value];
    }
    switch (ty.tag) {
      case "Product":
        ProductType.serializeValue(writer, ty.value, value, typespace);
        break;
      case "Sum":
        SumType.serializeValue(writer, ty.value, value, typespace);
        break;
      case "Array":
        if (ty.value.tag === "U8") {
          writer.writeUInt8Array(value);
        } else {
          const elemType = ty.value;
          writer.writeU32(value.length);
          for (const elem of value) {
            AlgebraicType.serializeValue(writer, elemType, elem, typespace);
          }
        }
        break;
      case "Bool":
        writer.writeBool(value);
        break;
      case "I8":
        writer.writeI8(value);
        break;
      case "U8":
        writer.writeU8(value);
        break;
      case "I16":
        writer.writeI16(value);
        break;
      case "U16":
        writer.writeU16(value);
        break;
      case "I32":
        writer.writeI32(value);
        break;
      case "U32":
        writer.writeU32(value);
        break;
      case "I64":
        writer.writeI64(value);
        break;
      case "U64":
        writer.writeU64(value);
        break;
      case "I128":
        writer.writeI128(value);
        break;
      case "U128":
        writer.writeU128(value);
        break;
      case "I256":
        writer.writeI256(value);
        break;
      case "U256":
        writer.writeU256(value);
        break;
      case "F32":
        writer.writeF32(value);
        break;
      case "F64":
        writer.writeF64(value);
        break;
      case "String":
        writer.writeString(value);
        break;
    }
  },
  deserializeValue: function(reader, ty, typespace) {
    if (ty.tag === "Ref") {
      if (!typespace)
        throw new Error("cannot deserialize refs without a typespace");
      while (ty.tag === "Ref") ty = typespace.types[ty.value];
    }
    switch (ty.tag) {
      case "Product":
        return ProductType.deserializeValue(reader, ty.value, typespace);
      case "Sum":
        return SumType.deserializeValue(reader, ty.value, typespace);
      case "Array":
        if (ty.value.tag === "U8") {
          return reader.readUInt8Array();
        } else {
          const elemType = ty.value;
          const length = reader.readU32();
          const result = [];
          for (let i = 0; i < length; i++) {
            result.push(
              AlgebraicType.deserializeValue(reader, elemType, typespace)
            );
          }
          return result;
        }
      case "Bool":
        return reader.readBool();
      case "I8":
        return reader.readI8();
      case "U8":
        return reader.readU8();
      case "I16":
        return reader.readI16();
      case "U16":
        return reader.readU16();
      case "I32":
        return reader.readI32();
      case "U32":
        return reader.readU32();
      case "I64":
        return reader.readI64();
      case "U64":
        return reader.readU64();
      case "I128":
        return reader.readI128();
      case "U128":
        return reader.readU128();
      case "I256":
        return reader.readI256();
      case "U256":
        return reader.readU256();
      case "F32":
        return reader.readF32();
      case "F64":
        return reader.readF64();
      case "String":
        return reader.readString();
    }
  },
  /**
   * Convert a value of the algebraic type into something that can be used as a key in a map.
   * There are no guarantees about being able to order it.
   * This is only guaranteed to be comparable to other values of the same type.
   * @param value A value of the algebraic type
   * @returns Something that can be used as a key in a map.
   */
  intoMapKey: function(ty, value) {
    switch (ty.tag) {
      case "U8":
      case "U16":
      case "U32":
      case "U64":
      case "U128":
      case "U256":
      case "I8":
      case "I16":
      case "I32":
      case "I64":
      case "I128":
      case "I256":
      case "F32":
      case "F64":
      case "String":
      case "Bool":
        return value;
      case "Product":
        return ProductType.intoMapKey(ty.value, value);
      default: {
        const writer = new BinaryWriter(10);
        AlgebraicType.serializeValue(writer, ty, value);
        return writer.toBase64();
      }
    }
  }
};
var ProductType = {
  serializeValue(writer, ty, value, typespace) {
    for (const element of ty.elements) {
      AlgebraicType.serializeValue(
        writer,
        element.algebraicType,
        value[element.name],
        typespace
      );
    }
  },
  deserializeValue(reader, ty, typespace) {
    const result = {};
    if (ty.elements.length === 1) {
      if (ty.elements[0].name === "__time_duration_micros__") {
        return new TimeDuration(reader.readI64());
      }
      if (ty.elements[0].name === "__timestamp_micros_since_unix_epoch__") {
        return new Timestamp(reader.readI64());
      }
      if (ty.elements[0].name === "__identity__") {
        return new Identity(reader.readU256());
      }
      if (ty.elements[0].name === "__connection_id__") {
        return new ConnectionId(reader.readU128());
      }
      if (ty.elements[0].name === "__uuid__") {
        return new Uuid(reader.readU128());
      }
    }
    for (const element of ty.elements) {
      result[element.name] = AlgebraicType.deserializeValue(
        reader,
        element.algebraicType,
        typespace
      );
    }
    return result;
  },
  intoMapKey(ty, value) {
    if (ty.elements.length === 1) {
      if (ty.elements[0].name === "__time_duration_micros__") {
        return value.__time_duration_micros__;
      }
      if (ty.elements[0].name === "__timestamp_micros_since_unix_epoch__") {
        return value.__timestamp_micros_since_unix_epoch__;
      }
      if (ty.elements[0].name === "__identity__") {
        return value.__identity__;
      }
      if (ty.elements[0].name === "__connection_id__") {
        return value.__connection_id__;
      }
      if (ty.elements[0].name === "__uuid__") {
        return value.__uuid__;
      }
    }
    const writer = new BinaryWriter(10);
    AlgebraicType.serializeValue(writer, AlgebraicType.Product(ty), value);
    return writer.toBase64();
  }
};
var SumType = {
  serializeValue: function(writer, ty, value, typespace) {
    if (ty.variants.length == 2 && ty.variants[0].name === "some" && ty.variants[1].name === "none") {
      if (value !== null && value !== void 0) {
        writer.writeByte(0);
        AlgebraicType.serializeValue(
          writer,
          ty.variants[0].algebraicType,
          value,
          typespace
        );
      } else {
        writer.writeByte(1);
      }
    } else if (ty.variants.length == 2 && ty.variants[0].name === "ok" && ty.variants[1].name === "err") {
      let variantName;
      let innerValue;
      let index;
      if ("ok" in value) {
        variantName = "ok";
        innerValue = value.ok;
        index = 0;
      } else {
        variantName = "err";
        innerValue = value.err;
        index = 1;
      }
      if (index < 0) {
        throw `Result serialization error: variant '${variantName}' not found in ${JSON.stringify(ty)}`;
      }
      writer.writeU8(index);
      AlgebraicType.serializeValue(
        writer,
        ty.variants[index].algebraicType,
        innerValue,
        typespace
      );
    } else {
      const variant = value["tag"];
      const index = ty.variants.findIndex((v) => v.name === variant);
      if (index < 0) {
        throw `Can't serialize a sum type, couldn't find ${value.tag} tag ${JSON.stringify(value)} in variants ${JSON.stringify(ty)}`;
      }
      writer.writeU8(index);
      AlgebraicType.serializeValue(
        writer,
        ty.variants[index].algebraicType,
        value["value"],
        typespace
      );
    }
  },
  deserializeValue: function(reader, ty, typespace) {
    const tag = reader.readU8();
    if (ty.variants.length == 2 && ty.variants[0].name === "some" && ty.variants[1].name === "none") {
      if (tag === 0) {
        return AlgebraicType.deserializeValue(
          reader,
          ty.variants[0].algebraicType,
          typespace
        );
      } else if (tag === 1) {
        return void 0;
      } else {
        throw `Can't deserialize an option type, couldn't find ${tag} tag`;
      }
    } else if (ty.variants.length == 2 && ty.variants[0].name === "ok" && ty.variants[1].name === "err") {
      if (tag === 0) {
        const value = AlgebraicType.deserializeValue(
          reader,
          ty.variants[0].algebraicType,
          typespace
        );
        return { ok: value };
      } else if (tag === 1) {
        const value = AlgebraicType.deserializeValue(
          reader,
          ty.variants[1].algebraicType,
          typespace
        );
        return { err: value };
      } else {
        throw `Can't deserialize a result type, couldn't find ${tag} tag`;
      }
    } else {
      const variant = ty.variants[tag];
      const value = AlgebraicType.deserializeValue(
        reader,
        variant.algebraicType,
        typespace
      );
      return { tag: variant.name, value };
    }
  }
};

// src/lib/option.ts
var Option = {
  getAlgebraicType(innerType) {
    return AlgebraicType.Sum({
      variants: [
        { name: "some", algebraicType: innerType },
        {
          name: "none",
          algebraicType: AlgebraicType.Product({ elements: [] })
        }
      ]
    });
  }
};

// src/lib/result.ts
var Result = {
  getAlgebraicType(okType, errType) {
    return AlgebraicType.Sum({
      variants: [
        { name: "ok", algebraicType: okType },
        { name: "err", algebraicType: errType }
      ]
    });
  }
};

// src/lib/schedule_at.ts
var ScheduleAt = {
  interval(value) {
    return Interval(value);
  },
  time(value) {
    return Time(value);
  },
  getAlgebraicType() {
    return AlgebraicType.Sum({
      variants: [
        {
          name: "Interval",
          algebraicType: TimeDuration.getAlgebraicType()
        },
        { name: "Time", algebraicType: Timestamp.getAlgebraicType() }
      ]
    });
  },
  isScheduleAt(algebraicType) {
    if (algebraicType.tag !== "Sum") {
      return false;
    }
    const variants = algebraicType.value.variants;
    if (variants.length !== 2) {
      return false;
    }
    const intervalVariant = variants.find((v) => v.name === "Interval");
    const timeVariant = variants.find((v) => v.name === "Time");
    if (!intervalVariant || !timeVariant) {
      return false;
    }
    return TimeDuration.isTimeDuration(intervalVariant.algebraicType) && Timestamp.isTimestamp(timeVariant.algebraicType);
  }
};
var Interval = (micros) => ({
  tag: "Interval",
  value: new TimeDuration(micros)
});
var Time = (microsSinceUnixEpoch) => ({
  tag: "Time",
  value: new Timestamp(microsSinceUnixEpoch)
});
var schedule_at_default = ScheduleAt;

// src/lib/type_util.ts
function set(x, t2) {
  return { ...x, ...t2 };
}

// src/lib/type_builders.ts
var TypeBuilder = class {
  /**
   * The TypeScript phantom type. This is not stored at runtime,
   * but is visible to the compiler
   */
  type;
  /**
   * The SpacetimeDB algebraic type (run‑time value). In addition to storing
   * the runtime representation of the `AlgebraicType`, it also captures
   * the TypeScript type information of the `AlgebraicType`. That is to say
   * the value is not merely an `AlgebraicType`, but is constructed to be
   * the corresponding concrete `AlgebraicType` for the TypeScript type `Type`.
   *
   * e.g. `string` corresponds to `AlgebraicType.String`
   */
  algebraicType;
  constructor(algebraicType) {
    this.algebraicType = algebraicType;
  }
  optional() {
    return new OptionBuilder(this);
  }
  serialize(writer, value) {
    AlgebraicType.serializeValue(writer, this.algebraicType, value);
  }
  deserialize(reader) {
    return AlgebraicType.deserializeValue(reader, this.algebraicType);
  }
};
var U8Builder = class extends TypeBuilder {
  constructor() {
    super(AlgebraicType.U8);
  }
  index(algorithm = "btree") {
    return new U8ColumnBuilder(
      this,
      set(defaultMetadata, { indexType: algorithm })
    );
  }
  unique() {
    return new U8ColumnBuilder(this, set(defaultMetadata, { isUnique: true }));
  }
  primaryKey() {
    return new U8ColumnBuilder(
      this,
      set(defaultMetadata, { isPrimaryKey: true })
    );
  }
  autoInc() {
    return new U8ColumnBuilder(
      this,
      set(defaultMetadata, { isAutoIncrement: true })
    );
  }
  default(value) {
    return new U8ColumnBuilder(
      this,
      set(defaultMetadata, { defaultValue: value })
    );
  }
  name(name) {
    return new U8ColumnBuilder(this, set(defaultMetadata, { name }));
  }
};
var U16Builder = class extends TypeBuilder {
  constructor() {
    super(AlgebraicType.U16);
  }
  index(algorithm = "btree") {
    return new U16ColumnBuilder(
      this,
      set(defaultMetadata, { indexType: algorithm })
    );
  }
  unique() {
    return new U16ColumnBuilder(this, set(defaultMetadata, { isUnique: true }));
  }
  primaryKey() {
    return new U16ColumnBuilder(
      this,
      set(defaultMetadata, { isPrimaryKey: true })
    );
  }
  autoInc() {
    return new U16ColumnBuilder(
      this,
      set(defaultMetadata, { isAutoIncrement: true })
    );
  }
  default(value) {
    return new U16ColumnBuilder(
      this,
      set(defaultMetadata, { defaultValue: value })
    );
  }
  name(name) {
    return new U16ColumnBuilder(this, set(defaultMetadata, { name }));
  }
};
var U32Builder = class extends TypeBuilder {
  constructor() {
    super(AlgebraicType.U32);
  }
  index(algorithm = "btree") {
    return new U32ColumnBuilder(
      this,
      set(defaultMetadata, { indexType: algorithm })
    );
  }
  unique() {
    return new U32ColumnBuilder(this, set(defaultMetadata, { isUnique: true }));
  }
  primaryKey() {
    return new U32ColumnBuilder(
      this,
      set(defaultMetadata, { isPrimaryKey: true })
    );
  }
  autoInc() {
    return new U32ColumnBuilder(
      this,
      set(defaultMetadata, { isAutoIncrement: true })
    );
  }
  default(value) {
    return new U32ColumnBuilder(
      this,
      set(defaultMetadata, { defaultValue: value })
    );
  }
  name(name) {
    return new U32ColumnBuilder(this, set(defaultMetadata, { name }));
  }
};
var U64Builder = class extends TypeBuilder {
  constructor() {
    super(AlgebraicType.U64);
  }
  index(algorithm = "btree") {
    return new U64ColumnBuilder(
      this,
      set(defaultMetadata, { indexType: algorithm })
    );
  }
  unique() {
    return new U64ColumnBuilder(this, set(defaultMetadata, { isUnique: true }));
  }
  primaryKey() {
    return new U64ColumnBuilder(
      this,
      set(defaultMetadata, { isPrimaryKey: true })
    );
  }
  autoInc() {
    return new U64ColumnBuilder(
      this,
      set(defaultMetadata, { isAutoIncrement: true })
    );
  }
  default(value) {
    return new U64ColumnBuilder(
      this,
      set(defaultMetadata, { defaultValue: value })
    );
  }
  name(name) {
    return new U64ColumnBuilder(this, set(defaultMetadata, { name }));
  }
};
var U128Builder = class extends TypeBuilder {
  constructor() {
    super(AlgebraicType.U128);
  }
  index(algorithm = "btree") {
    return new U128ColumnBuilder(
      this,
      set(defaultMetadata, { indexType: algorithm })
    );
  }
  unique() {
    return new U128ColumnBuilder(
      this,
      set(defaultMetadata, { isUnique: true })
    );
  }
  primaryKey() {
    return new U128ColumnBuilder(
      this,
      set(defaultMetadata, { isPrimaryKey: true })
    );
  }
  autoInc() {
    return new U128ColumnBuilder(
      this,
      set(defaultMetadata, { isAutoIncrement: true })
    );
  }
  default(value) {
    return new U128ColumnBuilder(
      this,
      set(defaultMetadata, { defaultValue: value })
    );
  }
  name(name) {
    return new U128ColumnBuilder(this, set(defaultMetadata, { name }));
  }
};
var U256Builder = class extends TypeBuilder {
  constructor() {
    super(AlgebraicType.U256);
  }
  index(algorithm = "btree") {
    return new U256ColumnBuilder(
      this,
      set(defaultMetadata, { indexType: algorithm })
    );
  }
  unique() {
    return new U256ColumnBuilder(
      this,
      set(defaultMetadata, { isUnique: true })
    );
  }
  primaryKey() {
    return new U256ColumnBuilder(
      this,
      set(defaultMetadata, { isPrimaryKey: true })
    );
  }
  autoInc() {
    return new U256ColumnBuilder(
      this,
      set(defaultMetadata, { isAutoIncrement: true })
    );
  }
  default(value) {
    return new U256ColumnBuilder(
      this,
      set(defaultMetadata, { defaultValue: value })
    );
  }
  name(name) {
    return new U256ColumnBuilder(this, set(defaultMetadata, { name }));
  }
};
var I8Builder = class extends TypeBuilder {
  constructor() {
    super(AlgebraicType.I8);
  }
  index(algorithm = "btree") {
    return new I8ColumnBuilder(
      this,
      set(defaultMetadata, { indexType: algorithm })
    );
  }
  unique() {
    return new I8ColumnBuilder(this, set(defaultMetadata, { isUnique: true }));
  }
  primaryKey() {
    return new I8ColumnBuilder(
      this,
      set(defaultMetadata, { isPrimaryKey: true })
    );
  }
  autoInc() {
    return new I8ColumnBuilder(
      this,
      set(defaultMetadata, { isAutoIncrement: true })
    );
  }
  default(value) {
    return new I8ColumnBuilder(
      this,
      set(defaultMetadata, { defaultValue: value })
    );
  }
  name(name) {
    return new I8ColumnBuilder(this, set(defaultMetadata, { name }));
  }
};
var I16Builder = class extends TypeBuilder {
  constructor() {
    super(AlgebraicType.I16);
  }
  index(algorithm = "btree") {
    return new I16ColumnBuilder(
      this,
      set(defaultMetadata, { indexType: algorithm })
    );
  }
  unique() {
    return new I16ColumnBuilder(this, set(defaultMetadata, { isUnique: true }));
  }
  primaryKey() {
    return new I16ColumnBuilder(
      this,
      set(defaultMetadata, { isPrimaryKey: true })
    );
  }
  autoInc() {
    return new I16ColumnBuilder(
      this,
      set(defaultMetadata, { isAutoIncrement: true })
    );
  }
  default(value) {
    return new I16ColumnBuilder(
      this,
      set(defaultMetadata, { defaultValue: value })
    );
  }
  name(name) {
    return new I16ColumnBuilder(this, set(defaultMetadata, { name }));
  }
};
var I32Builder = class extends TypeBuilder {
  constructor() {
    super(AlgebraicType.I32);
  }
  index(algorithm = "btree") {
    return new I32ColumnBuilder(
      this,
      set(defaultMetadata, { indexType: algorithm })
    );
  }
  unique() {
    return new I32ColumnBuilder(this, set(defaultMetadata, { isUnique: true }));
  }
  primaryKey() {
    return new I32ColumnBuilder(
      this,
      set(defaultMetadata, { isPrimaryKey: true })
    );
  }
  autoInc() {
    return new I32ColumnBuilder(
      this,
      set(defaultMetadata, { isAutoIncrement: true })
    );
  }
  default(value) {
    return new I32ColumnBuilder(
      this,
      set(defaultMetadata, { defaultValue: value })
    );
  }
  name(name) {
    return new I32ColumnBuilder(this, set(defaultMetadata, { name }));
  }
};
var I64Builder = class extends TypeBuilder {
  constructor() {
    super(AlgebraicType.I64);
  }
  index(algorithm = "btree") {
    return new I64ColumnBuilder(
      this,
      set(defaultMetadata, { indexType: algorithm })
    );
  }
  unique() {
    return new I64ColumnBuilder(this, set(defaultMetadata, { isUnique: true }));
  }
  primaryKey() {
    return new I64ColumnBuilder(
      this,
      set(defaultMetadata, { isPrimaryKey: true })
    );
  }
  autoInc() {
    return new I64ColumnBuilder(
      this,
      set(defaultMetadata, { isAutoIncrement: true })
    );
  }
  default(value) {
    return new I64ColumnBuilder(
      this,
      set(defaultMetadata, { defaultValue: value })
    );
  }
  name(name) {
    return new I64ColumnBuilder(this, set(defaultMetadata, { name }));
  }
};
var I128Builder = class extends TypeBuilder {
  constructor() {
    super(AlgebraicType.I128);
  }
  index(algorithm = "btree") {
    return new I128ColumnBuilder(
      this,
      set(defaultMetadata, { indexType: algorithm })
    );
  }
  unique() {
    return new I128ColumnBuilder(
      this,
      set(defaultMetadata, { isUnique: true })
    );
  }
  primaryKey() {
    return new I128ColumnBuilder(
      this,
      set(defaultMetadata, { isPrimaryKey: true })
    );
  }
  autoInc() {
    return new I128ColumnBuilder(
      this,
      set(defaultMetadata, { isAutoIncrement: true })
    );
  }
  default(value) {
    return new I128ColumnBuilder(
      this,
      set(defaultMetadata, { defaultValue: value })
    );
  }
  name(name) {
    return new I128ColumnBuilder(this, set(defaultMetadata, { name }));
  }
};
var I256Builder = class extends TypeBuilder {
  constructor() {
    super(AlgebraicType.I256);
  }
  index(algorithm = "btree") {
    return new I256ColumnBuilder(
      this,
      set(defaultMetadata, { indexType: algorithm })
    );
  }
  unique() {
    return new I256ColumnBuilder(
      this,
      set(defaultMetadata, { isUnique: true })
    );
  }
  primaryKey() {
    return new I256ColumnBuilder(
      this,
      set(defaultMetadata, { isPrimaryKey: true })
    );
  }
  autoInc() {
    return new I256ColumnBuilder(
      this,
      set(defaultMetadata, { isAutoIncrement: true })
    );
  }
  default(value) {
    return new I256ColumnBuilder(
      this,
      set(defaultMetadata, { defaultValue: value })
    );
  }
  name(name) {
    return new I256ColumnBuilder(this, set(defaultMetadata, { name }));
  }
};
var F32Builder = class extends TypeBuilder {
  constructor() {
    super(AlgebraicType.F32);
  }
  default(value) {
    return new F32ColumnBuilder(
      this,
      set(defaultMetadata, { defaultValue: value })
    );
  }
  name(name) {
    return new F32ColumnBuilder(this, set(defaultMetadata, { name }));
  }
};
var F64Builder = class extends TypeBuilder {
  constructor() {
    super(AlgebraicType.F64);
  }
  default(value) {
    return new F64ColumnBuilder(
      this,
      set(defaultMetadata, { defaultValue: value })
    );
  }
  name(name) {
    return new F64ColumnBuilder(this, set(defaultMetadata, { name }));
  }
};
var BoolBuilder = class extends TypeBuilder {
  constructor() {
    super(AlgebraicType.Bool);
  }
  index(algorithm = "btree") {
    return new BoolColumnBuilder(
      this,
      set(defaultMetadata, { indexType: algorithm })
    );
  }
  unique() {
    return new BoolColumnBuilder(
      this,
      set(defaultMetadata, { isUnique: true })
    );
  }
  primaryKey() {
    return new BoolColumnBuilder(
      this,
      set(defaultMetadata, { isPrimaryKey: true })
    );
  }
  default(value) {
    return new BoolColumnBuilder(
      this,
      set(defaultMetadata, { defaultValue: value })
    );
  }
  name(name) {
    return new BoolColumnBuilder(this, set(defaultMetadata, { name }));
  }
};
var StringBuilder = class extends TypeBuilder {
  constructor() {
    super(AlgebraicType.String);
  }
  index(algorithm = "btree") {
    return new StringColumnBuilder(
      this,
      set(defaultMetadata, { indexType: algorithm })
    );
  }
  unique() {
    return new StringColumnBuilder(
      this,
      set(defaultMetadata, { isUnique: true })
    );
  }
  primaryKey() {
    return new StringColumnBuilder(
      this,
      set(defaultMetadata, { isPrimaryKey: true })
    );
  }
  default(value) {
    return new StringColumnBuilder(
      this,
      set(defaultMetadata, { defaultValue: value })
    );
  }
  name(name) {
    return new StringColumnBuilder(this, set(defaultMetadata, { name }));
  }
};
var ArrayBuilder = class extends TypeBuilder {
  element;
  constructor(element) {
    super(AlgebraicType.Array(element.algebraicType));
    this.element = element;
  }
  default(value) {
    return new ArrayColumnBuilder(
      this.element,
      set(defaultMetadata, { defaultValue: value })
    );
  }
  name(name) {
    return new ArrayColumnBuilder(this.element, set(defaultMetadata, { name }));
  }
};
var ByteArrayBuilder = class extends TypeBuilder {
  constructor() {
    super(AlgebraicType.Array(AlgebraicType.U8));
  }
  default(value) {
    return new ByteArrayColumnBuilder(
      set(defaultMetadata, { defaultValue: value })
    );
  }
  name(name) {
    return new ByteArrayColumnBuilder(set(defaultMetadata, { name }));
  }
};
var OptionBuilder = class extends TypeBuilder {
  value;
  constructor(value) {
    super(Option.getAlgebraicType(value.algebraicType));
    this.value = value;
  }
  default(value) {
    return new OptionColumnBuilder(
      this,
      set(defaultMetadata, { defaultValue: value })
    );
  }
  name(name) {
    return new OptionColumnBuilder(this, set(defaultMetadata, { name }));
  }
};
var ProductBuilder = class extends TypeBuilder {
  typeName;
  elements;
  constructor(elements, name) {
    function elementsArrayFromElementsObj(obj) {
      return Object.keys(obj).map((key) => ({
        name: key,
        // Lazily resolve the underlying object's algebraicType.
        // This will call obj[key].algebraicType only when someone
        // actually reads this property.
        get algebraicType() {
          return obj[key].algebraicType;
        }
      }));
    }
    super(
      AlgebraicType.Product({
        elements: elementsArrayFromElementsObj(elements)
      })
    );
    this.typeName = name;
    this.elements = elements;
  }
  default(value) {
    return new ProductColumnBuilder(
      this,
      set(defaultMetadata, { defaultValue: value })
    );
  }
  name(name) {
    return new ProductColumnBuilder(this, set(defaultMetadata, { name }));
  }
};
var ResultBuilder = class extends TypeBuilder {
  ok;
  err;
  constructor(ok, err) {
    super(Result.getAlgebraicType(ok.algebraicType, err.algebraicType));
    this.ok = ok;
    this.err = err;
  }
  default(value) {
    return new ResultColumnBuilder(this, set(defaultMetadata, { defaultValue: value }));
  }
};
var UnitBuilder = class extends TypeBuilder {
  constructor() {
    super({ tag: "Product", value: { elements: [] } });
  }
};
var RowBuilder = class extends TypeBuilder {
  row;
  typeName;
  constructor(row, name) {
    const mappedRow = Object.fromEntries(
      Object.entries(row).map(([colName, builder]) => [
        colName,
        builder instanceof ColumnBuilder ? builder : new ColumnBuilder(builder, {})
      ])
    );
    const elements = Object.keys(mappedRow).map((name2) => ({
      name: name2,
      get algebraicType() {
        return mappedRow[name2].typeBuilder.algebraicType;
      }
    }));
    super(AlgebraicType.Product({ elements }));
    this.row = mappedRow;
    this.typeName = name;
  }
};
var SumBuilderImpl = class extends TypeBuilder {
  variants;
  typeName;
  constructor(variants, name) {
    function variantsArrayFromVariantsObj(variants2) {
      return Object.keys(variants2).map((key) => ({
        name: key,
        // Lazily resolve the underlying object's algebraicType.
        // This will call obj[key].algebraicType only when someone
        // actually reads this property.
        get algebraicType() {
          return variants2[key].algebraicType;
        }
      }));
    }
    super(
      AlgebraicType.Sum({
        variants: variantsArrayFromVariantsObj(variants)
      })
    );
    this.variants = variants;
    this.typeName = name;
    for (const key of Object.keys(variants)) {
      const desc = Object.getOwnPropertyDescriptor(variants, key);
      const isAccessor = !!desc && (typeof desc.get === "function" || typeof desc.set === "function");
      let isUnit2 = false;
      if (!isAccessor) {
        const variant = variants[key];
        isUnit2 = variant instanceof UnitBuilder;
      }
      if (isUnit2) {
        const constant = this.create(key);
        Object.defineProperty(this, key, {
          value: constant,
          writable: false,
          enumerable: true,
          configurable: false
        });
      } else {
        const fn = ((value) => this.create(key, value));
        Object.defineProperty(this, key, {
          value: fn,
          writable: false,
          enumerable: true,
          configurable: false
        });
      }
    }
  }
  create(tag, value) {
    return value === void 0 ? { tag } : { tag, value };
  }
  default(value) {
    return new SumColumnBuilder(
      this,
      set(defaultMetadata, { defaultValue: value })
    );
  }
  name(name) {
    return new SumColumnBuilder(this, set(defaultMetadata, { name }));
  }
};
var SumBuilder = SumBuilderImpl;
var SimpleSumBuilderImpl = class extends SumBuilderImpl {
  index(algorithm = "btree") {
    return new SimpleSumColumnBuilder(
      this,
      set(defaultMetadata, { indexType: algorithm })
    );
  }
  primaryKey() {
    return new SimpleSumColumnBuilder(
      this,
      set(defaultMetadata, { isPrimaryKey: true })
    );
  }
};
var SimpleSumBuilder = SimpleSumBuilderImpl;
var ScheduleAtBuilder = class extends TypeBuilder {
  constructor() {
    super(schedule_at_default.getAlgebraicType());
  }
  default(value) {
    return new ScheduleAtColumnBuilder(
      this,
      set(defaultMetadata, { defaultValue: value })
    );
  }
  name(name) {
    return new ScheduleAtColumnBuilder(this, set(defaultMetadata, { name }));
  }
};
var IdentityBuilder = class extends TypeBuilder {
  constructor() {
    super(Identity.getAlgebraicType());
  }
  index(algorithm = "btree") {
    return new IdentityColumnBuilder(
      this,
      set(defaultMetadata, { indexType: algorithm })
    );
  }
  unique() {
    return new IdentityColumnBuilder(
      this,
      set(defaultMetadata, { isUnique: true })
    );
  }
  primaryKey() {
    return new IdentityColumnBuilder(
      this,
      set(defaultMetadata, { isPrimaryKey: true })
    );
  }
  autoInc() {
    return new IdentityColumnBuilder(
      this,
      set(defaultMetadata, { isAutoIncrement: true })
    );
  }
  default(value) {
    return new IdentityColumnBuilder(
      this,
      set(defaultMetadata, { defaultValue: value })
    );
  }
  name(name) {
    return new IdentityColumnBuilder(this, set(defaultMetadata, { name }));
  }
};
var ConnectionIdBuilder = class extends TypeBuilder {
  constructor() {
    super(ConnectionId.getAlgebraicType());
  }
  index(algorithm = "btree") {
    return new ConnectionIdColumnBuilder(
      this,
      set(defaultMetadata, { indexType: algorithm })
    );
  }
  unique() {
    return new ConnectionIdColumnBuilder(
      this,
      set(defaultMetadata, { isUnique: true })
    );
  }
  primaryKey() {
    return new ConnectionIdColumnBuilder(
      this,
      set(defaultMetadata, { isPrimaryKey: true })
    );
  }
  autoInc() {
    return new ConnectionIdColumnBuilder(
      this,
      set(defaultMetadata, { isAutoIncrement: true })
    );
  }
  default(value) {
    return new ConnectionIdColumnBuilder(
      this,
      set(defaultMetadata, { defaultValue: value })
    );
  }
  name(name) {
    return new ConnectionIdColumnBuilder(this, set(defaultMetadata, { name }));
  }
};
var TimestampBuilder = class extends TypeBuilder {
  constructor() {
    super(Timestamp.getAlgebraicType());
  }
  index(algorithm = "btree") {
    return new TimestampColumnBuilder(
      this,
      set(defaultMetadata, { indexType: algorithm })
    );
  }
  unique() {
    return new TimestampColumnBuilder(
      this,
      set(defaultMetadata, { isUnique: true })
    );
  }
  primaryKey() {
    return new TimestampColumnBuilder(
      this,
      set(defaultMetadata, { isPrimaryKey: true })
    );
  }
  autoInc() {
    return new TimestampColumnBuilder(
      this,
      set(defaultMetadata, { isAutoIncrement: true })
    );
  }
  default(value) {
    return new TimestampColumnBuilder(
      this,
      set(defaultMetadata, { defaultValue: value })
    );
  }
  name(name) {
    return new TimestampColumnBuilder(this, set(defaultMetadata, { name }));
  }
};
var TimeDurationBuilder = class extends TypeBuilder {
  constructor() {
    super(TimeDuration.getAlgebraicType());
  }
  index(algorithm = "btree") {
    return new TimeDurationColumnBuilder(
      this,
      set(defaultMetadata, { indexType: algorithm })
    );
  }
  unique() {
    return new TimeDurationColumnBuilder(
      this,
      set(defaultMetadata, { isUnique: true })
    );
  }
  primaryKey() {
    return new TimeDurationColumnBuilder(
      this,
      set(defaultMetadata, { isPrimaryKey: true })
    );
  }
  autoInc() {
    return new TimeDurationColumnBuilder(
      this,
      set(defaultMetadata, { isAutoIncrement: true })
    );
  }
  default(value) {
    return new TimeDurationColumnBuilder(
      this,
      set(defaultMetadata, { defaultValue: value })
    );
  }
  name(name) {
    return new TimeDurationColumnBuilder(this, set(defaultMetadata, { name }));
  }
};
var UuidBuilder = class extends TypeBuilder {
  constructor() {
    super(Uuid.getAlgebraicType());
  }
  index(algorithm = "btree") {
    return new UuidColumnBuilder(
      this,
      set(defaultMetadata, { indexType: algorithm })
    );
  }
  unique() {
    return new UuidColumnBuilder(
      this,
      set(defaultMetadata, { isUnique: true })
    );
  }
  primaryKey() {
    return new UuidColumnBuilder(
      this,
      set(defaultMetadata, { isPrimaryKey: true })
    );
  }
  autoInc() {
    return new UuidColumnBuilder(
      this,
      set(defaultMetadata, { isAutoIncrement: true })
    );
  }
  default(value) {
    return new UuidColumnBuilder(
      this,
      set(defaultMetadata, { defaultValue: value })
    );
  }
};
var defaultMetadata = {};
var ColumnBuilder = class {
  typeBuilder;
  columnMetadata;
  constructor(typeBuilder, metadata) {
    this.typeBuilder = typeBuilder;
    this.columnMetadata = metadata;
  }
  serialize(writer, value) {
    AlgebraicType.serializeValue(writer, this.typeBuilder.algebraicType, value);
  }
  deserialize(reader) {
    return AlgebraicType.deserializeValue(
      reader,
      this.typeBuilder.algebraicType
    );
  }
};
var U8ColumnBuilder = class _U8ColumnBuilder extends ColumnBuilder {
  index(algorithm = "btree") {
    return new _U8ColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { indexType: algorithm })
    );
  }
  unique() {
    return new _U8ColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { isUnique: true })
    );
  }
  primaryKey() {
    return new _U8ColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { isPrimaryKey: true })
    );
  }
  autoInc() {
    return new _U8ColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { isAutoIncrement: true })
    );
  }
  default(value) {
    return new _U8ColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, {
        defaultValue: value
      })
    );
  }
  name(name) {
    return new _U8ColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { name })
    );
  }
};
var U16ColumnBuilder = class _U16ColumnBuilder extends ColumnBuilder {
  index(algorithm = "btree") {
    return new _U16ColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { indexType: algorithm })
    );
  }
  unique() {
    return new _U16ColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { isUnique: true })
    );
  }
  primaryKey() {
    return new _U16ColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { isPrimaryKey: true })
    );
  }
  autoInc() {
    return new _U16ColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { isAutoIncrement: true })
    );
  }
  default(value) {
    return new _U16ColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, {
        defaultValue: value
      })
    );
  }
  name(name) {
    return new _U16ColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { name })
    );
  }
};
var U32ColumnBuilder = class _U32ColumnBuilder extends ColumnBuilder {
  index(algorithm = "btree") {
    return new _U32ColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { indexType: algorithm })
    );
  }
  unique() {
    return new _U32ColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { isUnique: true })
    );
  }
  primaryKey() {
    return new _U32ColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { isPrimaryKey: true })
    );
  }
  autoInc() {
    return new _U32ColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { isAutoIncrement: true })
    );
  }
  default(value) {
    return new _U32ColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, {
        defaultValue: value
      })
    );
  }
  name(name) {
    return new _U32ColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { name })
    );
  }
};
var U64ColumnBuilder = class _U64ColumnBuilder extends ColumnBuilder {
  index(algorithm = "btree") {
    return new _U64ColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { indexType: algorithm })
    );
  }
  unique() {
    return new _U64ColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { isUnique: true })
    );
  }
  primaryKey() {
    return new _U64ColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { isPrimaryKey: true })
    );
  }
  autoInc() {
    return new _U64ColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { isAutoIncrement: true })
    );
  }
  default(value) {
    return new _U64ColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, {
        defaultValue: value
      })
    );
  }
  name(name) {
    return new _U64ColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { name })
    );
  }
};
var U128ColumnBuilder = class _U128ColumnBuilder extends ColumnBuilder {
  index(algorithm = "btree") {
    return new _U128ColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { indexType: algorithm })
    );
  }
  unique() {
    return new _U128ColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { isUnique: true })
    );
  }
  primaryKey() {
    return new _U128ColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { isPrimaryKey: true })
    );
  }
  autoInc() {
    return new _U128ColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { isAutoIncrement: true })
    );
  }
  default(value) {
    return new _U128ColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, {
        defaultValue: value
      })
    );
  }
  name(name) {
    return new _U128ColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { name })
    );
  }
};
var U256ColumnBuilder = class _U256ColumnBuilder extends ColumnBuilder {
  index(algorithm = "btree") {
    return new _U256ColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { indexType: algorithm })
    );
  }
  unique() {
    return new _U256ColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { isUnique: true })
    );
  }
  primaryKey() {
    return new _U256ColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { isPrimaryKey: true })
    );
  }
  autoInc() {
    return new _U256ColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { isAutoIncrement: true })
    );
  }
  default(value) {
    return new _U256ColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, {
        defaultValue: value
      })
    );
  }
  name(name) {
    return new _U256ColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { name })
    );
  }
};
var I8ColumnBuilder = class _I8ColumnBuilder extends ColumnBuilder {
  index(algorithm = "btree") {
    return new _I8ColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { indexType: algorithm })
    );
  }
  unique() {
    return new _I8ColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { isUnique: true })
    );
  }
  primaryKey() {
    return new _I8ColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { isPrimaryKey: true })
    );
  }
  autoInc() {
    return new _I8ColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { isAutoIncrement: true })
    );
  }
  default(value) {
    return new _I8ColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, {
        defaultValue: value
      })
    );
  }
  name(name) {
    return new _I8ColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { name })
    );
  }
};
var I16ColumnBuilder = class _I16ColumnBuilder extends ColumnBuilder {
  index(algorithm = "btree") {
    return new _I16ColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { indexType: algorithm })
    );
  }
  unique() {
    return new _I16ColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { isUnique: true })
    );
  }
  primaryKey() {
    return new _I16ColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { isPrimaryKey: true })
    );
  }
  autoInc() {
    return new _I16ColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { isAutoIncrement: true })
    );
  }
  default(value) {
    return new _I16ColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, {
        defaultValue: value
      })
    );
  }
  name(name) {
    return new _I16ColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { name })
    );
  }
};
var I32ColumnBuilder = class _I32ColumnBuilder extends ColumnBuilder {
  index(algorithm = "btree") {
    return new _I32ColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { indexType: algorithm })
    );
  }
  unique() {
    return new _I32ColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { isUnique: true })
    );
  }
  primaryKey() {
    return new _I32ColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { isPrimaryKey: true })
    );
  }
  autoInc() {
    return new _I32ColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { isAutoIncrement: true })
    );
  }
  default(value) {
    return new _I32ColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, {
        defaultValue: value
      })
    );
  }
  name(name) {
    return new _I32ColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { name })
    );
  }
};
var I64ColumnBuilder = class _I64ColumnBuilder extends ColumnBuilder {
  index(algorithm = "btree") {
    return new _I64ColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { indexType: algorithm })
    );
  }
  unique() {
    return new _I64ColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { isUnique: true })
    );
  }
  primaryKey() {
    return new _I64ColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { isPrimaryKey: true })
    );
  }
  autoInc() {
    return new _I64ColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { isAutoIncrement: true })
    );
  }
  default(value) {
    return new _I64ColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, {
        defaultValue: value
      })
    );
  }
  name(name) {
    return new _I64ColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { name })
    );
  }
};
var I128ColumnBuilder = class _I128ColumnBuilder extends ColumnBuilder {
  index(algorithm = "btree") {
    return new _I128ColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { indexType: algorithm })
    );
  }
  unique() {
    return new _I128ColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { isUnique: true })
    );
  }
  primaryKey() {
    return new _I128ColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { isPrimaryKey: true })
    );
  }
  autoInc() {
    return new _I128ColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { isAutoIncrement: true })
    );
  }
  default(value) {
    return new _I128ColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, {
        defaultValue: value
      })
    );
  }
  name(name) {
    return new _I128ColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { name })
    );
  }
};
var I256ColumnBuilder = class _I256ColumnBuilder extends ColumnBuilder {
  index(algorithm = "btree") {
    return new _I256ColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { indexType: algorithm })
    );
  }
  unique() {
    return new _I256ColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { isUnique: true })
    );
  }
  primaryKey() {
    return new _I256ColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { isPrimaryKey: true })
    );
  }
  autoInc() {
    return new _I256ColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { isAutoIncrement: true })
    );
  }
  default(value) {
    return new _I256ColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, {
        defaultValue: value
      })
    );
  }
  name(name) {
    return new _I256ColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { name })
    );
  }
};
var F32ColumnBuilder = class _F32ColumnBuilder extends ColumnBuilder {
  default(value) {
    return new _F32ColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, {
        defaultValue: value
      })
    );
  }
  name(name) {
    return new _F32ColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { name })
    );
  }
};
var F64ColumnBuilder = class _F64ColumnBuilder extends ColumnBuilder {
  default(value) {
    return new _F64ColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, {
        defaultValue: value
      })
    );
  }
  name(name) {
    return new _F64ColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { name })
    );
  }
};
var BoolColumnBuilder = class _BoolColumnBuilder extends ColumnBuilder {
  index(algorithm = "btree") {
    return new _BoolColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { indexType: algorithm })
    );
  }
  unique() {
    return new _BoolColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { isUnique: true })
    );
  }
  primaryKey() {
    return new _BoolColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { isPrimaryKey: true })
    );
  }
  default(value) {
    return new _BoolColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, {
        defaultValue: value
      })
    );
  }
  name(name) {
    return new _BoolColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { name })
    );
  }
};
var StringColumnBuilder = class _StringColumnBuilder extends ColumnBuilder {
  index(algorithm = "btree") {
    return new _StringColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { indexType: algorithm })
    );
  }
  unique() {
    return new _StringColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { isUnique: true })
    );
  }
  primaryKey() {
    return new _StringColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { isPrimaryKey: true })
    );
  }
  default(value) {
    return new _StringColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, {
        defaultValue: value
      })
    );
  }
  name(name) {
    return new _StringColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { name })
    );
  }
};
var ArrayColumnBuilder = class _ArrayColumnBuilder extends ColumnBuilder {
  default(value) {
    return new _ArrayColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, {
        defaultValue: value
      })
    );
  }
  name(name) {
    return new _ArrayColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { name })
    );
  }
};
var ByteArrayColumnBuilder = class _ByteArrayColumnBuilder extends ColumnBuilder {
  constructor(metadata) {
    super(new TypeBuilder(AlgebraicType.Array(AlgebraicType.U8)), metadata);
  }
  default(value) {
    return new _ByteArrayColumnBuilder(
      set(this.columnMetadata, { defaultValue: value })
    );
  }
  name(name) {
    return new _ByteArrayColumnBuilder(set(this.columnMetadata, { name }));
  }
};
var OptionColumnBuilder = class _OptionColumnBuilder extends ColumnBuilder {
  default(value) {
    return new _OptionColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, {
        defaultValue: value
      })
    );
  }
  name(name) {
    return new _OptionColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { name })
    );
  }
};
var ResultColumnBuilder = class _ResultColumnBuilder extends ColumnBuilder {
  constructor(typeBuilder, metadata) {
    super(typeBuilder, metadata);
  }
  default(value) {
    return new _ResultColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, {
        defaultValue: value
      })
    );
  }
};
var ProductColumnBuilder = class _ProductColumnBuilder extends ColumnBuilder {
  default(value) {
    return new _ProductColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { defaultValue: value })
    );
  }
  name(name) {
    return new _ProductColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { name })
    );
  }
};
var SumColumnBuilder = class _SumColumnBuilder extends ColumnBuilder {
  default(value) {
    return new _SumColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { defaultValue: value })
    );
  }
  name(name) {
    return new _SumColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { name })
    );
  }
};
var SimpleSumColumnBuilder = class _SimpleSumColumnBuilder extends SumColumnBuilder {
  index(algorithm = "btree") {
    return new _SimpleSumColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { indexType: algorithm })
    );
  }
  primaryKey() {
    return new _SimpleSumColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { isPrimaryKey: true })
    );
  }
};
var ScheduleAtColumnBuilder = class _ScheduleAtColumnBuilder extends ColumnBuilder {
  default(value) {
    return new _ScheduleAtColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { defaultValue: value })
    );
  }
  name(name) {
    return new _ScheduleAtColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { name })
    );
  }
};
var IdentityColumnBuilder = class _IdentityColumnBuilder extends ColumnBuilder {
  index(algorithm = "btree") {
    return new _IdentityColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { indexType: algorithm })
    );
  }
  unique() {
    return new _IdentityColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { isUnique: true })
    );
  }
  primaryKey() {
    return new _IdentityColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { isPrimaryKey: true })
    );
  }
  default(value) {
    return new _IdentityColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { defaultValue: value })
    );
  }
  name(name) {
    return new _IdentityColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { name })
    );
  }
};
var ConnectionIdColumnBuilder = class _ConnectionIdColumnBuilder extends ColumnBuilder {
  index(algorithm = "btree") {
    return new _ConnectionIdColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { indexType: algorithm })
    );
  }
  unique() {
    return new _ConnectionIdColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { isUnique: true })
    );
  }
  primaryKey() {
    return new _ConnectionIdColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { isPrimaryKey: true })
    );
  }
  default(value) {
    return new _ConnectionIdColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { defaultValue: value })
    );
  }
  name(name) {
    return new _ConnectionIdColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { name })
    );
  }
};
var TimestampColumnBuilder = class _TimestampColumnBuilder extends ColumnBuilder {
  index(algorithm = "btree") {
    return new _TimestampColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { indexType: algorithm })
    );
  }
  unique() {
    return new _TimestampColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { isUnique: true })
    );
  }
  primaryKey() {
    return new _TimestampColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { isPrimaryKey: true })
    );
  }
  default(value) {
    return new _TimestampColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { defaultValue: value })
    );
  }
  name(name) {
    return new _TimestampColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { name })
    );
  }
};
var TimeDurationColumnBuilder = class _TimeDurationColumnBuilder extends ColumnBuilder {
  index(algorithm = "btree") {
    return new _TimeDurationColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { indexType: algorithm })
    );
  }
  unique() {
    return new _TimeDurationColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { isUnique: true })
    );
  }
  primaryKey() {
    return new _TimeDurationColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { isPrimaryKey: true })
    );
  }
  default(value) {
    return new _TimeDurationColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { defaultValue: value })
    );
  }
  name(name) {
    return new _TimeDurationColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { name })
    );
  }
};
var UuidColumnBuilder = class _UuidColumnBuilder extends ColumnBuilder {
  index(algorithm = "btree") {
    return new _UuidColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { indexType: algorithm })
    );
  }
  unique() {
    return new _UuidColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { isUnique: true })
    );
  }
  primaryKey() {
    return new _UuidColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { isPrimaryKey: true })
    );
  }
  default(value) {
    return new _UuidColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { defaultValue: value })
    );
  }
};
var RefBuilder = class extends TypeBuilder {
  ref;
  /** The phantom type of the pointee of this ref. */
  __spacetimeType;
  constructor(ref) {
    super(AlgebraicType.Ref(ref));
    this.ref = ref;
  }
};
var enumImpl = ((nameOrObj, maybeObj) => {
  let obj = nameOrObj;
  let name = void 0;
  if (typeof nameOrObj === "string") {
    if (!maybeObj) {
      throw new TypeError(
        "When providing a name, you must also provide the variants object or array."
      );
    }
    obj = maybeObj;
    name = nameOrObj;
  }
  if (Array.isArray(obj)) {
    const simpleVariantsObj = {};
    for (const variant of obj) {
      simpleVariantsObj[variant] = new UnitBuilder();
    }
    return new SimpleSumBuilderImpl(simpleVariantsObj, name);
  }
  return new SumBuilder(obj, name);
});
var t = {
  /**
   * Creates a new `Bool` {@link AlgebraicType} to be used in table definitions
   * Represented as `boolean` in TypeScript.
   * @returns A new {@link BoolBuilder} instance
   */
  bool: () => new BoolBuilder(),
  /**
   * Creates a new `String` {@link AlgebraicType} to be used in table definitions
   * Represented as `string` in TypeScript.
   * @returns A new {@link StringBuilder} instance
   */
  string: () => new StringBuilder(),
  /**
   * Creates a new `F64` {@link AlgebraicType} to be used in table definitions
   * Represented as `number` in TypeScript.
   * @returns A new {@link F64Builder} instance
   */
  number: () => new F64Builder(),
  /**
   * Creates a new `I8` {@link AlgebraicType} to be used in table definitions
   * Represented as `number` in TypeScript.
   * @returns A new {@link I8Builder} instance
   */
  i8: () => new I8Builder(),
  /**
   * Creates a new `U8` {@link AlgebraicType} to be used in table definitions
   * Represented as `number` in TypeScript.
   * @returns A new {@link U8Builder} instance
   */
  u8: () => new U8Builder(),
  /**
   * Creates a new `I16` {@link AlgebraicType} to be used in table definitions
   * Represented as `number` in TypeScript.
   * @returns A new {@link I16Builder} instance
   */
  i16: () => new I16Builder(),
  /**
   * Creates a new `U16` {@link AlgebraicType} to be used in table definitions
   * Represented as `number` in TypeScript.
   * @returns A new {@link U16Builder} instance
   */
  u16: () => new U16Builder(),
  /**
   * Creates a new `I32` {@link AlgebraicType} to be used in table definitions
   * Represented as `number` in TypeScript.
   * @returns A new {@link I32Builder} instance
   */
  i32: () => new I32Builder(),
  /**
   * Creates a new `U32` {@link AlgebraicType} to be used in table definitions
   * Represented as `number` in TypeScript.
   * @returns A new {@link U32Builder} instance
   */
  u32: () => new U32Builder(),
  /**
   * Creates a new `I64` {@link AlgebraicType} to be used in table definitions
   * Represented as `bigint` in TypeScript.
   * @returns A new {@link I64Builder} instance
   */
  i64: () => new I64Builder(),
  /**
   * Creates a new `U64` {@link AlgebraicType} to be used in table definitions
   * Represented as `bigint` in TypeScript.
   * @returns A new {@link U64Builder} instance
   */
  u64: () => new U64Builder(),
  /**
   * Creates a new `I128` {@link AlgebraicType} to be used in table definitions
   * Represented as `bigint` in TypeScript.
   * @returns A new {@link I128Builder} instance
   */
  i128: () => new I128Builder(),
  /**
   * Creates a new `U128` {@link AlgebraicType} to be used in table definitions
   * Represented as `bigint` in TypeScript.
   * @returns A new {@link U128Builder} instance
   */
  u128: () => new U128Builder(),
  /**
   * Creates a new `I256` {@link AlgebraicType} to be used in table definitions
   * Represented as `bigint` in TypeScript.
   * @returns A new {@link I256Builder} instance
   */
  i256: () => new I256Builder(),
  /**
   * Creates a new `U256` {@link AlgebraicType} to be used in table definitions
   * Represented as `bigint` in TypeScript.
   * @returns A new {@link U256Builder} instance
   */
  u256: () => new U256Builder(),
  /**
   * Creates a new `F32` {@link AlgebraicType} to be used in table definitions
   * Represented as `number` in TypeScript.
   * @returns A new {@link F32Builder} instance
   */
  f32: () => new F32Builder(),
  /**
   * Creates a new `F64` {@link AlgebraicType} to be used in table definitions
   * Represented as `number` in TypeScript.
   * @returns A new {@link F64Builder} instance
   */
  f64: () => new F64Builder(),
  /**
   * Creates a new `Product` {@link AlgebraicType} to be used in table definitions. Product types in SpacetimeDB
   * are essentially the same as objects in JavaScript/TypeScript.
   * Properties of the object must also be {@link TypeBuilder}s.
   * Represented as an object with specific properties in TypeScript.
   *
   * @param name (optional) A display name for the product type. If omitted, an anonymous product type is created.
   * @param obj The object defining the properties of the type, whose property
   * values must be {@link TypeBuilder}s.
   * @returns A new {@link ProductBuilder} instance.
   */
  object: ((nameOrObj, maybeObj) => {
    if (typeof nameOrObj === "string") {
      if (!maybeObj) {
        throw new TypeError(
          "When providing a name, you must also provide the object."
        );
      }
      return new ProductBuilder(maybeObj, nameOrObj);
    }
    return new ProductBuilder(nameOrObj, void 0);
  }),
  /**
   * Creates a new `Row` {@link AlgebraicType} to be used in table definitions. Row types in SpacetimeDB
   * are similar to `Product` types, but are specifically used to define the schema of a table row.
   * Properties of the object must also be {@link TypeBuilder} or {@link ColumnBuilder}s.
   *
   * You can represent a `Row` as either a {@link RowObj} or an {@link RowBuilder} type when
   * defining a table schema.
   *
   * The {@link RowBuilder} type is useful when you want to create a type which can be used anywhere
   * a {@link TypeBuilder} is accepted, such as in nested objects or arrays, or as the argument
   * to a scheduled function.
   *
   * @param obj The object defining the properties of the row, whose property
   * values must be {@link TypeBuilder}s or {@link ColumnBuilder}s.
   * @returns A new {@link RowBuilder} instance
   */
  row: ((nameOrObj, maybeObj) => {
    const [obj, name] = typeof nameOrObj === "string" ? [maybeObj, nameOrObj] : [nameOrObj, void 0];
    return new RowBuilder(obj, name);
  }),
  /**
   * Creates a new `Array` {@link AlgebraicType} to be used in table definitions.
   * Represented as an array in TypeScript.
   * @param element The element type of the array, which must be a `TypeBuilder`.
   * @returns A new {@link ArrayBuilder} instance
   */
  array(e) {
    return new ArrayBuilder(e);
  },
  enum: enumImpl,
  /**
   * This is a special helper function for conveniently creating {@link Product} type columns with no fields.
   *
   * @returns A new {@link ProductBuilder} instance with no fields.
   */
  unit() {
    return new UnitBuilder();
  },
  /**
   * Creates a lazily-evaluated {@link TypeBuilder}. This is useful for creating
   * recursive types, such as a tree or linked list.
   * @param thunk A function that returns a {@link TypeBuilder}.
   * @returns A proxy {@link TypeBuilder} that evaluates the thunk on first access.
   */
  lazy(thunk) {
    let cached = null;
    const get = () => cached ??= thunk();
    const proxy = new Proxy({}, {
      get(_t, prop, recv) {
        const target = get();
        const val = Reflect.get(target, prop, recv);
        return typeof val === "function" ? val.bind(target) : val;
      },
      set(_t, prop, value, recv) {
        return Reflect.set(get(), prop, value, recv);
      },
      has(_t, prop) {
        return prop in get();
      },
      ownKeys() {
        return Reflect.ownKeys(get());
      },
      getOwnPropertyDescriptor(_t, prop) {
        return Object.getOwnPropertyDescriptor(get(), prop);
      },
      getPrototypeOf() {
        return Object.getPrototypeOf(get());
      }
    });
    return proxy;
  },
  /**
   * This is a special helper function for conveniently creating {@link ScheduleAt} type columns.
   * @returns A new ColumnBuilder instance with the {@link ScheduleAt} type.
   */
  scheduleAt: () => {
    return new ScheduleAtBuilder();
  },
  /**
   * This is a convenience method for creating a column with the {@link Option} type.
   * You can create a column of the same type by constructing an enum with a `some` and `none` variant.
   * @param value The type of the value contained in the `some` variant of the `Option`.
   * @returns A new {@link OptionBuilder} instance with the {@link Option} type.
   */
  option(value) {
    return new OptionBuilder(value);
  },
  /**
   * This is a convenience method for creating a column with the {@link Result} type.
   * You can create a column of the same type by constructing an enum with an `ok` and `err` variant.
   * @param ok The type of the value contained in the `ok` variant of the `Result`.
   * @param err The type of the value contained in the `err` variant of the `Result`.
   * @returns A new {@link ResultBuilder} instance with the {@link Result} type.
   */
  result(ok, err) {
    return new ResultBuilder(ok, err);
  },
  /**
   * This is a convenience method for creating a column with the {@link Identity} type.
   * You can create a column of the same type by constructing an `object` with a single `__identity__` element.
   * @returns A new {@link TypeBuilder} instance with the {@link Identity} type.
   */
  identity: () => {
    return new IdentityBuilder();
  },
  /**
   * This is a convenience method for creating a column with the {@link ConnectionId} type.
   * You can create a column of the same type by constructing an `object` with a single `__connection_id__` element.
   * @returns A new {@link TypeBuilder} instance with the {@link ConnectionId} type.
   */
  connectionId: () => {
    return new ConnectionIdBuilder();
  },
  /**
   * This is a convenience method for creating a column with the {@link Timestamp} type.
   * You can create a column of the same type by constructing an `object` with a single `__timestamp_micros_since_unix_epoch__` element.
   * @returns A new {@link TypeBuilder} instance with the {@link Timestamp} type.
   */
  timestamp: () => {
    return new TimestampBuilder();
  },
  /**
   * This is a convenience method for creating a column with the {@link TimeDuration} type.
   * You can create a column of the same type by constructing an `object` with a single `__time_duration_micros__` element.
   * @returns A new {@link TypeBuilder} instance with the {@link TimeDuration} type.
   */
  timeDuration: () => {
    return new TimeDurationBuilder();
  },
  /**
   * This is a convenience method for creating a column with the {@link Uuid} type.
   * You can create a column of the same type by constructing an `object` with a single `__uuid__` element.
   * @returns A new {@link TypeBuilder} instance with the {@link Uuid} type.
   */
  uuid: () => {
    return new UuidBuilder();
  },
  /**
   * This is a convenience method for creating a column with the {@link ByteArray} type.
   * You can create a column of the same type by constructing an `array` of `u8`.
   * The TypeScript representation is {@link Uint8Array}.
   * @returns A new {@link ByteArrayBuilder} instance with the {@link ByteArray} type.
   */
  byteArray: () => {
    return new ByteArrayBuilder();
  }
};

// src/lib/autogen/lifecycle_type.ts
var Lifecycle = t.enum("Lifecycle", {
  Init: t.unit(),
  OnConnect: t.unit(),
  OnDisconnect: t.unit()
});
var lifecycle_type_default = Lifecycle;

// src/lib/reducers.ts
function pushReducer(name, params, fn, lifecycle) {
  if (existingReducers.has(name)) {
    throw new TypeError(`There is already a reducer with the name '${name}'`);
  }
  existingReducers.add(name);
  if (!(params instanceof RowBuilder)) {
    params = new RowBuilder(params);
  }
  if (params.typeName === void 0) {
    params.typeName = toPascalCase(name);
  }
  const ref = registerTypesRecursively(params);
  const paramsType = resolveType(MODULE_DEF.typespace, ref).value;
  MODULE_DEF.reducers.push({
    name,
    params: paramsType,
    lifecycle
    // <- lifecycle flag lands here
  });
  if (!fn.name) {
    Object.defineProperty(fn, "name", { value: name, writable: false });
  }
  REDUCERS.push(fn);
}
var existingReducers = /* @__PURE__ */ new Set();
var REDUCERS = [];
function reducer(name, params, fn) {
  pushReducer(name, params, fn);
}
function init(name, params, fn) {
  pushReducer(name, params, fn, lifecycle_type_default.Init);
}
function clientConnected(name, params, fn) {
  pushReducer(name, params, fn, lifecycle_type_default.OnConnect);
}
function clientDisconnected(name, params, fn) {
  pushReducer(name, params, fn, lifecycle_type_default.OnDisconnect);
}
var Reducers = class {
  reducersType;
  constructor(handles) {
    this.reducersType = reducersToSchema(handles);
  }
};
function reducersToSchema(reducers2) {
  const mapped = reducers2.map((r) => {
    const paramsRow = r.params.row;
    return {
      name: r.reducerName,
      // Prefer the schema's own accessorName if present at runtime; otherwise derive it.
      accessorName: r.accessorName,
      params: paramsRow,
      paramsType: r.paramsSpacetimeType
    };
  });
  const result = { reducers: mapped };
  return result;
}
function reducers(...args) {
  const handles = args.length === 1 && Array.isArray(args[0]) ? args[0] : args;
  return new Reducers(handles);
}

// src/server/query.ts
var QueryBrand = Symbol("QueryBrand");
var isRowTypedQuery = (val) => !!val && typeof val === "object" && QueryBrand in val;
function toSql(q) {
  return q.toSql();
}
var SemijoinImpl = class _SemijoinImpl {
  constructor(sourceQuery, filterQuery, joinCondition) {
    this.sourceQuery = sourceQuery;
    this.filterQuery = filterQuery;
    this.joinCondition = joinCondition;
    if (sourceQuery.table.name === filterQuery.table.name) {
      throw new Error("Cannot semijoin a table to itself");
    }
  }
  [QueryBrand] = true;
  type = "semijoin";
  build() {
    return this;
  }
  where(predicate) {
    const nextSourceQuery = this.sourceQuery.where(predicate);
    return new _SemijoinImpl(
      nextSourceQuery,
      this.filterQuery,
      this.joinCondition
    );
  }
  toSql() {
    const left = this.filterQuery;
    const right = this.sourceQuery;
    const leftTable = quoteIdentifier(left.table.name);
    const rightTable = quoteIdentifier(right.table.name);
    let sql = `SELECT ${rightTable}.* FROM ${leftTable} JOIN ${rightTable} ON ${booleanExprToSql(this.joinCondition)}`;
    const clauses = [];
    if (left.whereClause) {
      clauses.push(booleanExprToSql(left.whereClause));
    }
    if (right.whereClause) {
      clauses.push(booleanExprToSql(right.whereClause));
    }
    if (clauses.length > 0) {
      const whereSql = clauses.length === 1 ? clauses[0] : clauses.map(wrapInParens).join(" AND ");
      sql += ` WHERE ${whereSql}`;
    }
    return sql;
  }
};
var FromBuilder = class _FromBuilder {
  constructor(table2, whereClause) {
    this.table = table2;
    this.whereClause = whereClause;
  }
  [QueryBrand] = true;
  where(predicate) {
    const newCondition = predicate(this.table.cols);
    const nextWhere = this.whereClause ? and(this.whereClause, newCondition) : newCondition;
    return new _FromBuilder(this.table, nextWhere);
  }
  rightSemijoin(right, on) {
    const sourceQuery = new _FromBuilder(right);
    const joinCondition = on(
      this.table.indexedCols,
      right.indexedCols
    );
    return new SemijoinImpl(sourceQuery, this, joinCondition);
  }
  leftSemijoin(right, on) {
    const filterQuery = new _FromBuilder(right);
    const joinCondition = on(
      this.table.indexedCols,
      right.indexedCols
    );
    return new SemijoinImpl(this, filterQuery, joinCondition);
  }
  toSql() {
    return renderSelectSqlWithJoins(this.table, this.whereClause);
  }
  build() {
    return this;
  }
};
var TableRefImpl = class {
  type = "table";
  name;
  cols;
  indexedCols;
  tableDef;
  constructor(tableDef) {
    this.name = tableDef.name;
    this.cols = createRowExpr(tableDef);
    this.indexedCols = this.cols;
    this.tableDef = tableDef;
    Object.freeze(this);
  }
  asFrom() {
    return new FromBuilder(this);
  }
  rightSemijoin(other, on) {
    return this.asFrom().rightSemijoin(other, on);
  }
  leftSemijoin(other, on) {
    return this.asFrom().leftSemijoin(other, on);
  }
  build() {
    return this.asFrom().build();
  }
  toSql() {
    return this.asFrom().toSql();
  }
  where(predicate) {
    return this.asFrom().where(predicate);
  }
};
function createTableRefFromDef(tableDef) {
  return new TableRefImpl(tableDef);
}
function makeQueryBuilder(schema2) {
  const qb = /* @__PURE__ */ Object.create(null);
  for (const table2 of schema2.tables) {
    const ref = createTableRefFromDef(
      table2
    );
    qb[table2.name] = ref;
  }
  return Object.freeze(qb);
}
function createRowExpr(tableDef) {
  const row = {};
  for (const columnName of Object.keys(tableDef.columns)) {
    const columnBuilder = tableDef.columns[columnName];
    const column = new ColumnExpression(
      tableDef.name,
      columnName,
      columnBuilder.typeBuilder.algebraicType
    );
    row[columnName] = Object.freeze(column);
  }
  return Object.freeze(row);
}
function renderSelectSqlWithJoins(table2, where, extraClauses = []) {
  const quotedTable = quoteIdentifier(table2.name);
  const sql = `SELECT * FROM ${quotedTable}`;
  const clauses = [];
  if (where) clauses.push(booleanExprToSql(where));
  clauses.push(...extraClauses);
  if (clauses.length === 0) return sql;
  const whereSql = clauses.length === 1 ? clauses[0] : clauses.map(wrapInParens).join(" AND ");
  return `${sql} WHERE ${whereSql}`;
}
var ColumnExpression = class {
  type = "column";
  column;
  table;
  // phantom: actual runtime value is undefined
  tsValueType;
  spacetimeType;
  constructor(table2, column, spacetimeType) {
    this.table = table2;
    this.column = column;
    this.spacetimeType = spacetimeType;
  }
  // These types could be tighted, but since we declare the overloads above, it doesn't weaken the API surface.
  eq(x) {
    return {
      type: "eq",
      left: this,
      right: normalizeValue(x)
    };
  }
  // These types could be tighted, but since we declare the overloads above, it doesn't weaken the API surface.
  lt(x) {
    return {
      type: "lt",
      left: this,
      right: normalizeValue(x)
    };
  }
  // These types could be tighted, but since we declare the overloads above, it doesn't weaken the API surface.
  lte(x) {
    return {
      type: "lte",
      left: this,
      right: normalizeValue(x)
    };
  }
  // These types could be tighted, but since we declare the overloads above, it doesn't weaken the API surface.
  gt(x) {
    return {
      type: "gt",
      left: this,
      right: normalizeValue(x)
    };
  }
  // These types could be tighted, but since we declare the overloads above, it doesn't weaken the API surface.
  gte(x) {
    return {
      type: "gte",
      left: this,
      right: normalizeValue(x)
    };
  }
};
function literal(value) {
  return { type: "literal", value };
}
function normalizeValue(val) {
  if (val.type === "literal")
    return val;
  if (typeof val === "object" && val != null && "type" in val && val.type === "column") {
    return val;
  }
  return literal(val);
}
function not(clause) {
  return { type: "not", clause };
}
function and(...clauses) {
  return { type: "and", clauses };
}
function or(...clauses) {
  return { type: "or", clauses };
}
function booleanExprToSql(expr, tableAlias) {
  switch (expr.type) {
    case "eq":
      return `${valueExprToSql(expr.left)} = ${valueExprToSql(expr.right)}`;
    case "ne":
      return `${valueExprToSql(expr.left)} <> ${valueExprToSql(expr.right)}`;
    case "gt":
      return `${valueExprToSql(expr.left)} > ${valueExprToSql(expr.right)}`;
    case "gte":
      return `${valueExprToSql(expr.left)} >= ${valueExprToSql(expr.right)}`;
    case "lt":
      return `${valueExprToSql(expr.left)} < ${valueExprToSql(expr.right)}`;
    case "lte":
      return `${valueExprToSql(expr.left)} <= ${valueExprToSql(expr.right)}`;
    case "and":
      return expr.clauses.map((c) => booleanExprToSql(c)).map(wrapInParens).join(" AND ");
    case "or":
      return expr.clauses.map((c) => booleanExprToSql(c)).map(wrapInParens).join(" OR ");
    case "not":
      return `NOT ${wrapInParens(booleanExprToSql(expr.clause))}`;
  }
}
function wrapInParens(sql) {
  return `(${sql})`;
}
function valueExprToSql(expr, tableAlias) {
  if (isLiteralExpr(expr)) {
    return literalValueToSql(expr.value);
  }
  const table2 = expr.table;
  return `${quoteIdentifier(table2)}.${quoteIdentifier(expr.column)}`;
}
function literalValueToSql(value) {
  if (value === null || value === void 0) {
    return "NULL";
  }
  if (value instanceof Identity || value instanceof ConnectionId) {
    return `0x${value.toHexString()}`;
  }
  switch (typeof value) {
    case "number":
    case "bigint":
      return String(value);
    case "boolean":
      return value ? "TRUE" : "FALSE";
    case "string":
      return `'${value.replace(/'/g, "''")}'`;
    default:
      return `'${JSON.stringify(value).replace(/'/g, "''")}'`;
  }
}
function quoteIdentifier(name) {
  return `"${name.replace(/"/g, '""')}"`;
}
function isLiteralExpr(expr) {
  return expr.type === "literal";
}

// src/lib/views.ts
function defineView(opts, anon, params, ret, fn) {
  const paramsBuilder = new RowBuilder(params, toPascalCase(opts.name));
  let returnType = registerTypesRecursively(ret).algebraicType;
  const { value: paramType } = resolveType(
    MODULE_DEF.typespace,
    registerTypesRecursively(paramsBuilder)
  );
  MODULE_DEF.miscExports.push({
    tag: "View",
    value: {
      name: opts.name,
      index: (anon ? ANON_VIEWS : VIEWS).length,
      isPublic: opts.public,
      isAnonymous: anon,
      params: paramType,
      returnType
    }
  });
  if (returnType.tag == "Sum") {
    const originalFn = fn;
    fn = ((ctx, args) => {
      const ret2 = originalFn(ctx, args);
      return ret2 == null ? [] : [ret2];
    });
    returnType = AlgebraicType.Array(
      returnType.value.variants[0].algebraicType
    );
  }
  (anon ? ANON_VIEWS : VIEWS).push({
    fn,
    params: paramType,
    returnType,
    returnTypeBaseSize: bsatnBaseSize(MODULE_DEF.typespace, returnType)
  });
}
var VIEWS = [];
var ANON_VIEWS = [];

// src/lib/procedures.ts
function procedure(name, params, ret, fn) {
  const paramsType = {
    elements: Object.entries(params).map(([n, c]) => ({
      name: n,
      algebraicType: registerTypesRecursively(
        "typeBuilder" in c ? c.typeBuilder : c
      ).algebraicType
    }))
  };
  const returnType = registerTypesRecursively(ret).algebraicType;
  MODULE_DEF.miscExports.push({
    tag: "Procedure",
    value: {
      name,
      params: paramsType,
      returnType
    }
  });
  PROCEDURES.push({
    fn,
    paramsType,
    returnType,
    returnTypeBaseSize: bsatnBaseSize(MODULE_DEF.typespace, returnType)
  });
}
var PROCEDURES = [];

// src/lib/schema.ts
var REGISTERED_SCHEMA = null;
function getRegisteredSchema() {
  if (REGISTERED_SCHEMA == null) {
    throw new Error("Schema has not been registered yet. Call schema() first.");
  }
  return REGISTERED_SCHEMA;
}
function tablesToSchema(tables) {
  return { tables: tables.map(tableToSchema) };
}
function tableToSchema(schema2) {
  const getColName = (i) => schema2.rowType.algebraicType.value.elements[i].name;
  return {
    name: schema2.tableName,
    accessorName: toCamelCase(schema2.tableName),
    columns: schema2.rowType.row,
    // typed as T[i]['rowType']['row'] under TablesToSchema<T>
    rowType: schema2.rowSpacetimeType,
    constraints: schema2.tableDef.constraints.map((c) => ({
      name: c.name,
      constraint: "unique",
      columns: c.data.value.columns.map(getColName)
    })),
    // TODO: horrible horrible horrible. we smuggle this `Array<UntypedIndex>`
    // by casting it to an `Array<IndexOpts>` as `TableToSchema` expects.
    // This is then used in `TableCacheImpl.constructor` and who knows where else.
    // We should stop lying about our types.
    indexes: schema2.tableDef.indexes.map((idx) => {
      const columnIds = idx.algorithm.tag === "Direct" ? [idx.algorithm.value] : idx.algorithm.value;
      return {
        name: idx.accessorName,
        unique: schema2.tableDef.constraints.some(
          (c) => c.data.value.columns.every((col) => columnIds.includes(col))
        ),
        algorithm: idx.algorithm.tag.toLowerCase(),
        columns: columnIds.map(getColName)
      };
    })
  };
}
var MODULE_DEF = {
  typespace: { types: [] },
  tables: [],
  reducers: [],
  types: [],
  miscExports: [],
  rowLevelSecurity: []
};
var COMPOUND_TYPES = /* @__PURE__ */ new Map();
function resolveType(typespace, typeBuilder) {
  let ty = typeBuilder.algebraicType;
  while (ty.tag === "Ref") {
    ty = typespace.types[ty.value];
  }
  return ty;
}
function registerTypesRecursively(typeBuilder) {
  if (typeBuilder instanceof ProductBuilder && !isUnit(typeBuilder) || typeBuilder instanceof SumBuilder || typeBuilder instanceof RowBuilder) {
    return registerCompoundTypeRecursively(typeBuilder);
  } else if (typeBuilder instanceof OptionBuilder) {
    return new OptionBuilder(
      registerTypesRecursively(typeBuilder.value)
    );
  } else if (typeBuilder instanceof ResultBuilder) {
    return new ResultBuilder(
      registerTypesRecursively(typeBuilder.ok),
      registerTypesRecursively(typeBuilder.err)
    );
  } else if (typeBuilder instanceof ArrayBuilder) {
    return new ArrayBuilder(
      registerTypesRecursively(typeBuilder.element)
    );
  } else {
    return typeBuilder;
  }
}
function registerCompoundTypeRecursively(typeBuilder) {
  const ty = typeBuilder.algebraicType;
  const name = typeBuilder.typeName;
  if (name === void 0) {
    throw new Error(
      `Missing type name for ${typeBuilder.constructor.name ?? "TypeBuilder"} ${JSON.stringify(typeBuilder)}`
    );
  }
  let r = COMPOUND_TYPES.get(ty);
  if (r != null) {
    return r;
  }
  const newTy = typeBuilder instanceof RowBuilder || typeBuilder instanceof ProductBuilder ? {
    tag: "Product",
    value: { elements: [] }
  } : { tag: "Sum", value: { variants: [] } };
  r = new RefBuilder(MODULE_DEF.typespace.types.length);
  MODULE_DEF.typespace.types.push(newTy);
  COMPOUND_TYPES.set(ty, r);
  if (typeBuilder instanceof RowBuilder) {
    for (const [name2, elem] of Object.entries(typeBuilder.row)) {
      newTy.value.elements.push({
        name: name2,
        algebraicType: registerTypesRecursively(elem.typeBuilder).algebraicType
      });
    }
  } else if (typeBuilder instanceof ProductBuilder) {
    for (const [name2, elem] of Object.entries(typeBuilder.elements)) {
      newTy.value.elements.push({
        name: name2,
        algebraicType: registerTypesRecursively(elem).algebraicType
      });
    }
  } else if (typeBuilder instanceof SumBuilder) {
    for (const [name2, variant] of Object.entries(typeBuilder.variants)) {
      newTy.value.variants.push({
        name: name2,
        algebraicType: registerTypesRecursively(variant).algebraicType
      });
    }
  }
  MODULE_DEF.types.push({
    name: splitName(name),
    ty: r.ref,
    customOrdering: true
  });
  return r;
}
function isUnit(typeBuilder) {
  return typeBuilder.typeName == null && typeBuilder.algebraicType.value.elements.length === 0;
}
function splitName(name) {
  const scope = name.split(".");
  return { name: scope.pop(), scope };
}
var Schema = class {
  tablesDef;
  typespace;
  schemaType;
  constructor(tables, typespace, handles) {
    this.tablesDef = { tables };
    this.typespace = typespace;
    this.schemaType = tablesToSchema(handles);
  }
  reducer(name, paramsOrFn, fn) {
    if (typeof paramsOrFn === "function") {
      reducer(name, {}, paramsOrFn);
      return paramsOrFn;
    } else {
      reducer(name, paramsOrFn, fn);
      return fn;
    }
  }
  init(nameOrFn, maybeFn) {
    const [name, fn] = typeof nameOrFn === "string" ? [nameOrFn, maybeFn] : ["init", nameOrFn];
    init(name, {}, fn);
  }
  clientConnected(nameOrFn, maybeFn) {
    const [name, fn] = typeof nameOrFn === "string" ? [nameOrFn, maybeFn] : ["on_connect", nameOrFn];
    clientConnected(name, {}, fn);
  }
  clientDisconnected(nameOrFn, maybeFn) {
    const [name, fn] = typeof nameOrFn === "string" ? [nameOrFn, maybeFn] : ["on_disconnect", nameOrFn];
    clientDisconnected(name, {}, fn);
  }
  view(opts, ret, fn) {
    defineView(opts, false, {}, ret, fn);
  }
  // TODO: re-enable once parameterized views are supported in SQL
  // view<Ret extends ViewReturnTypeBuilder>(
  //   opts: ViewOpts,
  //   ret: Ret,
  //   fn: ViewFn<S, {}, Ret>
  // ): void;
  // view<Params extends ParamsObj, Ret extends ViewReturnTypeBuilder>(
  //   opts: ViewOpts,
  //   params: Params,
  //   ret: Ret,
  //   fn: ViewFn<S, {}, Ret>
  // ): void;
  // view<Params extends ParamsObj, Ret extends ViewReturnTypeBuilder>(
  //   opts: ViewOpts,
  //   paramsOrRet: Ret | Params,
  //   retOrFn: ViewFn<S, {}, Ret> | Ret,
  //   maybeFn?: ViewFn<S, Params, Ret>
  // ): void {
  //   if (typeof retOrFn === 'function') {
  //     defineView(name, false, {}, paramsOrRet as Ret, retOrFn);
  //   } else {
  //     defineView(name, false, paramsOrRet as Params, retOrFn, maybeFn!);
  //   }
  // }
  anonymousView(opts, ret, fn) {
    defineView(opts, true, {}, ret, fn);
  }
  procedure(name, paramsOrRet, retOrFn, maybeFn) {
    if (typeof retOrFn === "function") {
      procedure(name, {}, paramsOrRet, retOrFn);
      return retOrFn;
    } else {
      procedure(name, paramsOrRet, retOrFn, maybeFn);
      return maybeFn;
    }
  }
  clientVisibilityFilter = {
    sql(filter) {
      MODULE_DEF.rowLevelSecurity.push({ sql: filter });
    }
  };
};
function schema(...args) {
  const handles = args.length === 1 && Array.isArray(args[0]) ? args[0] : args;
  const tableDefs = handles.map((h) => h.tableDef);
  MODULE_DEF.tables.push(...tableDefs);
  REGISTERED_SCHEMA = {
    tables: handles.map((handle) => ({
      name: handle.tableName,
      accessorName: handle.tableName,
      columns: handle.rowType.row,
      rowType: handle.rowSpacetimeType,
      indexes: handle.idxs,
      constraints: handle.constraints
    }))
  };
  return new Schema(tableDefs, MODULE_DEF.typespace, handles);
}

// src/lib/autogen/raw_index_algorithm_type.ts
var RawIndexAlgorithm = t.enum("RawIndexAlgorithm", {
  BTree: t.array(t.u16()),
  Hash: t.array(t.u16()),
  Direct: t.u16()
});
var raw_index_algorithm_type_default = RawIndexAlgorithm;

// src/lib/table.ts
function table(opts, row) {
  const {
    name,
    public: isPublic = false,
    indexes: userIndexes = [],
    scheduled
  } = opts;
  const colIds = /* @__PURE__ */ new Map();
  const colNameList = [];
  if (!(row instanceof RowBuilder)) {
    row = new RowBuilder(row);
  }
  if (row.typeName === void 0) {
    row.typeName = toPascalCase(name);
  }
  const rowTypeRef = registerTypesRecursively(row);
  row.algebraicType.value.elements.forEach((elem, i) => {
    colIds.set(elem.name, i);
    colNameList.push(elem.name);
  });
  const pk = [];
  const indexes = [];
  const constraints = [];
  const sequences = [];
  let scheduleAtCol;
  for (const [name2, builder] of Object.entries(row.row)) {
    const meta = builder.columnMetadata;
    if (meta.isPrimaryKey) {
      pk.push(colIds.get(name2));
    }
    const isUnique = meta.isUnique || meta.isPrimaryKey;
    if (meta.indexType || isUnique) {
      const algo = meta.indexType ?? "btree";
      const id = colIds.get(name2);
      let algorithm;
      switch (algo) {
        case "btree":
          algorithm = raw_index_algorithm_type_default.BTree([id]);
          break;
        case "direct":
          algorithm = raw_index_algorithm_type_default.Direct(id);
          break;
      }
      indexes.push({
        name: void 0,
        // Unnamed indexes will be assigned a globally unique name
        accessorName: name2,
        // The name of this column will be used as the accessor name
        algorithm
      });
    }
    if (isUnique) {
      constraints.push({
        name: void 0,
        data: { tag: "Unique", value: { columns: [colIds.get(name2)] } }
      });
    }
    if (meta.isAutoIncrement) {
      sequences.push({
        name: void 0,
        start: void 0,
        minValue: void 0,
        maxValue: void 0,
        column: colIds.get(name2),
        increment: 1n
      });
    }
    if (scheduled) {
      const algebraicType = builder.typeBuilder.algebraicType;
      if (schedule_at_default.isScheduleAt(algebraicType)) {
        scheduleAtCol = colIds.get(name2);
      }
    }
  }
  for (const indexOpts of userIndexes ?? []) {
    let algorithm;
    switch (indexOpts.algorithm) {
      case "btree":
        algorithm = {
          tag: "BTree",
          value: indexOpts.columns.map((c) => colIds.get(c))
        };
        break;
      case "direct":
        algorithm = { tag: "Direct", value: colIds.get(indexOpts.column) };
        break;
    }
    indexes.push({ name: void 0, accessorName: indexOpts.name, algorithm });
  }
  for (const constraintOpts of opts.constraints ?? []) {
    if (constraintOpts.constraint === "unique") {
      const data = {
        tag: "Unique",
        value: { columns: constraintOpts.columns.map((c) => colIds.get(c)) }
      };
      constraints.push({ name: constraintOpts.name, data });
      continue;
    }
  }
  for (const index of indexes) {
    const cols = index.algorithm.tag === "Direct" ? [index.algorithm.value] : index.algorithm.value;
    const colS = cols.map((i) => colNameList[i]).join("_");
    index.name = `${name}_${colS}_idx_${index.algorithm.tag.toLowerCase()}`;
  }
  const tableDef = {
    name,
    productTypeRef: rowTypeRef.ref,
    primaryKey: pk,
    indexes,
    constraints,
    sequences,
    schedule: scheduled && scheduleAtCol !== void 0 ? {
      name: void 0,
      reducerName: scheduled,
      scheduledAtColumn: scheduleAtCol
    } : void 0,
    tableType: { tag: "User" },
    tableAccess: { tag: isPublic ? "Public" : "Private" }
  };
  const productType = row.algebraicType.value;
  return {
    rowType: row,
    tableName: name,
    rowSpacetimeType: productType,
    tableDef,
    idxs: {},
    constraints
  };
}

// src/server/errors.ts
var SpacetimeHostError = class _SpacetimeHostError extends Error {
  code;
  message;
  constructor(code, message) {
    super();
    const proto = Object.getPrototypeOf(this);
    let cls;
    if (errorProtoypes.has(proto)) {
      cls = proto.constructor;
      if (code !== cls.CODE)
        throw new TypeError(`invalid error code for ${cls.name}`);
    } else if (proto === _SpacetimeHostError.prototype) {
      cls = errnoToClass.get(code);
      if (!cls) throw new RangeError(`unknown error code ${code}`);
    } else {
      throw new TypeError("cannot subclass SpacetimeError");
    }
    Object.setPrototypeOf(this, cls.prototype);
    this.code = cls.CODE;
    this.message = message ?? cls.MESSAGE;
  }
  get name() {
    return errnoToClass.get(this.code)?.name ?? "SpacetimeHostError";
  }
};
var SenderError = class extends Error {
  constructor(message) {
    super(message);
  }
  get name() {
    return "SenderError";
  }
};
var errorData = {
  /**
   * A generic error class for unknown error codes.
   */
  HostCallFailure: [1, "ABI called by host returned an error"],
  /**
   * Error indicating that an ABI call was made outside of a transaction.
   */
  NotInTransaction: [2, "ABI call can only be made while in a transaction"],
  /**
   * Error indicating that BSATN decoding failed.
   * This typically means that the data could not be decoded to the expected type.
   */
  BsatnDecodeError: [3, "Couldn't decode the BSATN to the expected type"],
  /**
   * Error indicating that a specified table does not exist.
   */
  NoSuchTable: [4, "No such table"],
  /**
   * Error indicating that a specified index does not exist.
   */
  NoSuchIndex: [5, "No such index"],
  /**
   * Error indicating that a specified row iterator is not valid.
   */
  NoSuchIter: [6, "The provided row iterator is not valid"],
  /**
   * Error indicating that a specified console timer does not exist.
   */
  NoSuchConsoleTimer: [7, "The provided console timer does not exist"],
  /**
   * Error indicating that a specified bytes source or sink is not valid.
   */
  NoSuchBytes: [8, "The provided bytes source or sink is not valid"],
  /**
   * Error indicating that a provided sink has no more space left.
   */
  NoSpace: [9, "The provided sink has no more space left"],
  /**
   * Error indicating that there is no more space in the database.
   */
  BufferTooSmall: [
    11,
    "The provided buffer is not large enough to store the data"
  ],
  /**
   * Error indicating that a value with a given unique identifier already exists.
   */
  UniqueAlreadyExists: [
    12,
    "Value with given unique identifier already exists"
  ],
  /**
   * Error indicating that the specified delay in scheduling a row was too long.
   */
  ScheduleAtDelayTooLong: [
    13,
    "Specified delay in scheduling row was too long"
  ],
  /**
   * Error indicating that an index was not unique when it was expected to be.
   */
  IndexNotUnique: [14, "The index was not unique"],
  /**
   * Error indicating that an index was not unique when it was expected to be.
   */
  NoSuchRow: [15, "The row was not found, e.g., in an update call"],
  /**
   * Error indicating that an auto-increment sequence has overflowed.
   */
  AutoIncOverflow: [16, "The auto-increment sequence overflowed"],
  WouldBlockTransaction: [
    17,
    "Attempted async or blocking op while holding open a transaction"
  ],
  TransactionNotAnonymous: [
    18,
    "Not in an anonymous transaction. Called by a reducer?"
  ],
  TransactionIsReadOnly: [
    19,
    "ABI call can only be made while within a mutable transaction"
  ],
  TransactionIsMut: [
    20,
    "ABI call can only be made while within a read-only transaction"
  ],
  HttpError: [21, "The HTTP request failed"]
};
function mapEntries(x, f) {
  return Object.fromEntries(
    Object.entries(x).map(([k, v]) => [k, f(k, v)])
  );
}
var errors = Object.freeze(
  mapEntries(
    errorData,
    (name, [code, message]) => Object.defineProperty(
      class extends SpacetimeHostError {
        static CODE = code;
        static MESSAGE = message;
        constructor() {
          super(code);
        }
      },
      "name",
      { value: name, writable: false }
    )
  )
);
var errorProtoypes = new Set(Object.values(errors).map((cls) => cls.prototype));
var errnoToClass = new Map(
  Object.values(errors).map((cls) => [cls.CODE, cls])
);

// src/server/polyfills.ts
__toESM(require_text_min());

// src/lib/autogen/sum_type_variant_type.ts
var sum_type_variant_type_default = t.object("SumTypeVariant", {
  name: t.option(t.string()),
  get algebraicType() {
    return algebraic_type_type_default;
  }
});

// src/lib/autogen/sum_type_type.ts
var sum_type_type_default = t.object("SumType", {
  get variants() {
    return t.array(sum_type_variant_type_default);
  }
});

// src/lib/autogen/product_type_element_type.ts
var product_type_element_type_default = t.object("ProductTypeElement", {
  name: t.option(t.string()),
  get algebraicType() {
    return algebraic_type_type_default;
  }
});

// src/lib/autogen/product_type_type.ts
var product_type_type_default = t.object("ProductType", {
  get elements() {
    return t.array(product_type_element_type_default);
  }
});

// src/lib/autogen/algebraic_type_type.ts
var AlgebraicType2 = t.enum("AlgebraicType", {
  Ref: t.u32(),
  get Sum() {
    return sum_type_type_default;
  },
  get Product() {
    return product_type_type_default;
  },
  get Array() {
    return AlgebraicType2;
  },
  String: t.unit(),
  Bool: t.unit(),
  I8: t.unit(),
  U8: t.unit(),
  I16: t.unit(),
  U16: t.unit(),
  I32: t.unit(),
  U32: t.unit(),
  I64: t.unit(),
  U64: t.unit(),
  I128: t.unit(),
  U128: t.unit(),
  I256: t.unit(),
  U256: t.unit(),
  F32: t.unit(),
  F64: t.unit()
});
var algebraic_type_type_default = AlgebraicType2;

// src/lib/autogen/typespace_type.ts
var typespace_type_default = t.object("Typespace", {
  get types() {
    return t.array(algebraic_type_type_default);
  }
});

// src/lib/autogen/raw_column_def_v_8_type.ts
var raw_column_def_v_8_type_default = t.object("RawColumnDefV8", {
  colName: t.string(),
  get colType() {
    return algebraic_type_type_default;
  }
});

// src/lib/autogen/index_type_type.ts
var IndexType = t.enum("IndexType", {
  BTree: t.unit(),
  Hash: t.unit()
});
var index_type_type_default = IndexType;

// src/lib/autogen/raw_index_def_v_8_type.ts
var raw_index_def_v_8_type_default = t.object("RawIndexDefV8", {
  indexName: t.string(),
  isUnique: t.bool(),
  get indexType() {
    return index_type_type_default;
  },
  columns: t.array(t.u16())
});

// src/lib/autogen/raw_constraint_def_v_8_type.ts
var raw_constraint_def_v_8_type_default = t.object("RawConstraintDefV8", {
  constraintName: t.string(),
  constraints: t.u8(),
  columns: t.array(t.u16())
});

// src/lib/autogen/raw_sequence_def_v_8_type.ts
var raw_sequence_def_v_8_type_default = t.object("RawSequenceDefV8", {
  sequenceName: t.string(),
  colPos: t.u16(),
  increment: t.i128(),
  start: t.option(t.i128()),
  minValue: t.option(t.i128()),
  maxValue: t.option(t.i128()),
  allocated: t.i128()
});

// src/lib/autogen/raw_table_def_v_8_type.ts
var raw_table_def_v_8_type_default = t.object("RawTableDefV8", {
  tableName: t.string(),
  get columns() {
    return t.array(raw_column_def_v_8_type_default);
  },
  get indexes() {
    return t.array(raw_index_def_v_8_type_default);
  },
  get constraints() {
    return t.array(raw_constraint_def_v_8_type_default);
  },
  get sequences() {
    return t.array(raw_sequence_def_v_8_type_default);
  },
  tableType: t.string(),
  tableAccess: t.string(),
  scheduled: t.option(t.string())
});

// src/lib/autogen/table_desc_type.ts
var table_desc_type_default = t.object("TableDesc", {
  get schema() {
    return raw_table_def_v_8_type_default;
  },
  data: t.u32()
});

// src/lib/autogen/reducer_def_type.ts
var reducer_def_type_default = t.object("ReducerDef", {
  name: t.string(),
  get args() {
    return t.array(product_type_element_type_default);
  }
});

// src/lib/autogen/type_alias_type.ts
var type_alias_type_default = t.object("TypeAlias", {
  name: t.string(),
  ty: t.u32()
});

// src/lib/autogen/misc_module_export_type.ts
var MiscModuleExport = t.enum("MiscModuleExport", {
  get TypeAlias() {
    return type_alias_type_default;
  }
});
var misc_module_export_type_default = MiscModuleExport;

// src/lib/autogen/raw_module_def_v_8_type.ts
var raw_module_def_v_8_type_default = t.object("RawModuleDefV8", {
  get typespace() {
    return typespace_type_default;
  },
  get tables() {
    return t.array(table_desc_type_default);
  },
  get reducers() {
    return t.array(reducer_def_type_default);
  },
  get miscExports() {
    return t.array(misc_module_export_type_default);
  }
});

// src/lib/autogen/raw_index_def_v_9_type.ts
var raw_index_def_v_9_type_default = t.object("RawIndexDefV9", {
  name: t.option(t.string()),
  accessorName: t.option(t.string()),
  get algorithm() {
    return raw_index_algorithm_type_default;
  }
});

// src/lib/autogen/raw_unique_constraint_data_v_9_type.ts
var raw_unique_constraint_data_v_9_type_default = t.object("RawUniqueConstraintDataV9", {
  columns: t.array(t.u16())
});

// src/lib/autogen/raw_constraint_data_v_9_type.ts
var RawConstraintDataV9 = t.enum("RawConstraintDataV9", {
  get Unique() {
    return raw_unique_constraint_data_v_9_type_default;
  }
});
var raw_constraint_data_v_9_type_default = RawConstraintDataV9;

// src/lib/autogen/raw_constraint_def_v_9_type.ts
var raw_constraint_def_v_9_type_default = t.object("RawConstraintDefV9", {
  name: t.option(t.string()),
  get data() {
    return raw_constraint_data_v_9_type_default;
  }
});

// src/lib/autogen/raw_sequence_def_v_9_type.ts
var raw_sequence_def_v_9_type_default = t.object("RawSequenceDefV9", {
  name: t.option(t.string()),
  column: t.u16(),
  start: t.option(t.i128()),
  minValue: t.option(t.i128()),
  maxValue: t.option(t.i128()),
  increment: t.i128()
});

// src/lib/autogen/raw_schedule_def_v_9_type.ts
var raw_schedule_def_v_9_type_default = t.object("RawScheduleDefV9", {
  name: t.option(t.string()),
  reducerName: t.string(),
  scheduledAtColumn: t.u16()
});

// src/lib/autogen/table_type_type.ts
var TableType = t.enum("TableType", {
  System: t.unit(),
  User: t.unit()
});
var table_type_type_default = TableType;

// src/lib/autogen/table_access_type.ts
var TableAccess = t.enum("TableAccess", {
  Public: t.unit(),
  Private: t.unit()
});
var table_access_type_default = TableAccess;

// src/lib/autogen/raw_table_def_v_9_type.ts
var raw_table_def_v_9_type_default = t.object("RawTableDefV9", {
  name: t.string(),
  productTypeRef: t.u32(),
  primaryKey: t.array(t.u16()),
  get indexes() {
    return t.array(raw_index_def_v_9_type_default);
  },
  get constraints() {
    return t.array(raw_constraint_def_v_9_type_default);
  },
  get sequences() {
    return t.array(raw_sequence_def_v_9_type_default);
  },
  get schedule() {
    return t.option(raw_schedule_def_v_9_type_default);
  },
  get tableType() {
    return table_type_type_default;
  },
  get tableAccess() {
    return table_access_type_default;
  }
});

// src/lib/autogen/raw_reducer_def_v_9_type.ts
var raw_reducer_def_v_9_type_default = t.object("RawReducerDefV9", {
  name: t.string(),
  get params() {
    return product_type_type_default;
  },
  get lifecycle() {
    return t.option(lifecycle_type_default);
  }
});

// src/lib/autogen/raw_scoped_type_name_v_9_type.ts
var raw_scoped_type_name_v_9_type_default = t.object("RawScopedTypeNameV9", {
  scope: t.array(t.string()),
  name: t.string()
});

// src/lib/autogen/raw_type_def_v_9_type.ts
var raw_type_def_v_9_type_default = t.object("RawTypeDefV9", {
  get name() {
    return raw_scoped_type_name_v_9_type_default;
  },
  ty: t.u32(),
  customOrdering: t.bool()
});

// src/lib/autogen/raw_column_default_value_v_9_type.ts
var raw_column_default_value_v_9_type_default = t.object("RawColumnDefaultValueV9", {
  table: t.string(),
  colId: t.u16(),
  value: t.byteArray()
});

// src/lib/autogen/raw_procedure_def_v_9_type.ts
var raw_procedure_def_v_9_type_default = t.object("RawProcedureDefV9", {
  name: t.string(),
  get params() {
    return product_type_type_default;
  },
  get returnType() {
    return algebraic_type_type_default;
  }
});

// src/lib/autogen/raw_view_def_v_9_type.ts
var raw_view_def_v_9_type_default = t.object("RawViewDefV9", {
  name: t.string(),
  index: t.u32(),
  isPublic: t.bool(),
  isAnonymous: t.bool(),
  get params() {
    return product_type_type_default;
  },
  get returnType() {
    return algebraic_type_type_default;
  }
});

// src/lib/autogen/raw_misc_module_export_v_9_type.ts
var RawMiscModuleExportV9 = t.enum("RawMiscModuleExportV9", {
  get ColumnDefaultValue() {
    return raw_column_default_value_v_9_type_default;
  },
  get Procedure() {
    return raw_procedure_def_v_9_type_default;
  },
  get View() {
    return raw_view_def_v_9_type_default;
  }
});
var raw_misc_module_export_v_9_type_default = RawMiscModuleExportV9;

// src/lib/autogen/raw_row_level_security_def_v_9_type.ts
var raw_row_level_security_def_v_9_type_default = t.object("RawRowLevelSecurityDefV9", {
  sql: t.string()
});

// src/lib/autogen/raw_module_def_v_9_type.ts
var raw_module_def_v_9_type_default = t.object("RawModuleDefV9", {
  get typespace() {
    return typespace_type_default;
  },
  get tables() {
    return t.array(raw_table_def_v_9_type_default);
  },
  get reducers() {
    return t.array(raw_reducer_def_v_9_type_default);
  },
  get types() {
    return t.array(raw_type_def_v_9_type_default);
  },
  get miscExports() {
    return t.array(raw_misc_module_export_v_9_type_default);
  },
  get rowLevelSecurity() {
    return t.array(raw_row_level_security_def_v_9_type_default);
  }
});

// src/lib/autogen/raw_module_def_type.ts
var RawModuleDef = t.enum("RawModuleDef", {
  get V8BackCompat() {
    return raw_module_def_v_8_type_default;
  },
  get V9() {
    return raw_module_def_v_9_type_default;
  }
});
var raw_module_def_type_default = RawModuleDef;

// src/server/range.ts
var Range = class {
  #from;
  #to;
  constructor(from, to) {
    this.#from = from ?? { tag: "unbounded" };
    this.#to = to ?? { tag: "unbounded" };
  }
  get from() {
    return this.#from;
  }
  get to() {
    return this.#to;
  }
};

// src/server/http_internal.ts
var import_statuses = __toESM(require_statuses());

// src/lib/autogen/http_header_pair_type.ts
var http_header_pair_type_default = t.object("HttpHeaderPair", {
  name: t.string(),
  value: t.byteArray()
});

// src/lib/autogen/http_headers_type.ts
var http_headers_type_default = t.object("HttpHeaders", {
  get entries() {
    return t.array(http_header_pair_type_default);
  }
});

// src/lib/autogen/http_method_type.ts
var HttpMethod = t.enum("HttpMethod", {
  Get: t.unit(),
  Head: t.unit(),
  Post: t.unit(),
  Put: t.unit(),
  Delete: t.unit(),
  Connect: t.unit(),
  Options: t.unit(),
  Trace: t.unit(),
  Patch: t.unit(),
  Extension: t.string()
});
var http_method_type_default = HttpMethod;

// src/lib/autogen/http_version_type.ts
var HttpVersion = t.enum("HttpVersion", {
  Http09: t.unit(),
  Http10: t.unit(),
  Http11: t.unit(),
  Http2: t.unit(),
  Http3: t.unit()
});
var http_version_type_default = HttpVersion;

// src/lib/autogen/http_request_type.ts
var http_request_type_default = t.object("HttpRequest", {
  get method() {
    return http_method_type_default;
  },
  get headers() {
    return http_headers_type_default;
  },
  timeout: t.option(t.timeDuration()),
  uri: t.string(),
  get version() {
    return http_version_type_default;
  }
});

// src/lib/autogen/http_response_type.ts
var http_response_type_default = t.object("HttpResponse", {
  get headers() {
    return http_headers_type_default;
  },
  get version() {
    return http_version_type_default;
  },
  code: t.u16()
});

// src/server/http_internal.ts
var { freeze } = Object;
var textEncoder = new TextEncoder();
var textDecoder = new TextDecoder(
  "utf-8"
  /* { fatal: true } */
);
var makeResponse = Symbol("makeResponse");
var SyncResponse = class _SyncResponse {
  #body;
  #inner;
  constructor(body, init2) {
    if (body == null) {
      this.#body = null;
    } else if (typeof body === "string") {
      this.#body = body;
    } else {
      this.#body = new Uint8Array(body).buffer;
    }
    this.#inner = {
      headers: new headersPolyfill.Headers(init2?.headers),
      status: init2?.status ?? 200,
      statusText: init2?.statusText ?? "",
      type: "default",
      url: null,
      aborted: false
    };
  }
  static [makeResponse](body, inner) {
    const me = new _SyncResponse(body);
    me.#inner = inner;
    return me;
  }
  get headers() {
    return this.#inner.headers;
  }
  get status() {
    return this.#inner.status;
  }
  get statusText() {
    return this.#inner.statusText;
  }
  get ok() {
    return 200 <= this.#inner.status && this.#inner.status <= 299;
  }
  get url() {
    return this.#inner.url ?? "";
  }
  get type() {
    return this.#inner.type;
  }
  arrayBuffer() {
    return this.bytes().buffer;
  }
  bytes() {
    if (this.#body == null) {
      return new Uint8Array();
    } else if (typeof this.#body === "string") {
      return textEncoder.encode(this.#body);
    } else {
      return new Uint8Array(this.#body);
    }
  }
  json() {
    return JSON.parse(this.text());
  }
  text() {
    if (this.#body == null) {
      return "";
    } else if (typeof this.#body === "string") {
      return this.#body;
    } else {
      return textDecoder.decode(this.#body);
    }
  }
};
var requestBaseSize = bsatnBaseSize({ types: [] }, http_request_type_default.algebraicType);
var methods = /* @__PURE__ */ new Map([
  ["GET", { tag: "Get" }],
  ["HEAD", { tag: "Head" }],
  ["POST", { tag: "Post" }],
  ["PUT", { tag: "Put" }],
  ["DELETE", { tag: "Delete" }],
  ["CONNECT", { tag: "Connect" }],
  ["OPTIONS", { tag: "Options" }],
  ["TRACE", { tag: "Trace" }],
  ["PATCH", { tag: "Patch" }]
]);
function fetch(url, init2 = {}) {
  const method = methods.get(init2.method?.toUpperCase() ?? "GET") ?? {
    tag: "Extension",
    value: init2.method
  };
  const headers = {
    // anys because the typings are wonky - see comment in SyncResponse.constructor
    entries: headersPolyfill.headersToList(new headersPolyfill.Headers(init2.headers)).flatMap(([k, v]) => Array.isArray(v) ? v.map((v2) => [k, v2]) : [[k, v]]).map(([name, value]) => ({ name, value: textEncoder.encode(value) }))
  };
  const uri = "" + url;
  const request = freeze({
    method,
    headers,
    timeout: init2.timeout,
    uri,
    version: { tag: "Http11" }
  });
  const requestBuf = new BinaryWriter(requestBaseSize);
  http_request_type_default.serialize(requestBuf, request);
  const body = init2.body == null ? new Uint8Array() : typeof init2.body === "string" ? init2.body : new Uint8Array(init2.body);
  const [responseBuf, responseBody] = sys.procedure_http_request(
    requestBuf.getBuffer(),
    body
  );
  const response = http_response_type_default.deserialize(new BinaryReader(responseBuf));
  return SyncResponse[makeResponse](responseBody, {
    type: "basic",
    url: uri,
    status: response.code,
    statusText: (0, import_statuses.default)(response.code),
    headers: new headersPolyfill.Headers(),
    aborted: false
  });
}
freeze(fetch);
var httpClient = freeze({ fetch });

// src/server/procedures.ts
var { freeze: freeze2 } = Object;
function callProcedure(id, sender, connectionId, timestamp, argsBuf) {
  const { fn, paramsType, returnType, returnTypeBaseSize } = PROCEDURES[id];
  const args = ProductType.deserializeValue(
    new BinaryReader(argsBuf),
    paramsType,
    MODULE_DEF.typespace
  );
  const ctx = {
    sender,
    timestamp,
    connectionId,
    http: httpClient,
    // **Note:** must be 0..=u32::MAX
    counter_uuid: { value: Number(0) },
    get identity() {
      return new Identity(sys.identity().__identity__);
    },
    withTx(body) {
      const run = () => {
        const timestamp2 = sys.procedure_start_mut_tx();
        try {
          const ctx2 = new ReducerCtxImpl(
            sender,
            new Timestamp(timestamp2),
            connectionId
          );
          return body(ctx2);
        } catch (e) {
          sys.procedure_abort_mut_tx();
          throw e;
        }
      };
      let res = run();
      try {
        sys.procedure_commit_mut_tx();
        return res;
      } catch {
      }
      console.warn("committing anonymous transaction failed");
      res = run();
      try {
        sys.procedure_commit_mut_tx();
        return res;
      } catch (e) {
        throw new Error("transaction retry failed again", { cause: e });
      }
    },
    /**
     * Create a new random {@link Uuid} `v4` using the {@link crypto} RNG.
     *
     * WARN: Until we use a spacetime RNG this make calls non-deterministic.
     */
    newUuidV4() {
      const bytes = crypto.getRandomValues(new Uint8Array(16));
      return Uuid.fromRandomBytesV4(bytes);
    },
    /**
     * Create a new sortable {@link Uuid} `v7` using the {@link crypto} RNG, counter,
     * and the timestamp.
     *
     * WARN: Until we use a spacetime RNG this make calls non-deterministic.
     */
    newUuidV7() {
      const bytes = crypto.getRandomValues(new Uint8Array(10));
      return Uuid.fromCounterV7(this.counter_uuid, this.timestamp, bytes);
    }
  };
  freeze2(ctx);
  const ret = callUserFunction(fn, ctx, args);
  const retBuf = new BinaryWriter(returnTypeBaseSize);
  AlgebraicType.serializeValue(retBuf, returnType, ret, MODULE_DEF.typespace);
  return retBuf.getBuffer();
}

// src/lib/autogen/view_result_header_type.ts
var ViewResultHeader = t.enum("ViewResultHeader", {
  RowData: t.unit(),
  RawSql: t.string()
});
var view_result_header_type_default = ViewResultHeader;

// src/server/runtime.ts
var { freeze: freeze3 } = Object;
var sys = freeze3(wrapSyscalls(_syscalls1_0__namespace, _syscalls1_2__namespace));
function parseJsonObject(json) {
  let value;
  try {
    value = JSON.parse(json);
  } catch {
    throw new Error("Invalid JSON: failed to parse string");
  }
  if (value === null || typeof value !== "object" || Array.isArray(value)) {
    throw new Error("Expected a JSON object at the top level");
  }
  return value;
}
var JwtClaimsImpl = class {
  /**
   * Creates a new JwtClaims instance.
   * @param rawPayload The JWT payload as a raw JSON string.
   * @param identity The identity for this JWT. We are only taking this because we don't have a blake3 implementation (which we need to compute it).
   */
  constructor(rawPayload, identity) {
    this.rawPayload = rawPayload;
    this.fullPayload = parseJsonObject(rawPayload);
    this._identity = identity;
  }
  fullPayload;
  _identity;
  get identity() {
    return this._identity;
  }
  get subject() {
    return this.fullPayload["sub"];
  }
  get issuer() {
    return this.fullPayload["iss"];
  }
  get audience() {
    const aud = this.fullPayload["aud"];
    if (aud == null) {
      return [];
    }
    return typeof aud === "string" ? [aud] : aud;
  }
};
var AuthCtxImpl = class _AuthCtxImpl {
  isInternal;
  // Source of the JWT payload string, if there is one.
  _jwtSource;
  // Whether we have initialized the JWT claims.
  _initializedJWT = false;
  _jwtClaims;
  _senderIdentity;
  constructor(opts) {
    this.isInternal = opts.isInternal;
    this._jwtSource = opts.jwtSource;
    this._senderIdentity = opts.senderIdentity;
  }
  _initializeJWT() {
    if (this._initializedJWT) return;
    this._initializedJWT = true;
    const token = this._jwtSource();
    if (!token) {
      this._jwtClaims = null;
    } else {
      this._jwtClaims = new JwtClaimsImpl(token, this._senderIdentity);
    }
    Object.freeze(this);
  }
  /** Lazily compute whether a JWT exists and is parseable. */
  get hasJWT() {
    this._initializeJWT();
    return this._jwtClaims !== null;
  }
  /** Lazily parse the JwtClaims only when accessed. */
  get jwt() {
    this._initializeJWT();
    return this._jwtClaims;
  }
  /** Create a context representing internal (non-user) requests. */
  static internal() {
    return new _AuthCtxImpl({
      isInternal: true,
      jwtSource: () => null,
      senderIdentity: Identity.zero()
    });
  }
  /** If there is a connection id, look up the JWT payload from the system tables. */
  static fromSystemTables(connectionId, sender) {
    if (connectionId === null) {
      return new _AuthCtxImpl({
        isInternal: false,
        jwtSource: () => null,
        senderIdentity: sender
      });
    }
    return new _AuthCtxImpl({
      isInternal: false,
      jwtSource: () => {
        const payloadBuf = sys.get_jwt_payload(connectionId.__connection_id__);
        if (payloadBuf.length === 0) return null;
        const payloadStr = new TextDecoder().decode(payloadBuf);
        return payloadStr;
      },
      senderIdentity: sender
    });
  }
};
var ReducerCtxImpl = class ReducerCtx {
  #identity;
  #senderAuth;
  #uuidCounter;
  sender;
  timestamp;
  connectionId;
  db;
  constructor(sender, timestamp, connectionId) {
    Object.seal(this);
    this.sender = sender;
    this.timestamp = timestamp;
    this.connectionId = connectionId;
    this.db = getDbView();
  }
  get identity() {
    return this.#identity ??= new Identity(sys.identity().__identity__);
  }
  get senderAuth() {
    return this.#senderAuth ??= AuthCtxImpl.fromSystemTables(
      this.connectionId,
      this.sender
    );
  }
  /**
   * Create a new random {@link Uuid} `v4` using the {@link crypto} RNG.
   *
   * WARN: Until we use a spacetime RNG this make calls non-deterministic.
   */
  newUuidV4() {
    const bytes = crypto.getRandomValues(new Uint8Array(16));
    return Uuid.fromRandomBytesV4(bytes);
  }
  /**
   * Create a new sortable {@link Uuid} `v7` using the {@link crypto} RNG, counter,
   * and the timestamp.
   *
   * WARN: Until we use a spacetime RNG this make calls non-deterministic.
   */
  newUuidV7() {
    const bytes = crypto.getRandomValues(new Uint8Array(4));
    const counter = this.#uuidCounter ??= { value: 0 };
    return Uuid.fromCounterV7(counter, this.timestamp, bytes);
  }
};
var callUserFunction = function __spacetimedb_end_short_backtrace(fn, ...args) {
  return fn(...args);
};
var hooks = {
  __describe_module__() {
    const writer = new BinaryWriter(128);
    AlgebraicType.serializeValue(
      writer,
      raw_module_def_type_default.algebraicType,
      raw_module_def_type_default.V9(MODULE_DEF)
    );
    return writer.getBuffer();
  },
  __call_reducer__(reducerId, sender, connId, timestamp, argsBuf) {
    const argsType = AlgebraicType.Product(
      MODULE_DEF.reducers[reducerId].params
    );
    const args = AlgebraicType.deserializeValue(
      new BinaryReader(argsBuf),
      argsType,
      MODULE_DEF.typespace
    );
    const senderIdentity = new Identity(sender);
    const ctx = new ReducerCtxImpl(
      senderIdentity,
      new Timestamp(timestamp),
      ConnectionId.nullIfZero(new ConnectionId(connId))
    );
    try {
      return callUserFunction(REDUCERS[reducerId], ctx, args) ?? { tag: "ok" };
    } catch (e) {
      if (e instanceof SenderError) {
        return { tag: "err", value: e.message };
      }
      throw e;
    }
  }
};
var hooks_v1_1 = {
  __call_view__(id, sender, argsBuf) {
    const { fn, params, returnType, returnTypeBaseSize } = VIEWS[id];
    const ctx = freeze3({
      sender: new Identity(sender),
      // this is the non-readonly DbView, but the typing for the user will be
      // the readonly one, and if they do call mutating functions it will fail
      // at runtime
      db: getDbView(),
      from: makeQueryBuilder(getRegisteredSchema())
    });
    const args = ProductType.deserializeValue(
      new BinaryReader(argsBuf),
      params,
      MODULE_DEF.typespace
    );
    const ret = callUserFunction(fn, ctx, args);
    const retBuf = new BinaryWriter(returnTypeBaseSize);
    if (isRowTypedQuery(ret)) {
      const query = toSql(ret);
      const v = view_result_header_type_default.RawSql(query);
      AlgebraicType.serializeValue(
        retBuf,
        view_result_header_type_default.algebraicType,
        v,
        MODULE_DEF.typespace
      );
      return {
        data: retBuf.getBuffer()
      };
    } else {
      AlgebraicType.serializeValue(
        retBuf,
        view_result_header_type_default.algebraicType,
        view_result_header_type_default.RowData,
        MODULE_DEF.typespace
      );
      AlgebraicType.serializeValue(
        retBuf,
        returnType,
        ret,
        MODULE_DEF.typespace
      );
      return {
        data: retBuf.getBuffer()
      };
    }
  },
  __call_view_anon__(id, argsBuf) {
    const { fn, params, returnType, returnTypeBaseSize } = ANON_VIEWS[id];
    const ctx = freeze3({
      // this is the non-readonly DbView, but the typing for the user will be
      // the readonly one, and if they do call mutating functions it will fail
      // at runtime
      db: getDbView(),
      from: makeQueryBuilder(getRegisteredSchema())
    });
    const args = ProductType.deserializeValue(
      new BinaryReader(argsBuf),
      params,
      MODULE_DEF.typespace
    );
    const ret = callUserFunction(fn, ctx, args);
    const retBuf = new BinaryWriter(returnTypeBaseSize);
    if (isRowTypedQuery(ret)) {
      const query = toSql(ret);
      const v = view_result_header_type_default.RawSql(query);
      AlgebraicType.serializeValue(
        retBuf,
        view_result_header_type_default.algebraicType,
        v,
        MODULE_DEF.typespace
      );
      return {
        data: retBuf.getBuffer()
      };
    } else {
      AlgebraicType.serializeValue(
        retBuf,
        view_result_header_type_default.algebraicType,
        view_result_header_type_default.RowData,
        MODULE_DEF.typespace
      );
      AlgebraicType.serializeValue(
        retBuf,
        returnType,
        ret,
        MODULE_DEF.typespace
      );
      return {
        data: retBuf.getBuffer()
      };
    }
  }
};
var hooks_v1_2 = {
  __call_procedure__(id, sender, connection_id, timestamp, args) {
    return callProcedure(
      id,
      new Identity(sender),
      ConnectionId.nullIfZero(new ConnectionId(connection_id)),
      new Timestamp(timestamp),
      args
    );
  }
};
var DB_VIEW = null;
function getDbView() {
  DB_VIEW ??= makeDbView(MODULE_DEF);
  return DB_VIEW;
}
function makeDbView(moduleDef) {
  return freeze3(
    Object.fromEntries(
      moduleDef.tables.map((table2) => [
        toCamelCase(table2.name),
        makeTableView(moduleDef.typespace, table2)
      ])
    )
  );
}
function makeTableView(typespace, table2) {
  const table_id = sys.table_id_from_name(table2.name);
  const rowType = typespace.types[table2.productTypeRef];
  if (rowType.tag !== "Product") {
    throw "impossible";
  }
  const baseSize = bsatnBaseSize(typespace, rowType);
  const sequences = table2.sequences.map((seq) => {
    const col = rowType.value.elements[seq.column];
    const colType = col.algebraicType;
    let sequenceTrigger;
    switch (colType.tag) {
      case "U8":
      case "I8":
      case "U16":
      case "I16":
      case "U32":
      case "I32":
        sequenceTrigger = 0;
        break;
      case "U64":
      case "I64":
      case "U128":
      case "I128":
      case "U256":
      case "I256":
        sequenceTrigger = 0n;
        break;
      default:
        throw new TypeError("invalid sequence type");
    }
    return {
      colName: col.name,
      sequenceTrigger,
      read: (reader) => AlgebraicType.deserializeValue(reader, colType, typespace)
    };
  });
  const hasAutoIncrement = sequences.length > 0;
  const iter = () => tableIterator(sys.datastore_table_scan_bsatn(table_id), rowType);
  const integrateGeneratedColumns = hasAutoIncrement ? (row, ret_buf) => {
    const reader = new BinaryReader(ret_buf);
    for (const { colName, read, sequenceTrigger } of sequences) {
      if (row[colName] === sequenceTrigger) {
        row[colName] = read(reader);
      }
    }
  } : null;
  const tableMethods = {
    count: () => sys.datastore_table_row_count(table_id),
    iter,
    [Symbol.iterator]: () => iter(),
    insert: (row) => {
      const writer = new BinaryWriter(baseSize);
      AlgebraicType.serializeValue(writer, rowType, row, typespace);
      const ret_buf = sys.datastore_insert_bsatn(table_id, writer.getBuffer());
      const ret = { ...row };
      integrateGeneratedColumns?.(ret, ret_buf);
      return ret;
    },
    delete: (row) => {
      const writer = new BinaryWriter(4 + baseSize);
      writer.writeU32(1);
      AlgebraicType.serializeValue(writer, rowType, row, typespace);
      const count = sys.datastore_delete_all_by_eq_bsatn(
        table_id,
        writer.getBuffer()
      );
      return count > 0;
    }
  };
  const tableView = Object.assign(
    /* @__PURE__ */ Object.create(null),
    tableMethods
  );
  for (const indexDef of table2.indexes) {
    const index_id = sys.index_id_from_name(indexDef.name);
    let column_ids;
    switch (indexDef.algorithm.tag) {
      case "BTree":
        column_ids = indexDef.algorithm.value;
        break;
      case "Hash":
        throw new Error("impossible");
      case "Direct":
        column_ids = [indexDef.algorithm.value];
        break;
    }
    const numColumns = column_ids.length;
    const columnSet = new Set(column_ids);
    const isUnique = table2.constraints.filter((x) => x.data.tag === "Unique").some((x) => columnSet.isSubsetOf(new Set(x.data.value.columns)));
    const indexType = AlgebraicType.Product({
      elements: column_ids.map((id) => rowType.value.elements[id])
    });
    const baseSize2 = bsatnBaseSize(typespace, indexType);
    const serializePrefix = (writer, prefix, prefix_elems) => {
      if (prefix_elems > numColumns - 1)
        throw new TypeError("too many elements in prefix");
      for (let i = 0; i < prefix_elems; i++) {
        const elemType = indexType.value.elements[i].algebraicType;
        AlgebraicType.serializeValue(writer, elemType, prefix[i], typespace);
      }
      return writer;
    };
    let index;
    if (isUnique) {
      const serializeBound = (colVal) => {
        if (colVal.length !== numColumns)
          throw new TypeError("wrong number of elements");
        const writer = new BinaryWriter(baseSize2 + 1);
        const prefix_elems = numColumns - 1;
        serializePrefix(writer, colVal, prefix_elems);
        const rstartOffset = writer.offset;
        writer.writeU8(0);
        AlgebraicType.serializeValue(
          writer,
          indexType.value.elements[numColumns - 1].algebraicType,
          colVal[numColumns - 1],
          typespace
        );
        const buffer = writer.getBuffer();
        const prefix = buffer.slice(0, rstartOffset);
        const rstart = buffer.slice(rstartOffset);
        return [prefix, prefix_elems, rstart, rstart];
      };
      index = {
        find: (colVal) => {
          if (numColumns === 1) colVal = [colVal];
          const args = serializeBound(colVal);
          const iter2 = tableIterator(
            sys.datastore_index_scan_range_bsatn(index_id, ...args),
            rowType
          );
          const { value, done } = iter2.next();
          if (done) return null;
          if (!iter2.next().done)
            throw new Error(
              "`datastore_index_scan_range_bsatn` on unique field cannot return >1 rows"
            );
          return value;
        },
        delete: (colVal) => {
          if (numColumns === 1) colVal = [colVal];
          const args = serializeBound(colVal);
          const num = sys.datastore_delete_by_index_scan_range_bsatn(
            index_id,
            ...args
          );
          return num > 0;
        },
        update: (row) => {
          const writer = new BinaryWriter(baseSize2);
          AlgebraicType.serializeValue(writer, rowType, row, typespace);
          const ret_buf = sys.datastore_update_bsatn(
            table_id,
            index_id,
            writer.getBuffer()
          );
          integrateGeneratedColumns?.(row, ret_buf);
          return row;
        }
      };
    } else {
      const serializeRange = (range) => {
        if (range.length > numColumns) throw new TypeError("too many elements");
        const writer = new BinaryWriter(baseSize2 + 1);
        const prefix_elems = range.length - 1;
        serializePrefix(writer, range, prefix_elems);
        const rstartOffset = writer.offset;
        const term = range[range.length - 1];
        const termType = indexType.value.elements[range.length - 1].algebraicType;
        let rstart, rend;
        if (term instanceof Range) {
          const writeBound = (bound) => {
            const tags = { included: 0, excluded: 1, unbounded: 2 };
            writer.writeU8(tags[bound.tag]);
            if (bound.tag !== "unbounded")
              AlgebraicType.serializeValue(
                writer,
                termType,
                bound.value,
                typespace
              );
          };
          writeBound(term.from);
          const rendOffset = writer.offset;
          writeBound(term.to);
          rstart = writer.getBuffer().slice(rstartOffset, rendOffset);
          rend = writer.getBuffer().slice(rendOffset);
        } else {
          writer.writeU8(0);
          AlgebraicType.serializeValue(writer, termType, term, typespace);
          rstart = rend = writer.getBuffer().slice(rstartOffset);
        }
        const buffer = writer.getBuffer();
        const prefix = buffer.slice(0, rstartOffset);
        return [prefix, prefix_elems, rstart, rend];
      };
      index = {
        filter: (range) => {
          if (numColumns === 1) range = [range];
          const args = serializeRange(range);
          return tableIterator(
            sys.datastore_index_scan_range_bsatn(index_id, ...args),
            rowType
          );
        },
        delete: (range) => {
          if (numColumns === 1) range = [range];
          const args = serializeRange(range);
          return sys.datastore_delete_by_index_scan_range_bsatn(
            index_id,
            ...args
          );
        }
      };
    }
    if (Object.hasOwn(tableView, indexDef.accessorName)) {
      freeze3(Object.assign(tableView[indexDef.accessorName], index));
    } else {
      tableView[indexDef.accessorName] = freeze3(index);
    }
  }
  return freeze3(tableView);
}
function hasOwn(o, k) {
  return Object.hasOwn(o, k);
}
function* tableIterator(id, ty) {
  var _stack = [];
  try {
    const iter = __using(_stack, new IteratorHandle(id));
    const { typespace } = MODULE_DEF;
    let buf;
    while ((buf = advanceIter(iter)) != null) {
      const reader = new BinaryReader(buf);
      while (reader.remaining > 0) {
        yield AlgebraicType.deserializeValue(reader, ty, typespace);
      }
    }
  } catch (_) {
    var _error = _, _hasError = true;
  } finally {
    __callDispose(_stack, _error, _hasError);
  }
}
function advanceIter(iter) {
  let buf_max_len = 65536;
  while (true) {
    try {
      return iter.advance(buf_max_len);
    } catch (e) {
      if (e && typeof e === "object" && hasOwn(e, "__buffer_too_small__")) {
        buf_max_len = e.__buffer_too_small__;
        continue;
      }
      throw e;
    }
  }
}
var IteratorHandle = class _IteratorHandle {
  #id;
  static #finalizationRegistry = new FinalizationRegistry(
    sys.row_iter_bsatn_close
  );
  constructor(id) {
    this.#id = id;
    _IteratorHandle.#finalizationRegistry.register(this, id, this);
  }
  /** Unregister this object with the finalization registry and return the id */
  #detach() {
    const id = this.#id;
    this.#id = -1;
    _IteratorHandle.#finalizationRegistry.unregister(this);
    return id;
  }
  /** Call `row_iter_bsatn_advance`, returning null if this iterator was already exhausted. */
  advance(buf_max_len) {
    if (this.#id === -1) return null;
    const { 0: done, 1: buf } = sys.row_iter_bsatn_advance(
      this.#id,
      buf_max_len
    );
    if (done) this.#detach();
    return buf;
  }
  [Symbol.dispose]() {
    if (this.#id >= 0) {
      const id = this.#detach();
      sys.row_iter_bsatn_close(id);
    }
  }
};
function wrapSyscalls(...modules) {
  return Object.fromEntries(
    modules.flatMap(Object.entries).map(([k, v]) => [k, wrapSyscall(v)])
  );
}
function wrapSyscall(func) {
  const name = func.name;
  return {
    [name](...args) {
      try {
        return func(...args);
      } catch (e) {
        if (e !== null && typeof e === "object" && hasOwn(e, "__code_error__") && typeof e.__code_error__ == "number") {
          const message = hasOwn(e, "__error_message__") && typeof e.__error_message__ === "string" ? e.__error_message__ : void 0;
          throw new SpacetimeHostError(e.__code_error__, message);
        }
        throw e;
      }
    }
  }[name];
}
function fmtLog(...data) {
  return data.join(" ");
}
var console_level_error = 0;
var console_level_warn = 1;
var console_level_info = 2;
var console_level_debug = 3;
var console_level_trace = 4;
var timerMap = /* @__PURE__ */ new Map();
var console2 = {
  // @ts-expect-error we want a blank prototype, but typescript complains
  __proto__: {},
  [Symbol.toStringTag]: "console",
  assert: (condition = false, ...data) => {
    if (!condition) {
      sys.console_log(console_level_error, fmtLog(...data));
    }
  },
  clear: () => {
  },
  debug: (...data) => {
    sys.console_log(console_level_debug, fmtLog(...data));
  },
  error: (...data) => {
    sys.console_log(console_level_error, fmtLog(...data));
  },
  info: (...data) => {
    sys.console_log(console_level_info, fmtLog(...data));
  },
  log: (...data) => {
    sys.console_log(console_level_info, fmtLog(...data));
  },
  table: (tabularData, _properties) => {
    sys.console_log(console_level_info, fmtLog(tabularData));
  },
  trace: (...data) => {
    sys.console_log(console_level_trace, fmtLog(...data));
  },
  warn: (...data) => {
    sys.console_log(console_level_warn, fmtLog(...data));
  },
  dir: (_item, _options) => {
  },
  dirxml: (..._data) => {
  },
  // Counting
  count: (_label = "default") => {
  },
  countReset: (_label = "default") => {
  },
  // Grouping
  group: (..._data) => {
  },
  groupCollapsed: (..._data) => {
  },
  groupEnd: () => {
  },
  // Timing
  time: (label = "default") => {
    if (timerMap.has(label)) {
      sys.console_log(console_level_warn, `Timer '${label}' already exists.`);
      return;
    }
    timerMap.set(label, sys.console_timer_start(label));
  },
  timeLog: (label = "default", ...data) => {
    sys.console_log(console_level_info, fmtLog(label, ...data));
  },
  timeEnd: (label = "default") => {
    const spanId = timerMap.get(label);
    if (spanId === void 0) {
      sys.console_log(console_level_warn, `Timer '${label}' does not exist.`);
      return;
    }
    sys.console_timer_end(spanId);
    timerMap.delete(label);
  },
  // Additional console methods to satisfy the Console interface
  timeStamp: () => {
  },
  profile: () => {
  },
  profileEnd: () => {
  }
};
console2.Console = console2;
globalThis.console = console2;

// src/server/register_hooks.ts
_syscalls1_0.register_hooks(hooks);
spacetime_sys_1_1.register_hooks(hooks_v1_1);
_syscalls1_2.register_hooks(hooks_v1_2);
/*! Bundled license information:

statuses/index.js:
  (*!
   * statuses
   * Copyright(c) 2014 Jonathan Ong
   * Copyright(c) 2016 Douglas Christopher Wilson
   * MIT Licensed
   *)
*/

exports.ArrayBuilder = ArrayBuilder;
exports.ArrayColumnBuilder = ArrayColumnBuilder;
exports.BoolBuilder = BoolBuilder;
exports.BoolColumnBuilder = BoolColumnBuilder;
exports.ByteArrayBuilder = ByteArrayBuilder;
exports.ByteArrayColumnBuilder = ByteArrayColumnBuilder;
exports.ColumnBuilder = ColumnBuilder;
exports.ConnectionIdBuilder = ConnectionIdBuilder;
exports.ConnectionIdColumnBuilder = ConnectionIdColumnBuilder;
exports.F32Builder = F32Builder;
exports.F32ColumnBuilder = F32ColumnBuilder;
exports.F64Builder = F64Builder;
exports.F64ColumnBuilder = F64ColumnBuilder;
exports.I128Builder = I128Builder;
exports.I128ColumnBuilder = I128ColumnBuilder;
exports.I16Builder = I16Builder;
exports.I16ColumnBuilder = I16ColumnBuilder;
exports.I256Builder = I256Builder;
exports.I256ColumnBuilder = I256ColumnBuilder;
exports.I32Builder = I32Builder;
exports.I32ColumnBuilder = I32ColumnBuilder;
exports.I64Builder = I64Builder;
exports.I64ColumnBuilder = I64ColumnBuilder;
exports.I8Builder = I8Builder;
exports.I8ColumnBuilder = I8ColumnBuilder;
exports.IdentityBuilder = IdentityBuilder;
exports.IdentityColumnBuilder = IdentityColumnBuilder;
exports.OptionBuilder = OptionBuilder;
exports.OptionColumnBuilder = OptionColumnBuilder;
exports.ProductBuilder = ProductBuilder;
exports.ProductColumnBuilder = ProductColumnBuilder;
exports.RefBuilder = RefBuilder;
exports.ResultBuilder = ResultBuilder;
exports.ResultColumnBuilder = ResultColumnBuilder;
exports.RowBuilder = RowBuilder;
exports.ScheduleAtBuilder = ScheduleAtBuilder;
exports.ScheduleAtColumnBuilder = ScheduleAtColumnBuilder;
exports.SenderError = SenderError;
exports.SimpleSumBuilder = SimpleSumBuilder;
exports.SimpleSumColumnBuilder = SimpleSumColumnBuilder;
exports.SpacetimeHostError = SpacetimeHostError;
exports.StringBuilder = StringBuilder;
exports.StringColumnBuilder = StringColumnBuilder;
exports.SumBuilder = SumBuilder;
exports.SumColumnBuilder = SumColumnBuilder;
exports.TimeDurationBuilder = TimeDurationBuilder;
exports.TimeDurationColumnBuilder = TimeDurationColumnBuilder;
exports.TimestampBuilder = TimestampBuilder;
exports.TimestampColumnBuilder = TimestampColumnBuilder;
exports.TypeBuilder = TypeBuilder;
exports.U128Builder = U128Builder;
exports.U128ColumnBuilder = U128ColumnBuilder;
exports.U16Builder = U16Builder;
exports.U16ColumnBuilder = U16ColumnBuilder;
exports.U256Builder = U256Builder;
exports.U256ColumnBuilder = U256ColumnBuilder;
exports.U32Builder = U32Builder;
exports.U32ColumnBuilder = U32ColumnBuilder;
exports.U64Builder = U64Builder;
exports.U64ColumnBuilder = U64ColumnBuilder;
exports.U8Builder = U8Builder;
exports.U8ColumnBuilder = U8ColumnBuilder;
exports.UuidBuilder = UuidBuilder;
exports.UuidColumnBuilder = UuidColumnBuilder;
exports.and = and;
exports.errors = errors;
exports.not = not;
exports.or = or;
exports.reducers = reducers;
exports.schema = schema;
exports.t = t;
exports.table = table;
exports.toCamelCase = toCamelCase;
//# sourceMappingURL=index.cjs.map
//# sourceMappingURL=index.cjs.map