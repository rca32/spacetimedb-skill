import { ConnectionId } from '../lib/connection_id';
import { Identity } from '../lib/identity';
import type { ColumnIndex, IndexColumns, IndexOpts } from '../lib/indexes';
import type { UntypedSchemaDef } from '../lib/schema';
import type { TableSchema } from '../lib/table_schema';
import type { ColumnBuilder, ColumnMetadata, RowBuilder, TypeBuilder } from '../lib/type_builders';
/**
 * Helper to get the set of table names.
 */
export type TableNames<SchemaDef extends UntypedSchemaDef> = SchemaDef['tables'][number]['name'] & string;
/** helper: pick the table def object from the schema by its name */
export type TableDefByName<SchemaDef extends UntypedSchemaDef, Name extends TableNames<SchemaDef>> = Extract<SchemaDef['tables'][number], {
    name: Name;
}>;
declare const QueryBrand: unique symbol;
export interface TableTypedQuery<TableDef extends TypedTableDef> {
    readonly [QueryBrand]: true;
    readonly __table?: TableDef;
}
export interface RowTypedQuery<Row, ST> {
    readonly [QueryBrand]: true;
    readonly __row?: Row;
    readonly __algebraicType?: ST;
}
export type Query<TableDef extends TypedTableDef> = RowTypedQuery<RowType<TableDef>, TableDef['rowType']>;
export declare const isRowTypedQuery: (val: unknown) => val is RowTypedQuery<any, any>;
export declare const isTypedQuery: (val: unknown) => val is TableTypedQuery<any>;
export declare function toSql(q: Query<any>): string;
type From<TableDef extends TypedTableDef> = Readonly<{
    where(predicate: (row: RowExpr<TableDef>) => BooleanExpr<TableDef>): From<TableDef>;
    rightSemijoin<RightTable extends TypedTableDef>(other: TableRef<RightTable>, on: (left: IndexedRowExpr<TableDef>, right: IndexedRowExpr<RightTable>) => EqExpr<TableDef | RightTable>): SemijoinBuilder<RightTable>;
    leftSemijoin<RightTable extends TypedTableDef>(other: TableRef<RightTable>, on: (left: IndexedRowExpr<TableDef>, right: IndexedRowExpr<RightTable>) => EqExpr<TableDef | RightTable>): SemijoinBuilder<TableDef>;
    build(): Query<TableDef>;
}>;
type SemijoinBuilder<TableDef extends TypedTableDef> = Readonly<{
    where(predicate: (row: RowExpr<TableDef>) => BooleanExpr<TableDef>): SemijoinBuilder<TableDef>;
    build(): Query<TableDef>;
}>;
export type QueryBuilder<SchemaDef extends UntypedSchemaDef> = {
    readonly [Tbl in SchemaDef['tables'][number] as Tbl['name']]: TableRef<Tbl> & From<Tbl>;
} & {};
/**
 * A runtime reference to a table. This materializes the RowExpr for us.
 * TODO: Maybe add the full SchemaDef to the type signature depending on how joins will work.
 */
export type TableRef<TableDef extends TypedTableDef> = Readonly<{
    type: 'table';
    name: TableDef['name'];
    cols: RowExpr<TableDef>;
    indexedCols: IndexedRowExpr<TableDef>;
    tableDef: TableDef;
}>;
export type RefSource<TableDef extends TypedTableDef> = TableRef<TableDef> | {
    ref(): TableRef<TableDef>;
};
export declare function createTableRefFromDef<TableDef extends TypedTableDef>(tableDef: TableDef): TableRef<TableDef>;
export declare function makeQueryBuilder<SchemaDef extends UntypedSchemaDef>(schema: SchemaDef): QueryBuilder<SchemaDef>;
export declare function from<TableDef extends TypedTableDef>(source: RefSource<TableDef>): From<TableDef>;
export type TypedTableDef<Columns extends Record<string, ColumnBuilder<any, any, ColumnMetadata<any>>> = Record<string, ColumnBuilder<any, any, ColumnMetadata<any>>>> = {
    name: string;
    columns: Columns;
    indexes: readonly IndexOpts<any>[];
    rowType: RowBuilder<Columns>['algebraicType']['value'];
};
export type TableSchemaAsTableDef<TSchema extends TableSchema<any, any, readonly any[]>> = {
    name: TSchema['tableName'];
    columns: TSchema['rowType']['row'];
    indexes: TSchema['idxs'];
};
type RowType<TableDef extends TypedTableDef> = {
    [K in keyof TableDef['columns']]: TableDef['columns'][K] extends ColumnBuilder<infer T, any, any> ? T : never;
};
export type ColumnExpr<TableDef extends TypedTableDef, ColumnName extends ColumnNames<TableDef>> = ColumnExpression<TableDef, ColumnName>;
type ColumnSpacetimeType<Col extends ColumnExpr<any, any>> = Col extends ColumnExpr<infer T, infer N> ? InferSpacetimeTypeOfColumn<T, N> : never;
type ColumnSameSpacetime<ThisTable extends TypedTableDef, ThisCol extends ColumnNames<ThisTable>, OtherCol extends ColumnExpr<any, any>> = [InferSpacetimeTypeOfColumn<ThisTable, ThisCol>] extends [
    ColumnSpacetimeType<OtherCol>
] ? [ColumnSpacetimeType<OtherCol>] extends [
    InferSpacetimeTypeOfColumn<ThisTable, ThisCol>
] ? OtherCol : never : never;
type ExtractTable<Col extends ColumnExpr<any, any>> = Col extends ColumnExpr<infer T, any> ? T : never;
export declare class ColumnExpression<TableDef extends TypedTableDef, ColumnName extends ColumnNames<TableDef>> {
    readonly type: "column";
    readonly column: ColumnName;
    readonly table: TableDef['name'];
    readonly tsValueType?: RowType<TableDef>[ColumnName];
    readonly spacetimeType: InferSpacetimeTypeOfColumn<TableDef, ColumnName>;
    constructor(table: TableDef['name'], column: ColumnName, spacetimeType: InferSpacetimeTypeOfColumn<TableDef, ColumnName>);
    eq(literal: LiteralValue & RowType<TableDef>[ColumnName]): EqExpr<TableDef>;
    eq<OtherCol extends ColumnExpr<any, any>>(value: ColumnSameSpacetime<TableDef, ColumnName, OtherCol>): EqExpr<TableDef | ExtractTable<OtherCol>>;
    lt(literal: LiteralValue & RowType<TableDef>[ColumnName]): BooleanExpr<TableDef>;
    lt<OtherCol extends ColumnExpr<any, any>>(value: ColumnSameSpacetime<TableDef, ColumnName, OtherCol>): BooleanExpr<TableDef | ExtractTable<OtherCol>>;
    lte(literal: LiteralValue & RowType<TableDef>[ColumnName]): BooleanExpr<TableDef>;
    lte<OtherCol extends ColumnExpr<any, any>>(value: ColumnSameSpacetime<TableDef, ColumnName, OtherCol>): BooleanExpr<TableDef | ExtractTable<OtherCol>>;
    gt(literal: LiteralValue & RowType<TableDef>[ColumnName]): BooleanExpr<TableDef>;
    gt<OtherCol extends ColumnExpr<any, any>>(value: ColumnSameSpacetime<TableDef, ColumnName, OtherCol>): BooleanExpr<TableDef | ExtractTable<OtherCol>>;
    gte(literal: LiteralValue & RowType<TableDef>[ColumnName]): BooleanExpr<TableDef>;
    gte<OtherCol extends ColumnExpr<any, any>>(value: ColumnSameSpacetime<TableDef, ColumnName, OtherCol>): BooleanExpr<TableDef | ExtractTable<OtherCol>>;
}
/**
 * Helper to get the spacetime type of a column.
 */
type InferSpacetimeTypeOfColumn<TableDef extends TypedTableDef, ColumnName extends ColumnNames<TableDef>> = TableDef['columns'][ColumnName]['typeBuilder'] extends TypeBuilder<any, infer U> ? U : never;
type ColumnNames<TableDef extends TypedTableDef> = keyof RowType<TableDef> & string;
type FirstIndexColumn<I extends IndexOpts<any>> = IndexColumns<I> extends readonly [infer Head extends string, ...infer _Rest] ? Head : never;
type ExplicitIndexedColumns<TableDef extends TypedTableDef> = TableDef['indexes'][number] extends infer I ? I extends IndexOpts<ColumnNames<TableDef>> ? FirstIndexColumn<I> & ColumnNames<TableDef> : never : never;
type MetadataIndexedColumns<TableDef extends TypedTableDef> = {
    [K in ColumnNames<TableDef>]: ColumnIndex<K, TableDef['columns'][K]['columnMetadata']> extends never ? never : K;
}[ColumnNames<TableDef>];
export type IndexedColumnNames<TableDef extends TypedTableDef> = ExplicitIndexedColumns<TableDef> | MetadataIndexedColumns<TableDef>;
export type IndexedRowExpr<TableDef extends TypedTableDef> = Readonly<{
    readonly [C in IndexedColumnNames<TableDef>]: ColumnExpr<TableDef, C>;
}>;
/**
 * Acts as a row when writing filters for queries. It is a way to get column references.
 */
export type RowExpr<TableDef extends TypedTableDef> = Readonly<{
    readonly [C in ColumnNames<TableDef>]: ColumnExpr<TableDef, C>;
}>;
/**
 * Union of ColumnExprs from Table whose spacetimeType is compatible with Value
 * (produces a union of ColumnExpr<Table, C> for matching columns).
 */
export type ColumnExprForValue<Table extends TypedTableDef, Value> = {
    [C in ColumnNames<Table>]: InferSpacetimeTypeOfColumn<Table, C> extends Value ? ColumnExpr<Table, C> : never;
}[ColumnNames<Table>];
type LiteralValue = string | number | bigint | boolean | Identity | ConnectionId;
export type ValueExpr<TableDef extends TypedTableDef, Value> = LiteralExpr<Value & LiteralValue> | ColumnExprForValue<TableDef, Value>;
type LiteralExpr<Value> = {
    type: 'literal';
    value: Value;
};
export declare function literal<Value extends LiteralValue>(value: Value): ValueExpr<never, Value>;
type EqExpr<Table extends TypedTableDef = any> = {
    type: 'eq';
    left: ValueExpr<Table, any>;
    right: ValueExpr<Table, any>;
} & {
    _tableType?: Table;
};
type BooleanExpr<Table extends TypedTableDef> = ({
    type: 'eq' | 'ne' | 'gt' | 'lt' | 'gte' | 'lte';
    left: ValueExpr<Table, any>;
    right: ValueExpr<Table, any>;
} | {
    type: 'and';
    clauses: readonly [
        BooleanExpr<Table>,
        BooleanExpr<Table>,
        ...BooleanExpr<Table>[]
    ];
} | {
    type: 'or';
    clauses: readonly [
        BooleanExpr<Table>,
        BooleanExpr<Table>,
        ...BooleanExpr<Table>[]
    ];
} | {
    type: 'not';
    clause: BooleanExpr<Table>;
}) & {
    _tableType?: Table;
};
export declare function not<T extends TypedTableDef>(clause: BooleanExpr<T>): BooleanExpr<T>;
export declare function and<T extends TypedTableDef>(...clauses: readonly [BooleanExpr<T>, BooleanExpr<T>, ...BooleanExpr<T>[]]): BooleanExpr<T>;
export declare function or<T extends TypedTableDef>(...clauses: readonly [BooleanExpr<T>, BooleanExpr<T>, ...BooleanExpr<T>[]]): BooleanExpr<T>;
export {};
//# sourceMappingURL=query.d.ts.map