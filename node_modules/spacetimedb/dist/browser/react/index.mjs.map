{"version":3,"sources":["../../../src/lib/time_duration.ts","../../../src/lib/timestamp.ts","../../../src/lib/uuid.ts","../../../src/lib/binary_writer.ts","../../../src/lib/binary_reader.ts","../../../src/lib/util.ts","../../../src/lib/identity.ts","../../../src/lib/algebraic_type.ts","../../../src/lib/connection_id.ts","../../../src/react/useSpacetimeDB.ts","../../../src/react/SpacetimeDBProvider.ts","../../../src/react/useTable.ts","../../../src/react/useReducer.ts"],"names":["conn","expr","where","useState","useRef","useCallback","useEffect"],"mappings":"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","file":"index.mjs","sourcesContent":["import { AlgebraicType } from './algebraic_type';\n\nexport type TimeDurationAlgebraicType = {\n  tag: 'Product';\n  value: {\n    elements: [\n      { name: '__time_duration_micros__'; algebraicType: { tag: 'I64' } },\n    ];\n  };\n};\n\n/**\n * A difference between two points in time, represented as a number of microseconds.\n */\nexport class TimeDuration {\n  __time_duration_micros__: bigint;\n\n  private static MICROS_PER_MILLIS: bigint = 1000n;\n\n  /**\n   * Get the algebraic type representation of the {@link TimeDuration} type.\n   * @returns The algebraic type representation of the type.\n   */\n  static getAlgebraicType(): TimeDurationAlgebraicType {\n    return AlgebraicType.Product({\n      elements: [\n        {\n          name: '__time_duration_micros__',\n          algebraicType: AlgebraicType.I64,\n        },\n      ],\n    });\n  }\n\n  static isTimeDuration(\n    algebraicType: AlgebraicType\n  ): algebraicType is TimeDurationAlgebraicType {\n    if (algebraicType.tag !== 'Product') {\n      return false;\n    }\n    const elements = algebraicType.value.elements;\n    if (elements.length !== 1) {\n      return false;\n    }\n    const microsElement = elements[0];\n    return (\n      microsElement.name === '__time_duration_micros__' &&\n      microsElement.algebraicType.tag === 'I64'\n    );\n  }\n\n  get micros(): bigint {\n    return this.__time_duration_micros__;\n  }\n\n  get millis(): number {\n    return Number(this.micros / TimeDuration.MICROS_PER_MILLIS);\n  }\n\n  constructor(micros: bigint) {\n    this.__time_duration_micros__ = micros;\n  }\n\n  static fromMillis(millis: number): TimeDuration {\n    return new TimeDuration(BigInt(millis) * TimeDuration.MICROS_PER_MILLIS);\n  }\n\n  /** This outputs the same string format that we use in the host and in Rust modules */\n  toString(): string {\n    const micros = this.micros;\n    const sign = micros < 0 ? '-' : '+';\n    const pos = micros < 0 ? -micros : micros;\n    const secs = pos / 1_000_000n;\n    const micros_remaining = pos % 1_000_000n;\n    return `${sign}${secs}.${String(micros_remaining).padStart(6, '0')}`;\n  }\n}\n","import { AlgebraicType } from './algebraic_type';\nimport { TimeDuration } from './time_duration';\n\nexport type TimestampAlgebraicType = {\n  tag: 'Product';\n  value: {\n    elements: [\n      {\n        name: '__timestamp_micros_since_unix_epoch__';\n        algebraicType: { tag: 'I64' };\n      },\n    ];\n  };\n};\n\n/**\n * A point in time, represented as a number of microseconds since the Unix epoch.\n */\nexport class Timestamp {\n  __timestamp_micros_since_unix_epoch__: bigint;\n\n  private static MICROS_PER_MILLIS: bigint = 1000n;\n\n  get microsSinceUnixEpoch(): bigint {\n    return this.__timestamp_micros_since_unix_epoch__;\n  }\n\n  constructor(micros: bigint) {\n    this.__timestamp_micros_since_unix_epoch__ = micros;\n  }\n\n  /**\n   * Get the algebraic type representation of the {@link Timestamp} type.\n   * @returns The algebraic type representation of the type.\n   */\n  static getAlgebraicType(): TimestampAlgebraicType {\n    return AlgebraicType.Product({\n      elements: [\n        {\n          name: '__timestamp_micros_since_unix_epoch__',\n          algebraicType: AlgebraicType.I64,\n        },\n      ],\n    });\n  }\n\n  static isTimestamp(\n    algebraicType: AlgebraicType\n  ): algebraicType is TimestampAlgebraicType {\n    if (algebraicType.tag !== 'Product') {\n      return false;\n    }\n    const elements = algebraicType.value.elements;\n    if (elements.length !== 1) {\n      return false;\n    }\n    const microsElement = elements[0];\n    return (\n      microsElement.name === '__timestamp_micros_since_unix_epoch__' &&\n      microsElement.algebraicType.tag === 'I64'\n    );\n  }\n\n  /**\n   * The Unix epoch, the midnight at the beginning of January 1, 1970, UTC.\n   */\n  static UNIX_EPOCH: Timestamp = new Timestamp(0n);\n\n  /**\n   * Get a `Timestamp` representing the execution environment's belief of the current moment in time.\n   */\n  static now(): Timestamp {\n    return Timestamp.fromDate(new Date());\n  }\n\n  /** Convert to milliseconds since Unix epoch. */\n  toMillis(): bigint {\n    return this.microsSinceUnixEpoch / 1000n;\n  }\n\n  /**\n   * Get a `Timestamp` representing the same point in time as `date`.\n   */\n  static fromDate(date: Date): Timestamp {\n    const millis = date.getTime();\n    const micros = BigInt(millis) * Timestamp.MICROS_PER_MILLIS;\n    return new Timestamp(micros);\n  }\n\n  /**\n   * Get a `Date` representing approximately the same point in time as `this`.\n   *\n   * This method truncates to millisecond precision,\n   * and throws `RangeError` if the `Timestamp` is outside the range representable as a `Date`.\n   */\n  toDate(): Date {\n    const micros = this.__timestamp_micros_since_unix_epoch__;\n    const millis = micros / Timestamp.MICROS_PER_MILLIS;\n    if (\n      millis > BigInt(Number.MAX_SAFE_INTEGER) ||\n      millis < BigInt(Number.MIN_SAFE_INTEGER)\n    ) {\n      throw new RangeError(\n        \"Timestamp is outside of the representable range of JS's Date\"\n      );\n    }\n    return new Date(Number(millis));\n  }\n\n  since(other: Timestamp): TimeDuration {\n    return new TimeDuration(\n      this.__timestamp_micros_since_unix_epoch__ -\n        other.__timestamp_micros_since_unix_epoch__\n    );\n  }\n}\n","import { Timestamp } from './timestamp';\nimport { AlgebraicType } from './algebraic_type.ts';\n\nexport type UuidAlgebraicType = {\n  tag: 'Product';\n  value: {\n    elements: [\n      {\n        name: '__uuid__';\n        algebraicType: { tag: 'U128' };\n      },\n    ];\n  };\n};\n\n/**\n * Supported UUID versions.\n *\n * - `Nil`  The \"Nil\" UUID (all zeros)\n * - `V4`   Version 4: random\n * - `V7`   Version 7: timestamp + counter + random\n * - `Max`  The \"Max\" UUID (all ones)\n */\ntype UuidVersion = 'Nil' | 'V4' | 'V7' | 'Max';\n\n/**\n * A universally unique identifier (UUID).\n *\n * Supports UUID `Nil`, `Max`, `V4` (random), and `V7`\n * (timestamp + counter + random).\n *\n * Internally represented as an unsigned 128-bit between 0 and `MAX_UUID_BIGINT`.\n */\nexport class Uuid {\n  __uuid__: bigint;\n\n  /**\n   * The nil UUID (all zeros).\n   *\n   * @example\n   * ```ts\n   * const uuid = Uuid.NIL;\n   * console.assert(\n   *   uuid.toString() === \"00000000-0000-0000-0000-000000000000\"\n   * );\n   * ```\n   */\n  static readonly NIL = new Uuid(0n);\n  static readonly MAX_UUID_BIGINT = 0xffffffffffffffffffffffffffffffffn;\n  /**\n   * The max UUID (all ones).\n   *\n   * @example\n   * ```ts\n   * const uuid = Uuid.MAX;\n   * console.assert(\n   *   uuid.toString() === \"ffffffff-ffff-ffff-ffff-ffffffffffff\"\n   * );\n   * ```\n   */\n  static readonly MAX = new Uuid(Uuid.MAX_UUID_BIGINT);\n\n  /**\n   * Create a UUID from a raw 128-bit value.\n   *\n   * @param u - Unsigned 128-bit integer\n   * @throws {Error} If the value is outside the valid UUID range\n   */\n  constructor(u: bigint) {\n    // Must fit in exactly 16 bytes\n    if (u < 0n || u > Uuid.MAX_UUID_BIGINT) {\n      throw new Error('Invalid UUID: must be between 0 and `MAX_UUID_BIGINT`');\n    }\n    this.__uuid__ = u;\n  }\n\n  /**\n   * Create a UUID `v4` from explicit random bytes.\n   *\n   * This method assumes the bytes are already sufficiently random.\n   * It only sets the appropriate bits for the UUID version and variant.\n   *\n   * @param bytes - Exactly 16 random bytes\n   * @returns A UUID `v4`\n   * @throws {Error} If `bytes.length !== 16`\n   *\n   * @example\n   * ```ts\n   * const randomBytes = new Uint8Array(16);\n   * const uuid = Uuid.fromRandomBytesV4(randomBytes);\n   *\n   * console.assert(\n   *   uuid.toString() === \"00000000-0000-4000-8000-000000000000\"\n   * );\n   * ```\n   */\n  static fromRandomBytesV4(bytes: Uint8Array): Uuid {\n    if (bytes.length !== 16) throw new Error('UUID v4 requires 16 bytes');\n    const arr = new Uint8Array(bytes);\n    arr[6] = (arr[6] & 0x0f) | 0x40; // version 4\n    arr[8] = (arr[8] & 0x3f) | 0x80; // variant\n    return new Uuid(Uuid.bytesToBigInt(arr));\n  }\n\n  /**\n   * Generate a UUID `v7` using a monotonic counter from `0` to `2^31 - 1`,\n   * a timestamp, and 4 random bytes.\n   *\n   * The counter wraps around on overflow.\n   *\n   * The UUID `v7` is structured as follows:\n   *\n   * ```ascii\n   * \n   * | B0  | B1  | B2  | B3  | B4  | B5              |         B6        |\n   * \n   * |                 unix_ts_ms                    |      version 7    |\n   * \n   * \n   * | B7           | B8      | B9  | B10 | B11  | B12 | B13 | B14 | B15 |\n   * \n   * | counter_high | variant |    counter_low   |        random         |\n   * \n   * ```\n   *\n   * @param counter - Mutable monotonic counter (31-bit)\n   * @param now - Timestamp since the Unix epoch\n   * @param randomBytes - Exactly 4 random bytes\n   * @returns A UUID `v7`\n   *\n   * @throws {Error} If the `counter` is negative\n   * @throws {Error} If the `timestamp` is before the Unix epoch\n   * @throws {Error} If `randomBytes.length !== 4`\n   *\n   * @example\n   * ```ts\n   * const now = Timestamp.fromMillis(1_686_000_000_000n);\n   * const counter = { value: 1 };\n   * const randomBytes = new Uint8Array(4);\n   *\n   * const uuid = Uuid.fromCounterV7(counter, now, randomBytes);\n   *\n   * console.assert(\n   *   uuid.toString() === \"0000647e-5180-7000-8000-000200000000\"\n   * );\n   * ```\n   */\n  static fromCounterV7(\n    counter: { value: number },\n    now: Timestamp,\n    randomBytes: Uint8Array\n  ): Uuid {\n    if (randomBytes.length !== 4) {\n      throw new Error('`fromCounterV7` requires `randomBytes.length == 4`');\n    }\n\n    if (counter.value < 0) {\n      throw new Error('`fromCounterV7` uuid `counter` must be non-negative');\n    }\n\n    if (now.__timestamp_micros_since_unix_epoch__ < 0) {\n      throw new Error('`fromCounterV7` `timestamp` before unix epoch');\n    }\n\n    // 31-bit monotonic counter with wraparound\n    const counterVal = counter.value;\n    counter.value = (counterVal + 1) & 0x7fff_ffff;\n\n    // 48-bit unix timestamp (ms)\n    const tsMs = now.toMillis() & 0xffff_ffff_ffffn;\n\n    const bytes = new Uint8Array(16);\n\n    // unix_ts_ms (48 bits)\n    bytes[0] = Number((tsMs >> 40n) & 0xffn);\n    bytes[1] = Number((tsMs >> 32n) & 0xffn);\n    bytes[2] = Number((tsMs >> 24n) & 0xffn);\n    bytes[3] = Number((tsMs >> 16n) & 0xffn);\n    bytes[4] = Number((tsMs >> 8n) & 0xffn);\n    bytes[5] = Number(tsMs & 0xffn);\n\n    // Counter bits (31 bits total)\n    bytes[7] = (counterVal >>> 23) & 0xff;\n    bytes[9] = (counterVal >>> 15) & 0xff;\n    bytes[10] = (counterVal >>> 7) & 0xff;\n    bytes[11] = ((counterVal & 0x7f) << 1) & 0xff;\n\n    // Random bytes\n    bytes[12] |= randomBytes[0] & 0x7f;\n    bytes[13] = randomBytes[1];\n    bytes[14] = randomBytes[2];\n    bytes[15] = randomBytes[3];\n\n    // Version 7\n    bytes[6] = (bytes[6] & 0x0f) | 0x70;\n\n    // Variant RFC4122\n    bytes[8] = (bytes[8] & 0x3f) | 0x80;\n\n    return new Uuid(Uuid.bytesToBigInt(bytes));\n  }\n\n  /**\n   * Parse a UUID from a string representation.\n   *\n   * @param s - UUID string\n   * @returns Parsed UUID\n   * @throws {Error} If the string is not a valid UUID\n   *\n   * @example\n   * ```ts\n   * const s = \"01888d6e-5c00-7000-8000-000000000000\";\n   * const uuid = Uuid.parse(s);\n   *\n   * console.assert(uuid.toString() === s);\n   * ```\n   */\n  static parse(s: string): Uuid {\n    const hex = s.replace(/-/g, '');\n    if (hex.length !== 32) throw new Error('Invalid hex UUID');\n\n    let v = 0n;\n    for (let i = 0; i < 32; i += 2) {\n      v = (v << 8n) | BigInt(parseInt(hex.slice(i, i + 2), 16));\n    }\n    return new Uuid(v);\n  }\n\n  /** Convert to string (hyphenated form). */\n  toString(): string {\n    const bytes = Uuid.bigIntToBytes(this.__uuid__);\n    const hex = [...bytes].map(b => b.toString(16).padStart(2, '0')).join('');\n\n    // Format as 8-4-4-4-12\n    return (\n      hex.slice(0, 8) +\n      '-' +\n      hex.slice(8, 12) +\n      '-' +\n      hex.slice(12, 16) +\n      '-' +\n      hex.slice(16, 20) +\n      '-' +\n      hex.slice(20)\n    );\n  }\n\n  /** Convert to bigint (u128). */\n  asBigInt(): bigint {\n    return this.__uuid__;\n  }\n\n  /** Return a `Uint8Array` of 16 bytes. */\n  toBytes(): Uint8Array {\n    return Uuid.bigIntToBytes(this.__uuid__);\n  }\n\n  private static bytesToBigInt(bytes: Uint8Array): bigint {\n    let result = 0n;\n    for (const b of bytes) result = (result << 8n) | BigInt(b);\n    return result;\n  }\n\n  private static bigIntToBytes(value: bigint): Uint8Array {\n    const bytes = new Uint8Array(16);\n    for (let i = 15; i >= 0; i--) {\n      bytes[i] = Number(value & 0xffn);\n      value >>= 8n;\n    }\n    return bytes;\n  }\n\n  /**\n   * Returns the version of this UUID.\n   *\n   * This represents the algorithm used to generate the value.\n   *\n   * @returns A `UuidVersion`\n   * @throws {Error} If the version field is not recognized\n   */\n  getVersion(): UuidVersion {\n    const version = (this.toBytes()[6] >> 4) & 0x0f;\n\n    switch (version) {\n      case 4:\n        return 'V4';\n      case 7:\n        return 'V7';\n      default:\n        if (this == Uuid.NIL) {\n          return 'Nil';\n        }\n        if (this == Uuid.MAX) {\n          return 'Max';\n        }\n        throw new Error(`Unsupported UUID version: ${version}`);\n    }\n  }\n\n  /**\n   * Extract the monotonic counter from a UUIDv7.\n   *\n   * Intended for testing and diagnostics.\n   * Behavior is undefined if called on a non-V7 UUID.\n   *\n   * @returns 31-bit counter value\n   */\n  getCounter(): number {\n    const bytes = this.toBytes(); // big-endian, 16 bytes\n\n    const high = bytes[7]; // bits 30..23\n    const mid1 = bytes[9]; // bits 22..15\n    const mid2 = bytes[10]; // bits 14..7\n    const low = bytes[11] >>> 1; // bits 6..0\n\n    // reconstruct 31-bit counter\n    return (high << 23) | (mid1 << 15) | (mid2 << 7) | low | 0; // force 32-bit int\n  }\n\n  compareTo(other: Uuid): number {\n    if (this.__uuid__ < other.__uuid__) return -1;\n    if (this.__uuid__ > other.__uuid__) return 1;\n\n    return 0;\n  }\n\n  static getAlgebraicType(): UuidAlgebraicType {\n    return AlgebraicType.Product({\n      elements: [\n        {\n          name: '__uuid__',\n          algebraicType: AlgebraicType.U128,\n        },\n      ],\n    });\n  }\n}\n","import { fromByteArray } from 'base64-js';\n\nexport default class BinaryWriter {\n  #buffer: Uint8Array;\n  #view: DataView;\n  #offset: number = 0;\n\n  constructor(size: number) {\n    this.#buffer = new Uint8Array(size);\n    this.#view = new DataView(this.#buffer.buffer);\n  }\n\n  #expandBuffer(additionalCapacity: number): void {\n    const minCapacity = this.#offset + additionalCapacity + 1;\n    if (minCapacity <= this.#buffer.length) return;\n    let newCapacity = this.#buffer.length * 2;\n    if (newCapacity < minCapacity) newCapacity = minCapacity;\n    const newBuffer = new Uint8Array(newCapacity);\n    newBuffer.set(this.#buffer);\n    this.#buffer = newBuffer;\n    this.#view = new DataView(this.#buffer.buffer);\n  }\n\n  toBase64(): string {\n    return fromByteArray(this.#buffer.subarray(0, this.#offset));\n  }\n\n  getBuffer(): Uint8Array {\n    return this.#buffer.slice(0, this.#offset);\n  }\n\n  get offset(): number {\n    return this.#offset;\n  }\n\n  writeUInt8Array(value: Uint8Array): void {\n    const length = value.length;\n\n    this.#expandBuffer(4 + length);\n\n    this.writeU32(length);\n    this.#buffer.set(value, this.#offset);\n    this.#offset += value.length;\n  }\n\n  writeBool(value: boolean): void {\n    this.#expandBuffer(1);\n    this.#view.setUint8(this.#offset, value ? 1 : 0);\n    this.#offset += 1;\n  }\n\n  writeByte(value: number): void {\n    this.#expandBuffer(1);\n    this.#view.setUint8(this.#offset, value);\n    this.#offset += 1;\n  }\n\n  writeI8(value: number): void {\n    this.#expandBuffer(1);\n    this.#view.setInt8(this.#offset, value);\n    this.#offset += 1;\n  }\n\n  writeU8(value: number): void {\n    this.#expandBuffer(1);\n    this.#view.setUint8(this.#offset, value);\n    this.#offset += 1;\n  }\n\n  writeI16(value: number): void {\n    this.#expandBuffer(2);\n    this.#view.setInt16(this.#offset, value, true);\n    this.#offset += 2;\n  }\n\n  writeU16(value: number): void {\n    this.#expandBuffer(2);\n    this.#view.setUint16(this.#offset, value, true);\n    this.#offset += 2;\n  }\n\n  writeI32(value: number): void {\n    this.#expandBuffer(4);\n    this.#view.setInt32(this.#offset, value, true);\n    this.#offset += 4;\n  }\n\n  writeU32(value: number): void {\n    this.#expandBuffer(4);\n    this.#view.setUint32(this.#offset, value, true);\n    this.#offset += 4;\n  }\n\n  writeI64(value: bigint): void {\n    this.#expandBuffer(8);\n    this.#view.setBigInt64(this.#offset, value, true);\n    this.#offset += 8;\n  }\n\n  writeU64(value: bigint): void {\n    this.#expandBuffer(8);\n    this.#view.setBigUint64(this.#offset, value, true);\n    this.#offset += 8;\n  }\n\n  writeU128(value: bigint): void {\n    this.#expandBuffer(16);\n    const lowerPart = value & BigInt('0xFFFFFFFFFFFFFFFF');\n    const upperPart = value >> BigInt(64);\n    this.#view.setBigUint64(this.#offset, lowerPart, true);\n    this.#view.setBigUint64(this.#offset + 8, upperPart, true);\n    this.#offset += 16;\n  }\n\n  writeI128(value: bigint): void {\n    this.#expandBuffer(16);\n    const lowerPart = value & BigInt('0xFFFFFFFFFFFFFFFF');\n    const upperPart = value >> BigInt(64);\n    this.#view.setBigInt64(this.#offset, lowerPart, true);\n    this.#view.setBigInt64(this.#offset + 8, upperPart, true);\n    this.#offset += 16;\n  }\n\n  writeU256(value: bigint): void {\n    this.#expandBuffer(32);\n    const low_64_mask = BigInt('0xFFFFFFFFFFFFFFFF');\n    const p0 = value & low_64_mask;\n    const p1 = (value >> BigInt(64 * 1)) & low_64_mask;\n    const p2 = (value >> BigInt(64 * 2)) & low_64_mask;\n    const p3 = value >> BigInt(64 * 3);\n    this.#view.setBigUint64(this.#offset + 8 * 0, p0, true);\n    this.#view.setBigUint64(this.#offset + 8 * 1, p1, true);\n    this.#view.setBigUint64(this.#offset + 8 * 2, p2, true);\n    this.#view.setBigUint64(this.#offset + 8 * 3, p3, true);\n    this.#offset += 32;\n  }\n\n  writeI256(value: bigint): void {\n    this.#expandBuffer(32);\n    const low_64_mask = BigInt('0xFFFFFFFFFFFFFFFF');\n    const p0 = value & low_64_mask;\n    const p1 = (value >> BigInt(64 * 1)) & low_64_mask;\n    const p2 = (value >> BigInt(64 * 2)) & low_64_mask;\n    const p3 = value >> BigInt(64 * 3);\n    this.#view.setBigUint64(this.#offset + 8 * 0, p0, true);\n    this.#view.setBigUint64(this.#offset + 8 * 1, p1, true);\n    this.#view.setBigUint64(this.#offset + 8 * 2, p2, true);\n    this.#view.setBigInt64(this.#offset + 8 * 3, p3, true);\n    this.#offset += 32;\n  }\n\n  writeF32(value: number): void {\n    this.#expandBuffer(4);\n    this.#view.setFloat32(this.#offset, value, true);\n    this.#offset += 4;\n  }\n\n  writeF64(value: number): void {\n    this.#expandBuffer(8);\n    this.#view.setFloat64(this.#offset, value, true);\n    this.#offset += 8;\n  }\n\n  writeString(value: string): void {\n    const encoder = new TextEncoder();\n    const encodedString = encoder.encode(value);\n    this.writeU32(encodedString.length);\n    this.#expandBuffer(encodedString.length);\n    this.#buffer.set(encodedString, this.#offset);\n    this.#offset += encodedString.length;\n  }\n}\n","export default class BinaryReader {\n  /**\n   * The DataView used to read values from the binary data.\n   *\n   * Note: The DataView's `byteOffset` is relative to the beginning of the\n   * underlying ArrayBuffer, not the start of the provided Uint8Array input.\n   * This `BinaryReader`'s `#offset` field is used to track the current read position\n   * relative to the start of the provided Uint8Array input.\n   */\n  #view: DataView;\n\n  /**\n   * Represents the offset (in bytes) relative to the start of the DataView\n   * and provided Uint8Array input.\n   *\n   * Note: This is *not* the absolute byte offset within the underlying ArrayBuffer.\n   */\n  #offset: number = 0;\n\n  constructor(input: Uint8Array) {\n    this.#view = new DataView(input.buffer, input.byteOffset, input.byteLength);\n    this.#offset = 0;\n  }\n\n  get offset(): number {\n    return this.#offset;\n  }\n\n  get remaining(): number {\n    return this.#view.byteLength - this.#offset;\n  }\n\n  /** Ensure we have at least `n` bytes left to read */\n  #ensure(n: number): void {\n    if (this.#offset + n > this.#view.byteLength) {\n      throw new RangeError(\n        `Tried to read ${n} byte(s) at relative offset ${this.#offset}, but only ${this.remaining} byte(s) remain`\n      );\n    }\n  }\n\n  readUInt8Array(): Uint8Array {\n    const length = this.readU32();\n    this.#ensure(length);\n    return this.readBytes(length);\n  }\n\n  readBool(): boolean {\n    const value = this.#view.getUint8(this.#offset);\n    this.#offset += 1;\n    return value !== 0;\n  }\n\n  readByte(): number {\n    const value = this.#view.getUint8(this.#offset);\n    this.#offset += 1;\n    return value;\n  }\n\n  readBytes(length: number): Uint8Array {\n    // Create a Uint8Array view over the DataView's buffer at the current offset\n    // The #view.buffer is the whole ArrayBuffer, so we need to account for the\n    // #view's starting position in that buffer (#view.byteOffset) and the current #offset\n    const array = new Uint8Array(\n      this.#view.buffer,\n      this.#view.byteOffset + this.#offset,\n      length\n    );\n    this.#offset += length;\n    return array;\n  }\n\n  readI8(): number {\n    const value = this.#view.getInt8(this.#offset);\n    this.#offset += 1;\n    return value;\n  }\n\n  readU8(): number {\n    return this.readByte();\n  }\n\n  readI16(): number {\n    const value = this.#view.getInt16(this.#offset, true);\n    this.#offset += 2;\n    return value;\n  }\n\n  readU16(): number {\n    const value = this.#view.getUint16(this.#offset, true);\n    this.#offset += 2;\n    return value;\n  }\n\n  readI32(): number {\n    const value = this.#view.getInt32(this.#offset, true);\n    this.#offset += 4;\n    return value;\n  }\n\n  readU32(): number {\n    const value = this.#view.getUint32(this.#offset, true);\n    this.#offset += 4;\n    return value;\n  }\n\n  readI64(): bigint {\n    const value = this.#view.getBigInt64(this.#offset, true);\n    this.#offset += 8;\n    return value;\n  }\n\n  readU64(): bigint {\n    const value = this.#view.getBigUint64(this.#offset, true);\n    this.#offset += 8;\n    return value;\n  }\n\n  readU128(): bigint {\n    const lowerPart = this.#view.getBigUint64(this.#offset, true);\n    const upperPart = this.#view.getBigUint64(this.#offset + 8, true);\n    this.#offset += 16;\n\n    return (upperPart << BigInt(64)) + lowerPart;\n  }\n\n  readI128(): bigint {\n    const lowerPart = this.#view.getBigUint64(this.#offset, true);\n    const upperPart = this.#view.getBigInt64(this.#offset + 8, true);\n    this.#offset += 16;\n\n    return (upperPart << BigInt(64)) + lowerPart;\n  }\n\n  readU256(): bigint {\n    const p0 = this.#view.getBigUint64(this.#offset, true);\n    const p1 = this.#view.getBigUint64(this.#offset + 8, true);\n    const p2 = this.#view.getBigUint64(this.#offset + 16, true);\n    const p3 = this.#view.getBigUint64(this.#offset + 24, true);\n    this.#offset += 32;\n\n    return (\n      (p3 << BigInt(3 * 64)) +\n      (p2 << BigInt(2 * 64)) +\n      (p1 << BigInt(1 * 64)) +\n      p0\n    );\n  }\n\n  readI256(): bigint {\n    const p0 = this.#view.getBigUint64(this.#offset, true);\n    const p1 = this.#view.getBigUint64(this.#offset + 8, true);\n    const p2 = this.#view.getBigUint64(this.#offset + 16, true);\n    const p3 = this.#view.getBigInt64(this.#offset + 24, true);\n    this.#offset += 32;\n\n    return (\n      (p3 << BigInt(3 * 64)) +\n      (p2 << BigInt(2 * 64)) +\n      (p1 << BigInt(1 * 64)) +\n      p0\n    );\n  }\n\n  readF32(): number {\n    const value = this.#view.getFloat32(this.#offset, true);\n    this.#offset += 4;\n    return value;\n  }\n\n  readF64(): number {\n    const value = this.#view.getFloat64(this.#offset, true);\n    this.#offset += 8;\n    return value;\n  }\n\n  readString(): string {\n    const uint8Array = this.readUInt8Array();\n    return new TextDecoder('utf-8').decode(uint8Array);\n  }\n}\n","import BinaryReader from './binary_reader';\nimport BinaryWriter from './binary_writer';\nimport type { CamelCase, SnakeCase } from './type_util';\n\n/**\n * Converts a string to PascalCase (UpperCamelCase).\n * @param str The string to convert\n * @returns The converted string\n */\nexport function toPascalCase(s: string): string {\n  const str = s.replace(/([-_][a-z])/gi, $1 => {\n    return $1.toUpperCase().replace('-', '').replace('_', '');\n  });\n\n  return str.charAt(0).toUpperCase() + str.slice(1);\n}\n\nexport function deepEqual(obj1: any, obj2: any): boolean {\n  // If both are strictly equal (covers primitives and reference equality), return true\n  if (obj1 === obj2) return true;\n\n  // If either is a primitive type or one is null, return false since we already checked for strict equality\n  if (\n    typeof obj1 !== 'object' ||\n    obj1 === null ||\n    typeof obj2 !== 'object' ||\n    obj2 === null\n  ) {\n    return false;\n  }\n\n  // Get keys of both objects\n  const keys1 = Object.keys(obj1);\n  const keys2 = Object.keys(obj2);\n\n  // If number of keys is different, return false\n  if (keys1.length !== keys2.length) return false;\n\n  // Check all keys and compare values recursively\n  for (const key of keys1) {\n    if (!keys2.includes(key) || !deepEqual(obj1[key], obj2[key])) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nexport function uint8ArrayToHexString(array: Uint8Array): string {\n  return Array.prototype.map\n    .call(array.reverse(), x => ('00' + x.toString(16)).slice(-2))\n    .join('');\n}\n\nexport function uint8ArrayToU128(array: Uint8Array): bigint {\n  if (array.length != 16) {\n    throw new Error(`Uint8Array is not 16 bytes long: ${array}`);\n  }\n  return new BinaryReader(array).readU128();\n}\n\nexport function uint8ArrayToU256(array: Uint8Array): bigint {\n  if (array.length != 32) {\n    throw new Error(`Uint8Array is not 32 bytes long: [${array}]`);\n  }\n  return new BinaryReader(array).readU256();\n}\n\nexport function hexStringToUint8Array(str: string): Uint8Array {\n  if (str.startsWith('0x')) {\n    str = str.slice(2);\n  }\n  const matches = str.match(/.{1,2}/g) || [];\n  const data = Uint8Array.from(\n    matches.map((byte: string) => parseInt(byte, 16))\n  );\n  return data.reverse();\n}\n\nexport function hexStringToU128(str: string): bigint {\n  return uint8ArrayToU128(hexStringToUint8Array(str));\n}\n\nexport function hexStringToU256(str: string): bigint {\n  return uint8ArrayToU256(hexStringToUint8Array(str));\n}\n\nexport function u128ToUint8Array(data: bigint): Uint8Array {\n  const writer = new BinaryWriter(16);\n  writer.writeU128(data);\n  return writer.getBuffer();\n}\n\nexport function u128ToHexString(data: bigint): string {\n  return uint8ArrayToHexString(u128ToUint8Array(data));\n}\n\nexport function u256ToUint8Array(data: bigint): Uint8Array {\n  const writer = new BinaryWriter(32);\n  writer.writeU256(data);\n  return writer.getBuffer();\n}\n\nexport function u256ToHexString(data: bigint): string {\n  return uint8ArrayToHexString(u256ToUint8Array(data));\n}\n\n/**\n * Type safe conversion from a string like \"some_identifier-name\" to \"someIdentifierName\".\n * @param str The string to convert\n * @returns The converted string\n */\nexport function toCamelCase<T extends string>(str: T): CamelCase<T> {\n  return str\n    .replace(/[-_]+/g, '_') // collapse runs to a single separator (no backtracking issue)\n    .replace(/_([a-zA-Z0-9])/g, (_, c) => c.toUpperCase()) as CamelCase<T>;\n}\n\n/** Type safe conversion from a string like \"some_Identifier-name\" to \"some_identifier_name\".\n * @param str The string to convert\n * @returns The converted string\n */\nexport function toSnakeCase<T extends string>(str: T): SnakeCase<T> {\n  return str\n    .replace(/([A-Z])/g, '_$1') // insert underscores before capitals\n    .replace(/[-\\s]+/g, '_') // replace spaces and dashes with underscores\n    .toLowerCase() as SnakeCase<T>;\n}\n\nimport type { AlgebraicType } from './algebraic_type';\nimport type Typespace from './autogen/typespace_type';\nimport type { ColumnBuilder, Infer, TypeBuilder } from './type_builders';\nimport type { ParamsObj } from './reducers';\n\nexport function bsatnBaseSize(\n  typespace: Infer<typeof Typespace>,\n  ty: AlgebraicType\n): number {\n  const assumedArrayLength = 4;\n  while (ty.tag === 'Ref') ty = typespace.types[ty.value];\n  if (ty.tag === 'Product') {\n    let sum = 0;\n    for (const { algebraicType: elem } of ty.value.elements) {\n      sum += bsatnBaseSize(typespace, elem);\n    }\n    return sum;\n  } else if (ty.tag === 'Sum') {\n    let min = Infinity;\n    for (const { algebraicType: vari } of ty.value.variants) {\n      const vSize = bsatnBaseSize(typespace, vari);\n      if (vSize < min) min = vSize;\n    }\n    if (min === Infinity) min = 0;\n    return 4 + min;\n  } else if (ty.tag == 'Array') {\n    return 4 + assumedArrayLength * bsatnBaseSize(typespace, ty.value);\n  }\n  return {\n    String: 4 + assumedArrayLength,\n    Sum: 1,\n    Bool: 1,\n    I8: 1,\n    U8: 1,\n    I16: 2,\n    U16: 2,\n    I32: 4,\n    U32: 4,\n    F32: 4,\n    I64: 8,\n    U64: 8,\n    F64: 8,\n    I128: 16,\n    U128: 16,\n    I256: 32,\n    U256: 32,\n  }[ty.tag];\n}\n\nexport type CoerceTypeBuilder<\n  Col extends TypeBuilder<any, any> | ColumnBuilder<any, any, any>,\n> = Col extends ColumnBuilder<any, any> ? Col['typeBuilder'] : Col;\n\nexport type CoerceParams<Params extends ParamsObj> = {\n  [k in keyof Params & string]: CoerceTypeBuilder<Params[k]>;\n};\n\nexport function coerceParams<Params extends ParamsObj>(\n  params: Params\n): CoerceParams<Params> {\n  return Object.fromEntries(\n    Object.entries(params).map(([n, c]) => [\n      n,\n      'typeBuilder' in c ? c.typeBuilder : c,\n    ])\n  ) as CoerceParams<Params>;\n}\n","import { AlgebraicType } from './algebraic_type';\nimport { hexStringToU256, u256ToHexString, u256ToUint8Array } from './util';\n\nexport type IdentityAlgebraicType = {\n  tag: 'Product';\n  value: {\n    elements: [{ name: '__identity__'; algebraicType: { tag: 'U256' } }];\n  };\n};\n\n/**\n * A unique identifier for a user connected to a database.\n */\nexport class Identity {\n  __identity__: bigint;\n\n  /**\n   * Creates a new `Identity`.\n   *\n   * `data` can be a hexadecimal string or a `bigint`.\n   */\n  constructor(data: string | bigint) {\n    // we get a JSON with __identity__ when getting a token with a JSON API\n    // and an bigint when using BSATN\n    this.__identity__ = typeof data === 'string' ? hexStringToU256(data) : data;\n  }\n\n  /**\n   * Get the algebraic type representation of the {@link Identity} type.\n   * @returns The algebraic type representation of the type.\n   */\n  static getAlgebraicType(): IdentityAlgebraicType {\n    return AlgebraicType.Product({\n      elements: [{ name: '__identity__', algebraicType: AlgebraicType.U256 }],\n    });\n  }\n\n  /**\n   * Check if two identities are equal.\n   */\n  isEqual(other: Identity): boolean {\n    return this.toHexString() === other.toHexString();\n  }\n\n  /**\n   * Check if two identities are equal.\n   */\n  equals(other: Identity): boolean {\n    return this.isEqual(other);\n  }\n\n  /**\n   * Print the identity as a hexadecimal string.\n   */\n  toHexString(): string {\n    return u256ToHexString(this.__identity__);\n  }\n\n  /**\n   * Convert the address to a Uint8Array.\n   */\n  toUint8Array(): Uint8Array {\n    return u256ToUint8Array(this.__identity__);\n  }\n\n  /**\n   * Parse an Identity from a hexadecimal string.\n   */\n  static fromString(str: string): Identity {\n    return new Identity(str);\n  }\n\n  /**\n   * Zero identity (0x0000000000000000000000000000000000000000000000000000000000000000)\n   */\n  static zero(): Identity {\n    return new Identity(0n);\n  }\n\n  toString(): string {\n    return this.toHexString();\n  }\n}\n","import { TimeDuration } from './time_duration';\nimport { Timestamp } from './timestamp';\nimport { Uuid } from './uuid';\nimport { ConnectionId } from './connection_id';\nimport type BinaryReader from './binary_reader';\nimport BinaryWriter from './binary_writer';\nimport { Identity } from './identity';\nimport * as AlgebraicTypeVariants from './algebraic_type_variants';\n\ntype TypespaceType = {\n  types: AlgebraicTypeType[];\n};\n\nexport type ProductTypeType = {\n  elements: ProductTypeElement[];\n};\n\n/**\n * A factor / element of a product type.\n *\n * An element consist of an optional name and a type.\n *\n * NOTE: Each element has an implicit element tag based on its order.\n * Uniquely identifies an element similarly to protobuf tags.\n */\nexport type ProductTypeElement = {\n  name: string | undefined;\n  algebraicType: AlgebraicTypeType;\n};\n\nexport type SumTypeType = {\n  variants: SumTypeVariant[];\n};\n\n/**\n * A variant of a sum type.\n *\n * NOTE: Each element has an implicit element tag based on its order.\n * Uniquely identifies an element similarly to protobuf tags.\n */\nexport type SumTypeVariant = {\n  name: string | undefined;\n  algebraicType: AlgebraicTypeType;\n};\n\nexport type AlgebraicTypeType =\n  | AlgebraicTypeVariants.Ref\n  | AlgebraicTypeVariants.Sum\n  | AlgebraicTypeVariants.Product\n  | AlgebraicTypeVariants.Array\n  | AlgebraicTypeVariants.String\n  | AlgebraicTypeVariants.Bool\n  | AlgebraicTypeVariants.I8\n  | AlgebraicTypeVariants.U8\n  | AlgebraicTypeVariants.I16\n  | AlgebraicTypeVariants.U16\n  | AlgebraicTypeVariants.I32\n  | AlgebraicTypeVariants.U32\n  | AlgebraicTypeVariants.I64\n  | AlgebraicTypeVariants.U64\n  | AlgebraicTypeVariants.I128\n  | AlgebraicTypeVariants.U128\n  | AlgebraicTypeVariants.I256\n  | AlgebraicTypeVariants.U256\n  | AlgebraicTypeVariants.F32\n  | AlgebraicTypeVariants.F64;\n\nexport type AlgebraicType = AlgebraicTypeType;\n\n/**\n * The variant types of the Algebraic Type tagged union.\n */\nexport { AlgebraicTypeVariants };\n\n// A value with helper functions to construct the type.\nexport const AlgebraicType = {\n  Ref: (value: number): AlgebraicTypeVariants.Ref => ({ tag: 'Ref', value }),\n  Sum: <T extends SumTypeType>(value: T): { tag: 'Sum'; value: T } => ({\n    tag: 'Sum',\n    value,\n  }),\n  Product: <T extends ProductTypeType>(\n    value: T\n  ): { tag: 'Product'; value: T } => ({\n    tag: 'Product',\n    value,\n  }),\n  Array: <T extends AlgebraicTypeType>(\n    value: T\n  ): { tag: 'Array'; value: T } => ({\n    tag: 'Array',\n    value,\n  }),\n  String: { tag: 'String' } as const,\n  Bool: { tag: 'Bool' } as const,\n  I8: { tag: 'I8' } as const,\n  U8: { tag: 'U8' } as const,\n  I16: { tag: 'I16' } as const,\n  U16: { tag: 'U16' } as const,\n  I32: { tag: 'I32' } as const,\n  U32: { tag: 'U32' } as const,\n  I64: { tag: 'I64' } as const,\n  U64: { tag: 'U64' } as const,\n  I128: { tag: 'I128' } as const,\n  U128: { tag: 'U128' } as const,\n  I256: { tag: 'I256' } as const,\n  U256: { tag: 'U256' } as const,\n  F32: { tag: 'F32' } as const,\n  F64: { tag: 'F64' } as const,\n  serializeValue(\n    writer: BinaryWriter,\n    ty: AlgebraicTypeType,\n    value: any,\n    typespace?: TypespaceType\n  ) {\n    if (ty.tag === 'Ref') {\n      if (!typespace)\n        throw new Error('cannot serialize refs without a typespace');\n      while (ty.tag === 'Ref') ty = typespace.types[ty.value];\n    }\n    switch (ty.tag) {\n      case 'Product':\n        ProductType.serializeValue(writer, ty.value, value, typespace);\n        break;\n      case 'Sum':\n        SumType.serializeValue(writer, ty.value, value, typespace);\n        break;\n      case 'Array':\n        if (ty.value.tag === 'U8') {\n          writer.writeUInt8Array(value);\n        } else {\n          const elemType = ty.value;\n          writer.writeU32(value.length);\n          for (const elem of value) {\n            AlgebraicType.serializeValue(writer, elemType, elem, typespace);\n          }\n        }\n        break;\n      case 'Bool':\n        writer.writeBool(value);\n        break;\n      case 'I8':\n        writer.writeI8(value);\n        break;\n      case 'U8':\n        writer.writeU8(value);\n        break;\n      case 'I16':\n        writer.writeI16(value);\n        break;\n      case 'U16':\n        writer.writeU16(value);\n        break;\n      case 'I32':\n        writer.writeI32(value);\n        break;\n      case 'U32':\n        writer.writeU32(value);\n        break;\n      case 'I64':\n        writer.writeI64(value);\n        break;\n      case 'U64':\n        writer.writeU64(value);\n        break;\n      case 'I128':\n        writer.writeI128(value);\n        break;\n      case 'U128':\n        writer.writeU128(value);\n        break;\n      case 'I256':\n        writer.writeI256(value);\n        break;\n      case 'U256':\n        writer.writeU256(value);\n        break;\n      case 'F32':\n        writer.writeF32(value);\n        break;\n      case 'F64':\n        writer.writeF64(value);\n        break;\n      case 'String':\n        writer.writeString(value);\n        break;\n    }\n  },\n  deserializeValue: function (\n    reader: BinaryReader,\n    ty: AlgebraicTypeType,\n    typespace?: TypespaceType\n  ): any {\n    if (ty.tag === 'Ref') {\n      if (!typespace)\n        throw new Error('cannot deserialize refs without a typespace');\n      while (ty.tag === 'Ref') ty = typespace.types[ty.value];\n    }\n    switch (ty.tag) {\n      case 'Product':\n        return ProductType.deserializeValue(reader, ty.value, typespace);\n      case 'Sum':\n        return SumType.deserializeValue(reader, ty.value, typespace);\n      case 'Array':\n        if (ty.value.tag === 'U8') {\n          return reader.readUInt8Array();\n        } else {\n          const elemType = ty.value;\n          const length = reader.readU32();\n          const result: any[] = [];\n          for (let i = 0; i < length; i++) {\n            result.push(\n              AlgebraicType.deserializeValue(reader, elemType, typespace)\n            );\n          }\n          return result;\n        }\n      case 'Bool':\n        return reader.readBool();\n      case 'I8':\n        return reader.readI8();\n      case 'U8':\n        return reader.readU8();\n      case 'I16':\n        return reader.readI16();\n      case 'U16':\n        return reader.readU16();\n      case 'I32':\n        return reader.readI32();\n      case 'U32':\n        return reader.readU32();\n      case 'I64':\n        return reader.readI64();\n      case 'U64':\n        return reader.readU64();\n      case 'I128':\n        return reader.readI128();\n      case 'U128':\n        return reader.readU128();\n      case 'I256':\n        return reader.readI256();\n      case 'U256':\n        return reader.readU256();\n      case 'F32':\n        return reader.readF32();\n      case 'F64':\n        return reader.readF64();\n      case 'String':\n        return reader.readString();\n    }\n  },\n  /**\n   * Convert a value of the algebraic type into something that can be used as a key in a map.\n   * There are no guarantees about being able to order it.\n   * This is only guaranteed to be comparable to other values of the same type.\n   * @param value A value of the algebraic type\n   * @returns Something that can be used as a key in a map.\n   */\n  intoMapKey: function (\n    ty: AlgebraicTypeType,\n    value: any\n  ): ComparablePrimitive {\n    switch (ty.tag) {\n      case 'U8':\n      case 'U16':\n      case 'U32':\n      case 'U64':\n      case 'U128':\n      case 'U256':\n      case 'I8':\n      case 'I16':\n      case 'I32':\n      case 'I64':\n      case 'I128':\n      case 'I256':\n      case 'F32':\n      case 'F64':\n      case 'String':\n      case 'Bool':\n        return value;\n      case 'Product':\n        return ProductType.intoMapKey(ty.value, value);\n      default: {\n        // The fallback is to serialize and base64 encode the bytes.\n        const writer = new BinaryWriter(10);\n        AlgebraicType.serializeValue(writer, ty, value);\n        return writer.toBase64();\n      }\n    }\n  },\n};\n\n/**\n * A structural product type  of the factors given by `elements`.\n *\n * This is also known as `struct` and `tuple` in many languages,\n * but note that unlike most languages, products in SATs are *[structural]* and not nominal.\n * When checking whether two nominal types are the same,\n * their names and/or declaration sites (e.g., module / namespace) are considered.\n * Meanwhile, a structural type system would only check the structure of the type itself,\n * e.g., the names of its fields and their types in the case of a record.\n * The name \"product\" comes from category theory.\n *\n * See also: https://ncatlab.org/nlab/show/product+type.\n *\n * These structures are known as product types because the number of possible values in product\n * ```ignore\n * { N_0: T_0, N_1: T_1, ..., N_n: T_n }\n * ```\n * is:\n * ```ignore\n *  (i  0..n). values(T_i)\n * ```\n * so for example, `values({ A: U64, B: Bool }) = values(U64) * values(Bool)`.\n *\n * [structural]: https://en.wikipedia.org/wiki/Structural_type_system\n */\nexport type ProductType = ProductTypeType;\n\nexport const ProductType = {\n  serializeValue(\n    writer: BinaryWriter,\n    ty: ProductTypeType,\n    value: any,\n    typespace?: TypespaceType\n  ): void {\n    for (const element of ty.elements) {\n      AlgebraicType.serializeValue(\n        writer,\n        element.algebraicType,\n        value[element.name!],\n        typespace\n      );\n    }\n  },\n  deserializeValue(\n    reader: BinaryReader,\n    ty: ProductTypeType,\n    typespace?: TypespaceType\n  ): any {\n    const result: { [key: string]: any } = {};\n    if (ty.elements.length === 1) {\n      if (ty.elements[0].name === '__time_duration_micros__') {\n        return new TimeDuration(reader.readI64());\n      }\n\n      if (ty.elements[0].name === '__timestamp_micros_since_unix_epoch__') {\n        return new Timestamp(reader.readI64());\n      }\n\n      if (ty.elements[0].name === '__identity__') {\n        return new Identity(reader.readU256());\n      }\n\n      if (ty.elements[0].name === '__connection_id__') {\n        return new ConnectionId(reader.readU128());\n      }\n\n      if (ty.elements[0].name === '__uuid__') {\n        return new Uuid(reader.readU128());\n      }\n    }\n\n    for (const element of ty.elements) {\n      result[element.name!] = AlgebraicType.deserializeValue(\n        reader,\n        element.algebraicType,\n        typespace\n      );\n    }\n    return result;\n  },\n  intoMapKey(ty: ProductTypeType, value: any): ComparablePrimitive {\n    if (ty.elements.length === 1) {\n      if (ty.elements[0].name === '__time_duration_micros__') {\n        return (value as TimeDuration).__time_duration_micros__;\n      }\n\n      if (ty.elements[0].name === '__timestamp_micros_since_unix_epoch__') {\n        return (value as Timestamp).__timestamp_micros_since_unix_epoch__;\n      }\n\n      if (ty.elements[0].name === '__identity__') {\n        return (value as Identity).__identity__;\n      }\n\n      if (ty.elements[0].name === '__connection_id__') {\n        return (value as ConnectionId).__connection_id__;\n      }\n\n      if (ty.elements[0].name === '__uuid__') {\n        return (value as Uuid).__uuid__;\n      }\n    }\n    // The fallback is to serialize and base64 encode the bytes.\n    const writer = new BinaryWriter(10);\n    AlgebraicType.serializeValue(writer, AlgebraicType.Product(ty), value);\n    return writer.toBase64();\n  },\n};\n\nexport type SumType = SumTypeType;\n\n/**\n * Unlike most languages, sums in SATS are *[structural]* and not nominal.\n * When checking whether two nominal types are the same,\n * their names and/or declaration sites (e.g., module / namespace) are considered.\n * Meanwhile, a structural type system would only check the structure of the type itself,\n * e.g., the names of its variants and their inner data types in the case of a sum.\n *\n * This is also known as a discriminated union (implementation) or disjoint union.\n * Another name is [coproduct (category theory)](https://ncatlab.org/nlab/show/coproduct).\n *\n * These structures are known as sum types because the number of possible values a sum\n * ```ignore\n * { N_0(T_0), N_1(T_1), ..., N_n(T_n) }\n * ```\n * is:\n * ```ignore\n *  (i  0..n). values(T_i)\n * ```\n * so for example, `values({ A(U64), B(Bool) }) = values(U64) + values(Bool)`.\n *\n * See also: https://ncatlab.org/nlab/show/sum+type.\n *\n * [structural]: https://en.wikipedia.org/wiki/Structural_type_system\n */\nexport const SumType = {\n  serializeValue: function (\n    writer: BinaryWriter,\n    ty: SumTypeType,\n    value: any,\n    typespace?: TypespaceType\n  ): void {\n    if (\n      ty.variants.length == 2 &&\n      ty.variants[0].name === 'some' &&\n      ty.variants[1].name === 'none'\n    ) {\n      if (value !== null && value !== undefined) {\n        writer.writeByte(0);\n        AlgebraicType.serializeValue(\n          writer,\n          ty.variants[0].algebraicType,\n          value,\n          typespace\n        );\n      } else {\n        writer.writeByte(1);\n      }\n    } else if (\n      ty.variants.length == 2 &&\n      ty.variants[0].name === 'ok' &&\n      ty.variants[1].name === 'err'\n    ) {\n      let variantName: 'ok' | 'err';\n      let innerValue: any;\n      let index: number;\n      if ('ok' in value) {\n        variantName = 'ok';\n        innerValue = value.ok;\n        index = 0;\n      } else {\n        variantName = 'err';\n        innerValue = value.err;\n        index = 1;\n      }\n\n      if (index < 0) {\n        throw `Result serialization error: variant '${variantName}' not found in ${JSON.stringify(ty)}`;\n      }\n\n      writer.writeU8(index);\n\n      AlgebraicType.serializeValue(\n        writer,\n        ty.variants[index].algebraicType,\n        innerValue,\n        typespace\n      );\n    } else {\n      const variant = value['tag'];\n      const index = ty.variants.findIndex(v => v.name === variant);\n      if (index < 0) {\n        throw `Can't serialize a sum type, couldn't find ${value.tag} tag ${JSON.stringify(value)} in variants ${JSON.stringify(ty)}`;\n      }\n      writer.writeU8(index);\n      AlgebraicType.serializeValue(\n        writer,\n        ty.variants[index].algebraicType,\n        value['value'],\n        typespace\n      );\n    }\n  },\n  deserializeValue: function (\n    reader: BinaryReader,\n    ty: SumTypeType,\n    typespace?: TypespaceType\n  ): any {\n    const tag = reader.readU8();\n    // In TypeScript we handle Option values as a special case\n    // we don't represent the some and none variants, but instead\n    // we represent the value directly.\n    if (\n      ty.variants.length == 2 &&\n      ty.variants[0].name === 'some' &&\n      ty.variants[1].name === 'none'\n    ) {\n      if (tag === 0) {\n        return AlgebraicType.deserializeValue(\n          reader,\n          ty.variants[0].algebraicType,\n          typespace\n        );\n      } else if (tag === 1) {\n        return undefined;\n      } else {\n        throw `Can't deserialize an option type, couldn't find ${tag} tag`;\n      }\n    } else if (\n      ty.variants.length == 2 &&\n      ty.variants[0].name === 'ok' &&\n      ty.variants[1].name === 'err'\n    ) {\n      if (tag === 0) {\n        const value = AlgebraicType.deserializeValue(\n          reader,\n          ty.variants[0].algebraicType,\n          typespace\n        );\n        return { ok: value };\n      } else if (tag === 1) {\n        const value = AlgebraicType.deserializeValue(\n          reader,\n          ty.variants[1].algebraicType,\n          typespace\n        );\n        return { err: value };\n      } else {\n        throw `Can't deserialize a result type, couldn't find ${tag} tag`;\n      }\n    } else {\n      const variant = ty.variants[tag];\n      const value = AlgebraicType.deserializeValue(\n        reader,\n        variant.algebraicType,\n        typespace\n      );\n      return { tag: variant.name, value };\n    }\n  },\n};\n\nexport type ComparablePrimitive = number | string | boolean | bigint;\n","import { AlgebraicType } from './algebraic_type';\nimport { hexStringToU128, u128ToHexString, u128ToUint8Array } from './util';\n\nexport type ConnectionIdAlgebraicType = {\n  tag: 'Product';\n  value: {\n    elements: [{ name: '__connection_id__'; algebraicType: { tag: 'U128' } }];\n  };\n};\n\n/**\n * A unique identifier for a client connected to a database.\n */\nexport class ConnectionId {\n  __connection_id__: bigint;\n\n  /**\n   * Creates a new `ConnectionId`.\n   */\n  constructor(data: bigint) {\n    this.__connection_id__ = data;\n  }\n\n  /**\n   * Get the algebraic type representation of the {@link ConnectionId} type.\n   * @returns The algebraic type representation of the type.\n   */\n  static getAlgebraicType(): ConnectionIdAlgebraicType {\n    return AlgebraicType.Product({\n      elements: [\n        { name: '__connection_id__', algebraicType: AlgebraicType.U128 },\n      ],\n    });\n  }\n\n  isZero(): boolean {\n    return this.__connection_id__ === BigInt(0);\n  }\n\n  static nullIfZero(addr: ConnectionId): ConnectionId | null {\n    if (addr.isZero()) {\n      return null;\n    } else {\n      return addr;\n    }\n  }\n\n  static random(): ConnectionId {\n    function randomU8(): number {\n      return Math.floor(Math.random() * 0xff);\n    }\n    let result = BigInt(0);\n    for (let i = 0; i < 16; i++) {\n      result = (result << BigInt(8)) | BigInt(randomU8());\n    }\n    return new ConnectionId(result);\n  }\n\n  /**\n   * Compare two connection IDs for equality.\n   */\n  isEqual(other: ConnectionId): boolean {\n    return this.__connection_id__ == other.__connection_id__;\n  }\n\n  /**\n   * Check if two connection IDs are equal.\n   */\n  equals(other: ConnectionId): boolean {\n    return this.isEqual(other);\n  }\n\n  /**\n   * Print the connection ID as a hexadecimal string.\n   */\n  toHexString(): string {\n    return u128ToHexString(this.__connection_id__);\n  }\n\n  /**\n   * Convert the connection ID to a Uint8Array.\n   */\n  toUint8Array(): Uint8Array {\n    return u128ToUint8Array(this.__connection_id__);\n  }\n\n  /**\n   * Parse a connection ID from a hexadecimal string.\n   */\n  static fromString(str: string): ConnectionId {\n    return new ConnectionId(hexStringToU128(str));\n  }\n\n  static fromStringOrNull(str: string): ConnectionId | null {\n    const addr = ConnectionId.fromString(str);\n    if (addr.isZero()) {\n      return null;\n    } else {\n      return addr;\n    }\n  }\n}\n","import { createContext, useContext } from 'react';\nimport type { ConnectionState } from './connection_state';\n\nexport const SpacetimeDBContext = createContext<ConnectionState | undefined>(\n  undefined\n);\n\n// Throws an error if used outside of a SpacetimeDBProvider\n// Error is caught by other hooks like useTable so they can provide better error messages\nexport function useSpacetimeDB(): ConnectionState {\n  const context = useContext(SpacetimeDBContext) as ConnectionState | undefined;\n  if (!context) {\n    throw new Error(\n      'useSpacetimeDB must be used within a SpacetimeDBProvider component. Did you forget to add a `SpacetimeDBProvider` to your component tree?'\n    );\n  }\n  return context;\n}\n","import {\n  DbConnectionBuilder,\n  type DbConnectionImpl,\n  type ErrorContextInterface,\n  type RemoteModuleOf,\n} from '../sdk/db_connection_impl';\nimport * as React from 'react';\nimport { SpacetimeDBContext } from './useSpacetimeDB';\nimport type { ConnectionState } from './connection_state';\nimport { ConnectionId } from '../lib/connection_id';\n\nexport interface SpacetimeDBProviderProps<\n  DbConnection extends DbConnectionImpl<any>,\n> {\n  connectionBuilder: DbConnectionBuilder<DbConnection>;\n  children?: React.ReactNode;\n}\n\nexport function SpacetimeDBProvider<\n  DbConnection extends DbConnectionImpl<any>,\n>({\n  connectionBuilder,\n  children,\n}: SpacetimeDBProviderProps<DbConnection>): React.JSX.Element {\n  // Holds the imperative connection instance when (and only when) were on the client.\n  const connRef = React.useRef<DbConnection | null>(null);\n  const getConnection = React.useCallback(() => connRef.current, []);\n\n  const [state, setState] = React.useState<ConnectionState>({\n    isActive: false,\n    identity: undefined,\n    token: undefined,\n    connectionId: ConnectionId.random(),\n    connectionError: undefined,\n    getConnection: getConnection as ConnectionState['getConnection'],\n  });\n\n  // Build on the client only; useEffect won't run during SSR.\n  React.useEffect(() => {\n    if (!connRef.current) {\n      connRef.current = connectionBuilder.build();\n    }\n    // Register callback for onConnect to update state\n    const onConnect = (conn: DbConnection) => {\n      setState(s => ({\n        ...s,\n        isActive: conn.isActive,\n        identity: conn.identity,\n        token: conn.token,\n        connectionId: conn.connectionId,\n      }));\n    };\n    const onDisconnect = (\n      ctx: ErrorContextInterface<RemoteModuleOf<DbConnection>>\n    ) => {\n      setState(s => ({\n        ...s,\n        isActive: ctx.isActive,\n      }));\n    };\n    const onConnectError = (\n      ctx: ErrorContextInterface<RemoteModuleOf<DbConnection>>,\n      err: Error\n    ) => {\n      setState(s => ({\n        ...s,\n        isActive: ctx.isActive,\n        connectionError: err,\n      }));\n    };\n    connectionBuilder.onConnect(onConnect);\n    connectionBuilder.onDisconnect(onDisconnect);\n    connectionBuilder.onConnectError(onConnectError);\n\n    const conn = connRef.current;\n    setState(s => ({\n      ...s,\n      isActive: conn.isActive,\n      identity: conn.identity,\n      token: conn.token,\n      connectionId: conn.connectionId,\n    }));\n\n    return () => {\n      connRef.current?.removeOnConnect(onConnect as any);\n      connRef.current?.removeOnDisconnect(onDisconnect as any);\n      connRef.current?.removeOnConnectError(onConnectError as any);\n      connRef.current?.disconnect();\n      connRef.current = null;\n    };\n  }, [connectionBuilder]);\n\n  return React.createElement(\n    SpacetimeDBContext.Provider,\n    { value: state },\n    children\n  );\n}\n","import {\n  useCallback,\n  useEffect,\n  useRef,\n  useState,\n  useSyncExternalStore,\n} from 'react';\nimport { useSpacetimeDB } from './useSpacetimeDB';\nimport { type EventContextInterface } from '../sdk/db_connection_impl';\nimport type { ConnectionState } from './connection_state';\nimport type { UntypedRemoteModule } from '../sdk/spacetime_module';\nimport type { RowType, UntypedTableDef } from '../lib/table';\nimport type { Prettify } from '../lib/type_util';\n\nexport interface UseTableCallbacks<RowType> {\n  onInsert?: (row: RowType) => void;\n  onDelete?: (row: RowType) => void;\n  onUpdate?: (oldRow: RowType, newRow: RowType) => void;\n}\n\nexport type Value = string | number | boolean;\n\nexport type Expr<Column extends string> =\n  | { type: 'eq'; key: Column; value: Value }\n  | { type: 'and'; children: Expr<Column>[] }\n  | { type: 'or'; children: Expr<Column>[] };\n\nexport const eq = <Column extends string>(\n  key: Column,\n  value: Value\n): Expr<Column> => ({ type: 'eq', key, value });\n\nexport const and = <Column extends string>(\n  ...children: Expr<Column>[]\n): Expr<Column> => {\n  const flat: Expr<Column>[] = [];\n  for (const c of children) {\n    if (!c) continue;\n    if (c.type === 'and') flat.push(...c.children);\n    else flat.push(c);\n  }\n  const pruned = flat.filter(Boolean);\n  if (pruned.length === 0) return { type: 'and', children: [] };\n  if (pruned.length === 1) return pruned[0];\n  return { type: 'and', children: pruned };\n};\n\nexport const or = <Column extends string>(\n  ...children: Expr<Column>[]\n): Expr<Column> => {\n  const flat: Expr<Column>[] = [];\n  for (const c of children) {\n    if (!c) continue;\n    if (c.type === 'or') flat.push(...c.children);\n    else flat.push(c);\n  }\n  const pruned = flat.filter(Boolean);\n  if (pruned.length === 0) return { type: 'or', children: [] };\n  if (pruned.length === 1) return pruned[0];\n  return { type: 'or', children: pruned };\n};\n\nexport const isEq = <Column extends string>(\n  e: Expr<Column>\n): e is Extract<Expr<Column>, { type: 'eq' }> => e.type === 'eq';\nexport const isAnd = <Column extends string>(\n  e: Expr<Column>\n): e is Extract<Expr<Column>, { type: 'and' }> => e.type === 'and';\nexport const isOr = <Column extends string>(\n  e: Expr<Column>\n): e is Extract<Expr<Column>, { type: 'or' }> => e.type === 'or';\n\nexport function evaluate<Column extends string>(\n  expr: Expr<Column>,\n  row: Record<Column, any>\n): boolean {\n  switch (expr.type) {\n    case 'eq': {\n      const v = row[expr.key];\n      if (\n        typeof v === 'string' ||\n        typeof v === 'number' ||\n        typeof v === 'boolean'\n      ) {\n        return v === expr.value;\n      }\n      return false;\n    }\n    case 'and':\n      return (\n        expr.children.length === 0 || expr.children.every(c => evaluate(c, row))\n      );\n    case 'or':\n      return (\n        expr.children.length !== 0 && expr.children.some(c => evaluate(c, row))\n      );\n  }\n}\n\nfunction formatValue(v: Value): string {\n  switch (typeof v) {\n    case 'string':\n      return `'${v.replace(/'/g, \"''\")}'`;\n    case 'number':\n      return Number.isFinite(v) ? String(v) : `'${String(v)}'`;\n    case 'boolean':\n      return v ? 'TRUE' : 'FALSE';\n  }\n}\n\nfunction escapeIdent(id: string): string {\n  if (/^[A-Za-z_][A-Za-z0-9_]*$/.test(id)) return id;\n  return `\"${id.replace(/\"/g, '\"\"')}\"`;\n}\n\nfunction parenthesize(s: string): string {\n  if (!s.includes(' AND ') && !s.includes(' OR ')) return s;\n  return `(${s})`;\n}\n\nexport function toString<TableDef extends UntypedTableDef>(\n  tableDef: TableDef,\n  expr: Expr<ColumnsFromRow<RowType<TableDef>>>\n): string {\n  switch (expr.type) {\n    case 'eq': {\n      const key = tableDef.columns[expr.key].columnMetadata.name ?? expr.key;\n      return `${escapeIdent(key)} = ${formatValue(expr.value)}`;\n    }\n    case 'and':\n      return parenthesize(\n        expr.children.map(expr => toString(tableDef, expr)).join(' AND ')\n      );\n    case 'or':\n      return parenthesize(\n        expr.children.map(expr => toString(tableDef, expr)).join(' OR ')\n      );\n  }\n}\n\n/**\n * This is just the identity function to make things look like SQL.\n * @param expr\n * @returns\n */\nexport function where<Column extends string>(expr: Expr<Column>): Expr<Column> {\n  return expr;\n}\n\ntype MembershipChange = 'enter' | 'leave' | 'stayIn' | 'stayOut';\n\nfunction classifyMembership<\n  Col extends string,\n  R extends Record<string, unknown>,\n>(where: Expr<Col> | undefined, oldRow: R, newRow: R): MembershipChange {\n  // No filter: everything is in, so updates are always \"stayIn\".\n  if (!where) {\n    return 'stayIn';\n  }\n\n  const oldIn = evaluate(where, oldRow);\n  const newIn = evaluate(where, newRow);\n\n  if (oldIn && !newIn) {\n    return 'leave';\n  }\n  if (!oldIn && newIn) {\n    return 'enter';\n  }\n  if (oldIn && newIn) {\n    return 'stayIn';\n  }\n  return 'stayOut';\n}\n\n/**\n * Extracts the column names from a RowType whose values are of type Value.\n * Note that this will exclude columns that are of type object, array, etc.\n */\ntype ColumnsFromRow<R> = {\n  [K in keyof R]-?: R[K] extends Value | undefined ? K : never;\n}[keyof R] &\n  string;\n\n/**\n * React hook to subscribe to a table in SpacetimeDB and receive live updates as rows are inserted, updated, or deleted.\n *\n * This hook returns a snapshot of the table's rows, filtered by an optional `where` clause, and provides a loading state\n * until the initial subscription is applied. It also allows you to specify callbacks for row insertions, deletions, and updates.\n *\n * The hook must be used within a component tree wrapped by `SpacetimeDBProvider`.\n *\n * Overloads:\n * - `useTable(tableName, where, callbacks?)`: Subscribe to a table with a filter and optional callbacks.\n * - `useTable(tableName, callbacks?)`: Subscribe to a table without a filter, with optional callbacks.\n *\n * @template DbConnection The type of the SpacetimeDB connection.\n * @template RowType The type of the table row.\n * @template TableName The name of the table.\n *\n * @param tableName - The name of the table to subscribe to.\n * @param whereClauseOrCallbacks - (Optional) Either a filter expression (where clause) or the callbacks object.\n * @param callbacks - (Optional) Callbacks for row insert, delete, and update events.\n *\n * @returns A snapshot object containing the current rows and the subscription state (`'loading'` or `'ready'`).\n *\n * @throws Error if the hook is used outside of a `SpacetimeDBProvider`.\n *\n * @example\n * ```tsx\n * const { rows, state } = useTable('users', where(eq('isActive', true)), {\n *   onInsert: (row) => console.log('Inserted:', row),\n *   onDelete: (row) => console.log('Deleted:', row),\n *   onUpdate: (oldRow, newRow) => console.log('Updated:', oldRow, newRow),\n * });\n * ```\n */\nexport function useTable<TableDef extends UntypedTableDef>(\n  tableDef: TableDef,\n  where: Expr<ColumnsFromRow<RowType<TableDef>>>,\n  callbacks?: UseTableCallbacks<Prettify<RowType<TableDef>>>\n): [readonly Prettify<RowType<TableDef>>[], boolean];\n\n/**\n * React hook to subscribe to a table in SpacetimeDB and receive live updates as rows are inserted, updated, or deleted.\n *\n * This hook returns a snapshot of the table's rows, filtered by an optional `where` clause, and provides a loading state\n * until the initial subscription is applied. It also allows you to specify callbacks for row insertions, deletions, and updates.\n *\n * The hook must be used within a component tree wrapped by `SpacetimeDBProvider`.\n *\n * Overloads:\n * - `useTable(tableName, where, callbacks?)`: Subscribe to a table with a filter and optional callbacks.\n * - `useTable(tableName, callbacks?)`: Subscribe to a table without a filter, with optional callbacks.\n *\n * @template DbConnection The type of the SpacetimeDB connection.\n * @template RowType The type of the table row.\n * @template TableName The name of the table.\n *\n * @param tableName - The name of the table to subscribe to.\n * @param whereClauseOrCallbacks - (Optional) Either a filter expression (where clause) or the callbacks object.\n * @param callbacks - (Optional) Callbacks for row insert, delete, and update events.\n *\n * @returns A snapshot object containing the current rows and the subscription state (`'loading'` or `'ready'`).\n *\n * @throws Error if the hook is used outside of a `SpacetimeDBProvider`.\n *\n * @example\n * ```tsx\n * const { rows, state } = useTable('users', where(eq('isActive', true)), {\n *   onInsert: (row) => console.log('Inserted:', row),\n *   onDelete: (row) => console.log('Deleted:', row),\n *   onUpdate: (oldRow, newRow) => console.log('Updated:', oldRow, newRow),\n * });\n * ```\n */\nexport function useTable<TableDef extends UntypedTableDef>(\n  tableDef: TableDef,\n  callbacks?: UseTableCallbacks<Prettify<RowType<TableDef>>>\n): [readonly Prettify<RowType<TableDef>>[], boolean];\n\nexport function useTable<TableDef extends UntypedTableDef>(\n  tableDef: TableDef,\n  whereClauseOrCallbacks?:\n    | Expr<ColumnsFromRow<RowType<TableDef>>>\n    | UseTableCallbacks<RowType<TableDef>>,\n  callbacks?: UseTableCallbacks<RowType<TableDef>>\n): [readonly Prettify<RowType<TableDef>>[], boolean] {\n  type UseTableRowType = RowType<TableDef>;\n  const tableName = tableDef.name;\n  const accessorName = tableDef.accessorName;\n  let whereClause: Expr<ColumnsFromRow<UseTableRowType>> | undefined;\n  if (\n    whereClauseOrCallbacks &&\n    typeof whereClauseOrCallbacks === 'object' &&\n    'type' in whereClauseOrCallbacks\n  ) {\n    whereClause = whereClauseOrCallbacks as Expr<\n      ColumnsFromRow<UseTableRowType>\n    >;\n  } else {\n    callbacks = whereClauseOrCallbacks as\n      | UseTableCallbacks<UseTableRowType>\n      | undefined;\n  }\n  const [subscribeApplied, setSubscribeApplied] = useState(false);\n  let connectionState: ConnectionState | undefined;\n  try {\n    connectionState = useSpacetimeDB();\n  } catch {\n    throw new Error(\n      'Could not find SpacetimeDB client! Did you forget to add a ' +\n        '`SpacetimeDBProvider`? `useTable` must be used in the React component tree ' +\n        'under a `SpacetimeDBProvider` component.'\n    );\n  }\n\n  const query =\n    `SELECT * FROM ${tableName}` +\n    (whereClause ? ` WHERE ${toString(tableDef, whereClause)}` : '');\n\n  const latestTransactionEvent = useRef<any>(null);\n  const lastSnapshotRef = useRef<\n    [readonly Prettify<UseTableRowType>[], boolean] | null\n  >(null);\n\n  const whereKey = whereClause ? toString(tableDef, whereClause) : '';\n\n  const computeSnapshot = useCallback((): [\n    readonly Prettify<UseTableRowType>[],\n    boolean,\n  ] => {\n    const connection = connectionState.getConnection();\n    if (!connection) {\n      return [[], false];\n    }\n    const table = connection.db[accessorName];\n    const result: readonly Prettify<UseTableRowType>[] = whereClause\n      ? (Array.from(table.iter()).filter(row =>\n          evaluate(whereClause, row as UseTableRowType)\n        ) as Prettify<UseTableRowType>[])\n      : (Array.from(table.iter()) as Prettify<UseTableRowType>[]);\n    return [result, subscribeApplied];\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [connectionState, accessorName, whereKey, subscribeApplied]);\n\n  useEffect(() => {\n    const connection = connectionState.getConnection()!;\n    if (connectionState.isActive && connection) {\n      const cancel = connection\n        .subscriptionBuilder()\n        .onApplied(() => {\n          setSubscribeApplied(true);\n        })\n        .subscribe(query);\n      return () => {\n        cancel.unsubscribe();\n      };\n    }\n  }, [query, connectionState.isActive, connectionState]);\n\n  const subscribe = useCallback(\n    (onStoreChange: () => void) => {\n      const onInsert = (\n        ctx: EventContextInterface<UntypedRemoteModule>,\n        row: any\n      ) => {\n        if (whereClause && !evaluate(whereClause, row)) {\n          return;\n        }\n        callbacks?.onInsert?.(row);\n        if (\n          ctx.event !== latestTransactionEvent.current ||\n          !latestTransactionEvent.current\n        ) {\n          latestTransactionEvent.current = ctx.event;\n          lastSnapshotRef.current = computeSnapshot();\n          onStoreChange();\n        }\n      };\n\n      const onDelete = (\n        ctx: EventContextInterface<UntypedRemoteModule>,\n        row: any\n      ) => {\n        if (whereClause && !evaluate(whereClause, row)) {\n          return;\n        }\n        callbacks?.onDelete?.(row);\n        if (\n          ctx.event !== latestTransactionEvent.current ||\n          !latestTransactionEvent.current\n        ) {\n          latestTransactionEvent.current = ctx.event;\n          lastSnapshotRef.current = computeSnapshot();\n          onStoreChange();\n        }\n      };\n\n      const onUpdate = (\n        ctx: EventContextInterface<UntypedRemoteModule>,\n        oldRow: any,\n        newRow: any\n      ) => {\n        const change = classifyMembership(whereClause, oldRow, newRow);\n\n        switch (change) {\n          case 'leave':\n            callbacks?.onDelete?.(oldRow);\n            break;\n          case 'enter':\n            callbacks?.onInsert?.(newRow);\n            break;\n          case 'stayIn':\n            callbacks?.onUpdate?.(oldRow, newRow);\n            break;\n          case 'stayOut':\n            return; // no-op\n        }\n\n        if (\n          ctx.event !== latestTransactionEvent.current ||\n          !latestTransactionEvent.current\n        ) {\n          latestTransactionEvent.current = ctx.event;\n          lastSnapshotRef.current = computeSnapshot();\n          onStoreChange();\n        }\n      };\n\n      const connection = connectionState.getConnection();\n      if (!connection) {\n        return () => {};\n      }\n\n      const table = connection.db[accessorName];\n      table.onInsert(onInsert);\n      table.onDelete(onDelete);\n      table.onUpdate?.(onUpdate);\n\n      return () => {\n        table.removeOnInsert(onInsert);\n        table.removeOnDelete(onDelete);\n        table.removeOnUpdate?.(onUpdate);\n      };\n    },\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    [\n      connectionState,\n      accessorName,\n      whereKey,\n      callbacks?.onDelete,\n      callbacks?.onInsert,\n      callbacks?.onUpdate,\n    ]\n  );\n\n  const getSnapshot = useCallback((): [\n    readonly Prettify<UseTableRowType>[],\n    boolean,\n  ] => {\n    if (!lastSnapshotRef.current) {\n      lastSnapshotRef.current = computeSnapshot();\n    }\n    return lastSnapshotRef.current;\n  }, [computeSnapshot]);\n\n  // SSR fallback can be the same getter\n  return useSyncExternalStore(subscribe, getSnapshot, getSnapshot);\n}\n","import { useCallback, useEffect, useRef } from 'react';\nimport type { InferTypeOfRow } from '../lib/type_builders';\nimport type { UntypedReducerDef } from '../sdk/reducers';\nimport { useSpacetimeDB } from './useSpacetimeDB';\nimport type { Prettify } from '../lib/type_util';\n\ntype IsEmptyObject<T> = [keyof T] extends [never] ? true : false;\ntype MaybeParams<T> = IsEmptyObject<T> extends true ? [] : [params: T];\n\ntype ParamsType<R extends UntypedReducerDef> = MaybeParams<\n  Prettify<InferTypeOfRow<R['params']>>\n>;\n\nexport function useReducer<ReducerDef extends UntypedReducerDef>(\n  reducerDef: ReducerDef\n): (...params: ParamsType<ReducerDef>) => void {\n  const { getConnection, isActive } = useSpacetimeDB();\n  const reducerName = reducerDef.accessorName;\n\n  // Holds calls made before the connection exists\n  const queueRef = useRef<ParamsType<ReducerDef>[]>([]);\n\n  // Flush when we finally have a connection\n  useEffect(() => {\n    const conn = getConnection();\n    if (!conn) {\n      return;\n    }\n    const fn = (conn.reducers as any)[reducerName] as (\n      ...p: ParamsType<ReducerDef>\n    ) => void;\n    if (queueRef.current.length) {\n      const pending = queueRef.current.splice(0);\n      for (const params of pending) {\n        fn(...params);\n      }\n    }\n  }, [getConnection, reducerName, isActive]);\n\n  return useCallback(\n    (...params: ParamsType<ReducerDef>) => {\n      const conn = getConnection();\n      if (!conn) {\n        queueRef.current.push(params);\n        return;\n      }\n      const fn = (conn.reducers as any)[reducerName] as (\n        ...p: ParamsType<ReducerDef>\n      ) => void;\n      return fn(...params);\n    },\n    [getConnection, reducerName]\n  );\n}\n"]}