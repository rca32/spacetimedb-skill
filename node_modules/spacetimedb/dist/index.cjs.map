{"version":3,"sources":["../src/lib/time_duration.ts","../src/lib/timestamp.ts","../src/lib/uuid.ts","../src/lib/binary_writer.ts","../src/lib/binary_reader.ts","../src/lib/util.ts","../src/lib/identity.ts","../src/lib/algebraic_type_variants.ts","../src/lib/algebraic_type.ts","../src/lib/connection_id.ts","../src/lib/algebraic_value.ts","../src/lib/schedule_at.ts","../src/lib/option.ts","../src/lib/result.ts","../src/lib/type_util.ts","../src/lib/type_builders.ts","../src/sdk/client_api/row_size_hint_type.ts","../src/sdk/client_api/bsatn_row_list_type.ts","../src/sdk/client_api/call_reducer_type.ts","../src/sdk/client_api/subscribe_type.ts","../src/sdk/client_api/one_off_query_type.ts","../src/sdk/client_api/query_id_type.ts","../src/sdk/client_api/subscribe_single_type.ts","../src/sdk/client_api/subscribe_multi_type.ts","../src/sdk/client_api/unsubscribe_type.ts","../src/sdk/client_api/unsubscribe_multi_type.ts","../src/sdk/client_api/call_procedure_type.ts","../src/sdk/client_api/client_message_type.ts","../src/sdk/client_api/query_update_type.ts","../src/sdk/client_api/compressable_query_update_type.ts","../src/sdk/client_api/table_update_type.ts","../src/sdk/client_api/database_update_type.ts","../src/sdk/client_api/initial_subscription_type.ts","../src/sdk/client_api/update_status_type.ts","../src/sdk/client_api/reducer_call_info_type.ts","../src/sdk/client_api/energy_quanta_type.ts","../src/sdk/client_api/transaction_update_type.ts","../src/sdk/client_api/transaction_update_light_type.ts","../src/sdk/client_api/identity_token_type.ts","../src/sdk/client_api/one_off_table_type.ts","../src/sdk/client_api/one_off_query_response_type.ts","../src/sdk/client_api/subscribe_rows_type.ts","../src/sdk/client_api/subscribe_applied_type.ts","../src/sdk/client_api/unsubscribe_applied_type.ts","../src/sdk/client_api/subscription_error_type.ts","../src/sdk/client_api/subscribe_multi_applied_type.ts","../src/sdk/client_api/unsubscribe_multi_applied_type.ts","../src/sdk/client_api/procedure_status_type.ts","../src/sdk/client_api/procedure_result_type.ts","../src/sdk/client_api/server_message_type.ts","../src/sdk/event_emitter.ts","../src/sdk/logger.ts","../src/sdk/table_cache.ts","../src/sdk/client_cache.ts","../src/sdk/version.ts","../src/sdk/decompress.ts","../src/sdk/ws.ts","../src/sdk/websocket_decompress_adapter.ts","../src/sdk/db_connection_builder.ts","../src/sdk/subscription_builder_impl.ts","../src/sdk/db_connection_impl.ts","../src/lib/autogen/lifecycle_type.ts","../src/lib/reducers.ts","../src/lib/views.ts","../src/lib/procedures.ts","../src/lib/schema.ts","../src/lib/autogen/raw_index_algorithm_type.ts","../src/lib/table.ts"],"names":["fromByteArray","t","name","variants","isUnit","table","reducer","procedure","event","eventContext","callbacks","reducers","ret","procedures","schema"],"mappings":"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","file":"index.cjs","sourcesContent":["import { AlgebraicType } from './algebraic_type';\n\nexport type TimeDurationAlgebraicType = {\n  tag: 'Product';\n  value: {\n    elements: [\n      { name: '__time_duration_micros__'; algebraicType: { tag: 'I64' } },\n    ];\n  };\n};\n\n/**\n * A difference between two points in time, represented as a number of microseconds.\n */\nexport class TimeDuration {\n  __time_duration_micros__: bigint;\n\n  private static MICROS_PER_MILLIS: bigint = 1000n;\n\n  /**\n   * Get the algebraic type representation of the {@link TimeDuration} type.\n   * @returns The algebraic type representation of the type.\n   */\n  static getAlgebraicType(): TimeDurationAlgebraicType {\n    return AlgebraicType.Product({\n      elements: [\n        {\n          name: '__time_duration_micros__',\n          algebraicType: AlgebraicType.I64,\n        },\n      ],\n    });\n  }\n\n  static isTimeDuration(\n    algebraicType: AlgebraicType\n  ): algebraicType is TimeDurationAlgebraicType {\n    if (algebraicType.tag !== 'Product') {\n      return false;\n    }\n    const elements = algebraicType.value.elements;\n    if (elements.length !== 1) {\n      return false;\n    }\n    const microsElement = elements[0];\n    return (\n      microsElement.name === '__time_duration_micros__' &&\n      microsElement.algebraicType.tag === 'I64'\n    );\n  }\n\n  get micros(): bigint {\n    return this.__time_duration_micros__;\n  }\n\n  get millis(): number {\n    return Number(this.micros / TimeDuration.MICROS_PER_MILLIS);\n  }\n\n  constructor(micros: bigint) {\n    this.__time_duration_micros__ = micros;\n  }\n\n  static fromMillis(millis: number): TimeDuration {\n    return new TimeDuration(BigInt(millis) * TimeDuration.MICROS_PER_MILLIS);\n  }\n\n  /** This outputs the same string format that we use in the host and in Rust modules */\n  toString(): string {\n    const micros = this.micros;\n    const sign = micros < 0 ? '-' : '+';\n    const pos = micros < 0 ? -micros : micros;\n    const secs = pos / 1_000_000n;\n    const micros_remaining = pos % 1_000_000n;\n    return `${sign}${secs}.${String(micros_remaining).padStart(6, '0')}`;\n  }\n}\n","import { AlgebraicType } from './algebraic_type';\nimport { TimeDuration } from './time_duration';\n\nexport type TimestampAlgebraicType = {\n  tag: 'Product';\n  value: {\n    elements: [\n      {\n        name: '__timestamp_micros_since_unix_epoch__';\n        algebraicType: { tag: 'I64' };\n      },\n    ];\n  };\n};\n\n/**\n * A point in time, represented as a number of microseconds since the Unix epoch.\n */\nexport class Timestamp {\n  __timestamp_micros_since_unix_epoch__: bigint;\n\n  private static MICROS_PER_MILLIS: bigint = 1000n;\n\n  get microsSinceUnixEpoch(): bigint {\n    return this.__timestamp_micros_since_unix_epoch__;\n  }\n\n  constructor(micros: bigint) {\n    this.__timestamp_micros_since_unix_epoch__ = micros;\n  }\n\n  /**\n   * Get the algebraic type representation of the {@link Timestamp} type.\n   * @returns The algebraic type representation of the type.\n   */\n  static getAlgebraicType(): TimestampAlgebraicType {\n    return AlgebraicType.Product({\n      elements: [\n        {\n          name: '__timestamp_micros_since_unix_epoch__',\n          algebraicType: AlgebraicType.I64,\n        },\n      ],\n    });\n  }\n\n  static isTimestamp(\n    algebraicType: AlgebraicType\n  ): algebraicType is TimestampAlgebraicType {\n    if (algebraicType.tag !== 'Product') {\n      return false;\n    }\n    const elements = algebraicType.value.elements;\n    if (elements.length !== 1) {\n      return false;\n    }\n    const microsElement = elements[0];\n    return (\n      microsElement.name === '__timestamp_micros_since_unix_epoch__' &&\n      microsElement.algebraicType.tag === 'I64'\n    );\n  }\n\n  /**\n   * The Unix epoch, the midnight at the beginning of January 1, 1970, UTC.\n   */\n  static UNIX_EPOCH: Timestamp = new Timestamp(0n);\n\n  /**\n   * Get a `Timestamp` representing the execution environment's belief of the current moment in time.\n   */\n  static now(): Timestamp {\n    return Timestamp.fromDate(new Date());\n  }\n\n  /** Convert to milliseconds since Unix epoch. */\n  toMillis(): bigint {\n    return this.microsSinceUnixEpoch / 1000n;\n  }\n\n  /**\n   * Get a `Timestamp` representing the same point in time as `date`.\n   */\n  static fromDate(date: Date): Timestamp {\n    const millis = date.getTime();\n    const micros = BigInt(millis) * Timestamp.MICROS_PER_MILLIS;\n    return new Timestamp(micros);\n  }\n\n  /**\n   * Get a `Date` representing approximately the same point in time as `this`.\n   *\n   * This method truncates to millisecond precision,\n   * and throws `RangeError` if the `Timestamp` is outside the range representable as a `Date`.\n   */\n  toDate(): Date {\n    const micros = this.__timestamp_micros_since_unix_epoch__;\n    const millis = micros / Timestamp.MICROS_PER_MILLIS;\n    if (\n      millis > BigInt(Number.MAX_SAFE_INTEGER) ||\n      millis < BigInt(Number.MIN_SAFE_INTEGER)\n    ) {\n      throw new RangeError(\n        \"Timestamp is outside of the representable range of JS's Date\"\n      );\n    }\n    return new Date(Number(millis));\n  }\n\n  since(other: Timestamp): TimeDuration {\n    return new TimeDuration(\n      this.__timestamp_micros_since_unix_epoch__ -\n        other.__timestamp_micros_since_unix_epoch__\n    );\n  }\n}\n","import { Timestamp } from './timestamp';\nimport { AlgebraicType } from './algebraic_type.ts';\n\nexport type UuidAlgebraicType = {\n  tag: 'Product';\n  value: {\n    elements: [\n      {\n        name: '__uuid__';\n        algebraicType: { tag: 'U128' };\n      },\n    ];\n  };\n};\n\n/**\n * Supported UUID versions.\n *\n * - `Nil`  The \"Nil\" UUID (all zeros)\n * - `V4`   Version 4: random\n * - `V7`   Version 7: timestamp + counter + random\n * - `Max`  The \"Max\" UUID (all ones)\n */\ntype UuidVersion = 'Nil' | 'V4' | 'V7' | 'Max';\n\n/**\n * A universally unique identifier (UUID).\n *\n * Supports UUID `Nil`, `Max`, `V4` (random), and `V7`\n * (timestamp + counter + random).\n *\n * Internally represented as an unsigned 128-bit between 0 and `MAX_UUID_BIGINT`.\n */\nexport class Uuid {\n  __uuid__: bigint;\n\n  /**\n   * The nil UUID (all zeros).\n   *\n   * @example\n   * ```ts\n   * const uuid = Uuid.NIL;\n   * console.assert(\n   *   uuid.toString() === \"00000000-0000-0000-0000-000000000000\"\n   * );\n   * ```\n   */\n  static readonly NIL = new Uuid(0n);\n  static readonly MAX_UUID_BIGINT = 0xffffffffffffffffffffffffffffffffn;\n  /**\n   * The max UUID (all ones).\n   *\n   * @example\n   * ```ts\n   * const uuid = Uuid.MAX;\n   * console.assert(\n   *   uuid.toString() === \"ffffffff-ffff-ffff-ffff-ffffffffffff\"\n   * );\n   * ```\n   */\n  static readonly MAX = new Uuid(Uuid.MAX_UUID_BIGINT);\n\n  /**\n   * Create a UUID from a raw 128-bit value.\n   *\n   * @param u - Unsigned 128-bit integer\n   * @throws {Error} If the value is outside the valid UUID range\n   */\n  constructor(u: bigint) {\n    // Must fit in exactly 16 bytes\n    if (u < 0n || u > Uuid.MAX_UUID_BIGINT) {\n      throw new Error('Invalid UUID: must be between 0 and `MAX_UUID_BIGINT`');\n    }\n    this.__uuid__ = u;\n  }\n\n  /**\n   * Create a UUID `v4` from explicit random bytes.\n   *\n   * This method assumes the bytes are already sufficiently random.\n   * It only sets the appropriate bits for the UUID version and variant.\n   *\n   * @param bytes - Exactly 16 random bytes\n   * @returns A UUID `v4`\n   * @throws {Error} If `bytes.length !== 16`\n   *\n   * @example\n   * ```ts\n   * const randomBytes = new Uint8Array(16);\n   * const uuid = Uuid.fromRandomBytesV4(randomBytes);\n   *\n   * console.assert(\n   *   uuid.toString() === \"00000000-0000-4000-8000-000000000000\"\n   * );\n   * ```\n   */\n  static fromRandomBytesV4(bytes: Uint8Array): Uuid {\n    if (bytes.length !== 16) throw new Error('UUID v4 requires 16 bytes');\n    const arr = new Uint8Array(bytes);\n    arr[6] = (arr[6] & 0x0f) | 0x40; // version 4\n    arr[8] = (arr[8] & 0x3f) | 0x80; // variant\n    return new Uuid(Uuid.bytesToBigInt(arr));\n  }\n\n  /**\n   * Generate a UUID `v7` using a monotonic counter from `0` to `2^31 - 1`,\n   * a timestamp, and 4 random bytes.\n   *\n   * The counter wraps around on overflow.\n   *\n   * The UUID `v7` is structured as follows:\n   *\n   * ```ascii\n   * \n   * | B0  | B1  | B2  | B3  | B4  | B5              |         B6        |\n   * \n   * |                 unix_ts_ms                    |      version 7    |\n   * \n   * \n   * | B7           | B8      | B9  | B10 | B11  | B12 | B13 | B14 | B15 |\n   * \n   * | counter_high | variant |    counter_low   |        random         |\n   * \n   * ```\n   *\n   * @param counter - Mutable monotonic counter (31-bit)\n   * @param now - Timestamp since the Unix epoch\n   * @param randomBytes - Exactly 4 random bytes\n   * @returns A UUID `v7`\n   *\n   * @throws {Error} If the `counter` is negative\n   * @throws {Error} If the `timestamp` is before the Unix epoch\n   * @throws {Error} If `randomBytes.length !== 4`\n   *\n   * @example\n   * ```ts\n   * const now = Timestamp.fromMillis(1_686_000_000_000n);\n   * const counter = { value: 1 };\n   * const randomBytes = new Uint8Array(4);\n   *\n   * const uuid = Uuid.fromCounterV7(counter, now, randomBytes);\n   *\n   * console.assert(\n   *   uuid.toString() === \"0000647e-5180-7000-8000-000200000000\"\n   * );\n   * ```\n   */\n  static fromCounterV7(\n    counter: { value: number },\n    now: Timestamp,\n    randomBytes: Uint8Array\n  ): Uuid {\n    if (randomBytes.length !== 4) {\n      throw new Error('`fromCounterV7` requires `randomBytes.length == 4`');\n    }\n\n    if (counter.value < 0) {\n      throw new Error('`fromCounterV7` uuid `counter` must be non-negative');\n    }\n\n    if (now.__timestamp_micros_since_unix_epoch__ < 0) {\n      throw new Error('`fromCounterV7` `timestamp` before unix epoch');\n    }\n\n    // 31-bit monotonic counter with wraparound\n    const counterVal = counter.value;\n    counter.value = (counterVal + 1) & 0x7fff_ffff;\n\n    // 48-bit unix timestamp (ms)\n    const tsMs = now.toMillis() & 0xffff_ffff_ffffn;\n\n    const bytes = new Uint8Array(16);\n\n    // unix_ts_ms (48 bits)\n    bytes[0] = Number((tsMs >> 40n) & 0xffn);\n    bytes[1] = Number((tsMs >> 32n) & 0xffn);\n    bytes[2] = Number((tsMs >> 24n) & 0xffn);\n    bytes[3] = Number((tsMs >> 16n) & 0xffn);\n    bytes[4] = Number((tsMs >> 8n) & 0xffn);\n    bytes[5] = Number(tsMs & 0xffn);\n\n    // Counter bits (31 bits total)\n    bytes[7] = (counterVal >>> 23) & 0xff;\n    bytes[9] = (counterVal >>> 15) & 0xff;\n    bytes[10] = (counterVal >>> 7) & 0xff;\n    bytes[11] = ((counterVal & 0x7f) << 1) & 0xff;\n\n    // Random bytes\n    bytes[12] |= randomBytes[0] & 0x7f;\n    bytes[13] = randomBytes[1];\n    bytes[14] = randomBytes[2];\n    bytes[15] = randomBytes[3];\n\n    // Version 7\n    bytes[6] = (bytes[6] & 0x0f) | 0x70;\n\n    // Variant RFC4122\n    bytes[8] = (bytes[8] & 0x3f) | 0x80;\n\n    return new Uuid(Uuid.bytesToBigInt(bytes));\n  }\n\n  /**\n   * Parse a UUID from a string representation.\n   *\n   * @param s - UUID string\n   * @returns Parsed UUID\n   * @throws {Error} If the string is not a valid UUID\n   *\n   * @example\n   * ```ts\n   * const s = \"01888d6e-5c00-7000-8000-000000000000\";\n   * const uuid = Uuid.parse(s);\n   *\n   * console.assert(uuid.toString() === s);\n   * ```\n   */\n  static parse(s: string): Uuid {\n    const hex = s.replace(/-/g, '');\n    if (hex.length !== 32) throw new Error('Invalid hex UUID');\n\n    let v = 0n;\n    for (let i = 0; i < 32; i += 2) {\n      v = (v << 8n) | BigInt(parseInt(hex.slice(i, i + 2), 16));\n    }\n    return new Uuid(v);\n  }\n\n  /** Convert to string (hyphenated form). */\n  toString(): string {\n    const bytes = Uuid.bigIntToBytes(this.__uuid__);\n    const hex = [...bytes].map(b => b.toString(16).padStart(2, '0')).join('');\n\n    // Format as 8-4-4-4-12\n    return (\n      hex.slice(0, 8) +\n      '-' +\n      hex.slice(8, 12) +\n      '-' +\n      hex.slice(12, 16) +\n      '-' +\n      hex.slice(16, 20) +\n      '-' +\n      hex.slice(20)\n    );\n  }\n\n  /** Convert to bigint (u128). */\n  asBigInt(): bigint {\n    return this.__uuid__;\n  }\n\n  /** Return a `Uint8Array` of 16 bytes. */\n  toBytes(): Uint8Array {\n    return Uuid.bigIntToBytes(this.__uuid__);\n  }\n\n  private static bytesToBigInt(bytes: Uint8Array): bigint {\n    let result = 0n;\n    for (const b of bytes) result = (result << 8n) | BigInt(b);\n    return result;\n  }\n\n  private static bigIntToBytes(value: bigint): Uint8Array {\n    const bytes = new Uint8Array(16);\n    for (let i = 15; i >= 0; i--) {\n      bytes[i] = Number(value & 0xffn);\n      value >>= 8n;\n    }\n    return bytes;\n  }\n\n  /**\n   * Returns the version of this UUID.\n   *\n   * This represents the algorithm used to generate the value.\n   *\n   * @returns A `UuidVersion`\n   * @throws {Error} If the version field is not recognized\n   */\n  getVersion(): UuidVersion {\n    const version = (this.toBytes()[6] >> 4) & 0x0f;\n\n    switch (version) {\n      case 4:\n        return 'V4';\n      case 7:\n        return 'V7';\n      default:\n        if (this == Uuid.NIL) {\n          return 'Nil';\n        }\n        if (this == Uuid.MAX) {\n          return 'Max';\n        }\n        throw new Error(`Unsupported UUID version: ${version}`);\n    }\n  }\n\n  /**\n   * Extract the monotonic counter from a UUIDv7.\n   *\n   * Intended for testing and diagnostics.\n   * Behavior is undefined if called on a non-V7 UUID.\n   *\n   * @returns 31-bit counter value\n   */\n  getCounter(): number {\n    const bytes = this.toBytes(); // big-endian, 16 bytes\n\n    const high = bytes[7]; // bits 30..23\n    const mid1 = bytes[9]; // bits 22..15\n    const mid2 = bytes[10]; // bits 14..7\n    const low = bytes[11] >>> 1; // bits 6..0\n\n    // reconstruct 31-bit counter\n    return (high << 23) | (mid1 << 15) | (mid2 << 7) | low | 0; // force 32-bit int\n  }\n\n  compareTo(other: Uuid): number {\n    if (this.__uuid__ < other.__uuid__) return -1;\n    if (this.__uuid__ > other.__uuid__) return 1;\n\n    return 0;\n  }\n\n  static getAlgebraicType(): UuidAlgebraicType {\n    return AlgebraicType.Product({\n      elements: [\n        {\n          name: '__uuid__',\n          algebraicType: AlgebraicType.U128,\n        },\n      ],\n    });\n  }\n}\n","import { fromByteArray } from 'base64-js';\n\nexport default class BinaryWriter {\n  #buffer: Uint8Array;\n  #view: DataView;\n  #offset: number = 0;\n\n  constructor(size: number) {\n    this.#buffer = new Uint8Array(size);\n    this.#view = new DataView(this.#buffer.buffer);\n  }\n\n  #expandBuffer(additionalCapacity: number): void {\n    const minCapacity = this.#offset + additionalCapacity + 1;\n    if (minCapacity <= this.#buffer.length) return;\n    let newCapacity = this.#buffer.length * 2;\n    if (newCapacity < minCapacity) newCapacity = minCapacity;\n    const newBuffer = new Uint8Array(newCapacity);\n    newBuffer.set(this.#buffer);\n    this.#buffer = newBuffer;\n    this.#view = new DataView(this.#buffer.buffer);\n  }\n\n  toBase64(): string {\n    return fromByteArray(this.#buffer.subarray(0, this.#offset));\n  }\n\n  getBuffer(): Uint8Array {\n    return this.#buffer.slice(0, this.#offset);\n  }\n\n  get offset(): number {\n    return this.#offset;\n  }\n\n  writeUInt8Array(value: Uint8Array): void {\n    const length = value.length;\n\n    this.#expandBuffer(4 + length);\n\n    this.writeU32(length);\n    this.#buffer.set(value, this.#offset);\n    this.#offset += value.length;\n  }\n\n  writeBool(value: boolean): void {\n    this.#expandBuffer(1);\n    this.#view.setUint8(this.#offset, value ? 1 : 0);\n    this.#offset += 1;\n  }\n\n  writeByte(value: number): void {\n    this.#expandBuffer(1);\n    this.#view.setUint8(this.#offset, value);\n    this.#offset += 1;\n  }\n\n  writeI8(value: number): void {\n    this.#expandBuffer(1);\n    this.#view.setInt8(this.#offset, value);\n    this.#offset += 1;\n  }\n\n  writeU8(value: number): void {\n    this.#expandBuffer(1);\n    this.#view.setUint8(this.#offset, value);\n    this.#offset += 1;\n  }\n\n  writeI16(value: number): void {\n    this.#expandBuffer(2);\n    this.#view.setInt16(this.#offset, value, true);\n    this.#offset += 2;\n  }\n\n  writeU16(value: number): void {\n    this.#expandBuffer(2);\n    this.#view.setUint16(this.#offset, value, true);\n    this.#offset += 2;\n  }\n\n  writeI32(value: number): void {\n    this.#expandBuffer(4);\n    this.#view.setInt32(this.#offset, value, true);\n    this.#offset += 4;\n  }\n\n  writeU32(value: number): void {\n    this.#expandBuffer(4);\n    this.#view.setUint32(this.#offset, value, true);\n    this.#offset += 4;\n  }\n\n  writeI64(value: bigint): void {\n    this.#expandBuffer(8);\n    this.#view.setBigInt64(this.#offset, value, true);\n    this.#offset += 8;\n  }\n\n  writeU64(value: bigint): void {\n    this.#expandBuffer(8);\n    this.#view.setBigUint64(this.#offset, value, true);\n    this.#offset += 8;\n  }\n\n  writeU128(value: bigint): void {\n    this.#expandBuffer(16);\n    const lowerPart = value & BigInt('0xFFFFFFFFFFFFFFFF');\n    const upperPart = value >> BigInt(64);\n    this.#view.setBigUint64(this.#offset, lowerPart, true);\n    this.#view.setBigUint64(this.#offset + 8, upperPart, true);\n    this.#offset += 16;\n  }\n\n  writeI128(value: bigint): void {\n    this.#expandBuffer(16);\n    const lowerPart = value & BigInt('0xFFFFFFFFFFFFFFFF');\n    const upperPart = value >> BigInt(64);\n    this.#view.setBigInt64(this.#offset, lowerPart, true);\n    this.#view.setBigInt64(this.#offset + 8, upperPart, true);\n    this.#offset += 16;\n  }\n\n  writeU256(value: bigint): void {\n    this.#expandBuffer(32);\n    const low_64_mask = BigInt('0xFFFFFFFFFFFFFFFF');\n    const p0 = value & low_64_mask;\n    const p1 = (value >> BigInt(64 * 1)) & low_64_mask;\n    const p2 = (value >> BigInt(64 * 2)) & low_64_mask;\n    const p3 = value >> BigInt(64 * 3);\n    this.#view.setBigUint64(this.#offset + 8 * 0, p0, true);\n    this.#view.setBigUint64(this.#offset + 8 * 1, p1, true);\n    this.#view.setBigUint64(this.#offset + 8 * 2, p2, true);\n    this.#view.setBigUint64(this.#offset + 8 * 3, p3, true);\n    this.#offset += 32;\n  }\n\n  writeI256(value: bigint): void {\n    this.#expandBuffer(32);\n    const low_64_mask = BigInt('0xFFFFFFFFFFFFFFFF');\n    const p0 = value & low_64_mask;\n    const p1 = (value >> BigInt(64 * 1)) & low_64_mask;\n    const p2 = (value >> BigInt(64 * 2)) & low_64_mask;\n    const p3 = value >> BigInt(64 * 3);\n    this.#view.setBigUint64(this.#offset + 8 * 0, p0, true);\n    this.#view.setBigUint64(this.#offset + 8 * 1, p1, true);\n    this.#view.setBigUint64(this.#offset + 8 * 2, p2, true);\n    this.#view.setBigInt64(this.#offset + 8 * 3, p3, true);\n    this.#offset += 32;\n  }\n\n  writeF32(value: number): void {\n    this.#expandBuffer(4);\n    this.#view.setFloat32(this.#offset, value, true);\n    this.#offset += 4;\n  }\n\n  writeF64(value: number): void {\n    this.#expandBuffer(8);\n    this.#view.setFloat64(this.#offset, value, true);\n    this.#offset += 8;\n  }\n\n  writeString(value: string): void {\n    const encoder = new TextEncoder();\n    const encodedString = encoder.encode(value);\n    this.writeU32(encodedString.length);\n    this.#expandBuffer(encodedString.length);\n    this.#buffer.set(encodedString, this.#offset);\n    this.#offset += encodedString.length;\n  }\n}\n","export default class BinaryReader {\n  /**\n   * The DataView used to read values from the binary data.\n   *\n   * Note: The DataView's `byteOffset` is relative to the beginning of the\n   * underlying ArrayBuffer, not the start of the provided Uint8Array input.\n   * This `BinaryReader`'s `#offset` field is used to track the current read position\n   * relative to the start of the provided Uint8Array input.\n   */\n  #view: DataView;\n\n  /**\n   * Represents the offset (in bytes) relative to the start of the DataView\n   * and provided Uint8Array input.\n   *\n   * Note: This is *not* the absolute byte offset within the underlying ArrayBuffer.\n   */\n  #offset: number = 0;\n\n  constructor(input: Uint8Array) {\n    this.#view = new DataView(input.buffer, input.byteOffset, input.byteLength);\n    this.#offset = 0;\n  }\n\n  get offset(): number {\n    return this.#offset;\n  }\n\n  get remaining(): number {\n    return this.#view.byteLength - this.#offset;\n  }\n\n  /** Ensure we have at least `n` bytes left to read */\n  #ensure(n: number): void {\n    if (this.#offset + n > this.#view.byteLength) {\n      throw new RangeError(\n        `Tried to read ${n} byte(s) at relative offset ${this.#offset}, but only ${this.remaining} byte(s) remain`\n      );\n    }\n  }\n\n  readUInt8Array(): Uint8Array {\n    const length = this.readU32();\n    this.#ensure(length);\n    return this.readBytes(length);\n  }\n\n  readBool(): boolean {\n    const value = this.#view.getUint8(this.#offset);\n    this.#offset += 1;\n    return value !== 0;\n  }\n\n  readByte(): number {\n    const value = this.#view.getUint8(this.#offset);\n    this.#offset += 1;\n    return value;\n  }\n\n  readBytes(length: number): Uint8Array {\n    // Create a Uint8Array view over the DataView's buffer at the current offset\n    // The #view.buffer is the whole ArrayBuffer, so we need to account for the\n    // #view's starting position in that buffer (#view.byteOffset) and the current #offset\n    const array = new Uint8Array(\n      this.#view.buffer,\n      this.#view.byteOffset + this.#offset,\n      length\n    );\n    this.#offset += length;\n    return array;\n  }\n\n  readI8(): number {\n    const value = this.#view.getInt8(this.#offset);\n    this.#offset += 1;\n    return value;\n  }\n\n  readU8(): number {\n    return this.readByte();\n  }\n\n  readI16(): number {\n    const value = this.#view.getInt16(this.#offset, true);\n    this.#offset += 2;\n    return value;\n  }\n\n  readU16(): number {\n    const value = this.#view.getUint16(this.#offset, true);\n    this.#offset += 2;\n    return value;\n  }\n\n  readI32(): number {\n    const value = this.#view.getInt32(this.#offset, true);\n    this.#offset += 4;\n    return value;\n  }\n\n  readU32(): number {\n    const value = this.#view.getUint32(this.#offset, true);\n    this.#offset += 4;\n    return value;\n  }\n\n  readI64(): bigint {\n    const value = this.#view.getBigInt64(this.#offset, true);\n    this.#offset += 8;\n    return value;\n  }\n\n  readU64(): bigint {\n    const value = this.#view.getBigUint64(this.#offset, true);\n    this.#offset += 8;\n    return value;\n  }\n\n  readU128(): bigint {\n    const lowerPart = this.#view.getBigUint64(this.#offset, true);\n    const upperPart = this.#view.getBigUint64(this.#offset + 8, true);\n    this.#offset += 16;\n\n    return (upperPart << BigInt(64)) + lowerPart;\n  }\n\n  readI128(): bigint {\n    const lowerPart = this.#view.getBigUint64(this.#offset, true);\n    const upperPart = this.#view.getBigInt64(this.#offset + 8, true);\n    this.#offset += 16;\n\n    return (upperPart << BigInt(64)) + lowerPart;\n  }\n\n  readU256(): bigint {\n    const p0 = this.#view.getBigUint64(this.#offset, true);\n    const p1 = this.#view.getBigUint64(this.#offset + 8, true);\n    const p2 = this.#view.getBigUint64(this.#offset + 16, true);\n    const p3 = this.#view.getBigUint64(this.#offset + 24, true);\n    this.#offset += 32;\n\n    return (\n      (p3 << BigInt(3 * 64)) +\n      (p2 << BigInt(2 * 64)) +\n      (p1 << BigInt(1 * 64)) +\n      p0\n    );\n  }\n\n  readI256(): bigint {\n    const p0 = this.#view.getBigUint64(this.#offset, true);\n    const p1 = this.#view.getBigUint64(this.#offset + 8, true);\n    const p2 = this.#view.getBigUint64(this.#offset + 16, true);\n    const p3 = this.#view.getBigInt64(this.#offset + 24, true);\n    this.#offset += 32;\n\n    return (\n      (p3 << BigInt(3 * 64)) +\n      (p2 << BigInt(2 * 64)) +\n      (p1 << BigInt(1 * 64)) +\n      p0\n    );\n  }\n\n  readF32(): number {\n    const value = this.#view.getFloat32(this.#offset, true);\n    this.#offset += 4;\n    return value;\n  }\n\n  readF64(): number {\n    const value = this.#view.getFloat64(this.#offset, true);\n    this.#offset += 8;\n    return value;\n  }\n\n  readString(): string {\n    const uint8Array = this.readUInt8Array();\n    return new TextDecoder('utf-8').decode(uint8Array);\n  }\n}\n","import BinaryReader from './binary_reader';\nimport BinaryWriter from './binary_writer';\nimport type { CamelCase, SnakeCase } from './type_util';\n\n/**\n * Converts a string to PascalCase (UpperCamelCase).\n * @param str The string to convert\n * @returns The converted string\n */\nexport function toPascalCase(s: string): string {\n  const str = s.replace(/([-_][a-z])/gi, $1 => {\n    return $1.toUpperCase().replace('-', '').replace('_', '');\n  });\n\n  return str.charAt(0).toUpperCase() + str.slice(1);\n}\n\nexport function deepEqual(obj1: any, obj2: any): boolean {\n  // If both are strictly equal (covers primitives and reference equality), return true\n  if (obj1 === obj2) return true;\n\n  // If either is a primitive type or one is null, return false since we already checked for strict equality\n  if (\n    typeof obj1 !== 'object' ||\n    obj1 === null ||\n    typeof obj2 !== 'object' ||\n    obj2 === null\n  ) {\n    return false;\n  }\n\n  // Get keys of both objects\n  const keys1 = Object.keys(obj1);\n  const keys2 = Object.keys(obj2);\n\n  // If number of keys is different, return false\n  if (keys1.length !== keys2.length) return false;\n\n  // Check all keys and compare values recursively\n  for (const key of keys1) {\n    if (!keys2.includes(key) || !deepEqual(obj1[key], obj2[key])) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nexport function uint8ArrayToHexString(array: Uint8Array): string {\n  return Array.prototype.map\n    .call(array.reverse(), x => ('00' + x.toString(16)).slice(-2))\n    .join('');\n}\n\nexport function uint8ArrayToU128(array: Uint8Array): bigint {\n  if (array.length != 16) {\n    throw new Error(`Uint8Array is not 16 bytes long: ${array}`);\n  }\n  return new BinaryReader(array).readU128();\n}\n\nexport function uint8ArrayToU256(array: Uint8Array): bigint {\n  if (array.length != 32) {\n    throw new Error(`Uint8Array is not 32 bytes long: [${array}]`);\n  }\n  return new BinaryReader(array).readU256();\n}\n\nexport function hexStringToUint8Array(str: string): Uint8Array {\n  if (str.startsWith('0x')) {\n    str = str.slice(2);\n  }\n  const matches = str.match(/.{1,2}/g) || [];\n  const data = Uint8Array.from(\n    matches.map((byte: string) => parseInt(byte, 16))\n  );\n  return data.reverse();\n}\n\nexport function hexStringToU128(str: string): bigint {\n  return uint8ArrayToU128(hexStringToUint8Array(str));\n}\n\nexport function hexStringToU256(str: string): bigint {\n  return uint8ArrayToU256(hexStringToUint8Array(str));\n}\n\nexport function u128ToUint8Array(data: bigint): Uint8Array {\n  const writer = new BinaryWriter(16);\n  writer.writeU128(data);\n  return writer.getBuffer();\n}\n\nexport function u128ToHexString(data: bigint): string {\n  return uint8ArrayToHexString(u128ToUint8Array(data));\n}\n\nexport function u256ToUint8Array(data: bigint): Uint8Array {\n  const writer = new BinaryWriter(32);\n  writer.writeU256(data);\n  return writer.getBuffer();\n}\n\nexport function u256ToHexString(data: bigint): string {\n  return uint8ArrayToHexString(u256ToUint8Array(data));\n}\n\n/**\n * Type safe conversion from a string like \"some_identifier-name\" to \"someIdentifierName\".\n * @param str The string to convert\n * @returns The converted string\n */\nexport function toCamelCase<T extends string>(str: T): CamelCase<T> {\n  return str\n    .replace(/[-_]+/g, '_') // collapse runs to a single separator (no backtracking issue)\n    .replace(/_([a-zA-Z0-9])/g, (_, c) => c.toUpperCase()) as CamelCase<T>;\n}\n\n/** Type safe conversion from a string like \"some_Identifier-name\" to \"some_identifier_name\".\n * @param str The string to convert\n * @returns The converted string\n */\nexport function toSnakeCase<T extends string>(str: T): SnakeCase<T> {\n  return str\n    .replace(/([A-Z])/g, '_$1') // insert underscores before capitals\n    .replace(/[-\\s]+/g, '_') // replace spaces and dashes with underscores\n    .toLowerCase() as SnakeCase<T>;\n}\n\nimport type { AlgebraicType } from './algebraic_type';\nimport type Typespace from './autogen/typespace_type';\nimport type { ColumnBuilder, Infer, TypeBuilder } from './type_builders';\nimport type { ParamsObj } from './reducers';\n\nexport function bsatnBaseSize(\n  typespace: Infer<typeof Typespace>,\n  ty: AlgebraicType\n): number {\n  const assumedArrayLength = 4;\n  while (ty.tag === 'Ref') ty = typespace.types[ty.value];\n  if (ty.tag === 'Product') {\n    let sum = 0;\n    for (const { algebraicType: elem } of ty.value.elements) {\n      sum += bsatnBaseSize(typespace, elem);\n    }\n    return sum;\n  } else if (ty.tag === 'Sum') {\n    let min = Infinity;\n    for (const { algebraicType: vari } of ty.value.variants) {\n      const vSize = bsatnBaseSize(typespace, vari);\n      if (vSize < min) min = vSize;\n    }\n    if (min === Infinity) min = 0;\n    return 4 + min;\n  } else if (ty.tag == 'Array') {\n    return 4 + assumedArrayLength * bsatnBaseSize(typespace, ty.value);\n  }\n  return {\n    String: 4 + assumedArrayLength,\n    Sum: 1,\n    Bool: 1,\n    I8: 1,\n    U8: 1,\n    I16: 2,\n    U16: 2,\n    I32: 4,\n    U32: 4,\n    F32: 4,\n    I64: 8,\n    U64: 8,\n    F64: 8,\n    I128: 16,\n    U128: 16,\n    I256: 32,\n    U256: 32,\n  }[ty.tag];\n}\n\nexport type CoerceTypeBuilder<\n  Col extends TypeBuilder<any, any> | ColumnBuilder<any, any, any>,\n> = Col extends ColumnBuilder<any, any> ? Col['typeBuilder'] : Col;\n\nexport type CoerceParams<Params extends ParamsObj> = {\n  [k in keyof Params & string]: CoerceTypeBuilder<Params[k]>;\n};\n\nexport function coerceParams<Params extends ParamsObj>(\n  params: Params\n): CoerceParams<Params> {\n  return Object.fromEntries(\n    Object.entries(params).map(([n, c]) => [\n      n,\n      'typeBuilder' in c ? c.typeBuilder : c,\n    ])\n  ) as CoerceParams<Params>;\n}\n","import { AlgebraicType } from './algebraic_type';\nimport { hexStringToU256, u256ToHexString, u256ToUint8Array } from './util';\n\nexport type IdentityAlgebraicType = {\n  tag: 'Product';\n  value: {\n    elements: [{ name: '__identity__'; algebraicType: { tag: 'U256' } }];\n  };\n};\n\n/**\n * A unique identifier for a user connected to a database.\n */\nexport class Identity {\n  __identity__: bigint;\n\n  /**\n   * Creates a new `Identity`.\n   *\n   * `data` can be a hexadecimal string or a `bigint`.\n   */\n  constructor(data: string | bigint) {\n    // we get a JSON with __identity__ when getting a token with a JSON API\n    // and an bigint when using BSATN\n    this.__identity__ = typeof data === 'string' ? hexStringToU256(data) : data;\n  }\n\n  /**\n   * Get the algebraic type representation of the {@link Identity} type.\n   * @returns The algebraic type representation of the type.\n   */\n  static getAlgebraicType(): IdentityAlgebraicType {\n    return AlgebraicType.Product({\n      elements: [{ name: '__identity__', algebraicType: AlgebraicType.U256 }],\n    });\n  }\n\n  /**\n   * Check if two identities are equal.\n   */\n  isEqual(other: Identity): boolean {\n    return this.toHexString() === other.toHexString();\n  }\n\n  /**\n   * Check if two identities are equal.\n   */\n  equals(other: Identity): boolean {\n    return this.isEqual(other);\n  }\n\n  /**\n   * Print the identity as a hexadecimal string.\n   */\n  toHexString(): string {\n    return u256ToHexString(this.__identity__);\n  }\n\n  /**\n   * Convert the address to a Uint8Array.\n   */\n  toUint8Array(): Uint8Array {\n    return u256ToUint8Array(this.__identity__);\n  }\n\n  /**\n   * Parse an Identity from a hexadecimal string.\n   */\n  static fromString(str: string): Identity {\n    return new Identity(str);\n  }\n\n  /**\n   * Zero identity (0x0000000000000000000000000000000000000000000000000000000000000000)\n   */\n  static zero(): Identity {\n    return new Identity(0n);\n  }\n\n  toString(): string {\n    return this.toHexString();\n  }\n}\n","import type {\n  AlgebraicTypeType,\n  ProductTypeType,\n  SumTypeType,\n} from './algebraic_type';\n\nexport type Ref = { tag: 'Ref'; value: number };\nexport type Sum = { tag: 'Sum'; value: SumTypeType };\nexport type Product = { tag: 'Product'; value: ProductTypeType };\nexport type Array = { tag: 'Array'; value: AlgebraicTypeType };\nexport type String = { tag: 'String' };\nexport type Bool = { tag: 'Bool' };\nexport type I8 = { tag: 'I8' };\nexport type U8 = { tag: 'U8' };\nexport type I16 = { tag: 'I16' };\nexport type U16 = { tag: 'U16' };\nexport type I32 = { tag: 'I32' };\nexport type U32 = { tag: 'U32' };\nexport type I64 = { tag: 'I64' };\nexport type U64 = { tag: 'U64' };\nexport type I128 = { tag: 'I128' };\nexport type U128 = { tag: 'U128' };\nexport type I256 = { tag: 'I256' };\nexport type U256 = { tag: 'U256' };\nexport type F32 = { tag: 'F32' };\nexport type F64 = { tag: 'F64' };\n","import { TimeDuration } from './time_duration';\nimport { Timestamp } from './timestamp';\nimport { Uuid } from './uuid';\nimport { ConnectionId } from './connection_id';\nimport type BinaryReader from './binary_reader';\nimport BinaryWriter from './binary_writer';\nimport { Identity } from './identity';\nimport * as AlgebraicTypeVariants from './algebraic_type_variants';\n\ntype TypespaceType = {\n  types: AlgebraicTypeType[];\n};\n\nexport type ProductTypeType = {\n  elements: ProductTypeElement[];\n};\n\n/**\n * A factor / element of a product type.\n *\n * An element consist of an optional name and a type.\n *\n * NOTE: Each element has an implicit element tag based on its order.\n * Uniquely identifies an element similarly to protobuf tags.\n */\nexport type ProductTypeElement = {\n  name: string | undefined;\n  algebraicType: AlgebraicTypeType;\n};\n\nexport type SumTypeType = {\n  variants: SumTypeVariant[];\n};\n\n/**\n * A variant of a sum type.\n *\n * NOTE: Each element has an implicit element tag based on its order.\n * Uniquely identifies an element similarly to protobuf tags.\n */\nexport type SumTypeVariant = {\n  name: string | undefined;\n  algebraicType: AlgebraicTypeType;\n};\n\nexport type AlgebraicTypeType =\n  | AlgebraicTypeVariants.Ref\n  | AlgebraicTypeVariants.Sum\n  | AlgebraicTypeVariants.Product\n  | AlgebraicTypeVariants.Array\n  | AlgebraicTypeVariants.String\n  | AlgebraicTypeVariants.Bool\n  | AlgebraicTypeVariants.I8\n  | AlgebraicTypeVariants.U8\n  | AlgebraicTypeVariants.I16\n  | AlgebraicTypeVariants.U16\n  | AlgebraicTypeVariants.I32\n  | AlgebraicTypeVariants.U32\n  | AlgebraicTypeVariants.I64\n  | AlgebraicTypeVariants.U64\n  | AlgebraicTypeVariants.I128\n  | AlgebraicTypeVariants.U128\n  | AlgebraicTypeVariants.I256\n  | AlgebraicTypeVariants.U256\n  | AlgebraicTypeVariants.F32\n  | AlgebraicTypeVariants.F64;\n\nexport type AlgebraicType = AlgebraicTypeType;\n\n/**\n * The variant types of the Algebraic Type tagged union.\n */\nexport { AlgebraicTypeVariants };\n\n// A value with helper functions to construct the type.\nexport const AlgebraicType = {\n  Ref: (value: number): AlgebraicTypeVariants.Ref => ({ tag: 'Ref', value }),\n  Sum: <T extends SumTypeType>(value: T): { tag: 'Sum'; value: T } => ({\n    tag: 'Sum',\n    value,\n  }),\n  Product: <T extends ProductTypeType>(\n    value: T\n  ): { tag: 'Product'; value: T } => ({\n    tag: 'Product',\n    value,\n  }),\n  Array: <T extends AlgebraicTypeType>(\n    value: T\n  ): { tag: 'Array'; value: T } => ({\n    tag: 'Array',\n    value,\n  }),\n  String: { tag: 'String' } as const,\n  Bool: { tag: 'Bool' } as const,\n  I8: { tag: 'I8' } as const,\n  U8: { tag: 'U8' } as const,\n  I16: { tag: 'I16' } as const,\n  U16: { tag: 'U16' } as const,\n  I32: { tag: 'I32' } as const,\n  U32: { tag: 'U32' } as const,\n  I64: { tag: 'I64' } as const,\n  U64: { tag: 'U64' } as const,\n  I128: { tag: 'I128' } as const,\n  U128: { tag: 'U128' } as const,\n  I256: { tag: 'I256' } as const,\n  U256: { tag: 'U256' } as const,\n  F32: { tag: 'F32' } as const,\n  F64: { tag: 'F64' } as const,\n  serializeValue(\n    writer: BinaryWriter,\n    ty: AlgebraicTypeType,\n    value: any,\n    typespace?: TypespaceType\n  ) {\n    if (ty.tag === 'Ref') {\n      if (!typespace)\n        throw new Error('cannot serialize refs without a typespace');\n      while (ty.tag === 'Ref') ty = typespace.types[ty.value];\n    }\n    switch (ty.tag) {\n      case 'Product':\n        ProductType.serializeValue(writer, ty.value, value, typespace);\n        break;\n      case 'Sum':\n        SumType.serializeValue(writer, ty.value, value, typespace);\n        break;\n      case 'Array':\n        if (ty.value.tag === 'U8') {\n          writer.writeUInt8Array(value);\n        } else {\n          const elemType = ty.value;\n          writer.writeU32(value.length);\n          for (const elem of value) {\n            AlgebraicType.serializeValue(writer, elemType, elem, typespace);\n          }\n        }\n        break;\n      case 'Bool':\n        writer.writeBool(value);\n        break;\n      case 'I8':\n        writer.writeI8(value);\n        break;\n      case 'U8':\n        writer.writeU8(value);\n        break;\n      case 'I16':\n        writer.writeI16(value);\n        break;\n      case 'U16':\n        writer.writeU16(value);\n        break;\n      case 'I32':\n        writer.writeI32(value);\n        break;\n      case 'U32':\n        writer.writeU32(value);\n        break;\n      case 'I64':\n        writer.writeI64(value);\n        break;\n      case 'U64':\n        writer.writeU64(value);\n        break;\n      case 'I128':\n        writer.writeI128(value);\n        break;\n      case 'U128':\n        writer.writeU128(value);\n        break;\n      case 'I256':\n        writer.writeI256(value);\n        break;\n      case 'U256':\n        writer.writeU256(value);\n        break;\n      case 'F32':\n        writer.writeF32(value);\n        break;\n      case 'F64':\n        writer.writeF64(value);\n        break;\n      case 'String':\n        writer.writeString(value);\n        break;\n    }\n  },\n  deserializeValue: function (\n    reader: BinaryReader,\n    ty: AlgebraicTypeType,\n    typespace?: TypespaceType\n  ): any {\n    if (ty.tag === 'Ref') {\n      if (!typespace)\n        throw new Error('cannot deserialize refs without a typespace');\n      while (ty.tag === 'Ref') ty = typespace.types[ty.value];\n    }\n    switch (ty.tag) {\n      case 'Product':\n        return ProductType.deserializeValue(reader, ty.value, typespace);\n      case 'Sum':\n        return SumType.deserializeValue(reader, ty.value, typespace);\n      case 'Array':\n        if (ty.value.tag === 'U8') {\n          return reader.readUInt8Array();\n        } else {\n          const elemType = ty.value;\n          const length = reader.readU32();\n          const result: any[] = [];\n          for (let i = 0; i < length; i++) {\n            result.push(\n              AlgebraicType.deserializeValue(reader, elemType, typespace)\n            );\n          }\n          return result;\n        }\n      case 'Bool':\n        return reader.readBool();\n      case 'I8':\n        return reader.readI8();\n      case 'U8':\n        return reader.readU8();\n      case 'I16':\n        return reader.readI16();\n      case 'U16':\n        return reader.readU16();\n      case 'I32':\n        return reader.readI32();\n      case 'U32':\n        return reader.readU32();\n      case 'I64':\n        return reader.readI64();\n      case 'U64':\n        return reader.readU64();\n      case 'I128':\n        return reader.readI128();\n      case 'U128':\n        return reader.readU128();\n      case 'I256':\n        return reader.readI256();\n      case 'U256':\n        return reader.readU256();\n      case 'F32':\n        return reader.readF32();\n      case 'F64':\n        return reader.readF64();\n      case 'String':\n        return reader.readString();\n    }\n  },\n  /**\n   * Convert a value of the algebraic type into something that can be used as a key in a map.\n   * There are no guarantees about being able to order it.\n   * This is only guaranteed to be comparable to other values of the same type.\n   * @param value A value of the algebraic type\n   * @returns Something that can be used as a key in a map.\n   */\n  intoMapKey: function (\n    ty: AlgebraicTypeType,\n    value: any\n  ): ComparablePrimitive {\n    switch (ty.tag) {\n      case 'U8':\n      case 'U16':\n      case 'U32':\n      case 'U64':\n      case 'U128':\n      case 'U256':\n      case 'I8':\n      case 'I16':\n      case 'I32':\n      case 'I64':\n      case 'I128':\n      case 'I256':\n      case 'F32':\n      case 'F64':\n      case 'String':\n      case 'Bool':\n        return value;\n      case 'Product':\n        return ProductType.intoMapKey(ty.value, value);\n      default: {\n        // The fallback is to serialize and base64 encode the bytes.\n        const writer = new BinaryWriter(10);\n        AlgebraicType.serializeValue(writer, ty, value);\n        return writer.toBase64();\n      }\n    }\n  },\n};\n\n/**\n * A structural product type  of the factors given by `elements`.\n *\n * This is also known as `struct` and `tuple` in many languages,\n * but note that unlike most languages, products in SATs are *[structural]* and not nominal.\n * When checking whether two nominal types are the same,\n * their names and/or declaration sites (e.g., module / namespace) are considered.\n * Meanwhile, a structural type system would only check the structure of the type itself,\n * e.g., the names of its fields and their types in the case of a record.\n * The name \"product\" comes from category theory.\n *\n * See also: https://ncatlab.org/nlab/show/product+type.\n *\n * These structures are known as product types because the number of possible values in product\n * ```ignore\n * { N_0: T_0, N_1: T_1, ..., N_n: T_n }\n * ```\n * is:\n * ```ignore\n *  (i  0..n). values(T_i)\n * ```\n * so for example, `values({ A: U64, B: Bool }) = values(U64) * values(Bool)`.\n *\n * [structural]: https://en.wikipedia.org/wiki/Structural_type_system\n */\nexport type ProductType = ProductTypeType;\n\nexport const ProductType = {\n  serializeValue(\n    writer: BinaryWriter,\n    ty: ProductTypeType,\n    value: any,\n    typespace?: TypespaceType\n  ): void {\n    for (const element of ty.elements) {\n      AlgebraicType.serializeValue(\n        writer,\n        element.algebraicType,\n        value[element.name!],\n        typespace\n      );\n    }\n  },\n  deserializeValue(\n    reader: BinaryReader,\n    ty: ProductTypeType,\n    typespace?: TypespaceType\n  ): any {\n    const result: { [key: string]: any } = {};\n    if (ty.elements.length === 1) {\n      if (ty.elements[0].name === '__time_duration_micros__') {\n        return new TimeDuration(reader.readI64());\n      }\n\n      if (ty.elements[0].name === '__timestamp_micros_since_unix_epoch__') {\n        return new Timestamp(reader.readI64());\n      }\n\n      if (ty.elements[0].name === '__identity__') {\n        return new Identity(reader.readU256());\n      }\n\n      if (ty.elements[0].name === '__connection_id__') {\n        return new ConnectionId(reader.readU128());\n      }\n\n      if (ty.elements[0].name === '__uuid__') {\n        return new Uuid(reader.readU128());\n      }\n    }\n\n    for (const element of ty.elements) {\n      result[element.name!] = AlgebraicType.deserializeValue(\n        reader,\n        element.algebraicType,\n        typespace\n      );\n    }\n    return result;\n  },\n  intoMapKey(ty: ProductTypeType, value: any): ComparablePrimitive {\n    if (ty.elements.length === 1) {\n      if (ty.elements[0].name === '__time_duration_micros__') {\n        return (value as TimeDuration).__time_duration_micros__;\n      }\n\n      if (ty.elements[0].name === '__timestamp_micros_since_unix_epoch__') {\n        return (value as Timestamp).__timestamp_micros_since_unix_epoch__;\n      }\n\n      if (ty.elements[0].name === '__identity__') {\n        return (value as Identity).__identity__;\n      }\n\n      if (ty.elements[0].name === '__connection_id__') {\n        return (value as ConnectionId).__connection_id__;\n      }\n\n      if (ty.elements[0].name === '__uuid__') {\n        return (value as Uuid).__uuid__;\n      }\n    }\n    // The fallback is to serialize and base64 encode the bytes.\n    const writer = new BinaryWriter(10);\n    AlgebraicType.serializeValue(writer, AlgebraicType.Product(ty), value);\n    return writer.toBase64();\n  },\n};\n\nexport type SumType = SumTypeType;\n\n/**\n * Unlike most languages, sums in SATS are *[structural]* and not nominal.\n * When checking whether two nominal types are the same,\n * their names and/or declaration sites (e.g., module / namespace) are considered.\n * Meanwhile, a structural type system would only check the structure of the type itself,\n * e.g., the names of its variants and their inner data types in the case of a sum.\n *\n * This is also known as a discriminated union (implementation) or disjoint union.\n * Another name is [coproduct (category theory)](https://ncatlab.org/nlab/show/coproduct).\n *\n * These structures are known as sum types because the number of possible values a sum\n * ```ignore\n * { N_0(T_0), N_1(T_1), ..., N_n(T_n) }\n * ```\n * is:\n * ```ignore\n *  (i  0..n). values(T_i)\n * ```\n * so for example, `values({ A(U64), B(Bool) }) = values(U64) + values(Bool)`.\n *\n * See also: https://ncatlab.org/nlab/show/sum+type.\n *\n * [structural]: https://en.wikipedia.org/wiki/Structural_type_system\n */\nexport const SumType = {\n  serializeValue: function (\n    writer: BinaryWriter,\n    ty: SumTypeType,\n    value: any,\n    typespace?: TypespaceType\n  ): void {\n    if (\n      ty.variants.length == 2 &&\n      ty.variants[0].name === 'some' &&\n      ty.variants[1].name === 'none'\n    ) {\n      if (value !== null && value !== undefined) {\n        writer.writeByte(0);\n        AlgebraicType.serializeValue(\n          writer,\n          ty.variants[0].algebraicType,\n          value,\n          typespace\n        );\n      } else {\n        writer.writeByte(1);\n      }\n    } else if (\n      ty.variants.length == 2 &&\n      ty.variants[0].name === 'ok' &&\n      ty.variants[1].name === 'err'\n    ) {\n      let variantName: 'ok' | 'err';\n      let innerValue: any;\n      let index: number;\n      if ('ok' in value) {\n        variantName = 'ok';\n        innerValue = value.ok;\n        index = 0;\n      } else {\n        variantName = 'err';\n        innerValue = value.err;\n        index = 1;\n      }\n\n      if (index < 0) {\n        throw `Result serialization error: variant '${variantName}' not found in ${JSON.stringify(ty)}`;\n      }\n\n      writer.writeU8(index);\n\n      AlgebraicType.serializeValue(\n        writer,\n        ty.variants[index].algebraicType,\n        innerValue,\n        typespace\n      );\n    } else {\n      const variant = value['tag'];\n      const index = ty.variants.findIndex(v => v.name === variant);\n      if (index < 0) {\n        throw `Can't serialize a sum type, couldn't find ${value.tag} tag ${JSON.stringify(value)} in variants ${JSON.stringify(ty)}`;\n      }\n      writer.writeU8(index);\n      AlgebraicType.serializeValue(\n        writer,\n        ty.variants[index].algebraicType,\n        value['value'],\n        typespace\n      );\n    }\n  },\n  deserializeValue: function (\n    reader: BinaryReader,\n    ty: SumTypeType,\n    typespace?: TypespaceType\n  ): any {\n    const tag = reader.readU8();\n    // In TypeScript we handle Option values as a special case\n    // we don't represent the some and none variants, but instead\n    // we represent the value directly.\n    if (\n      ty.variants.length == 2 &&\n      ty.variants[0].name === 'some' &&\n      ty.variants[1].name === 'none'\n    ) {\n      if (tag === 0) {\n        return AlgebraicType.deserializeValue(\n          reader,\n          ty.variants[0].algebraicType,\n          typespace\n        );\n      } else if (tag === 1) {\n        return undefined;\n      } else {\n        throw `Can't deserialize an option type, couldn't find ${tag} tag`;\n      }\n    } else if (\n      ty.variants.length == 2 &&\n      ty.variants[0].name === 'ok' &&\n      ty.variants[1].name === 'err'\n    ) {\n      if (tag === 0) {\n        const value = AlgebraicType.deserializeValue(\n          reader,\n          ty.variants[0].algebraicType,\n          typespace\n        );\n        return { ok: value };\n      } else if (tag === 1) {\n        const value = AlgebraicType.deserializeValue(\n          reader,\n          ty.variants[1].algebraicType,\n          typespace\n        );\n        return { err: value };\n      } else {\n        throw `Can't deserialize a result type, couldn't find ${tag} tag`;\n      }\n    } else {\n      const variant = ty.variants[tag];\n      const value = AlgebraicType.deserializeValue(\n        reader,\n        variant.algebraicType,\n        typespace\n      );\n      return { tag: variant.name, value };\n    }\n  },\n};\n\nexport type ComparablePrimitive = number | string | boolean | bigint;\n","import { AlgebraicType } from './algebraic_type';\nimport { hexStringToU128, u128ToHexString, u128ToUint8Array } from './util';\n\nexport type ConnectionIdAlgebraicType = {\n  tag: 'Product';\n  value: {\n    elements: [{ name: '__connection_id__'; algebraicType: { tag: 'U128' } }];\n  };\n};\n\n/**\n * A unique identifier for a client connected to a database.\n */\nexport class ConnectionId {\n  __connection_id__: bigint;\n\n  /**\n   * Creates a new `ConnectionId`.\n   */\n  constructor(data: bigint) {\n    this.__connection_id__ = data;\n  }\n\n  /**\n   * Get the algebraic type representation of the {@link ConnectionId} type.\n   * @returns The algebraic type representation of the type.\n   */\n  static getAlgebraicType(): ConnectionIdAlgebraicType {\n    return AlgebraicType.Product({\n      elements: [\n        { name: '__connection_id__', algebraicType: AlgebraicType.U128 },\n      ],\n    });\n  }\n\n  isZero(): boolean {\n    return this.__connection_id__ === BigInt(0);\n  }\n\n  static nullIfZero(addr: ConnectionId): ConnectionId | null {\n    if (addr.isZero()) {\n      return null;\n    } else {\n      return addr;\n    }\n  }\n\n  static random(): ConnectionId {\n    function randomU8(): number {\n      return Math.floor(Math.random() * 0xff);\n    }\n    let result = BigInt(0);\n    for (let i = 0; i < 16; i++) {\n      result = (result << BigInt(8)) | BigInt(randomU8());\n    }\n    return new ConnectionId(result);\n  }\n\n  /**\n   * Compare two connection IDs for equality.\n   */\n  isEqual(other: ConnectionId): boolean {\n    return this.__connection_id__ == other.__connection_id__;\n  }\n\n  /**\n   * Check if two connection IDs are equal.\n   */\n  equals(other: ConnectionId): boolean {\n    return this.isEqual(other);\n  }\n\n  /**\n   * Print the connection ID as a hexadecimal string.\n   */\n  toHexString(): string {\n    return u128ToHexString(this.__connection_id__);\n  }\n\n  /**\n   * Convert the connection ID to a Uint8Array.\n   */\n  toUint8Array(): Uint8Array {\n    return u128ToUint8Array(this.__connection_id__);\n  }\n\n  /**\n   * Parse a connection ID from a hexadecimal string.\n   */\n  static fromString(str: string): ConnectionId {\n    return new ConnectionId(hexStringToU128(str));\n  }\n\n  static fromStringOrNull(str: string): ConnectionId | null {\n    const addr = ConnectionId.fromString(str);\n    if (addr.isZero()) {\n      return null;\n    } else {\n      return addr;\n    }\n  }\n}\n","import BinaryReader from './binary_reader';\n\nexport interface ParseableType<T> {\n  deserialize: (reader: BinaryReader) => T;\n}\n\nexport function parseValue<T>(ty: ParseableType<T>, src: Uint8Array): T {\n  const reader = new BinaryReader(src);\n  return ty.deserialize(reader);\n}\n","import { AlgebraicType } from './algebraic_type';\nimport { TimeDuration, type TimeDurationAlgebraicType } from './time_duration';\nimport { Timestamp, type TimestampAlgebraicType } from './timestamp';\n\nexport type ScheduleAtAlgebraicType = {\n  tag: 'Sum';\n  value: {\n    variants: [\n      { name: 'Interval'; algebraicType: TimeDurationAlgebraicType },\n      { name: 'Time'; algebraicType: TimestampAlgebraicType },\n    ];\n  };\n};\n\ntype ScheduleAtType = Interval | Time;\n\nexport const ScheduleAt: {\n  interval: (micros: bigint) => ScheduleAtType;\n  time: (microsSinceUnixEpoch: bigint) => ScheduleAtType;\n  /**\n   * Get the algebraic type representation of the {@link ScheduleAt} type.\n   * @returns The algebraic type representation of the type.\n   */\n  getAlgebraicType(): ScheduleAtAlgebraicType;\n  isScheduleAt(\n    algebraicType: AlgebraicType\n  ): algebraicType is ScheduleAtAlgebraicType;\n} = {\n  interval(value: bigint): ScheduleAtType {\n    return Interval(value);\n  },\n  time(value: bigint): ScheduleAtType {\n    return Time(value);\n  },\n  getAlgebraicType(): ScheduleAtAlgebraicType {\n    return AlgebraicType.Sum({\n      variants: [\n        {\n          name: 'Interval',\n          algebraicType: TimeDuration.getAlgebraicType(),\n        },\n        { name: 'Time', algebraicType: Timestamp.getAlgebraicType() },\n      ],\n    });\n  },\n  isScheduleAt(\n    algebraicType: AlgebraicType\n  ): algebraicType is ScheduleAtAlgebraicType {\n    if (algebraicType.tag !== 'Sum') {\n      return false;\n    }\n    const variants = algebraicType.value.variants;\n    if (variants.length !== 2) {\n      return false;\n    }\n    const intervalVariant = variants.find(v => v.name === 'Interval');\n    const timeVariant = variants.find(v => v.name === 'Time');\n    if (!intervalVariant || !timeVariant) {\n      return false;\n    }\n    return (\n      TimeDuration.isTimeDuration(intervalVariant.algebraicType) &&\n      Timestamp.isTimestamp(timeVariant.algebraicType)\n    );\n  },\n};\n\nexport type Interval = {\n  tag: 'Interval';\n  value: TimeDuration;\n};\nexport const Interval = (micros: bigint): Interval => ({\n  tag: 'Interval',\n  value: new TimeDuration(micros),\n});\nexport type Time = {\n  tag: 'Time';\n  value: Timestamp;\n};\nexport const Time = (microsSinceUnixEpoch: bigint): Time => ({\n  tag: 'Time',\n  value: new Timestamp(microsSinceUnixEpoch),\n});\n\nexport default ScheduleAt;\nexport type ScheduleAt = ScheduleAtType;\n","import { AlgebraicType } from './algebraic_type';\n\nexport type OptionAlgebraicType<T extends AlgebraicType = AlgebraicType> = {\n  tag: 'Sum';\n  value: {\n    variants: [\n      { name: 'some'; algebraicType: T },\n      {\n        name: 'none';\n        algebraicType: { tag: 'Product'; value: { elements: [] } };\n      },\n    ];\n  };\n};\n\nexport const Option: {\n  getAlgebraicType<T extends AlgebraicType = AlgebraicType>(\n    innerType: T\n  ): OptionAlgebraicType<T>;\n} = {\n  getAlgebraicType<T extends AlgebraicType = AlgebraicType>(\n    innerType: T\n  ): OptionAlgebraicType<T> {\n    return AlgebraicType.Sum({\n      variants: [\n        { name: 'some', algebraicType: innerType },\n        {\n          name: 'none',\n          algebraicType: AlgebraicType.Product({ elements: [] }),\n        },\n      ],\n    });\n  },\n};\n","import { AlgebraicType } from './algebraic_type';\n\nexport type ResultAlgebraicType<\n  T extends AlgebraicType = AlgebraicType,\n  E extends AlgebraicType = AlgebraicType,\n> = {\n  tag: 'Sum';\n  value: {\n    variants: [\n      { name: 'ok'; algebraicType: T },\n      { name: 'err'; algebraicType: E },\n    ];\n  };\n};\n\nexport const Result: {\n  getAlgebraicType<\n    T extends AlgebraicType = AlgebraicType,\n    E extends AlgebraicType = AlgebraicType,\n  >(\n    okType: T,\n    errType: E\n  ): ResultAlgebraicType<T, E>;\n} = {\n  getAlgebraicType<\n    T extends AlgebraicType = AlgebraicType,\n    E extends AlgebraicType = AlgebraicType,\n  >(okType: T, errType: E): ResultAlgebraicType<T, E> {\n    return AlgebraicType.Sum({\n      variants: [\n        { name: 'ok', algebraicType: okType },\n        { name: 'err', algebraicType: errType },\n      ],\n    });\n  },\n};\n","import type { ConnectionId } from './connection_id';\nimport type { Identity } from './identity';\nimport type { ScheduleAt } from './schedule_at';\nimport type { TimeDuration } from './time_duration';\nimport type { Timestamp } from './timestamp';\n\ntype DoNotPrettify =\n  | Identity\n  | ConnectionId\n  | Timestamp\n  | TimeDuration\n  | ScheduleAt;\n\n/**\n * Utility to make TS show cleaner types by flattening intersections.\n */\nexport type Prettify<T> = T extends DoNotPrettify\n  ? T\n  : { [K in keyof T]: T[K] } & {};\n\n/**\n * Helper function to sets a field in an object\n */\nexport type SetField<T, F extends string, V> = Prettify<\n  Omit<T, F> & { [K in F]: V }\n>;\n\n/**\n * Sets a field in an object\n * @param x The original object\n * @param t The object containing the field to set\n * @returns A new object with the field set\n */\nexport function set<T, F extends string, V>(\n  x: T,\n  t: { [k in F]: V }\n): SetField<T, F, V> {\n  return { ...x, ...t } as SetField<T, F, V>;\n}\n\n/**\n * Helper to extract the value types from an object type\n */\nexport type Values<T> = T[keyof T];\n\n/**\n * A helper type to collapse a tuple into a single type if it has only one element.\n */\nexport type CollapseTuple<A extends any[]> = A extends [infer T] ? T : A;\n\ntype CamelCaseImpl<S extends string> = S extends `${infer Head}_${infer Tail}`\n  ? `${Head}${Capitalize<CamelCaseImpl<Tail>>}`\n  : S extends `${infer Head}-${infer Tail}`\n    ? `${Head}${Capitalize<CamelCaseImpl<Tail>>}`\n    : S;\n\n/**\n * Convert \"Some_identifier-name\" -> \"someIdentifierName\"\n * - No spaces; allowed separators: \"_\" and \"-\"\n * - Normalizes the *first* character to lowercase (e.g. \"User_Name\" -> \"userName\")\n */\nexport type CamelCase<S extends string> = Uncapitalize<CamelCaseImpl<S>>;\n\n/** Type safe conversion from \"some_identifier-name\" to \"some_identifier_name\"\n * - No spaces; allowed separators: \"_\" and \"-\"\n * - Normalizes the *first* character to lowercase (e.g. \"User_Name\" -> \"user_name\")\n */\nexport type SnakeCase<S extends string> = S extends `${infer Head}${infer Tail}`\n  ? Tail extends Uncapitalize<Tail>\n    ? `${Lowercase<Head>}${SnakeCase<Tail>}`\n    : `${Lowercase<Head>}_${SnakeCase<Tail>}`\n  : Lowercase<S>;\n\ntype PascalCaseImpl<S extends string> = S extends `${infer Head}_${infer Tail}`\n  ? `${Capitalize<Head>}${PascalCaseImpl<Tail>}`\n  : S extends `${infer Head}-${infer Tail}`\n    ? `${Capitalize<Head>}${PascalCaseImpl<Tail>}`\n    : Capitalize<S>;\n\n/**\n * Convert \"some_identifier-name\" -> \"SomeIdentifierName\"\n * - No spaces; allowed separators: \"_\" and \"-\"\n * - Normalizes the *first* character to uppercase (e.g. \"user_name\" -> \"UserName\")\n */\nexport type PascalCase<S extends string> = PascalCaseImpl<S>;\n","import { AlgebraicType, type AlgebraicTypeVariants } from './algebraic_type';\nimport type BinaryReader from './binary_reader';\nimport type BinaryWriter from './binary_writer';\nimport { ConnectionId, type ConnectionIdAlgebraicType } from './connection_id';\nimport { Identity, type IdentityAlgebraicType } from './identity';\nimport { Option, type OptionAlgebraicType } from './option';\nimport { Result, type ResultAlgebraicType } from './result';\nimport ScheduleAt, { type ScheduleAtAlgebraicType } from './schedule_at';\nimport type { CoerceRow } from './table';\nimport { TimeDuration, type TimeDurationAlgebraicType } from './time_duration';\nimport { Timestamp, type TimestampAlgebraicType } from './timestamp';\nimport { set, type Prettify, type SetField } from './type_util';\nimport { Uuid, type UuidAlgebraicType } from './uuid';\n\n// Used in codegen files\nexport { type AlgebraicTypeType } from './algebraic_type';\n\n/**\n * Helper type to extract the TypeScript type from a TypeBuilder\n */\nexport type InferTypeOfTypeBuilder<T extends TypeBuilder<any, any>> =\n  T extends TypeBuilder<infer U, any> ? Prettify<U> : never;\n\n/**\n * Helper type to extract the Spacetime type from a TypeBuilder\n */\nexport type InferSpacetimeTypeOfTypeBuilder<T extends TypeBuilder<any, any>> =\n  T extends TypeBuilder<any, infer U> ? U : never;\n\n/**\n * Helper type to extract the TypeScript type from a TypeBuilder\n */\nexport type Infer<T> = T extends RowObj\n  ? InferTypeOfRow<T>\n  : T extends TypeBuilder<any, any>\n    ? InferTypeOfTypeBuilder<T>\n    : never;\n\n/**\n * Helper type to extract the type of a row from an object.\n */\nexport type InferTypeOfRow<T extends RowObj> = {\n  [K in keyof T & string]: InferTypeOfTypeBuilder<CollapseColumn<T[K]>>;\n};\n\n/**\n * Helper type to extract the type of a row from an object.\n */\nexport type InferSpacetimeTypeOfRow<T extends RowObj> = {\n  [K in keyof T & string]: InferSpacetimeTypeOfTypeBuilder<\n    CollapseColumn<T[K]>\n  >;\n};\n\n/**\n * Helper type to extract the Spacetime type from a row object.\n */\ntype CollapseColumn<\n  T extends TypeBuilder<any, any> | ColumnBuilder<any, any, any>,\n> = T extends ColumnBuilder<any, any, any> ? T['typeBuilder'] : T;\n\n/**\n * A type representing an object which is used to define the type of\n * a row in a table.\n */\nexport type RowObj = Record<\n  string,\n  TypeBuilder<any, any> | ColumnBuilder<any, any, ColumnMetadata<any>>\n>;\n\n/**\n * Type which converts the elements of RowObj to a ProductType elements array\n */\ntype ElementsArrayFromRowObj<Obj extends RowObj> = Array<\n  {\n    [N in keyof Obj & string]: {\n      name: N;\n      algebraicType: InferSpacetimeTypeOfTypeBuilder<CollapseColumn<Obj[N]>>;\n    };\n  }[keyof Obj & string]\n>;\n\n/**\n * A type which converts the elements of RowObj to a TypeScript object type.\n * It works by `Infer`ing the types of the column builders which are the values of\n * the keys in the object passed in.\n *\n * e.g. { a: I32TypeBuilder, b: StringBuilder } -> { a: number, b: string }\n */\ntype RowType<Row extends RowObj> = {\n  [K in keyof Row]: InferTypeOfTypeBuilder<CollapseColumn<Row[K]>>;\n};\n\n/**\n * Type which represents a valid argument to the ProductColumnBuilder\n */\nexport type ElementsObj = Record<string, TypeBuilder<any, any>>;\n\n/**\n * Type which converts the elements of ElementsObj to a ProductType elements array\n */\ntype ElementsArrayFromElementsObj<Obj extends ElementsObj> = Array<\n  {\n    [N in keyof Obj & string]: {\n      name: N;\n      algebraicType: InferSpacetimeTypeOfTypeBuilder<Obj[N]>;\n    };\n  }[keyof Obj & string]\n>;\n\n/**\n * A type which converts the elements of ElementsObj to a TypeScript object type.\n * It works by `Infer`ing the types of the column builders which are the values of\n * the keys in the object passed in.\n *\n * e.g. { a: I32TypeBuilder, b: StringBuilder } -> { a: number, b: string }\n */\ntype ObjectType<Elements extends ElementsObj> = {\n  [K in keyof Elements]: InferTypeOfTypeBuilder<Elements[K]>;\n};\n\nexport type VariantsObj = Record<string, TypeBuilder<any, any>>;\ntype SimpleVariantsObj = Record<string, UnitBuilder>;\n\ntype IsUnit<B> = B extends UnitBuilder ? true : false;\n\n/**\n * A type which converts the elements of ElementsObj to a TypeScript object type.\n * It works by `Infer`ing the types of the column builders which are the values of\n * the keys in the object passed in.\n *\n * e.g. { A: I32TypeBuilder, B: StringBuilder } -> { tag: \"A\", value: number } | { tag: \"B\", value: string }\n */\ntype EnumType<Variants extends VariantsObj> = {\n  [K in keyof Variants & string]: IsUnit<Variants[K]> extends true\n    ? { tag: K }\n    : { tag: K; value: InferTypeOfTypeBuilder<Variants[K]> };\n}[keyof Variants & string];\n\n/**\n * Type which converts the elements of VariantsObj to a SumType variants array\n */\ntype VariantsArrayFromVariantsObj<Obj extends VariantsObj> = {\n  name: keyof Obj & string;\n  algebraicType: InferSpacetimeTypeOfTypeBuilder<Obj[keyof Obj & string]>;\n}[];\n\n/**\n * A generic type builder that captures both the TypeScript type\n * and the corresponding `AlgebraicType`.\n */\nexport class TypeBuilder<Type, SpacetimeType extends AlgebraicType>\n  implements Optional<Type, SpacetimeType>\n{\n  /**\n   * The TypeScript phantom type. This is not stored at runtime,\n   * but is visible to the compiler\n   */\n  readonly type!: Type;\n\n  /**\n   * The SpacetimeDB algebraic type (runtime value). In addition to storing\n   * the runtime representation of the `AlgebraicType`, it also captures\n   * the TypeScript type information of the `AlgebraicType`. That is to say\n   * the value is not merely an `AlgebraicType`, but is constructed to be\n   * the corresponding concrete `AlgebraicType` for the TypeScript type `Type`.\n   *\n   * e.g. `string` corresponds to `AlgebraicType.String`\n   */\n  readonly algebraicType: SpacetimeType;\n\n  constructor(algebraicType: SpacetimeType) {\n    this.algebraicType = algebraicType;\n  }\n\n  optional(): OptionBuilder<typeof this> {\n    return new OptionBuilder(this);\n  }\n\n  serialize(writer: BinaryWriter, value: Type): void {\n    AlgebraicType.serializeValue(writer, this.algebraicType, value);\n  }\n\n  deserialize(reader: BinaryReader): Type {\n    return AlgebraicType.deserializeValue(reader, this.algebraicType);\n  }\n}\n\n/**\n * Interface for types that can be converted into a column builder with primary key metadata.\n *\n * Implementing this interface allows a type to be marked as the primary key of a table column\n * in a type-safe manner. The `primaryKey()` method returns a new `ColumnBuilder` instance\n * with the metadata updated to indicate that the column is a primary key.\n *\n * @typeParam Type - The TypeScript type of the column's value.\n * @typeParam SpacetimeType - The corresponding SpacetimeDB algebraic type.\n * @typeParam M - The metadata type for the column, defaulting to `DefaultMetadata`.\n *\n * @remarks\n * - This interface is typically implemented by type builders for primitive and complex types.\n * - The returned `ColumnBuilder` will have its metadata extended with `{ isPrimaryKey: true }`.\n * - Marking a column as a primary key is mutually exclusive with certain other metadata flags,\n *   such as `isAutoIncrement` or `isUnique`, depending on the database schema rules.\n */\ninterface PrimaryKeyable<\n  Type,\n  SpacetimeType extends AlgebraicType,\n  M extends ColumnMetadata<Type> = DefaultMetadata,\n> {\n  /**\n   * Specify this column as primary key\n   */\n  primaryKey(): ColumnBuilder<\n    Type,\n    SpacetimeType,\n    SetField<M, 'isPrimaryKey', true>\n  >;\n}\n\n/**\n * Interface for types that can be converted into a column builder with unique metadata.\n *\n * Implementing this interface allows a type to be marked as unique in a table column\n * in a type-safe manner. The `unique()` method returns a new `ColumnBuilder` instance\n * with the metadata updated to indicate that the column is unique.\n *\n * @typeParam Type - The TypeScript type of the column's value.\n * @typeParam SpacetimeType - The corresponding SpacetimeDB algebraic type.\n * @typeParam M - The metadata type for the column, defaulting to `DefaultMetadata`.\n *\n * @remarks\n * - This interface is typically implemented by type builders for primitive and complex types.\n * - The returned `ColumnBuilder` will have its metadata extended with `{ isUnique: true }`.\n * - Marking a column as unique is mutually exclusive with certain other metadata flags,\n *   such as `isAutoIncrement` or `isPrimaryKey`, depending on the database schema rules.\n */\ninterface Uniqueable<\n  Type,\n  SpacetimeType extends AlgebraicType,\n  M extends ColumnMetadata<Type> = DefaultMetadata,\n> {\n  /**\n   * Specify this column as unique\n   */\n  unique(): ColumnBuilder<Type, SpacetimeType, SetField<M, 'isUnique', true>>;\n}\n\n/**\n * Interface for types that can be converted into a column builder with index metadata.\n *\n * Implementing this interface allows a type to be indexed in a table column\n * in a type-safe manner. The `index()` method returns a new `ColumnBuilder` instance\n * with the metadata updated to indicate the index type.\n *\n * @typeParam Type - The TypeScript type of the column's value.\n * @typeParam SpacetimeType - The corresponding SpacetimeDB algebraic type.\n * @typeParam M - The metadata type for the column, defaulting to `DefaultMetadata`.\n *\n * @remarks\n * - This interface is typically implemented by type builders for primitive and complex types.\n * - The returned `ColumnBuilder` will have its metadata extended with `{ indexType: N }`.\n * - Indexing a column may have implications for performance and query optimization.\n */\ninterface Indexable<\n  Type,\n  SpacetimeType extends AlgebraicType,\n  M extends ColumnMetadata<Type> = DefaultMetadata,\n> {\n  /**\n   * Specify the index type for this column\n   * @param algorithm The index algorithm to use\n   */\n  index(): ColumnBuilder<\n    Type,\n    SpacetimeType,\n    SetField<M, 'indexType', 'btree'>\n  >;\n  index<N extends NonNullable<IndexTypes>>(\n    algorithm: N\n  ): ColumnBuilder<Type, SpacetimeType, SetField<M, 'indexType', N>>;\n}\n\n/**\n * Interface for types that can be converted into a column builder with auto-increment metadata.\n *\n * Implementing this interface allows a type to be marked as auto-incrementing in a table column\n * in a type-safe manner. The `autoInc()` method returns a new `ColumnBuilder` instance\n * with the metadata updated to indicate that the column is auto-incrementing.\n *\n * @typeParam Type - The TypeScript type of the column's value.\n * @typeParam SpacetimeType - The corresponding SpacetimeDB algebraic type.\n * @typeParam M - The metadata type for the column, defaulting to `DefaultMetadata`.\n *\n * @remarks\n * - This interface is typically implemented by type builders for primitive and complex types.\n * - The returned `ColumnBuilder` will have its metadata extended with `{ isAutoIncrement: true }`.\n * - Marking a column as auto-incrementing is mutually exclusive with certain other metadata flags,\n *   such as `isUnique` or `isPrimaryKey`, depending on the database schema rules.\n */\ninterface AutoIncrementable<\n  Type,\n  SpacetimeType extends AlgebraicType,\n  M extends ColumnMetadata<Type> = DefaultMetadata,\n> {\n  /**\n   * Specify this column as auto-incrementing\n   */\n  autoInc(): ColumnBuilder<\n    Type,\n    SpacetimeType,\n    SetField<M, 'isAutoIncrement', true>\n  >;\n}\n\n/**\n * Interface for types that can be converted into an optional type.\n * All {@link TypeBuilder}s implement this interface, however since the `optional()` method\n * returns an {@link OptionBuilder}, {@link OptionBuilder} controls what metadata is allowed\n * to be configured for the column. This allows us to restrict whether things like indexes\n * or unique constraints can be applied to optional columns.\n *\n * For this reason {@link ColumnBuilder} does not implement this interface.\n */\ninterface Optional<Type, SpacetimeType extends AlgebraicType> {\n  /**\n   * Specify this column as optional\n   */\n  optional(this: TypeBuilder<Type, SpacetimeType>): OptionBuilder<typeof this>;\n}\n\n/**\n * Interface for types that can be converted into a column builder with default value metadata.\n * Implementing this interface allows a type to have a default value specified in a table column\n * in a type-safe manner. The `default()` method returns a new `ColumnBuilder` instance\n * with the metadata updated to include the specified default value.\n *\n * @typeParam Type - The TypeScript type of the column's value.\n * @typeParam SpacetimeType - The corresponding SpacetimeDB algebraic type.\n * @typeParam M - The metadata type for the column, defaulting to `DefaultMetadata`.\n *\n * @remarks\n * - This interface is typically implemented by type builders for primitive and complex types.\n * - The returned `ColumnBuilder` will have its metadata extended with `{ default: value }`.\n * - The default value must be of the same type as the column's TypeScript type.\n * - This method can be called multiple times; the last call takes precedence.\n */\ninterface Defaultable<\n  Type,\n  SpacetimeType extends AlgebraicType,\n  M extends ColumnMetadata<Type> = DefaultMetadata,\n> {\n  /**\n   * Specify a default value for this column\n   * @param value The default value for the column\n   * @example\n   * ```typescript\n   * const col = t.i32().default(42);\n   * ```\n   * @remarks\n   * - This method can be called multiple times; the last call takes precedence.\n   * - The default value must be of the same type as the column's TypeScript type.\n   */\n  default(\n    value: Type\n  ): ColumnBuilder<Type, SpacetimeType, SetField<M, 'defaultValue', Type>>;\n}\n\ninterface Nameable<\n  Type,\n  SpacetimeType extends AlgebraicType,\n  M extends ColumnMetadata<Type> = DefaultMetadata,\n> {\n  /**\n   * Specify the in-database name for this column.\n   */\n  name<const Name extends string>(\n    name: Name\n  ): Nameable<Type, SpacetimeType, SetField<M, 'name', Name>>;\n}\n\nexport class U8Builder\n  extends TypeBuilder<number, AlgebraicTypeVariants.U8>\n  implements\n    Indexable<number, AlgebraicTypeVariants.U8>,\n    Uniqueable<number, AlgebraicTypeVariants.U8>,\n    PrimaryKeyable<number, AlgebraicTypeVariants.U8>,\n    AutoIncrementable<number, AlgebraicTypeVariants.U8>,\n    Defaultable<number, AlgebraicTypeVariants.U8>,\n    Nameable<number, AlgebraicTypeVariants.U8>\n{\n  constructor() {\n    super(AlgebraicType.U8);\n  }\n  index(): U8ColumnBuilder<SetField<DefaultMetadata, 'indexType', 'btree'>>;\n  index<N extends NonNullable<IndexTypes>>(\n    algorithm: N\n  ): U8ColumnBuilder<SetField<DefaultMetadata, 'indexType', N>>;\n  index(\n    algorithm: IndexTypes = 'btree'\n  ): U8ColumnBuilder<SetField<DefaultMetadata, 'indexType', IndexTypes>> {\n    return new U8ColumnBuilder(\n      this,\n      set(defaultMetadata, { indexType: algorithm })\n    );\n  }\n  unique(): U8ColumnBuilder<SetField<DefaultMetadata, 'isUnique', true>> {\n    return new U8ColumnBuilder(this, set(defaultMetadata, { isUnique: true }));\n  }\n  primaryKey(): U8ColumnBuilder<\n    SetField<DefaultMetadata, 'isPrimaryKey', true>\n  > {\n    return new U8ColumnBuilder(\n      this,\n      set(defaultMetadata, { isPrimaryKey: true })\n    );\n  }\n  autoInc(): U8ColumnBuilder<\n    SetField<DefaultMetadata, 'isAutoIncrement', true>\n  > {\n    return new U8ColumnBuilder(\n      this,\n      set(defaultMetadata, { isAutoIncrement: true })\n    );\n  }\n  default(\n    value: number\n  ): U8ColumnBuilder<SetField<DefaultMetadata, 'defaultValue', number>> {\n    return new U8ColumnBuilder(\n      this,\n      set(defaultMetadata, { defaultValue: value })\n    );\n  }\n  name<const Name extends string>(\n    name: Name\n  ): U8ColumnBuilder<SetField<DefaultMetadata, 'name', Name>> {\n    return new U8ColumnBuilder(this, set(defaultMetadata, { name }));\n  }\n}\n\nexport class U16Builder\n  extends TypeBuilder<number, AlgebraicTypeVariants.U16>\n  implements\n    Indexable<number, AlgebraicTypeVariants.U16>,\n    Uniqueable<number, AlgebraicTypeVariants.U16>,\n    PrimaryKeyable<number, AlgebraicTypeVariants.U16>,\n    AutoIncrementable<number, AlgebraicTypeVariants.U16>,\n    Defaultable<number, AlgebraicTypeVariants.U16>,\n    Nameable<number, AlgebraicTypeVariants.U16>\n{\n  constructor() {\n    super(AlgebraicType.U16);\n  }\n  index(): U16ColumnBuilder<SetField<DefaultMetadata, 'indexType', 'btree'>>;\n  index<N extends NonNullable<IndexTypes>>(\n    algorithm: N\n  ): U16ColumnBuilder<SetField<DefaultMetadata, 'indexType', N>>;\n  index(\n    algorithm: IndexTypes = 'btree'\n  ): U16ColumnBuilder<SetField<DefaultMetadata, 'indexType', IndexTypes>> {\n    return new U16ColumnBuilder(\n      this,\n      set(defaultMetadata, { indexType: algorithm })\n    );\n  }\n  unique(): U16ColumnBuilder<SetField<DefaultMetadata, 'isUnique', true>> {\n    return new U16ColumnBuilder(this, set(defaultMetadata, { isUnique: true }));\n  }\n  primaryKey(): U16ColumnBuilder<\n    SetField<DefaultMetadata, 'isPrimaryKey', true>\n  > {\n    return new U16ColumnBuilder(\n      this,\n      set(defaultMetadata, { isPrimaryKey: true })\n    );\n  }\n  autoInc(): U16ColumnBuilder<\n    SetField<DefaultMetadata, 'isAutoIncrement', true>\n  > {\n    return new U16ColumnBuilder(\n      this,\n      set(defaultMetadata, { isAutoIncrement: true })\n    );\n  }\n  default(\n    value: number\n  ): U16ColumnBuilder<SetField<DefaultMetadata, 'defaultValue', number>> {\n    return new U16ColumnBuilder(\n      this,\n      set(defaultMetadata, { defaultValue: value })\n    );\n  }\n  name<const Name extends string>(\n    name: Name\n  ): U16ColumnBuilder<SetField<DefaultMetadata, 'name', Name>> {\n    return new U16ColumnBuilder(this, set(defaultMetadata, { name }));\n  }\n}\n\nexport class U32Builder\n  extends TypeBuilder<number, AlgebraicTypeVariants.U32>\n  implements\n    Indexable<number, AlgebraicTypeVariants.U32>,\n    Uniqueable<number, AlgebraicTypeVariants.U32>,\n    PrimaryKeyable<number, AlgebraicTypeVariants.U32>,\n    AutoIncrementable<number, AlgebraicTypeVariants.U32>,\n    Defaultable<number, AlgebraicTypeVariants.U32>,\n    Nameable<number, AlgebraicTypeVariants.U32>\n{\n  constructor() {\n    super(AlgebraicType.U32);\n  }\n  index(): U32ColumnBuilder<SetField<DefaultMetadata, 'indexType', 'btree'>>;\n  index<N extends NonNullable<IndexTypes>>(\n    algorithm: N\n  ): U32ColumnBuilder<SetField<DefaultMetadata, 'indexType', N>>;\n  index(\n    algorithm: IndexTypes = 'btree'\n  ): U32ColumnBuilder<SetField<DefaultMetadata, 'indexType', IndexTypes>> {\n    return new U32ColumnBuilder(\n      this,\n      set(defaultMetadata, { indexType: algorithm })\n    );\n  }\n  unique(): U32ColumnBuilder<SetField<DefaultMetadata, 'isUnique', true>> {\n    return new U32ColumnBuilder(this, set(defaultMetadata, { isUnique: true }));\n  }\n  primaryKey(): U32ColumnBuilder<\n    SetField<DefaultMetadata, 'isPrimaryKey', true>\n  > {\n    return new U32ColumnBuilder(\n      this,\n      set(defaultMetadata, { isPrimaryKey: true })\n    );\n  }\n  autoInc(): U32ColumnBuilder<\n    SetField<DefaultMetadata, 'isAutoIncrement', true>\n  > {\n    return new U32ColumnBuilder(\n      this,\n      set(defaultMetadata, { isAutoIncrement: true })\n    );\n  }\n  default(\n    value: number\n  ): U32ColumnBuilder<SetField<DefaultMetadata, 'defaultValue', number>> {\n    return new U32ColumnBuilder(\n      this,\n      set(defaultMetadata, { defaultValue: value })\n    );\n  }\n  name<const Name extends string>(\n    name: Name\n  ): U32ColumnBuilder<SetField<DefaultMetadata, 'name', Name>> {\n    return new U32ColumnBuilder(this, set(defaultMetadata, { name }));\n  }\n}\n\nexport class U64Builder\n  extends TypeBuilder<bigint, AlgebraicTypeVariants.U64>\n  implements\n    Indexable<bigint, AlgebraicTypeVariants.U64>,\n    Uniqueable<bigint, AlgebraicTypeVariants.U64>,\n    PrimaryKeyable<bigint, AlgebraicTypeVariants.U64>,\n    AutoIncrementable<bigint, AlgebraicTypeVariants.U64>,\n    Defaultable<bigint, AlgebraicTypeVariants.U64>,\n    Nameable<bigint, AlgebraicTypeVariants.U64>\n{\n  constructor() {\n    super(AlgebraicType.U64);\n  }\n  index(): U64ColumnBuilder<SetField<DefaultMetadata, 'indexType', 'btree'>>;\n  index<N extends NonNullable<IndexTypes>>(\n    algorithm: N\n  ): U64ColumnBuilder<SetField<DefaultMetadata, 'indexType', N>>;\n  index(\n    algorithm: IndexTypes = 'btree'\n  ): U64ColumnBuilder<SetField<DefaultMetadata, 'indexType', IndexTypes>> {\n    return new U64ColumnBuilder(\n      this,\n      set(defaultMetadata, { indexType: algorithm })\n    );\n  }\n  unique(): U64ColumnBuilder<SetField<DefaultMetadata, 'isUnique', true>> {\n    return new U64ColumnBuilder(this, set(defaultMetadata, { isUnique: true }));\n  }\n  primaryKey(): U64ColumnBuilder<\n    SetField<DefaultMetadata, 'isPrimaryKey', true>\n  > {\n    return new U64ColumnBuilder(\n      this,\n      set(defaultMetadata, { isPrimaryKey: true })\n    );\n  }\n  autoInc(): U64ColumnBuilder<\n    SetField<DefaultMetadata, 'isAutoIncrement', true>\n  > {\n    return new U64ColumnBuilder(\n      this,\n      set(defaultMetadata, { isAutoIncrement: true })\n    );\n  }\n  default(\n    value: bigint\n  ): U64ColumnBuilder<SetField<DefaultMetadata, 'defaultValue', bigint>> {\n    return new U64ColumnBuilder(\n      this,\n      set(defaultMetadata, { defaultValue: value })\n    );\n  }\n  name<const Name extends string>(\n    name: Name\n  ): U64ColumnBuilder<SetField<DefaultMetadata, 'name', Name>> {\n    return new U64ColumnBuilder(this, set(defaultMetadata, { name }));\n  }\n}\n\nexport class U128Builder\n  extends TypeBuilder<bigint, AlgebraicTypeVariants.U128>\n  implements\n    Indexable<bigint, AlgebraicTypeVariants.U128>,\n    Uniqueable<bigint, AlgebraicTypeVariants.U128>,\n    PrimaryKeyable<bigint, AlgebraicTypeVariants.U128>,\n    AutoIncrementable<bigint, AlgebraicTypeVariants.U128>,\n    Defaultable<bigint, AlgebraicTypeVariants.U128>,\n    Nameable<bigint, AlgebraicTypeVariants.U128>\n{\n  constructor() {\n    super(AlgebraicType.U128);\n  }\n  index(): U128ColumnBuilder<SetField<DefaultMetadata, 'indexType', 'btree'>>;\n  index<N extends NonNullable<IndexTypes>>(\n    algorithm: N\n  ): U128ColumnBuilder<SetField<DefaultMetadata, 'indexType', N>>;\n  index(\n    algorithm: IndexTypes = 'btree'\n  ): U128ColumnBuilder<SetField<DefaultMetadata, 'indexType', IndexTypes>> {\n    return new U128ColumnBuilder(\n      this,\n      set(defaultMetadata, { indexType: algorithm })\n    );\n  }\n  unique(): U128ColumnBuilder<SetField<DefaultMetadata, 'isUnique', true>> {\n    return new U128ColumnBuilder(\n      this,\n      set(defaultMetadata, { isUnique: true })\n    );\n  }\n  primaryKey(): U128ColumnBuilder<\n    SetField<DefaultMetadata, 'isPrimaryKey', true>\n  > {\n    return new U128ColumnBuilder(\n      this,\n      set(defaultMetadata, { isPrimaryKey: true })\n    );\n  }\n  autoInc(): U128ColumnBuilder<\n    SetField<DefaultMetadata, 'isAutoIncrement', true>\n  > {\n    return new U128ColumnBuilder(\n      this,\n      set(defaultMetadata, { isAutoIncrement: true })\n    );\n  }\n  default(\n    value: bigint\n  ): U128ColumnBuilder<SetField<DefaultMetadata, 'defaultValue', bigint>> {\n    return new U128ColumnBuilder(\n      this,\n      set(defaultMetadata, { defaultValue: value })\n    );\n  }\n  name<const Name extends string>(\n    name: Name\n  ): U128ColumnBuilder<SetField<DefaultMetadata, 'name', Name>> {\n    return new U128ColumnBuilder(this, set(defaultMetadata, { name }));\n  }\n}\n\nexport class U256Builder\n  extends TypeBuilder<bigint, AlgebraicTypeVariants.U256>\n  implements\n    Indexable<bigint, AlgebraicTypeVariants.U256>,\n    Uniqueable<bigint, AlgebraicTypeVariants.U256>,\n    PrimaryKeyable<bigint, AlgebraicTypeVariants.U256>,\n    AutoIncrementable<bigint, AlgebraicTypeVariants.U256>,\n    Defaultable<bigint, AlgebraicTypeVariants.U256>,\n    Nameable<bigint, AlgebraicTypeVariants.U256>\n{\n  constructor() {\n    super(AlgebraicType.U256);\n  }\n  index(): U256ColumnBuilder<SetField<DefaultMetadata, 'indexType', 'btree'>>;\n  index<N extends NonNullable<IndexTypes>>(\n    algorithm: N\n  ): U256ColumnBuilder<SetField<DefaultMetadata, 'indexType', N>>;\n  index(\n    algorithm: IndexTypes = 'btree'\n  ): U256ColumnBuilder<SetField<DefaultMetadata, 'indexType', IndexTypes>> {\n    return new U256ColumnBuilder(\n      this,\n      set(defaultMetadata, { indexType: algorithm })\n    );\n  }\n  unique(): U256ColumnBuilder<SetField<DefaultMetadata, 'isUnique', true>> {\n    return new U256ColumnBuilder(\n      this,\n      set(defaultMetadata, { isUnique: true })\n    );\n  }\n  primaryKey(): U256ColumnBuilder<\n    SetField<DefaultMetadata, 'isPrimaryKey', true>\n  > {\n    return new U256ColumnBuilder(\n      this,\n      set(defaultMetadata, { isPrimaryKey: true })\n    );\n  }\n  autoInc(): U256ColumnBuilder<\n    SetField<DefaultMetadata, 'isAutoIncrement', true>\n  > {\n    return new U256ColumnBuilder(\n      this,\n      set(defaultMetadata, { isAutoIncrement: true })\n    );\n  }\n  default(\n    value: bigint\n  ): U256ColumnBuilder<SetField<DefaultMetadata, 'defaultValue', bigint>> {\n    return new U256ColumnBuilder(\n      this,\n      set(defaultMetadata, { defaultValue: value })\n    );\n  }\n  name<const Name extends string>(\n    name: Name\n  ): U256ColumnBuilder<SetField<DefaultMetadata, 'name', Name>> {\n    return new U256ColumnBuilder(this, set(defaultMetadata, { name }));\n  }\n}\n\nexport class I8Builder\n  extends TypeBuilder<number, AlgebraicTypeVariants.I8>\n  implements\n    Indexable<number, AlgebraicTypeVariants.I8>,\n    Uniqueable<number, AlgebraicTypeVariants.I8>,\n    PrimaryKeyable<number, AlgebraicTypeVariants.I8>,\n    AutoIncrementable<number, AlgebraicTypeVariants.I8>,\n    Defaultable<number, AlgebraicTypeVariants.I8>,\n    Nameable<number, AlgebraicTypeVariants.I8>\n{\n  constructor() {\n    super(AlgebraicType.I8);\n  }\n  index(): I8ColumnBuilder<SetField<DefaultMetadata, 'indexType', 'btree'>>;\n  index<N extends NonNullable<IndexTypes>>(\n    algorithm: N\n  ): I8ColumnBuilder<SetField<DefaultMetadata, 'indexType', N>>;\n  index(\n    algorithm: IndexTypes = 'btree'\n  ): I8ColumnBuilder<SetField<DefaultMetadata, 'indexType', IndexTypes>> {\n    return new I8ColumnBuilder(\n      this,\n      set(defaultMetadata, { indexType: algorithm })\n    );\n  }\n  unique(): I8ColumnBuilder<SetField<DefaultMetadata, 'isUnique', true>> {\n    return new I8ColumnBuilder(this, set(defaultMetadata, { isUnique: true }));\n  }\n  primaryKey(): I8ColumnBuilder<\n    SetField<DefaultMetadata, 'isPrimaryKey', true>\n  > {\n    return new I8ColumnBuilder(\n      this,\n      set(defaultMetadata, { isPrimaryKey: true })\n    );\n  }\n  autoInc(): I8ColumnBuilder<\n    SetField<DefaultMetadata, 'isAutoIncrement', true>\n  > {\n    return new I8ColumnBuilder(\n      this,\n      set(defaultMetadata, { isAutoIncrement: true })\n    );\n  }\n  default(\n    value: number\n  ): I8ColumnBuilder<SetField<DefaultMetadata, 'defaultValue', number>> {\n    return new I8ColumnBuilder(\n      this,\n      set(defaultMetadata, { defaultValue: value })\n    );\n  }\n  name<const Name extends string>(\n    name: Name\n  ): I8ColumnBuilder<SetField<DefaultMetadata, 'name', Name>> {\n    return new I8ColumnBuilder(this, set(defaultMetadata, { name }));\n  }\n}\n\nexport class I16Builder\n  extends TypeBuilder<number, AlgebraicTypeVariants.I16>\n  implements\n    Indexable<number, AlgebraicTypeVariants.I16>,\n    Uniqueable<number, AlgebraicTypeVariants.I16>,\n    PrimaryKeyable<number, AlgebraicTypeVariants.I16>,\n    AutoIncrementable<number, AlgebraicTypeVariants.I16>,\n    Defaultable<number, AlgebraicTypeVariants.I16>,\n    Nameable<number, AlgebraicTypeVariants.I16>\n{\n  constructor() {\n    super(AlgebraicType.I16);\n  }\n  index(): I16ColumnBuilder<SetField<DefaultMetadata, 'indexType', 'btree'>>;\n  index<N extends NonNullable<IndexTypes>>(\n    algorithm: N\n  ): I16ColumnBuilder<SetField<DefaultMetadata, 'indexType', N>>;\n  index(\n    algorithm: IndexTypes = 'btree'\n  ): I16ColumnBuilder<SetField<DefaultMetadata, 'indexType', IndexTypes>> {\n    return new I16ColumnBuilder(\n      this,\n      set(defaultMetadata, { indexType: algorithm })\n    );\n  }\n  unique(): I16ColumnBuilder<SetField<DefaultMetadata, 'isUnique', true>> {\n    return new I16ColumnBuilder(this, set(defaultMetadata, { isUnique: true }));\n  }\n  primaryKey(): I16ColumnBuilder<\n    SetField<DefaultMetadata, 'isPrimaryKey', true>\n  > {\n    return new I16ColumnBuilder(\n      this,\n      set(defaultMetadata, { isPrimaryKey: true })\n    );\n  }\n  autoInc(): I16ColumnBuilder<\n    SetField<DefaultMetadata, 'isAutoIncrement', true>\n  > {\n    return new I16ColumnBuilder(\n      this,\n      set(defaultMetadata, { isAutoIncrement: true })\n    );\n  }\n  default(\n    value: number\n  ): I16ColumnBuilder<SetField<DefaultMetadata, 'defaultValue', number>> {\n    return new I16ColumnBuilder(\n      this,\n      set(defaultMetadata, { defaultValue: value })\n    );\n  }\n  name<const Name extends string>(\n    name: Name\n  ): I16ColumnBuilder<SetField<DefaultMetadata, 'name', Name>> {\n    return new I16ColumnBuilder(this, set(defaultMetadata, { name }));\n  }\n}\n\nexport class I32Builder\n  extends TypeBuilder<number, AlgebraicTypeVariants.I32>\n  implements\n    TypeBuilder<number, AlgebraicTypeVariants.I32>,\n    Indexable<number, AlgebraicTypeVariants.I32>,\n    Uniqueable<number, AlgebraicTypeVariants.I32>,\n    PrimaryKeyable<number, AlgebraicTypeVariants.I32>,\n    AutoIncrementable<number, AlgebraicTypeVariants.I32>,\n    Defaultable<number, AlgebraicTypeVariants.I32>,\n    Nameable<number, AlgebraicTypeVariants.I32>\n{\n  constructor() {\n    super(AlgebraicType.I32);\n  }\n  index(): I32ColumnBuilder<SetField<DefaultMetadata, 'indexType', 'btree'>>;\n  index<N extends NonNullable<IndexTypes>>(\n    algorithm: N\n  ): I32ColumnBuilder<SetField<DefaultMetadata, 'indexType', N>>;\n  index(\n    algorithm: IndexTypes = 'btree'\n  ): I32ColumnBuilder<SetField<DefaultMetadata, 'indexType', IndexTypes>> {\n    return new I32ColumnBuilder(\n      this,\n      set(defaultMetadata, { indexType: algorithm })\n    );\n  }\n  unique(): I32ColumnBuilder<SetField<DefaultMetadata, 'isUnique', true>> {\n    return new I32ColumnBuilder(this, set(defaultMetadata, { isUnique: true }));\n  }\n  primaryKey(): I32ColumnBuilder<\n    SetField<DefaultMetadata, 'isPrimaryKey', true>\n  > {\n    return new I32ColumnBuilder(\n      this,\n      set(defaultMetadata, { isPrimaryKey: true })\n    );\n  }\n  autoInc(): I32ColumnBuilder<\n    SetField<DefaultMetadata, 'isAutoIncrement', true>\n  > {\n    return new I32ColumnBuilder(\n      this,\n      set(defaultMetadata, { isAutoIncrement: true })\n    );\n  }\n  default(\n    value: number\n  ): I32ColumnBuilder<SetField<DefaultMetadata, 'defaultValue', number>> {\n    return new I32ColumnBuilder(\n      this,\n      set(defaultMetadata, { defaultValue: value })\n    );\n  }\n  name<const Name extends string>(\n    name: Name\n  ): I32ColumnBuilder<SetField<DefaultMetadata, 'name', Name>> {\n    return new I32ColumnBuilder(this, set(defaultMetadata, { name }));\n  }\n}\n\nexport class I64Builder\n  extends TypeBuilder<bigint, AlgebraicTypeVariants.I64>\n  implements\n    Indexable<bigint, AlgebraicTypeVariants.I64>,\n    Uniqueable<bigint, AlgebraicTypeVariants.I64>,\n    PrimaryKeyable<bigint, AlgebraicTypeVariants.I64>,\n    AutoIncrementable<bigint, AlgebraicTypeVariants.I64>,\n    Defaultable<bigint, AlgebraicTypeVariants.I64>,\n    Nameable<bigint, AlgebraicTypeVariants.I64>\n{\n  constructor() {\n    super(AlgebraicType.I64);\n  }\n  index(): I64ColumnBuilder<SetField<DefaultMetadata, 'indexType', 'btree'>>;\n  index<N extends NonNullable<IndexTypes>>(\n    algorithm: N\n  ): I64ColumnBuilder<SetField<DefaultMetadata, 'indexType', N>>;\n  index(\n    algorithm: IndexTypes = 'btree'\n  ): I64ColumnBuilder<SetField<DefaultMetadata, 'indexType', IndexTypes>> {\n    return new I64ColumnBuilder(\n      this,\n      set(defaultMetadata, { indexType: algorithm })\n    );\n  }\n  unique(): I64ColumnBuilder<SetField<DefaultMetadata, 'isUnique', true>> {\n    return new I64ColumnBuilder(this, set(defaultMetadata, { isUnique: true }));\n  }\n  primaryKey(): I64ColumnBuilder<\n    SetField<DefaultMetadata, 'isPrimaryKey', true>\n  > {\n    return new I64ColumnBuilder(\n      this,\n      set(defaultMetadata, { isPrimaryKey: true })\n    );\n  }\n  autoInc(): I64ColumnBuilder<\n    SetField<DefaultMetadata, 'isAutoIncrement', true>\n  > {\n    return new I64ColumnBuilder(\n      this,\n      set(defaultMetadata, { isAutoIncrement: true })\n    );\n  }\n  default(\n    value: bigint\n  ): I64ColumnBuilder<SetField<DefaultMetadata, 'defaultValue', bigint>> {\n    return new I64ColumnBuilder(\n      this,\n      set(defaultMetadata, { defaultValue: value })\n    );\n  }\n  name<const Name extends string>(\n    name: Name\n  ): I64ColumnBuilder<SetField<DefaultMetadata, 'name', Name>> {\n    return new I64ColumnBuilder(this, set(defaultMetadata, { name }));\n  }\n}\n\nexport class I128Builder\n  extends TypeBuilder<bigint, AlgebraicTypeVariants.I128>\n  implements\n    Indexable<bigint, AlgebraicTypeVariants.I128>,\n    Uniqueable<bigint, AlgebraicTypeVariants.I128>,\n    PrimaryKeyable<bigint, AlgebraicTypeVariants.I128>,\n    AutoIncrementable<bigint, AlgebraicTypeVariants.I128>,\n    Defaultable<bigint, AlgebraicTypeVariants.I128>,\n    Nameable<bigint, AlgebraicTypeVariants.I128>\n{\n  constructor() {\n    super(AlgebraicType.I128);\n  }\n  index(): I128ColumnBuilder<SetField<DefaultMetadata, 'indexType', 'btree'>>;\n  index<N extends NonNullable<IndexTypes>>(\n    algorithm: N\n  ): I128ColumnBuilder<SetField<DefaultMetadata, 'indexType', N>>;\n  index(\n    algorithm: IndexTypes = 'btree'\n  ): I128ColumnBuilder<SetField<DefaultMetadata, 'indexType', IndexTypes>> {\n    return new I128ColumnBuilder(\n      this,\n      set(defaultMetadata, { indexType: algorithm })\n    );\n  }\n  unique(): I128ColumnBuilder<SetField<DefaultMetadata, 'isUnique', true>> {\n    return new I128ColumnBuilder(\n      this,\n      set(defaultMetadata, { isUnique: true })\n    );\n  }\n  primaryKey(): I128ColumnBuilder<\n    SetField<DefaultMetadata, 'isPrimaryKey', true>\n  > {\n    return new I128ColumnBuilder(\n      this,\n      set(defaultMetadata, { isPrimaryKey: true })\n    );\n  }\n  autoInc(): I128ColumnBuilder<\n    SetField<DefaultMetadata, 'isAutoIncrement', true>\n  > {\n    return new I128ColumnBuilder(\n      this,\n      set(defaultMetadata, { isAutoIncrement: true })\n    );\n  }\n  default(\n    value: bigint\n  ): I128ColumnBuilder<SetField<DefaultMetadata, 'defaultValue', bigint>> {\n    return new I128ColumnBuilder(\n      this,\n      set(defaultMetadata, { defaultValue: value })\n    );\n  }\n  name<const Name extends string>(\n    name: Name\n  ): I128ColumnBuilder<SetField<DefaultMetadata, 'name', Name>> {\n    return new I128ColumnBuilder(this, set(defaultMetadata, { name }));\n  }\n}\n\nexport class I256Builder\n  extends TypeBuilder<bigint, AlgebraicTypeVariants.I256>\n  implements\n    Indexable<bigint, AlgebraicTypeVariants.I256>,\n    Uniqueable<bigint, AlgebraicTypeVariants.I256>,\n    PrimaryKeyable<bigint, AlgebraicTypeVariants.I256>,\n    AutoIncrementable<bigint, AlgebraicTypeVariants.I256>,\n    Defaultable<bigint, AlgebraicTypeVariants.I256>,\n    Nameable<bigint, AlgebraicTypeVariants.I256>\n{\n  constructor() {\n    super(AlgebraicType.I256);\n  }\n  index(): I256ColumnBuilder<SetField<DefaultMetadata, 'indexType', 'btree'>>;\n  index<N extends NonNullable<IndexTypes>>(\n    algorithm: N\n  ): I256ColumnBuilder<SetField<DefaultMetadata, 'indexType', N>>;\n  index(\n    algorithm: IndexTypes = 'btree'\n  ): I256ColumnBuilder<SetField<DefaultMetadata, 'indexType', IndexTypes>> {\n    return new I256ColumnBuilder(\n      this,\n      set(defaultMetadata, { indexType: algorithm })\n    );\n  }\n  unique(): I256ColumnBuilder<SetField<DefaultMetadata, 'isUnique', true>> {\n    return new I256ColumnBuilder(\n      this,\n      set(defaultMetadata, { isUnique: true })\n    );\n  }\n  primaryKey(): I256ColumnBuilder<\n    SetField<DefaultMetadata, 'isPrimaryKey', true>\n  > {\n    return new I256ColumnBuilder(\n      this,\n      set(defaultMetadata, { isPrimaryKey: true })\n    );\n  }\n  autoInc(): I256ColumnBuilder<\n    SetField<DefaultMetadata, 'isAutoIncrement', true>\n  > {\n    return new I256ColumnBuilder(\n      this,\n      set(defaultMetadata, { isAutoIncrement: true })\n    );\n  }\n  default(\n    value: bigint\n  ): I256ColumnBuilder<SetField<DefaultMetadata, 'defaultValue', bigint>> {\n    return new I256ColumnBuilder(\n      this,\n      set(defaultMetadata, { defaultValue: value })\n    );\n  }\n  name<const Name extends string>(\n    name: Name\n  ): I256ColumnBuilder<SetField<DefaultMetadata, 'name', Name>> {\n    return new I256ColumnBuilder(this, set(defaultMetadata, { name }));\n  }\n}\n\nexport class F32Builder\n  extends TypeBuilder<number, AlgebraicTypeVariants.F32>\n  implements\n    Defaultable<number, AlgebraicTypeVariants.F32>,\n    Nameable<number, AlgebraicTypeVariants.F32>\n{\n  constructor() {\n    super(AlgebraicType.F32);\n  }\n  default(\n    value: number\n  ): F32ColumnBuilder<SetField<DefaultMetadata, 'defaultValue', number>> {\n    return new F32ColumnBuilder(\n      this,\n      set(defaultMetadata, { defaultValue: value })\n    );\n  }\n  name<const Name extends string>(\n    name: Name\n  ): F32ColumnBuilder<SetField<DefaultMetadata, 'name', Name>> {\n    return new F32ColumnBuilder(this, set(defaultMetadata, { name }));\n  }\n}\n\nexport class F64Builder\n  extends TypeBuilder<number, AlgebraicTypeVariants.F64>\n  implements\n    Defaultable<number, AlgebraicTypeVariants.F64>,\n    Nameable<number, AlgebraicTypeVariants.F64>\n{\n  constructor() {\n    super(AlgebraicType.F64);\n  }\n  default(\n    value: number\n  ): F64ColumnBuilder<SetField<DefaultMetadata, 'defaultValue', number>> {\n    return new F64ColumnBuilder(\n      this,\n      set(defaultMetadata, { defaultValue: value })\n    );\n  }\n  name<const Name extends string>(\n    name: Name\n  ): F64ColumnBuilder<SetField<DefaultMetadata, 'name', Name>> {\n    return new F64ColumnBuilder(this, set(defaultMetadata, { name }));\n  }\n}\n\nexport class BoolBuilder\n  extends TypeBuilder<boolean, AlgebraicTypeVariants.Bool>\n  implements\n    Indexable<boolean, AlgebraicTypeVariants.Bool>,\n    Uniqueable<boolean, AlgebraicTypeVariants.Bool>,\n    PrimaryKeyable<boolean, AlgebraicTypeVariants.Bool>,\n    Defaultable<boolean, AlgebraicTypeVariants.Bool>,\n    Nameable<boolean, AlgebraicTypeVariants.Bool>\n{\n  constructor() {\n    super(AlgebraicType.Bool);\n  }\n  index(): BoolColumnBuilder<SetField<DefaultMetadata, 'indexType', 'btree'>>;\n  index<N extends NonNullable<IndexTypes>>(\n    algorithm: N\n  ): BoolColumnBuilder<SetField<DefaultMetadata, 'indexType', N>>;\n  index(\n    algorithm: IndexTypes = 'btree'\n  ): BoolColumnBuilder<SetField<DefaultMetadata, 'indexType', IndexTypes>> {\n    return new BoolColumnBuilder(\n      this,\n      set(defaultMetadata, { indexType: algorithm })\n    );\n  }\n  unique(): BoolColumnBuilder<SetField<DefaultMetadata, 'isUnique', true>> {\n    return new BoolColumnBuilder(\n      this,\n      set(defaultMetadata, { isUnique: true })\n    );\n  }\n  primaryKey(): BoolColumnBuilder<\n    SetField<DefaultMetadata, 'isPrimaryKey', true>\n  > {\n    return new BoolColumnBuilder(\n      this,\n      set(defaultMetadata, { isPrimaryKey: true })\n    );\n  }\n  default(\n    value: boolean\n  ): BoolColumnBuilder<SetField<DefaultMetadata, 'defaultValue', boolean>> {\n    return new BoolColumnBuilder(\n      this,\n      set(defaultMetadata, { defaultValue: value })\n    );\n  }\n  name<const Name extends string>(\n    name: Name\n  ): BoolColumnBuilder<SetField<DefaultMetadata, 'name', Name>> {\n    return new BoolColumnBuilder(this, set(defaultMetadata, { name }));\n  }\n}\n\nexport class StringBuilder\n  extends TypeBuilder<string, AlgebraicTypeVariants.String>\n  implements\n    Indexable<string, AlgebraicTypeVariants.String>,\n    Uniqueable<string, AlgebraicTypeVariants.String>,\n    PrimaryKeyable<string, AlgebraicTypeVariants.String>,\n    Defaultable<string, AlgebraicTypeVariants.String>,\n    Nameable<string, AlgebraicTypeVariants.String>\n{\n  constructor() {\n    super(AlgebraicType.String);\n  }\n  index(): StringColumnBuilder<SetField<DefaultMetadata, 'indexType', 'btree'>>;\n  index<N extends NonNullable<IndexTypes>>(\n    algorithm: N\n  ): StringColumnBuilder<SetField<DefaultMetadata, 'indexType', N>>;\n  index(\n    algorithm: IndexTypes = 'btree'\n  ): StringColumnBuilder<SetField<DefaultMetadata, 'indexType', IndexTypes>> {\n    return new StringColumnBuilder(\n      this,\n      set(defaultMetadata, { indexType: algorithm })\n    );\n  }\n  unique(): StringColumnBuilder<SetField<DefaultMetadata, 'isUnique', true>> {\n    return new StringColumnBuilder(\n      this,\n      set(defaultMetadata, { isUnique: true })\n    );\n  }\n  primaryKey(): StringColumnBuilder<\n    SetField<DefaultMetadata, 'isPrimaryKey', true>\n  > {\n    return new StringColumnBuilder(\n      this,\n      set(defaultMetadata, { isPrimaryKey: true })\n    );\n  }\n  default(\n    value: string\n  ): StringColumnBuilder<SetField<DefaultMetadata, 'defaultValue', string>> {\n    return new StringColumnBuilder(\n      this,\n      set(defaultMetadata, { defaultValue: value })\n    );\n  }\n  name<const Name extends string>(\n    name: Name\n  ): StringColumnBuilder<SetField<DefaultMetadata, 'name', Name>> {\n    return new StringColumnBuilder(this, set(defaultMetadata, { name }));\n  }\n}\n\nexport class ArrayBuilder<Element extends TypeBuilder<any, any>>\n  extends TypeBuilder<\n    Array<InferTypeOfTypeBuilder<Element>>,\n    { tag: 'Array'; value: InferSpacetimeTypeOfTypeBuilder<Element> }\n  >\n  implements\n    Defaultable<Array<InferTypeOfTypeBuilder<Element>>, any>,\n    Nameable<Array<InferTypeOfTypeBuilder<Element>>, any>\n{\n  element: Element;\n\n  constructor(element: Element) {\n    super(AlgebraicType.Array(element.algebraicType));\n    this.element = element;\n  }\n  default(\n    value: Array<InferTypeOfTypeBuilder<Element>>\n  ): ArrayColumnBuilder<\n    Element,\n    SetField<DefaultMetadata, 'defaultValue', any>\n  > {\n    return new ArrayColumnBuilder(\n      this.element,\n      set(defaultMetadata, { defaultValue: value })\n    );\n  }\n  name<const Name extends string>(\n    name: Name\n  ): ArrayColumnBuilder<Element, SetField<DefaultMetadata, 'name', Name>> {\n    return new ArrayColumnBuilder(this.element, set(defaultMetadata, { name }));\n  }\n}\n\nexport class ByteArrayBuilder\n  extends TypeBuilder<\n    Uint8Array,\n    { tag: 'Array'; value: AlgebraicTypeVariants.U8 }\n  >\n  implements Defaultable<Uint8Array, any>, Nameable<Uint8Array, any>\n{\n  constructor() {\n    super(AlgebraicType.Array(AlgebraicType.U8));\n  }\n  default(\n    value: Uint8Array\n  ): ByteArrayColumnBuilder<SetField<DefaultMetadata, 'defaultValue', any>> {\n    return new ByteArrayColumnBuilder(\n      set(defaultMetadata, { defaultValue: value })\n    );\n  }\n  name<const Name extends string>(\n    name: Name\n  ): ByteArrayColumnBuilder<SetField<DefaultMetadata, 'name', Name>> {\n    return new ByteArrayColumnBuilder(set(defaultMetadata, { name }));\n  }\n}\n\nexport class OptionBuilder<Value extends TypeBuilder<any, any>>\n  extends TypeBuilder<\n    InferTypeOfTypeBuilder<Value> | undefined,\n    OptionAlgebraicType<InferSpacetimeTypeOfTypeBuilder<Value>>\n  >\n  implements\n    Defaultable<\n      InferTypeOfTypeBuilder<Value> | undefined,\n      OptionAlgebraicType<InferSpacetimeTypeOfTypeBuilder<Value>>\n    >,\n    Nameable<\n      InferTypeOfTypeBuilder<Value> | undefined,\n      OptionAlgebraicType<InferSpacetimeTypeOfTypeBuilder<Value>>\n    >\n{\n  value: Value;\n\n  constructor(value: Value) {\n    super(Option.getAlgebraicType(value.algebraicType));\n    this.value = value;\n  }\n  default(\n    value: InferTypeOfTypeBuilder<Value> | undefined\n  ): OptionColumnBuilder<\n    Value,\n    SetField<\n      DefaultMetadata,\n      'defaultValue',\n      InferTypeOfTypeBuilder<Value> | undefined\n    >\n  > {\n    return new OptionColumnBuilder(\n      this,\n      set(defaultMetadata, { defaultValue: value })\n    );\n  }\n  name<const Name extends string>(\n    name: Name\n  ): OptionColumnBuilder<Value, SetField<DefaultMetadata, 'name', Name>> {\n    return new OptionColumnBuilder(this, set(defaultMetadata, { name }));\n  }\n}\n\ntype ElementsToProductType<Elements extends ElementsObj> = {\n  tag: 'Product';\n  value: { elements: ElementsArrayFromElementsObj<Elements> };\n};\n\nexport class ProductBuilder<Elements extends ElementsObj>\n  extends TypeBuilder<ObjectType<Elements>, ElementsToProductType<Elements>>\n  implements\n    Defaultable<ObjectType<Elements>, ElementsToProductType<Elements>>,\n    Nameable<ObjectType<Elements>, ElementsToProductType<Elements>>\n{\n  readonly typeName: string | undefined;\n  readonly elements: Elements;\n  constructor(elements: Elements, name?: string) {\n    function elementsArrayFromElementsObj<Obj extends ElementsObj>(obj: Obj) {\n      return Object.keys(obj).map(key => ({\n        name: key,\n        // Lazily resolve the underlying object's algebraicType.\n        // This will call obj[key].algebraicType only when someone\n        // actually reads this property.\n        get algebraicType() {\n          return obj[key].algebraicType;\n        },\n      }));\n    }\n    super(\n      AlgebraicType.Product({\n        elements: elementsArrayFromElementsObj(elements),\n      })\n    );\n    this.typeName = name;\n    this.elements = elements;\n  }\n  default(\n    value: ObjectType<Elements>\n  ): ProductColumnBuilder<\n    Elements,\n    SetField<DefaultMetadata, 'defaultValue', any>\n  > {\n    return new ProductColumnBuilder(\n      this,\n      set(defaultMetadata, { defaultValue: value })\n    );\n  }\n  name<const Name extends string>(\n    name: Name\n  ): ProductColumnBuilder<Elements, SetField<DefaultMetadata, 'name', Name>> {\n    return new ProductColumnBuilder(this, set(defaultMetadata, { name }));\n  }\n}\n\nexport class ResultBuilder<\n    Ok extends TypeBuilder<any, any>,\n    Err extends TypeBuilder<any, any>,\n  >\n  extends TypeBuilder<\n    InferTypeOfTypeBuilder<Ok> | InferTypeOfTypeBuilder<Err>,\n    ResultAlgebraicType<\n      InferSpacetimeTypeOfTypeBuilder<Ok>,\n      InferSpacetimeTypeOfTypeBuilder<Err>\n    >\n  >\n  implements\n    Defaultable<\n      InferTypeOfTypeBuilder<Ok> | InferTypeOfTypeBuilder<Err>,\n      ResultAlgebraicType<\n        InferSpacetimeTypeOfTypeBuilder<Ok>,\n        InferSpacetimeTypeOfTypeBuilder<Err>\n      >\n    >\n{\n  ok: Ok;\n  err: Err;\n\n  constructor(ok: Ok, err: Err) {\n    super(Result.getAlgebraicType(ok.algebraicType, err.algebraicType));\n    this.ok = ok;\n    this.err = err;\n  }\n  default(\n    value: InferTypeOfTypeBuilder<Ok> | InferTypeOfTypeBuilder<Err>\n  ): ResultColumnBuilder<\n    Ok,\n    Err,\n    SetField<\n      DefaultMetadata,\n      'defaultValue',\n      InferTypeOfTypeBuilder<Ok> | InferTypeOfTypeBuilder<Err>\n    >\n  > {\n    return new ResultColumnBuilder<\n      Ok,\n      Err,\n      SetField<\n        DefaultMetadata,\n        'defaultValue',\n        InferTypeOfTypeBuilder<Ok> | InferTypeOfTypeBuilder<Err>\n      >\n    >(this, set(defaultMetadata, { defaultValue: value }));\n  }\n}\n\nclass UnitBuilder extends TypeBuilder<\n  {},\n  { tag: 'Product'; value: { elements: [] } }\n> {\n  constructor() {\n    super({ tag: 'Product', value: { elements: [] } });\n  }\n}\n\nexport class RowBuilder<Row extends RowObj> extends TypeBuilder<\n  RowType<CoerceRow<Row>>,\n  {\n    tag: 'Product';\n    value: { elements: ElementsArrayFromRowObj<CoerceRow<Row>> };\n  }\n> {\n  readonly row: CoerceRow<Row>;\n  typeName: string | undefined;\n  constructor(row: Row, name?: string) {\n    const mappedRow = Object.fromEntries(\n      Object.entries(row).map(([colName, builder]) => [\n        colName,\n        builder instanceof ColumnBuilder\n          ? builder\n          : new ColumnBuilder(builder, {}),\n      ])\n    ) as CoerceRow<Row>;\n\n    const elements = Object.keys(mappedRow).map(name => ({\n      name,\n      get algebraicType() {\n        return mappedRow[name].typeBuilder.algebraicType;\n      },\n    }));\n\n    super(AlgebraicType.Product({ elements }));\n    this.row = mappedRow;\n    this.typeName = name;\n  }\n}\n\n// Value type produced for a given variant key + builder\ntype EnumValue<K extends string, B extends TypeBuilder<any, any>> =\n  IsUnit<B> extends true\n    ? { tag: K }\n    : { tag: K; value: InferTypeOfTypeBuilder<B> };\n\ntype VariantConstructor<K extends string, V extends TypeBuilder<any, any>> =\n  IsUnit<V> extends true\n    ? EnumValue<K, V>\n    : (value: InferTypeOfTypeBuilder<V>) => EnumValue<K, V>;\n\ntype SumBuilderVariantConstructors<Variants extends VariantsObj> = {\n  [K in keyof Variants & string]: VariantConstructor<K, Variants[K]>;\n};\n\nexport type SumBuilder<Variants extends VariantsObj> =\n  SumBuilderImpl<Variants> & SumBuilderVariantConstructors<Variants>;\n\ntype VariantsToSumType<Variants extends VariantsObj> = {\n  tag: 'Sum';\n  value: { variants: VariantsArrayFromVariantsObj<Variants> };\n};\n\nclass SumBuilderImpl<Variants extends VariantsObj>\n  extends TypeBuilder<EnumType<Variants>, VariantsToSumType<Variants>>\n  implements\n    Defaultable<EnumType<Variants>, VariantsToSumType<Variants>>,\n    Nameable<EnumType<Variants>, VariantsToSumType<Variants>>\n{\n  readonly variants: Variants;\n  readonly typeName: string | undefined;\n\n  constructor(variants: Variants, name?: string) {\n    function variantsArrayFromVariantsObj<Variants extends VariantsObj>(\n      variants: Variants\n    ) {\n      return (Object.keys(variants) as Array<keyof Variants>).map(key => ({\n        name: key as string,\n        // Lazily resolve the underlying object's algebraicType.\n        // This will call obj[key].algebraicType only when someone\n        // actually reads this property.\n        get algebraicType() {\n          return variants[key].algebraicType;\n        },\n      }));\n    }\n    super(\n      AlgebraicType.Sum({\n        variants: variantsArrayFromVariantsObj(variants),\n      })\n    );\n\n    this.variants = variants;\n    this.typeName = name;\n\n    for (const key of Object.keys(variants) as Array<keyof Variants & string>) {\n      const desc = Object.getOwnPropertyDescriptor(variants, key);\n\n      const isAccessor =\n        !!desc &&\n        (typeof desc.get === 'function' || typeof desc.set === 'function');\n\n      let isUnit = false;\n\n      if (!isAccessor) {\n        // Only read variants[key] if it's a *data* property\n        // otherwise assume non-unit because it's a getter\n        const variant = variants[key];\n        isUnit = variant instanceof UnitBuilder;\n      }\n\n      if (isUnit) {\n        // Unit: expose a read-only VALUE (no call)\n        const constant = this.create(key as any) as EnumValue<\n          typeof key,\n          Variants[typeof key]\n        >;\n        Object.defineProperty(this, key, {\n          value: constant,\n          writable: false,\n          enumerable: true,\n          configurable: false,\n        });\n      } else {\n        const fn = ((value: any) =>\n          this.create(key as any, value)) as VariantConstructor<\n          typeof key & string,\n          Variants[typeof key]\n        >;\n\n        Object.defineProperty(this, key, {\n          value: fn,\n          writable: false,\n          enumerable: true,\n          configurable: false,\n        });\n      }\n    }\n  }\n\n  /**\n   * Create a value of this sum type.\n   * - Unit variants: create('bar')\n   * - Payload variants: create('foo', value)\n   */\n  private create<K extends keyof Variants & string>(\n    tag: K\n  ): EnumValue<K, Variants[K]>;\n  private create<K extends keyof Variants & string>(\n    tag: K,\n    value: InferTypeOfTypeBuilder<Variants[K]>\n  ): EnumValue<K, Variants[K]>;\n  private create(tag: string, value?: unknown) {\n    return value === undefined ? { tag } : { tag, value };\n  }\n\n  default(\n    value: EnumType<Variants>\n  ): SumColumnBuilder<\n    Variants,\n    SetField<DefaultMetadata, 'defaultValue', any>\n  > {\n    return new SumColumnBuilder(\n      this,\n      set(defaultMetadata, { defaultValue: value })\n    );\n  }\n  name<const Name extends string>(\n    name: Name\n  ): SumColumnBuilder<Variants, SetField<DefaultMetadata, 'name', Name>> {\n    return new SumColumnBuilder(this, set(defaultMetadata, { name }));\n  }\n}\n\nexport const SumBuilder: {\n  new <Variants extends VariantsObj>(\n    variants: Variants,\n    name?: string\n  ): SumBuilder<Variants>;\n  [Symbol.hasInstance](x: any): x is SumBuilder<VariantsObj>;\n} = SumBuilderImpl as any;\n\nclass SimpleSumBuilderImpl<Variants extends SimpleVariantsObj>\n  extends SumBuilderImpl<Variants>\n  implements\n    Indexable<\n      EnumType<Variants>,\n      {\n        tag: 'Sum';\n        value: { variants: VariantsArrayFromVariantsObj<Variants> };\n      }\n    >,\n    PrimaryKeyable<\n      EnumType<Variants>,\n      {\n        tag: 'Sum';\n        value: { variants: VariantsArrayFromVariantsObj<Variants> };\n      }\n    >\n{\n  index(): SimpleSumColumnBuilder<\n    Variants,\n    SetField<DefaultMetadata, 'indexType', 'btree'>\n  >;\n  index<N extends NonNullable<IndexTypes>>(\n    algorithm: N\n  ): SimpleSumColumnBuilder<\n    Variants,\n    SetField<DefaultMetadata, 'indexType', N>\n  >;\n  index(\n    algorithm: IndexTypes = 'btree'\n  ): SimpleSumColumnBuilder<\n    Variants,\n    SetField<DefaultMetadata, 'indexType', IndexTypes>\n  > {\n    return new SimpleSumColumnBuilder(\n      this,\n      set(defaultMetadata, { indexType: algorithm })\n    );\n  }\n  primaryKey(): SimpleSumColumnBuilder<\n    Variants,\n    SetField<DefaultMetadata, 'isPrimaryKey', true>\n  > {\n    return new SimpleSumColumnBuilder(\n      this,\n      set(defaultMetadata, { isPrimaryKey: true })\n    );\n  }\n}\n\nexport const SimpleSumBuilder: {\n  new <Variants extends SimpleVariantsObj>(\n    variants: Variants,\n    name?: string\n  ): SimpleSumBuilderImpl<Variants> & SumBuilderVariantConstructors<Variants>;\n} = SimpleSumBuilderImpl as any;\n\nexport type SimpleSumBuilder<Variants extends SimpleVariantsObj> =\n  SimpleSumBuilderImpl<Variants> & SumBuilderVariantConstructors<Variants>;\n\nexport class ScheduleAtBuilder\n  extends TypeBuilder<ScheduleAt, ScheduleAtAlgebraicType>\n  implements\n    Defaultable<ScheduleAt, ScheduleAtAlgebraicType>,\n    Nameable<ScheduleAt, ScheduleAtAlgebraicType>\n{\n  constructor() {\n    super(ScheduleAt.getAlgebraicType());\n  }\n  default(\n    value: ScheduleAt\n  ): ScheduleAtColumnBuilder<\n    SetField<DefaultMetadata, 'defaultValue', ScheduleAt>\n  > {\n    return new ScheduleAtColumnBuilder(\n      this,\n      set(defaultMetadata, { defaultValue: value })\n    );\n  }\n  name<const Name extends string>(\n    name: Name\n  ): ScheduleAtColumnBuilder<SetField<DefaultMetadata, 'name', Name>> {\n    return new ScheduleAtColumnBuilder(this, set(defaultMetadata, { name }));\n  }\n}\n\nexport class IdentityBuilder\n  extends TypeBuilder<Identity, IdentityAlgebraicType>\n  implements\n    Indexable<Identity, IdentityAlgebraicType>,\n    Uniqueable<Identity, IdentityAlgebraicType>,\n    PrimaryKeyable<Identity, IdentityAlgebraicType>,\n    Defaultable<Identity, IdentityAlgebraicType>,\n    Nameable<Identity, IdentityAlgebraicType>\n{\n  constructor() {\n    super(Identity.getAlgebraicType());\n  }\n  index(): IdentityColumnBuilder<\n    SetField<DefaultMetadata, 'indexType', 'btree'>\n  >;\n  index<N extends NonNullable<IndexTypes>>(\n    algorithm: N\n  ): IdentityColumnBuilder<SetField<DefaultMetadata, 'indexType', N>>;\n  index(\n    algorithm: IndexTypes = 'btree'\n  ): IdentityColumnBuilder<SetField<DefaultMetadata, 'indexType', IndexTypes>> {\n    return new IdentityColumnBuilder(\n      this,\n      set(defaultMetadata, { indexType: algorithm })\n    );\n  }\n  unique(): IdentityColumnBuilder<SetField<DefaultMetadata, 'isUnique', true>> {\n    return new IdentityColumnBuilder(\n      this,\n      set(defaultMetadata, { isUnique: true })\n    );\n  }\n  primaryKey(): IdentityColumnBuilder<\n    SetField<DefaultMetadata, 'isPrimaryKey', true>\n  > {\n    return new IdentityColumnBuilder(\n      this,\n      set(defaultMetadata, { isPrimaryKey: true })\n    );\n  }\n  autoInc(): IdentityColumnBuilder<\n    SetField<DefaultMetadata, 'isAutoIncrement', true>\n  > {\n    return new IdentityColumnBuilder(\n      this,\n      set(defaultMetadata, { isAutoIncrement: true })\n    );\n  }\n  default(\n    value: Identity\n  ): IdentityColumnBuilder<\n    SetField<DefaultMetadata, 'defaultValue', Identity>\n  > {\n    return new IdentityColumnBuilder(\n      this,\n      set(defaultMetadata, { defaultValue: value })\n    );\n  }\n  name<const Name extends string>(\n    name: Name\n  ): IdentityColumnBuilder<SetField<DefaultMetadata, 'name', Name>> {\n    return new IdentityColumnBuilder(this, set(defaultMetadata, { name }));\n  }\n}\n\nexport class ConnectionIdBuilder\n  extends TypeBuilder<ConnectionId, ConnectionIdAlgebraicType>\n  implements\n    Indexable<ConnectionId, ConnectionIdAlgebraicType>,\n    Uniqueable<ConnectionId, ConnectionIdAlgebraicType>,\n    PrimaryKeyable<ConnectionId, ConnectionIdAlgebraicType>,\n    Defaultable<ConnectionId, ConnectionIdAlgebraicType>,\n    Nameable<ConnectionId, ConnectionIdAlgebraicType>\n{\n  constructor() {\n    super(ConnectionId.getAlgebraicType());\n  }\n  index(): ConnectionIdColumnBuilder<\n    SetField<DefaultMetadata, 'indexType', 'btree'>\n  >;\n  index<N extends NonNullable<IndexTypes>>(\n    algorithm: N\n  ): ConnectionIdColumnBuilder<SetField<DefaultMetadata, 'indexType', N>>;\n  index(\n    algorithm: IndexTypes = 'btree'\n  ): ConnectionIdColumnBuilder<\n    SetField<DefaultMetadata, 'indexType', IndexTypes>\n  > {\n    return new ConnectionIdColumnBuilder(\n      this,\n      set(defaultMetadata, { indexType: algorithm })\n    );\n  }\n  unique(): ConnectionIdColumnBuilder<\n    SetField<DefaultMetadata, 'isUnique', true>\n  > {\n    return new ConnectionIdColumnBuilder(\n      this,\n      set(defaultMetadata, { isUnique: true })\n    );\n  }\n  primaryKey(): ConnectionIdColumnBuilder<\n    SetField<DefaultMetadata, 'isPrimaryKey', true>\n  > {\n    return new ConnectionIdColumnBuilder(\n      this,\n      set(defaultMetadata, { isPrimaryKey: true })\n    );\n  }\n  autoInc(): ConnectionIdColumnBuilder<\n    SetField<DefaultMetadata, 'isAutoIncrement', true>\n  > {\n    return new ConnectionIdColumnBuilder(\n      this,\n      set(defaultMetadata, { isAutoIncrement: true })\n    );\n  }\n  default(\n    value: ConnectionId\n  ): ConnectionIdColumnBuilder<\n    SetField<DefaultMetadata, 'defaultValue', ConnectionId>\n  > {\n    return new ConnectionIdColumnBuilder(\n      this,\n      set(defaultMetadata, { defaultValue: value })\n    );\n  }\n  name<const Name extends string>(\n    name: Name\n  ): ConnectionIdColumnBuilder<SetField<DefaultMetadata, 'name', Name>> {\n    return new ConnectionIdColumnBuilder(this, set(defaultMetadata, { name }));\n  }\n}\n\nexport class TimestampBuilder\n  extends TypeBuilder<Timestamp, TimestampAlgebraicType>\n  implements\n    Indexable<Timestamp, TimestampAlgebraicType>,\n    Uniqueable<Timestamp, TimestampAlgebraicType>,\n    PrimaryKeyable<Timestamp, TimestampAlgebraicType>,\n    Defaultable<Timestamp, TimestampAlgebraicType>,\n    Nameable<Timestamp, TimestampAlgebraicType>\n{\n  constructor() {\n    super(Timestamp.getAlgebraicType());\n  }\n  index(): TimestampColumnBuilder<\n    SetField<DefaultMetadata, 'indexType', 'btree'>\n  >;\n  index<N extends NonNullable<IndexTypes>>(\n    algorithm: N\n  ): TimestampColumnBuilder<SetField<DefaultMetadata, 'indexType', N>>;\n  index(\n    algorithm: IndexTypes = 'btree'\n  ): TimestampColumnBuilder<\n    SetField<DefaultMetadata, 'indexType', IndexTypes>\n  > {\n    return new TimestampColumnBuilder(\n      this,\n      set(defaultMetadata, { indexType: algorithm })\n    );\n  }\n  unique(): TimestampColumnBuilder<\n    SetField<DefaultMetadata, 'isUnique', true>\n  > {\n    return new TimestampColumnBuilder(\n      this,\n      set(defaultMetadata, { isUnique: true })\n    );\n  }\n  primaryKey(): TimestampColumnBuilder<\n    SetField<DefaultMetadata, 'isPrimaryKey', true>\n  > {\n    return new TimestampColumnBuilder(\n      this,\n      set(defaultMetadata, { isPrimaryKey: true })\n    );\n  }\n  autoInc(): TimestampColumnBuilder<\n    SetField<DefaultMetadata, 'isAutoIncrement', true>\n  > {\n    return new TimestampColumnBuilder(\n      this,\n      set(defaultMetadata, { isAutoIncrement: true })\n    );\n  }\n  default(\n    value: Timestamp\n  ): TimestampColumnBuilder<\n    SetField<DefaultMetadata, 'defaultValue', Timestamp>\n  > {\n    return new TimestampColumnBuilder(\n      this,\n      set(defaultMetadata, { defaultValue: value })\n    );\n  }\n  name<const Name extends string>(\n    name: Name\n  ): TimestampColumnBuilder<SetField<DefaultMetadata, 'name', Name>> {\n    return new TimestampColumnBuilder(this, set(defaultMetadata, { name }));\n  }\n}\n\nexport class TimeDurationBuilder\n  extends TypeBuilder<TimeDuration, TimeDurationAlgebraicType>\n  implements\n    Indexable<TimeDuration, TimeDurationAlgebraicType>,\n    Uniqueable<TimeDuration, TimeDurationAlgebraicType>,\n    PrimaryKeyable<TimeDuration, TimeDurationAlgebraicType>,\n    Defaultable<TimeDuration, TimeDurationAlgebraicType>,\n    Nameable<TimeDuration, TimeDurationAlgebraicType>\n{\n  constructor() {\n    super(TimeDuration.getAlgebraicType());\n  }\n  index(): TimeDurationColumnBuilder<\n    SetField<DefaultMetadata, 'indexType', 'btree'>\n  >;\n  index<N extends NonNullable<IndexTypes>>(\n    algorithm: N\n  ): TimeDurationColumnBuilder<SetField<DefaultMetadata, 'indexType', N>>;\n  index(\n    algorithm: IndexTypes = 'btree'\n  ): TimeDurationColumnBuilder<\n    SetField<DefaultMetadata, 'indexType', IndexTypes>\n  > {\n    return new TimeDurationColumnBuilder(\n      this,\n      set(defaultMetadata, { indexType: algorithm })\n    );\n  }\n  unique(): TimeDurationColumnBuilder<\n    SetField<DefaultMetadata, 'isUnique', true>\n  > {\n    return new TimeDurationColumnBuilder(\n      this,\n      set(defaultMetadata, { isUnique: true })\n    );\n  }\n  primaryKey(): TimeDurationColumnBuilder<\n    SetField<DefaultMetadata, 'isPrimaryKey', true>\n  > {\n    return new TimeDurationColumnBuilder(\n      this,\n      set(defaultMetadata, { isPrimaryKey: true })\n    );\n  }\n  autoInc(): TimeDurationColumnBuilder<\n    SetField<DefaultMetadata, 'isAutoIncrement', true>\n  > {\n    return new TimeDurationColumnBuilder(\n      this,\n      set(defaultMetadata, { isAutoIncrement: true })\n    );\n  }\n  default(\n    value: TimeDuration\n  ): TimeDurationColumnBuilder<\n    SetField<DefaultMetadata, 'defaultValue', TimeDuration>\n  > {\n    return new TimeDurationColumnBuilder(\n      this,\n      set(defaultMetadata, { defaultValue: value })\n    );\n  }\n  name<const Name extends string>(\n    name: Name\n  ): TimeDurationColumnBuilder<SetField<DefaultMetadata, 'name', Name>> {\n    return new TimeDurationColumnBuilder(this, set(defaultMetadata, { name }));\n  }\n}\n\nexport class UuidBuilder\n  extends TypeBuilder<Uuid, UuidAlgebraicType>\n  implements\n    Indexable<Uuid, UuidAlgebraicType>,\n    Uniqueable<Uuid, UuidAlgebraicType>,\n    PrimaryKeyable<Uuid, UuidAlgebraicType>,\n    Defaultable<Uuid, UuidAlgebraicType>\n{\n  constructor() {\n    super(Uuid.getAlgebraicType());\n  }\n  index(): UuidColumnBuilder<SetField<DefaultMetadata, 'indexType', 'btree'>>;\n  index<N extends NonNullable<IndexTypes>>(\n    algorithm: N\n  ): UuidColumnBuilder<SetField<DefaultMetadata, 'indexType', N>>;\n  index(\n    algorithm: IndexTypes = 'btree'\n  ): UuidColumnBuilder<SetField<DefaultMetadata, 'indexType', IndexTypes>> {\n    return new UuidColumnBuilder(\n      this,\n      set(defaultMetadata, { indexType: algorithm })\n    );\n  }\n  unique(): UuidColumnBuilder<SetField<DefaultMetadata, 'isUnique', true>> {\n    return new UuidColumnBuilder(\n      this,\n      set(defaultMetadata, { isUnique: true })\n    );\n  }\n  primaryKey(): UuidColumnBuilder<\n    SetField<DefaultMetadata, 'isPrimaryKey', true>\n  > {\n    return new UuidColumnBuilder(\n      this,\n      set(defaultMetadata, { isPrimaryKey: true })\n    );\n  }\n  autoInc(): UuidColumnBuilder<\n    SetField<DefaultMetadata, 'isAutoIncrement', true>\n  > {\n    return new UuidColumnBuilder(\n      this,\n      set(defaultMetadata, { isAutoIncrement: true })\n    );\n  }\n  default(\n    value: Uuid\n  ): UuidColumnBuilder<SetField<DefaultMetadata, 'defaultValue', Uuid>> {\n    return new UuidColumnBuilder(\n      this,\n      set(defaultMetadata, { defaultValue: value })\n    );\n  }\n}\n\n/**\n * The type of index types that can be applied to a column.\n * `undefined` is the default\n */\nexport type IndexTypes = 'btree' | 'direct' | undefined;\n\n/**\n * Metadata describing column constraints and index type\n */\nexport type ColumnMetadata<Type = any> = {\n  isPrimaryKey?: true;\n  isUnique?: true;\n  isAutoIncrement?: true;\n  indexType?: IndexTypes;\n  defaultValue?: Type;\n  name?: string;\n};\n\n/**\n * Default metadata state type for a newly created column\n */\ntype DefaultMetadata = object;\n\n/**\n * Default metadata state value for a newly created column\n */\nconst defaultMetadata: ColumnMetadata<never> = {};\n\n/**\n * A column builder allows you to incrementally specify constraints\n * and metadata for a column in a type-safe way.\n *\n * It carries both a phantom TypeScript type (the `Type`) and\n * runtime algebraic type information.\n *\n * IMPORTANT! We have deliberately chosen to not have {@link ColumnBuilder}\n * extend {@link TypeBuilder} so that you cannot pass a {@link ColumnBuilder}\n * where a {@link TypeBuilder} is expected. i.e. We want to maintain\n * contravariance for functions that accept {@link TypeBuilder} parameters.\n */\nexport class ColumnBuilder<\n  Type,\n  SpacetimeType extends AlgebraicType,\n  M extends ColumnMetadata<Type> = DefaultMetadata,\n> {\n  typeBuilder: TypeBuilder<Type, SpacetimeType>;\n  columnMetadata: M;\n\n  constructor(typeBuilder: TypeBuilder<Type, SpacetimeType>, metadata: M) {\n    this.typeBuilder = typeBuilder;\n    this.columnMetadata = metadata;\n  }\n\n  serialize(writer: BinaryWriter, value: Type): void {\n    AlgebraicType.serializeValue(writer, this.typeBuilder.algebraicType, value);\n  }\n\n  deserialize(reader: BinaryReader): Type {\n    return AlgebraicType.deserializeValue(\n      reader,\n      this.typeBuilder.algebraicType\n    );\n  }\n}\n\nexport class U8ColumnBuilder<M extends ColumnMetadata<number> = DefaultMetadata>\n  extends ColumnBuilder<number, AlgebraicTypeVariants.U8, M>\n  implements\n    Indexable<number, AlgebraicTypeVariants.U8>,\n    Uniqueable<number, AlgebraicTypeVariants.U8>,\n    PrimaryKeyable<number, AlgebraicTypeVariants.U8>,\n    AutoIncrementable<number, AlgebraicTypeVariants.U8>,\n    Defaultable<number, AlgebraicTypeVariants.U8>,\n    Nameable<number, AlgebraicTypeVariants.U8>\n{\n  index(): U8ColumnBuilder<SetField<M, 'indexType', 'btree'>>;\n  index<N extends NonNullable<IndexTypes>>(\n    algorithm: N\n  ): U8ColumnBuilder<SetField<M, 'indexType', N>>;\n  index(\n    algorithm: IndexTypes = 'btree'\n  ): U8ColumnBuilder<SetField<M, 'indexType', IndexTypes>> {\n    return new U8ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { indexType: algorithm })\n    );\n  }\n  unique(): U8ColumnBuilder<SetField<M, 'isUnique', true>> {\n    return new U8ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { isUnique: true })\n    );\n  }\n  primaryKey(): U8ColumnBuilder<SetField<M, 'isPrimaryKey', true>> {\n    return new U8ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { isPrimaryKey: true })\n    );\n  }\n  autoInc(): U8ColumnBuilder<SetField<M, 'isAutoIncrement', true>> {\n    return new U8ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { isAutoIncrement: true as const })\n    );\n  }\n  default(value: number): U8ColumnBuilder<SetField<M, 'defaultValue', number>> {\n    return new U8ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, {\n        defaultValue: value,\n      })\n    );\n  }\n  name<const Name extends string>(\n    name: Name\n  ): U8ColumnBuilder<SetField<M, 'name', Name>> {\n    return new U8ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { name })\n    );\n  }\n}\n\nexport class U16ColumnBuilder<\n    M extends ColumnMetadata<number> = DefaultMetadata,\n  >\n  extends ColumnBuilder<number, AlgebraicTypeVariants.U16, M>\n  implements\n    Indexable<number, AlgebraicTypeVariants.U16>,\n    Uniqueable<number, AlgebraicTypeVariants.U16>,\n    PrimaryKeyable<number, AlgebraicTypeVariants.U16>,\n    AutoIncrementable<number, AlgebraicTypeVariants.U16>,\n    Defaultable<number, AlgebraicTypeVariants.U16>,\n    Nameable<number, AlgebraicTypeVariants.U16>\n{\n  index(): U16ColumnBuilder<SetField<M, 'indexType', 'btree'>>;\n  index<N extends NonNullable<IndexTypes>>(\n    algorithm: N\n  ): U16ColumnBuilder<SetField<M, 'indexType', N>>;\n  index(\n    algorithm: IndexTypes = 'btree'\n  ): U16ColumnBuilder<SetField<M, 'indexType', IndexTypes>> {\n    return new U16ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { indexType: algorithm })\n    );\n  }\n  unique(): U16ColumnBuilder<SetField<M, 'isUnique', true>> {\n    return new U16ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { isUnique: true })\n    );\n  }\n  primaryKey(): U16ColumnBuilder<SetField<M, 'isPrimaryKey', true>> {\n    return new U16ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { isPrimaryKey: true })\n    );\n  }\n  autoInc(): U16ColumnBuilder<SetField<M, 'isAutoIncrement', true>> {\n    return new U16ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { isAutoIncrement: true })\n    );\n  }\n  default(\n    value: number\n  ): U16ColumnBuilder<SetField<M, 'defaultValue', number>> {\n    return new U16ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, {\n        defaultValue: value,\n      })\n    );\n  }\n  name<const Name extends string>(\n    name: Name\n  ): U16ColumnBuilder<SetField<M, 'name', Name>> {\n    return new U16ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { name })\n    );\n  }\n}\n\nexport class U32ColumnBuilder<\n    M extends ColumnMetadata<number> = DefaultMetadata,\n  >\n  extends ColumnBuilder<number, AlgebraicTypeVariants.U32, M>\n  implements\n    Indexable<number, AlgebraicTypeVariants.U32>,\n    Uniqueable<number, AlgebraicTypeVariants.U32>,\n    PrimaryKeyable<number, AlgebraicTypeVariants.U32>,\n    AutoIncrementable<number, AlgebraicTypeVariants.U32>,\n    Defaultable<number, AlgebraicTypeVariants.U32>,\n    Nameable<number, AlgebraicTypeVariants.U32>\n{\n  index(): U32ColumnBuilder<SetField<M, 'indexType', 'btree'>>;\n  index<N extends NonNullable<IndexTypes>>(\n    algorithm: N\n  ): U32ColumnBuilder<SetField<M, 'indexType', N>>;\n  index(\n    algorithm: IndexTypes = 'btree'\n  ): U32ColumnBuilder<SetField<M, 'indexType', IndexTypes>> {\n    return new U32ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { indexType: algorithm })\n    );\n  }\n  unique(): U32ColumnBuilder<SetField<M, 'isUnique', true>> {\n    return new U32ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { isUnique: true })\n    );\n  }\n  primaryKey(): U32ColumnBuilder<SetField<M, 'isPrimaryKey', true>> {\n    return new U32ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { isPrimaryKey: true })\n    );\n  }\n  autoInc(): U32ColumnBuilder<SetField<M, 'isAutoIncrement', true>> {\n    return new U32ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { isAutoIncrement: true })\n    );\n  }\n  default(\n    value: number\n  ): U32ColumnBuilder<SetField<M, 'defaultValue', number>> {\n    return new U32ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, {\n        defaultValue: value,\n      })\n    );\n  }\n  name<const Name extends string>(\n    name: Name\n  ): U32ColumnBuilder<SetField<M, 'name', Name>> {\n    return new U32ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { name })\n    );\n  }\n}\n\nexport class U64ColumnBuilder<\n    M extends ColumnMetadata<bigint> = DefaultMetadata,\n  >\n  extends ColumnBuilder<bigint, AlgebraicTypeVariants.U64, M>\n  implements\n    Indexable<bigint, AlgebraicTypeVariants.U64>,\n    Uniqueable<bigint, AlgebraicTypeVariants.U64>,\n    PrimaryKeyable<bigint, AlgebraicTypeVariants.U64>,\n    AutoIncrementable<bigint, AlgebraicTypeVariants.U64>,\n    Defaultable<bigint, AlgebraicTypeVariants.U64>,\n    Nameable<bigint, AlgebraicTypeVariants.U64>\n{\n  index(): U64ColumnBuilder<SetField<M, 'indexType', 'btree'>>;\n  index<N extends NonNullable<IndexTypes>>(\n    algorithm: N\n  ): U64ColumnBuilder<SetField<M, 'indexType', N>>;\n  index(\n    algorithm: IndexTypes = 'btree'\n  ): U64ColumnBuilder<SetField<M, 'indexType', IndexTypes>> {\n    return new U64ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { indexType: algorithm })\n    );\n  }\n  unique(): U64ColumnBuilder<SetField<M, 'isUnique', true>> {\n    return new U64ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { isUnique: true })\n    );\n  }\n  primaryKey(): U64ColumnBuilder<SetField<M, 'isPrimaryKey', true>> {\n    return new U64ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { isPrimaryKey: true })\n    );\n  }\n  autoInc(): U64ColumnBuilder<SetField<M, 'isAutoIncrement', true>> {\n    return new U64ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { isAutoIncrement: true })\n    );\n  }\n  default(\n    value: bigint\n  ): U64ColumnBuilder<SetField<M, 'defaultValue', bigint>> {\n    return new U64ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, {\n        defaultValue: value,\n      })\n    );\n  }\n  name<const Name extends string>(\n    name: Name\n  ): U64ColumnBuilder<SetField<M, 'name', Name>> {\n    return new U64ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { name })\n    );\n  }\n}\n\nexport class U128ColumnBuilder<\n    M extends ColumnMetadata<bigint> = DefaultMetadata,\n  >\n  extends ColumnBuilder<bigint, AlgebraicTypeVariants.U128, M>\n  implements\n    Indexable<bigint, AlgebraicTypeVariants.U128>,\n    Uniqueable<bigint, AlgebraicTypeVariants.U128>,\n    PrimaryKeyable<bigint, AlgebraicTypeVariants.U128>,\n    AutoIncrementable<bigint, AlgebraicTypeVariants.U128>,\n    Defaultable<bigint, AlgebraicTypeVariants.U128>,\n    Nameable<bigint, AlgebraicTypeVariants.U128>\n{\n  index(): U128ColumnBuilder<SetField<M, 'indexType', 'btree'>>;\n  index<N extends NonNullable<IndexTypes>>(\n    algorithm: N\n  ): U128ColumnBuilder<SetField<M, 'indexType', N>>;\n  index(\n    algorithm: IndexTypes = 'btree'\n  ): U128ColumnBuilder<SetField<M, 'indexType', IndexTypes>> {\n    return new U128ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { indexType: algorithm })\n    );\n  }\n  unique(): U128ColumnBuilder<SetField<M, 'isUnique', true>> {\n    return new U128ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { isUnique: true })\n    );\n  }\n  primaryKey(): U128ColumnBuilder<SetField<M, 'isPrimaryKey', true>> {\n    return new U128ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { isPrimaryKey: true })\n    );\n  }\n  autoInc(): U128ColumnBuilder<SetField<M, 'isAutoIncrement', true>> {\n    return new U128ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { isAutoIncrement: true })\n    );\n  }\n  default(\n    value: bigint\n  ): U128ColumnBuilder<SetField<M, 'defaultValue', bigint>> {\n    return new U128ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, {\n        defaultValue: value,\n      })\n    );\n  }\n  name<const Name extends string>(\n    name: Name\n  ): U128ColumnBuilder<SetField<M, 'name', Name>> {\n    return new U128ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { name })\n    );\n  }\n}\n\nexport class U256ColumnBuilder<\n    M extends ColumnMetadata<bigint> = DefaultMetadata,\n  >\n  extends ColumnBuilder<bigint, AlgebraicTypeVariants.U256, M>\n  implements\n    Indexable<bigint, AlgebraicTypeVariants.U256>,\n    Uniqueable<bigint, AlgebraicTypeVariants.U256>,\n    PrimaryKeyable<bigint, AlgebraicTypeVariants.U256>,\n    AutoIncrementable<bigint, AlgebraicTypeVariants.U256>,\n    Defaultable<bigint, AlgebraicTypeVariants.U256>,\n    Nameable<bigint, AlgebraicTypeVariants.U256>\n{\n  index(): U256ColumnBuilder<SetField<M, 'indexType', 'btree'>>;\n  index<N extends NonNullable<IndexTypes>>(\n    algorithm: N\n  ): U256ColumnBuilder<SetField<M, 'indexType', N>>;\n  index(\n    algorithm: IndexTypes = 'btree'\n  ): U256ColumnBuilder<SetField<M, 'indexType', IndexTypes>> {\n    return new U256ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { indexType: algorithm })\n    );\n  }\n  unique(): U256ColumnBuilder<SetField<M, 'isUnique', true>> {\n    return new U256ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { isUnique: true })\n    );\n  }\n  primaryKey(): U256ColumnBuilder<SetField<M, 'isPrimaryKey', true>> {\n    return new U256ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { isPrimaryKey: true })\n    );\n  }\n  autoInc(): U256ColumnBuilder<SetField<M, 'isAutoIncrement', true>> {\n    return new U256ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { isAutoIncrement: true })\n    );\n  }\n  default(\n    value: bigint\n  ): U256ColumnBuilder<SetField<M, 'defaultValue', bigint>> {\n    return new U256ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, {\n        defaultValue: value,\n      })\n    );\n  }\n  name<const Name extends string>(\n    name: Name\n  ): U256ColumnBuilder<SetField<M, 'name', Name>> {\n    return new U256ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { name })\n    );\n  }\n}\n\nexport class I8ColumnBuilder<M extends ColumnMetadata<number> = DefaultMetadata>\n  extends ColumnBuilder<number, AlgebraicTypeVariants.I8, M>\n  implements\n    Indexable<number, AlgebraicTypeVariants.I8>,\n    Uniqueable<number, AlgebraicTypeVariants.I8>,\n    PrimaryKeyable<number, AlgebraicTypeVariants.I8>,\n    AutoIncrementable<number, AlgebraicTypeVariants.I8>,\n    Defaultable<number, AlgebraicTypeVariants.I8>,\n    Nameable<number, AlgebraicTypeVariants.I8>\n{\n  index(): I8ColumnBuilder<SetField<M, 'indexType', 'btree'>>;\n  index<N extends NonNullable<IndexTypes>>(\n    algorithm: N\n  ): I8ColumnBuilder<SetField<M, 'indexType', N>>;\n  index(\n    algorithm: IndexTypes = 'btree'\n  ): I8ColumnBuilder<SetField<M, 'indexType', IndexTypes>> {\n    return new I8ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { indexType: algorithm })\n    );\n  }\n  unique(): I8ColumnBuilder<SetField<M, 'isUnique', true>> {\n    return new I8ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { isUnique: true })\n    );\n  }\n  primaryKey(): I8ColumnBuilder<SetField<M, 'isPrimaryKey', true>> {\n    return new I8ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { isPrimaryKey: true })\n    );\n  }\n  autoInc(): I8ColumnBuilder<SetField<M, 'isAutoIncrement', true>> {\n    return new I8ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { isAutoIncrement: true })\n    );\n  }\n  default(value: number): I8ColumnBuilder<SetField<M, 'defaultValue', number>> {\n    return new I8ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, {\n        defaultValue: value,\n      })\n    );\n  }\n  name<const Name extends string>(\n    name: Name\n  ): I8ColumnBuilder<SetField<M, 'name', Name>> {\n    return new I8ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { name })\n    );\n  }\n}\n\nexport class I16ColumnBuilder<\n    M extends ColumnMetadata<number> = DefaultMetadata,\n  >\n  extends ColumnBuilder<number, AlgebraicTypeVariants.I16, M>\n  implements\n    Indexable<number, AlgebraicTypeVariants.I16>,\n    Uniqueable<number, AlgebraicTypeVariants.I16>,\n    PrimaryKeyable<number, AlgebraicTypeVariants.I16>,\n    AutoIncrementable<number, AlgebraicTypeVariants.I16>,\n    Defaultable<number, AlgebraicTypeVariants.I16>,\n    Nameable<number, AlgebraicTypeVariants.I16>\n{\n  index(): I16ColumnBuilder<SetField<M, 'indexType', 'btree'>>;\n  index<N extends NonNullable<IndexTypes>>(\n    algorithm: N\n  ): I16ColumnBuilder<SetField<M, 'indexType', N>>;\n  index(\n    algorithm: IndexTypes = 'btree'\n  ): I16ColumnBuilder<SetField<M, 'indexType', IndexTypes>> {\n    return new I16ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { indexType: algorithm })\n    );\n  }\n  unique(): I16ColumnBuilder<SetField<M, 'isUnique', true>> {\n    return new I16ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { isUnique: true })\n    );\n  }\n  primaryKey(): I16ColumnBuilder<SetField<M, 'isPrimaryKey', true>> {\n    return new I16ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { isPrimaryKey: true })\n    );\n  }\n  autoInc(): I16ColumnBuilder<SetField<M, 'isAutoIncrement', true>> {\n    return new I16ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { isAutoIncrement: true })\n    );\n  }\n  default(\n    value: number\n  ): I16ColumnBuilder<SetField<M, 'defaultValue', number>> {\n    return new I16ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, {\n        defaultValue: value,\n      })\n    );\n  }\n  name<const Name extends string>(\n    name: Name\n  ): I16ColumnBuilder<SetField<M, 'name', Name>> {\n    return new I16ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { name })\n    );\n  }\n}\n\nexport class I32ColumnBuilder<\n    M extends ColumnMetadata<number> = DefaultMetadata,\n  >\n  extends ColumnBuilder<number, AlgebraicTypeVariants.I32, M>\n  implements\n    Indexable<number, AlgebraicTypeVariants.I32>,\n    Uniqueable<number, AlgebraicTypeVariants.I32>,\n    PrimaryKeyable<number, AlgebraicTypeVariants.I32>,\n    AutoIncrementable<number, AlgebraicTypeVariants.I32>,\n    Defaultable<number, AlgebraicTypeVariants.I32>,\n    Nameable<number, AlgebraicTypeVariants.I32>\n{\n  index(): I32ColumnBuilder<SetField<M, 'indexType', 'btree'>>;\n  index<N extends NonNullable<IndexTypes>>(\n    algorithm: N\n  ): I32ColumnBuilder<SetField<M, 'indexType', N>>;\n  index(\n    algorithm: IndexTypes = 'btree'\n  ): I32ColumnBuilder<SetField<M, 'indexType', IndexTypes>> {\n    return new I32ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { indexType: algorithm })\n    );\n  }\n  unique(): I32ColumnBuilder<SetField<M, 'isUnique', true>> {\n    return new I32ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { isUnique: true })\n    );\n  }\n  primaryKey(): I32ColumnBuilder<SetField<M, 'isPrimaryKey', true>> {\n    return new I32ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { isPrimaryKey: true })\n    );\n  }\n  autoInc(): I32ColumnBuilder<SetField<M, 'isAutoIncrement', true>> {\n    return new I32ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { isAutoIncrement: true })\n    );\n  }\n  default(\n    value: number\n  ): I32ColumnBuilder<SetField<M, 'defaultValue', number>> {\n    return new I32ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, {\n        defaultValue: value,\n      })\n    );\n  }\n  name<const Name extends string>(\n    name: Name\n  ): I32ColumnBuilder<SetField<M, 'name', Name>> {\n    return new I32ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { name })\n    );\n  }\n}\n\nexport class I64ColumnBuilder<\n    M extends ColumnMetadata<bigint> = DefaultMetadata,\n  >\n  extends ColumnBuilder<bigint, AlgebraicTypeVariants.I64, M>\n  implements\n    Indexable<bigint, AlgebraicTypeVariants.I64>,\n    Uniqueable<bigint, AlgebraicTypeVariants.I64>,\n    PrimaryKeyable<bigint, AlgebraicTypeVariants.I64>,\n    AutoIncrementable<bigint, AlgebraicTypeVariants.I64>,\n    Defaultable<bigint, AlgebraicTypeVariants.I64>,\n    Nameable<bigint, AlgebraicTypeVariants.I64>\n{\n  index(): I64ColumnBuilder<SetField<M, 'indexType', 'btree'>>;\n  index<N extends NonNullable<IndexTypes>>(\n    algorithm: N\n  ): I64ColumnBuilder<SetField<M, 'indexType', N>>;\n  index(\n    algorithm: IndexTypes = 'btree'\n  ): I64ColumnBuilder<SetField<M, 'indexType', IndexTypes>> {\n    return new I64ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { indexType: algorithm })\n    );\n  }\n  unique(): I64ColumnBuilder<SetField<M, 'isUnique', true>> {\n    return new I64ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { isUnique: true })\n    );\n  }\n  primaryKey(): I64ColumnBuilder<SetField<M, 'isPrimaryKey', true>> {\n    return new I64ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { isPrimaryKey: true })\n    );\n  }\n  autoInc(): I64ColumnBuilder<SetField<M, 'isAutoIncrement', true>> {\n    return new I64ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { isAutoIncrement: true })\n    );\n  }\n  default(\n    value: bigint\n  ): I64ColumnBuilder<SetField<M, 'defaultValue', bigint>> {\n    return new I64ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, {\n        defaultValue: value,\n      })\n    );\n  }\n  name<const Name extends string>(\n    name: Name\n  ): I64ColumnBuilder<SetField<M, 'name', Name>> {\n    return new I64ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { name })\n    );\n  }\n}\n\nexport class I128ColumnBuilder<\n    M extends ColumnMetadata<bigint> = DefaultMetadata,\n  >\n  extends ColumnBuilder<bigint, AlgebraicTypeVariants.I128, M>\n  implements\n    Indexable<bigint, AlgebraicTypeVariants.I128>,\n    Uniqueable<bigint, AlgebraicTypeVariants.I128>,\n    PrimaryKeyable<bigint, AlgebraicTypeVariants.I128>,\n    AutoIncrementable<bigint, AlgebraicTypeVariants.I128>,\n    Defaultable<bigint, AlgebraicTypeVariants.I128>,\n    Nameable<bigint, AlgebraicTypeVariants.I128>\n{\n  index(): I128ColumnBuilder<SetField<M, 'indexType', 'btree'>>;\n  index<N extends NonNullable<IndexTypes>>(\n    algorithm: N\n  ): I128ColumnBuilder<SetField<M, 'indexType', N>>;\n  index(\n    algorithm: IndexTypes = 'btree'\n  ): I128ColumnBuilder<SetField<M, 'indexType', IndexTypes>> {\n    return new I128ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { indexType: algorithm })\n    );\n  }\n  unique(): I128ColumnBuilder<SetField<M, 'isUnique', true>> {\n    return new I128ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { isUnique: true })\n    );\n  }\n  primaryKey(): I128ColumnBuilder<SetField<M, 'isPrimaryKey', true>> {\n    return new I128ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { isPrimaryKey: true })\n    );\n  }\n  autoInc(): I128ColumnBuilder<SetField<M, 'isAutoIncrement', true>> {\n    return new I128ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { isAutoIncrement: true })\n    );\n  }\n  default(\n    value: bigint\n  ): I128ColumnBuilder<SetField<M, 'defaultValue', bigint>> {\n    return new I128ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, {\n        defaultValue: value,\n      })\n    );\n  }\n  name<const Name extends string>(\n    name: Name\n  ): I128ColumnBuilder<SetField<M, 'name', Name>> {\n    return new I128ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { name })\n    );\n  }\n}\n\nexport class I256ColumnBuilder<\n    M extends ColumnMetadata<bigint> = DefaultMetadata,\n  >\n  extends ColumnBuilder<bigint, AlgebraicTypeVariants.I256, M>\n  implements\n    Indexable<bigint, AlgebraicTypeVariants.I256>,\n    Uniqueable<bigint, AlgebraicTypeVariants.I256>,\n    PrimaryKeyable<bigint, AlgebraicTypeVariants.I256>,\n    AutoIncrementable<bigint, AlgebraicTypeVariants.I256>,\n    Defaultable<bigint, AlgebraicTypeVariants.I256>,\n    Nameable<bigint, AlgebraicTypeVariants.I256>\n{\n  index(): I256ColumnBuilder<SetField<M, 'indexType', 'btree'>>;\n  index<N extends NonNullable<IndexTypes>>(\n    algorithm: N\n  ): I256ColumnBuilder<SetField<M, 'indexType', N>>;\n  index(\n    algorithm: IndexTypes = 'btree'\n  ): I256ColumnBuilder<SetField<M, 'indexType', IndexTypes>> {\n    return new I256ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { indexType: algorithm })\n    );\n  }\n  unique(): I256ColumnBuilder<SetField<M, 'isUnique', true>> {\n    return new I256ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { isUnique: true })\n    );\n  }\n  primaryKey(): I256ColumnBuilder<SetField<M, 'isPrimaryKey', true>> {\n    return new I256ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { isPrimaryKey: true })\n    );\n  }\n  autoInc(): I256ColumnBuilder<SetField<M, 'isAutoIncrement', true>> {\n    return new I256ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { isAutoIncrement: true })\n    );\n  }\n  default(\n    value: bigint\n  ): I256ColumnBuilder<SetField<M, 'defaultValue', bigint>> {\n    return new I256ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, {\n        defaultValue: value,\n      })\n    );\n  }\n  name<const Name extends string>(\n    name: Name\n  ): I256ColumnBuilder<SetField<M, 'name', Name>> {\n    return new I256ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { name })\n    );\n  }\n}\n\nexport class F32ColumnBuilder<\n    M extends ColumnMetadata<number> = DefaultMetadata,\n  >\n  extends ColumnBuilder<number, AlgebraicTypeVariants.F32, M>\n  implements\n    Defaultable<number, AlgebraicTypeVariants.F32>,\n    Nameable<number, AlgebraicTypeVariants.F32>\n{\n  default(\n    value: number\n  ): F32ColumnBuilder<SetField<M, 'defaultValue', number>> {\n    return new F32ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, {\n        defaultValue: value,\n      })\n    );\n  }\n  name<const Name extends string>(\n    name: Name\n  ): F32ColumnBuilder<SetField<M, 'name', Name>> {\n    return new F32ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { name })\n    );\n  }\n}\n\nexport class F64ColumnBuilder<\n    M extends ColumnMetadata<number> = DefaultMetadata,\n  >\n  extends ColumnBuilder<number, AlgebraicTypeVariants.F64, M>\n  implements\n    Defaultable<number, AlgebraicTypeVariants.F64>,\n    Nameable<number, AlgebraicTypeVariants.F64>\n{\n  default(\n    value: number\n  ): F64ColumnBuilder<SetField<M, 'defaultValue', number>> {\n    return new F64ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, {\n        defaultValue: value,\n      })\n    );\n  }\n  name<const Name extends string>(\n    name: Name\n  ): F64ColumnBuilder<SetField<M, 'name', Name>> {\n    return new F64ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { name })\n    );\n  }\n}\n\nexport class BoolColumnBuilder<\n    M extends ColumnMetadata<boolean> = DefaultMetadata,\n  >\n  extends ColumnBuilder<boolean, AlgebraicTypeVariants.Bool, M>\n  implements\n    Indexable<boolean, AlgebraicTypeVariants.Bool>,\n    Uniqueable<boolean, AlgebraicTypeVariants.Bool>,\n    PrimaryKeyable<boolean, AlgebraicTypeVariants.Bool>,\n    Defaultable<boolean, AlgebraicTypeVariants.Bool>,\n    Nameable<boolean, AlgebraicTypeVariants.Bool>\n{\n  index(): BoolColumnBuilder<SetField<M, 'indexType', 'btree'>>;\n  index<N extends NonNullable<IndexTypes>>(\n    algorithm: N\n  ): BoolColumnBuilder<SetField<M, 'indexType', N>>;\n  index(\n    algorithm: IndexTypes = 'btree'\n  ): BoolColumnBuilder<SetField<M, 'indexType', IndexTypes>> {\n    return new BoolColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { indexType: algorithm })\n    );\n  }\n  unique(): BoolColumnBuilder<SetField<M, 'isUnique', true>> {\n    return new BoolColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { isUnique: true })\n    );\n  }\n  primaryKey(): BoolColumnBuilder<SetField<M, 'isPrimaryKey', true>> {\n    return new BoolColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { isPrimaryKey: true })\n    );\n  }\n  default(\n    value: boolean\n  ): BoolColumnBuilder<SetField<M, 'defaultValue', boolean>> {\n    return new BoolColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, {\n        defaultValue: value,\n      })\n    );\n  }\n  name<const Name extends string>(\n    name: Name\n  ): BoolColumnBuilder<SetField<M, 'name', Name>> {\n    return new BoolColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { name })\n    );\n  }\n}\n\nexport class StringColumnBuilder<\n    M extends ColumnMetadata<string> = DefaultMetadata,\n  >\n  extends ColumnBuilder<string, AlgebraicTypeVariants.String, M>\n  implements\n    Indexable<string, AlgebraicTypeVariants.String>,\n    Uniqueable<string, AlgebraicTypeVariants.String>,\n    PrimaryKeyable<string, AlgebraicTypeVariants.String>,\n    Defaultable<string, AlgebraicTypeVariants.String>,\n    Nameable<string, AlgebraicTypeVariants.String>\n{\n  index(): StringColumnBuilder<SetField<M, 'indexType', 'btree'>>;\n  index<N extends NonNullable<IndexTypes>>(\n    algorithm: N\n  ): StringColumnBuilder<SetField<M, 'indexType', N>>;\n  index(\n    algorithm: IndexTypes = 'btree'\n  ): StringColumnBuilder<SetField<M, 'indexType', IndexTypes>> {\n    return new StringColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { indexType: algorithm })\n    );\n  }\n  unique(): StringColumnBuilder<SetField<M, 'isUnique', true>> {\n    return new StringColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { isUnique: true })\n    );\n  }\n  primaryKey(): StringColumnBuilder<SetField<M, 'isPrimaryKey', true>> {\n    return new StringColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { isPrimaryKey: true })\n    );\n  }\n  default(\n    value: string\n  ): StringColumnBuilder<SetField<M, 'defaultValue', string>> {\n    return new StringColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, {\n        defaultValue: value,\n      })\n    );\n  }\n  name<const Name extends string>(\n    name: Name\n  ): StringColumnBuilder<SetField<M, 'name', Name>> {\n    return new StringColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { name })\n    );\n  }\n}\n\nexport class ArrayColumnBuilder<\n    Element extends TypeBuilder<any, any>,\n    M extends ColumnMetadata<\n      Array<InferTypeOfTypeBuilder<Element>>\n    > = DefaultMetadata,\n  >\n  extends ColumnBuilder<\n    Array<InferTypeOfTypeBuilder<Element>>,\n    { tag: 'Array'; value: InferSpacetimeTypeOfTypeBuilder<Element> },\n    M\n  >\n  implements\n    Defaultable<\n      Array<InferTypeOfTypeBuilder<Element>>,\n      AlgebraicTypeVariants.Array\n    >,\n    Nameable<\n      Array<InferTypeOfTypeBuilder<Element>>,\n      AlgebraicTypeVariants.Array\n    >\n{\n  default(\n    value: Array<InferTypeOfTypeBuilder<Element>>\n  ): ArrayColumnBuilder<\n    Element,\n    SetField<M, 'defaultValue', Array<InferTypeOfTypeBuilder<Element>>>\n  > {\n    return new ArrayColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, {\n        defaultValue: value,\n      })\n    );\n  }\n  name<const Name extends string>(\n    name: Name\n  ): ArrayColumnBuilder<Element, SetField<M, 'name', Name>> {\n    return new ArrayColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { name })\n    );\n  }\n}\n\ntype ByteArrayType = {\n  tag: 'Array';\n  value: AlgebraicTypeVariants.U8;\n};\n\nexport class ByteArrayColumnBuilder<\n    M extends ColumnMetadata<Uint8Array> = DefaultMetadata,\n  >\n  extends ColumnBuilder<Uint8Array, ByteArrayType, M>\n  implements\n    Defaultable<Uint8Array, ByteArrayType, M>,\n    Nameable<Uint8Array, ByteArrayType, M>\n{\n  constructor(metadata: M) {\n    super(new TypeBuilder(AlgebraicType.Array(AlgebraicType.U8)), metadata);\n  }\n  default(\n    value: Uint8Array\n  ): ByteArrayColumnBuilder<SetField<M, 'defaultValue', Uint8Array>> {\n    return new ByteArrayColumnBuilder(\n      set(this.columnMetadata, { defaultValue: value })\n    );\n  }\n  name<const Name extends string>(\n    name: Name\n  ): ByteArrayColumnBuilder<SetField<M, 'name', Name>> {\n    return new ByteArrayColumnBuilder(set(this.columnMetadata, { name }));\n  }\n}\n\nexport class OptionColumnBuilder<\n    Value extends TypeBuilder<any, any>,\n    M extends ColumnMetadata<\n      InferTypeOfTypeBuilder<Value> | undefined\n    > = DefaultMetadata,\n  >\n  extends ColumnBuilder<\n    InferTypeOfTypeBuilder<Value> | undefined,\n    OptionAlgebraicType<InferSpacetimeTypeOfTypeBuilder<Value>>,\n    M\n  >\n  implements\n    Defaultable<\n      InferTypeOfTypeBuilder<Value> | undefined,\n      OptionAlgebraicType<InferSpacetimeTypeOfTypeBuilder<Value>>\n    >,\n    Nameable<\n      InferTypeOfTypeBuilder<Value> | undefined,\n      OptionAlgebraicType<InferSpacetimeTypeOfTypeBuilder<Value>>\n    >\n{\n  default(\n    value: InferTypeOfTypeBuilder<Value> | undefined\n  ): OptionColumnBuilder<\n    Value,\n    SetField<M, 'defaultValue', InferTypeOfTypeBuilder<Value> | undefined>\n  > {\n    return new OptionColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, {\n        defaultValue: value,\n      })\n    );\n  }\n  name<const Name extends string>(\n    name: Name\n  ): OptionColumnBuilder<Value, SetField<M, 'name', Name>> {\n    return new OptionColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { name })\n    );\n  }\n}\n\nexport class ResultColumnBuilder<\n    Ok extends TypeBuilder<any, any>,\n    Err extends TypeBuilder<any, any>,\n    M extends ColumnMetadata<\n      InferTypeOfTypeBuilder<Ok> | InferTypeOfTypeBuilder<Err>\n    > = DefaultMetadata,\n  >\n  extends ColumnBuilder<\n    InferTypeOfTypeBuilder<Ok> | InferTypeOfTypeBuilder<Err>,\n    ResultAlgebraicType<\n      InferSpacetimeTypeOfTypeBuilder<Ok>,\n      InferSpacetimeTypeOfTypeBuilder<Err>\n    >,\n    M\n  >\n  implements\n    Defaultable<\n      InferTypeOfTypeBuilder<Ok> | InferTypeOfTypeBuilder<Err>,\n      ResultAlgebraicType<\n        InferSpacetimeTypeOfTypeBuilder<Ok>,\n        InferSpacetimeTypeOfTypeBuilder<Err>\n      >\n    >\n{\n  constructor(typeBuilder: TypeBuilder<any, any>, metadata: M) {\n    super(typeBuilder, metadata);\n  }\n\n  default(\n    value: InferTypeOfTypeBuilder<Ok> | InferTypeOfTypeBuilder<Err>\n  ): ResultColumnBuilder<\n    Ok,\n    Err,\n    SetField<\n      M,\n      'defaultValue',\n      InferTypeOfTypeBuilder<Ok> | InferTypeOfTypeBuilder<Err>\n    >\n  > {\n    return new ResultColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, {\n        defaultValue: value,\n      })\n    );\n  }\n}\n\nexport class ProductColumnBuilder<\n    Elements extends ElementsObj,\n    M extends ColumnMetadata<ObjectType<Elements>> = DefaultMetadata,\n  >\n  extends ColumnBuilder<\n    ObjectType<Elements>,\n    ElementsToProductType<Elements>,\n    M\n  >\n  implements\n    Defaultable<ObjectType<Elements>, ElementsToProductType<Elements>>,\n    Nameable<ObjectType<Elements>, ElementsToProductType<Elements>>\n{\n  default(\n    value: ObjectType<Elements>\n  ): ProductColumnBuilder<\n    Elements,\n    SetField<DefaultMetadata, 'defaultValue', any>\n  > {\n    return new ProductColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { defaultValue: value })\n    );\n  }\n  name<const Name extends string>(\n    name: Name\n  ): ProductColumnBuilder<Elements, SetField<DefaultMetadata, 'name', Name>> {\n    return new ProductColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { name })\n    );\n  }\n}\n\nexport class SumColumnBuilder<\n    Variants extends VariantsObj,\n    M extends ColumnMetadata<EnumType<Variants>> = DefaultMetadata,\n  >\n  extends ColumnBuilder<EnumType<Variants>, VariantsToSumType<Variants>, M>\n  implements\n    Defaultable<EnumType<Variants>, VariantsToSumType<Variants>>,\n    Nameable<EnumType<Variants>, VariantsToSumType<Variants>>\n{\n  default(\n    value: EnumType<Variants>\n  ): SumColumnBuilder<\n    Variants,\n    SetField<DefaultMetadata, 'defaultValue', any>\n  > {\n    return new SumColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { defaultValue: value })\n    );\n  }\n  name<const Name extends string>(\n    name: Name\n  ): SumColumnBuilder<Variants, SetField<DefaultMetadata, 'name', Name>> {\n    return new SumColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { name })\n    );\n  }\n}\n\nexport class SimpleSumColumnBuilder<\n    Variants extends VariantsObj,\n    M extends ColumnMetadata<EnumType<Variants>> = DefaultMetadata,\n  >\n  extends SumColumnBuilder<Variants, M>\n  implements\n    Indexable<EnumType<Variants>, AlgebraicTypeVariants.Sum>,\n    PrimaryKeyable<EnumType<Variants>, AlgebraicTypeVariants.Sum>\n{\n  index(): SimpleSumColumnBuilder<\n    Variants,\n    SetField<DefaultMetadata, 'indexType', 'btree'>\n  >;\n  index<N extends NonNullable<IndexTypes>>(\n    algorithm: N\n  ): SimpleSumColumnBuilder<\n    Variants,\n    SetField<DefaultMetadata, 'indexType', N>\n  >;\n  index(\n    algorithm: IndexTypes = 'btree'\n  ): SimpleSumColumnBuilder<\n    Variants,\n    SetField<DefaultMetadata, 'indexType', IndexTypes>\n  > {\n    return new SimpleSumColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { indexType: algorithm })\n    );\n  }\n  primaryKey(): SimpleSumColumnBuilder<\n    Variants,\n    SetField<DefaultMetadata, 'isPrimaryKey', true>\n  > {\n    return new SimpleSumColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { isPrimaryKey: true })\n    );\n  }\n}\n\nexport class ScheduleAtColumnBuilder<\n    M extends ColumnMetadata<ScheduleAt> = DefaultMetadata,\n  >\n  extends ColumnBuilder<ScheduleAt, ScheduleAtAlgebraicType, M>\n  implements\n    Defaultable<ScheduleAt, ScheduleAtAlgebraicType>,\n    Nameable<ScheduleAt, ScheduleAtAlgebraicType>\n{\n  default(\n    value: ScheduleAt\n  ): ScheduleAtColumnBuilder<SetField<M, 'defaultValue', ScheduleAt>> {\n    return new ScheduleAtColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { defaultValue: value })\n    );\n  }\n  name<const Name extends string>(\n    name: Name\n  ): ScheduleAtColumnBuilder<SetField<M, 'name', Name>> {\n    return new ScheduleAtColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { name })\n    );\n  }\n}\n\nexport class IdentityColumnBuilder<\n    M extends ColumnMetadata<Identity> = DefaultMetadata,\n  >\n  extends ColumnBuilder<Identity, IdentityAlgebraicType, M>\n  implements\n    Indexable<Identity, IdentityAlgebraicType>,\n    Uniqueable<Identity, IdentityAlgebraicType>,\n    PrimaryKeyable<Identity, IdentityAlgebraicType>,\n    Defaultable<Identity, IdentityAlgebraicType>,\n    Nameable<Identity, IdentityAlgebraicType>\n{\n  index(): IdentityColumnBuilder<SetField<M, 'indexType', 'btree'>>;\n  index<N extends NonNullable<IndexTypes>>(\n    algorithm: N\n  ): IdentityColumnBuilder<SetField<M, 'indexType', N>>;\n  index(\n    algorithm: IndexTypes = 'btree'\n  ): IdentityColumnBuilder<SetField<M, 'indexType', IndexTypes>> {\n    return new IdentityColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { indexType: algorithm })\n    );\n  }\n  unique(): IdentityColumnBuilder<SetField<M, 'isUnique', true>> {\n    return new IdentityColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { isUnique: true })\n    );\n  }\n  primaryKey(): IdentityColumnBuilder<SetField<M, 'isPrimaryKey', true>> {\n    return new IdentityColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { isPrimaryKey: true })\n    );\n  }\n  default(\n    value: Identity\n  ): IdentityColumnBuilder<SetField<M, 'defaultValue', Identity>> {\n    return new IdentityColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { defaultValue: value })\n    );\n  }\n  name<const Name extends string>(\n    name: Name\n  ): IdentityColumnBuilder<SetField<M, 'name', Name>> {\n    return new IdentityColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { name })\n    );\n  }\n}\n\nexport class ConnectionIdColumnBuilder<\n    M extends ColumnMetadata<ConnectionId> = DefaultMetadata,\n  >\n  extends ColumnBuilder<ConnectionId, ConnectionIdAlgebraicType, M>\n  implements\n    Indexable<ConnectionId, ConnectionIdAlgebraicType>,\n    Uniqueable<ConnectionId, ConnectionIdAlgebraicType>,\n    PrimaryKeyable<ConnectionId, ConnectionIdAlgebraicType>,\n    Defaultable<ConnectionId, ConnectionIdAlgebraicType>,\n    Nameable<ConnectionId, ConnectionIdAlgebraicType>\n{\n  index(): ConnectionIdColumnBuilder<SetField<M, 'indexType', 'btree'>>;\n  index<N extends NonNullable<IndexTypes>>(\n    algorithm: N\n  ): ConnectionIdColumnBuilder<SetField<M, 'indexType', N>>;\n  index(\n    algorithm: IndexTypes = 'btree'\n  ): ConnectionIdColumnBuilder<SetField<M, 'indexType', IndexTypes>> {\n    return new ConnectionIdColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { indexType: algorithm })\n    );\n  }\n  unique(): ConnectionIdColumnBuilder<SetField<M, 'isUnique', true>> {\n    return new ConnectionIdColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { isUnique: true })\n    );\n  }\n  primaryKey(): ConnectionIdColumnBuilder<SetField<M, 'isPrimaryKey', true>> {\n    return new ConnectionIdColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { isPrimaryKey: true })\n    );\n  }\n  default(\n    value: ConnectionId\n  ): ConnectionIdColumnBuilder<SetField<M, 'defaultValue', ConnectionId>> {\n    return new ConnectionIdColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { defaultValue: value })\n    );\n  }\n  name<const Name extends string>(\n    name: Name\n  ): ConnectionIdColumnBuilder<SetField<M, 'name', Name>> {\n    return new ConnectionIdColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { name })\n    );\n  }\n}\n\nexport class TimestampColumnBuilder<\n    M extends ColumnMetadata<Timestamp> = DefaultMetadata,\n  >\n  extends ColumnBuilder<Timestamp, TimestampAlgebraicType, M>\n  implements\n    Indexable<Timestamp, TimestampAlgebraicType>,\n    Uniqueable<Timestamp, TimestampAlgebraicType>,\n    PrimaryKeyable<Timestamp, TimestampAlgebraicType>,\n    Defaultable<Timestamp, TimestampAlgebraicType>,\n    Nameable<Timestamp, TimestampAlgebraicType>\n{\n  index(): TimestampColumnBuilder<SetField<M, 'indexType', 'btree'>>;\n  index<N extends NonNullable<IndexTypes>>(\n    algorithm: N\n  ): TimestampColumnBuilder<SetField<M, 'indexType', N>>;\n  index(\n    algorithm: IndexTypes = 'btree'\n  ): TimestampColumnBuilder<SetField<M, 'indexType', IndexTypes>> {\n    return new TimestampColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { indexType: algorithm })\n    );\n  }\n  unique(): TimestampColumnBuilder<SetField<M, 'isUnique', true>> {\n    return new TimestampColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { isUnique: true })\n    );\n  }\n  primaryKey(): TimestampColumnBuilder<SetField<M, 'isPrimaryKey', true>> {\n    return new TimestampColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { isPrimaryKey: true })\n    );\n  }\n  default(\n    value: Timestamp\n  ): TimestampColumnBuilder<SetField<M, 'defaultValue', Timestamp>> {\n    return new TimestampColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { defaultValue: value })\n    );\n  }\n  name<const Name extends string>(\n    name: Name\n  ): TimestampColumnBuilder<SetField<M, 'name', Name>> {\n    return new TimestampColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { name })\n    );\n  }\n}\n\nexport class TimeDurationColumnBuilder<\n    M extends ColumnMetadata<TimeDuration> = DefaultMetadata,\n  >\n  extends ColumnBuilder<TimeDuration, TimeDurationAlgebraicType, M>\n  implements\n    Indexable<TimeDuration, TimeDurationAlgebraicType>,\n    Uniqueable<TimeDuration, TimeDurationAlgebraicType>,\n    PrimaryKeyable<TimeDuration, TimeDurationAlgebraicType>,\n    Defaultable<TimeDuration, TimeDurationAlgebraicType>,\n    Nameable<TimeDuration, TimeDurationAlgebraicType>\n{\n  index(): TimeDurationColumnBuilder<SetField<M, 'indexType', 'btree'>>;\n  index<N extends NonNullable<IndexTypes>>(\n    algorithm: N\n  ): TimeDurationColumnBuilder<SetField<M, 'indexType', N>>;\n  index(\n    algorithm: IndexTypes = 'btree'\n  ): TimeDurationColumnBuilder<SetField<M, 'indexType', IndexTypes>> {\n    return new TimeDurationColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { indexType: algorithm })\n    );\n  }\n  unique(): TimeDurationColumnBuilder<SetField<M, 'isUnique', true>> {\n    return new TimeDurationColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { isUnique: true })\n    );\n  }\n  primaryKey(): TimeDurationColumnBuilder<SetField<M, 'isPrimaryKey', true>> {\n    return new TimeDurationColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { isPrimaryKey: true })\n    );\n  }\n  default(\n    value: TimeDuration\n  ): TimeDurationColumnBuilder<SetField<M, 'defaultValue', TimeDuration>> {\n    return new TimeDurationColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { defaultValue: value })\n    );\n  }\n  name<const Name extends string>(\n    name: Name\n  ): TimeDurationColumnBuilder<SetField<M, 'name', Name>> {\n    return new TimeDurationColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { name })\n    );\n  }\n}\n\nexport class UuidColumnBuilder<M extends ColumnMetadata<Uuid> = DefaultMetadata>\n  extends ColumnBuilder<Uuid, UuidAlgebraicType, M>\n  implements\n    Indexable<Uuid, UuidAlgebraicType>,\n    Uniqueable<Uuid, UuidAlgebraicType>,\n    PrimaryKeyable<Uuid, UuidAlgebraicType>,\n    Defaultable<Uuid, UuidAlgebraicType>\n{\n  index(): UuidColumnBuilder<SetField<M, 'indexType', 'btree'>>;\n  index<N extends NonNullable<IndexTypes>>(\n    algorithm: N\n  ): UuidColumnBuilder<SetField<M, 'indexType', N>>;\n  index(\n    algorithm: IndexTypes = 'btree'\n  ): UuidColumnBuilder<SetField<M, 'indexType', IndexTypes>> {\n    return new UuidColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { indexType: algorithm })\n    );\n  }\n  unique(): UuidColumnBuilder<SetField<M, 'isUnique', true>> {\n    return new UuidColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { isUnique: true })\n    );\n  }\n  primaryKey(): UuidColumnBuilder<SetField<M, 'isPrimaryKey', true>> {\n    return new UuidColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { isPrimaryKey: true })\n    );\n  }\n  default(value: Uuid): UuidColumnBuilder<SetField<M, 'defaultValue', Uuid>> {\n    return new UuidColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { defaultValue: value })\n    );\n  }\n}\n\nexport class RefBuilder<Type, SpacetimeType> extends TypeBuilder<\n  Type,\n  AlgebraicTypeVariants.Ref\n> {\n  readonly ref: number;\n  /** The phantom type of the pointee of this ref. */\n  private readonly __spacetimeType!: SpacetimeType;\n  constructor(ref: number) {\n    super(AlgebraicType.Ref(ref));\n    this.ref = ref;\n  }\n}\n\ninterface EnumFn {\n  /**\n   * Creates a simple sum type whose cases are all unit variants.\n   * Each string in the array becomes a case of the enum.\n   *\n   * Example:\n   * ```ts\n   * t.enum(\"Color\", [\"red\", \"green\", \"blue\"]);\n   * ```\n   */\n  <Case extends string>(\n    name: string,\n    cases: readonly [Case, ...Case[]]\n  ): SimpleSumBuilderImpl<Record<Case, UnitBuilder>>;\n\n  /**\n   * Creates an empty simple sum type (no cases, equivalent to `never`).\n   * This can be useful for code generation or placeholder types.\n   * Example:\n   * ```ts\n   * t.enum(\"Never\", []);\n   * ```\n   */\n  (name: string, cases: []): SimpleSumBuilderImpl<Record<never, UnitBuilder>>;\n\n  /**\n   * Creates a full sum type, where each case can have a payload.\n   * Each value in the object must be a {@link TypeBuilder}.\n   *\n   * Example:\n   * ```ts\n   * t.enum(\"Result\", { Ok: t.unit(), Err: t.string() });\n   * ```\n   */\n  <Obj extends VariantsObj>(name: string, obj: Obj): SumBuilder<Obj>;\n}\n\nconst enumImpl = ((nameOrObj: any, maybeObj?: any) => {\n  let obj: any = nameOrObj;\n  let name: string | undefined = undefined;\n\n  if (typeof nameOrObj === 'string') {\n    if (!maybeObj) {\n      throw new TypeError(\n        'When providing a name, you must also provide the variants object or array.'\n      );\n    }\n    obj = maybeObj;\n    name = nameOrObj;\n  }\n\n  // Simple sum (array form)\n  if (Array.isArray(obj)) {\n    const simpleVariantsObj: Record<string, UnitBuilder> = {};\n    for (const variant of obj) {\n      simpleVariantsObj[variant] = new UnitBuilder();\n    }\n    return new SimpleSumBuilderImpl(simpleVariantsObj, name);\n  }\n\n  // Regular sum (object form)\n  return new SumBuilder(obj, name);\n}) as EnumFn;\n\n/**\n * A collection of factory functions for creating various SpacetimeDB algebraic types\n * to be used in table definitions. Each function returns a corresponding builder\n * for a specific type, such as `BoolBuilder`, `StringBuilder`, or `F64Builder`.\n *\n * These builders are used to define the schema of tables in SpacetimeDB, and each\n * builder implements the {@link TypeBuilder} interface, allowing for type-safe\n * schema construction in TypeScript.\n *\n * @remarks\n * - Primitive types (e.g., `bool`, `string`, `number`) map to their respective TypeScript types.\n * - Integer and floating-point types (e.g., `i8`, `u64`, `f32`) are represented as `number` or `bigint` in TypeScript.\n * - Complex types such as `object`, `array`, and `enum` allow for nested and structured schemas.\n * - The `scheduleAt` builder is a special column type for scheduling.\n *\n * @see {@link TypeBuilder}\n */\nexport const t = {\n  /**\n   * Creates a new `Bool` {@link AlgebraicType} to be used in table definitions\n   * Represented as `boolean` in TypeScript.\n   * @returns A new {@link BoolBuilder} instance\n   */\n  bool: (): BoolBuilder => new BoolBuilder(),\n\n  /**\n   * Creates a new `String` {@link AlgebraicType} to be used in table definitions\n   * Represented as `string` in TypeScript.\n   * @returns A new {@link StringBuilder} instance\n   */\n  string: (): StringBuilder => new StringBuilder(),\n\n  /**\n   * Creates a new `F64` {@link AlgebraicType} to be used in table definitions\n   * Represented as `number` in TypeScript.\n   * @returns A new {@link F64Builder} instance\n   */\n  number: (): F64Builder => new F64Builder(),\n\n  /**\n   * Creates a new `I8` {@link AlgebraicType} to be used in table definitions\n   * Represented as `number` in TypeScript.\n   * @returns A new {@link I8Builder} instance\n   */\n  i8: (): I8Builder => new I8Builder(),\n\n  /**\n   * Creates a new `U8` {@link AlgebraicType} to be used in table definitions\n   * Represented as `number` in TypeScript.\n   * @returns A new {@link U8Builder} instance\n   */\n  u8: (): U8Builder => new U8Builder(),\n\n  /**\n   * Creates a new `I16` {@link AlgebraicType} to be used in table definitions\n   * Represented as `number` in TypeScript.\n   * @returns A new {@link I16Builder} instance\n   */\n  i16: (): I16Builder => new I16Builder(),\n\n  /**\n   * Creates a new `U16` {@link AlgebraicType} to be used in table definitions\n   * Represented as `number` in TypeScript.\n   * @returns A new {@link U16Builder} instance\n   */\n  u16: (): U16Builder => new U16Builder(),\n\n  /**\n   * Creates a new `I32` {@link AlgebraicType} to be used in table definitions\n   * Represented as `number` in TypeScript.\n   * @returns A new {@link I32Builder} instance\n   */\n  i32: (): I32Builder => new I32Builder(),\n\n  /**\n   * Creates a new `U32` {@link AlgebraicType} to be used in table definitions\n   * Represented as `number` in TypeScript.\n   * @returns A new {@link U32Builder} instance\n   */\n  u32: (): U32Builder => new U32Builder(),\n\n  /**\n   * Creates a new `I64` {@link AlgebraicType} to be used in table definitions\n   * Represented as `bigint` in TypeScript.\n   * @returns A new {@link I64Builder} instance\n   */\n  i64: (): I64Builder => new I64Builder(),\n\n  /**\n   * Creates a new `U64` {@link AlgebraicType} to be used in table definitions\n   * Represented as `bigint` in TypeScript.\n   * @returns A new {@link U64Builder} instance\n   */\n  u64: (): U64Builder => new U64Builder(),\n\n  /**\n   * Creates a new `I128` {@link AlgebraicType} to be used in table definitions\n   * Represented as `bigint` in TypeScript.\n   * @returns A new {@link I128Builder} instance\n   */\n  i128: (): I128Builder => new I128Builder(),\n\n  /**\n   * Creates a new `U128` {@link AlgebraicType} to be used in table definitions\n   * Represented as `bigint` in TypeScript.\n   * @returns A new {@link U128Builder} instance\n   */\n  u128: (): U128Builder => new U128Builder(),\n\n  /**\n   * Creates a new `I256` {@link AlgebraicType} to be used in table definitions\n   * Represented as `bigint` in TypeScript.\n   * @returns A new {@link I256Builder} instance\n   */\n  i256: (): I256Builder => new I256Builder(),\n\n  /**\n   * Creates a new `U256` {@link AlgebraicType} to be used in table definitions\n   * Represented as `bigint` in TypeScript.\n   * @returns A new {@link U256Builder} instance\n   */\n  u256: (): U256Builder => new U256Builder(),\n\n  /**\n   * Creates a new `F32` {@link AlgebraicType} to be used in table definitions\n   * Represented as `number` in TypeScript.\n   * @returns A new {@link F32Builder} instance\n   */\n  f32: (): F32Builder => new F32Builder(),\n\n  /**\n   * Creates a new `F64` {@link AlgebraicType} to be used in table definitions\n   * Represented as `number` in TypeScript.\n   * @returns A new {@link F64Builder} instance\n   */\n  f64: (): F64Builder => new F64Builder(),\n\n  /**\n   * Creates a new `Product` {@link AlgebraicType} to be used in table definitions. Product types in SpacetimeDB\n   * are essentially the same as objects in JavaScript/TypeScript.\n   * Properties of the object must also be {@link TypeBuilder}s.\n   * Represented as an object with specific properties in TypeScript.\n   *\n   * @param name (optional) A display name for the product type. If omitted, an anonymous product type is created.\n   * @param obj The object defining the properties of the type, whose property\n   * values must be {@link TypeBuilder}s.\n   * @returns A new {@link ProductBuilder} instance.\n   */\n  object: ((nameOrObj: any, maybeObj?: any) => {\n    if (typeof nameOrObj === 'string') {\n      if (!maybeObj) {\n        throw new TypeError(\n          'When providing a name, you must also provide the object.'\n        );\n      }\n      return new ProductBuilder(maybeObj, nameOrObj);\n    }\n    return new ProductBuilder(nameOrObj, undefined);\n  }) as {\n    <Obj extends ElementsObj>(name: string, obj: Obj): ProductBuilder<Obj>;\n    // TODO: Currently names are not optional\n    // <Obj extends ElementsObj>(obj: Obj): ProductBuilder<Obj>;\n  },\n\n  /**\n   * Creates a new `Row` {@link AlgebraicType} to be used in table definitions. Row types in SpacetimeDB\n   * are similar to `Product` types, but are specifically used to define the schema of a table row.\n   * Properties of the object must also be {@link TypeBuilder} or {@link ColumnBuilder}s.\n   *\n   * You can represent a `Row` as either a {@link RowObj} or an {@link RowBuilder} type when\n   * defining a table schema.\n   *\n   * The {@link RowBuilder} type is useful when you want to create a type which can be used anywhere\n   * a {@link TypeBuilder} is accepted, such as in nested objects or arrays, or as the argument\n   * to a scheduled function.\n   *\n   * @param obj The object defining the properties of the row, whose property\n   * values must be {@link TypeBuilder}s or {@link ColumnBuilder}s.\n   * @returns A new {@link RowBuilder} instance\n   */\n  row: (<Obj extends RowObj>(\n    nameOrObj: string | Obj,\n    maybeObj?: Obj\n  ): RowBuilder<Obj> => {\n    const [obj, name] =\n      typeof nameOrObj === 'string'\n        ? [maybeObj!, nameOrObj]\n        : [nameOrObj, undefined];\n    return new RowBuilder(obj, name);\n  }) as {\n    <Obj extends RowObj>(obj: Obj): RowBuilder<Obj>;\n    <Obj extends RowObj>(name: string, obj: Obj): RowBuilder<Obj>;\n  },\n\n  /**\n   * Creates a new `Array` {@link AlgebraicType} to be used in table definitions.\n   * Represented as an array in TypeScript.\n   * @param element The element type of the array, which must be a `TypeBuilder`.\n   * @returns A new {@link ArrayBuilder} instance\n   */\n  array<Element extends TypeBuilder<any, any>>(\n    e: Element\n  ): ArrayBuilder<Element> {\n    return new ArrayBuilder(e);\n  },\n\n  enum: enumImpl,\n\n  /**\n   * This is a special helper function for conveniently creating {@link Product} type columns with no fields.\n   *\n   * @returns A new {@link ProductBuilder} instance with no fields.\n   */\n  unit(): UnitBuilder {\n    return new UnitBuilder();\n  },\n\n  /**\n   * Creates a lazily-evaluated {@link TypeBuilder}. This is useful for creating\n   * recursive types, such as a tree or linked list.\n   * @param thunk A function that returns a {@link TypeBuilder}.\n   * @returns A proxy {@link TypeBuilder} that evaluates the thunk on first access.\n   */\n  lazy<Build extends () => TypeBuilder<any, any>>(\n    thunk: Build\n  ): ReturnType<Build> {\n    type B = ReturnType<Build>;\n    let cached: B | null = null;\n    const get = (): B => (cached ??= thunk() as B);\n\n    const proxy = new Proxy({} as unknown as B, {\n      get(_t, prop, recv) {\n        const target = get() as any;\n        const val = Reflect.get(target, prop, recv);\n        return typeof val === 'function' ? val.bind(target) : val;\n      },\n      set(_t, prop, value, recv) {\n        return Reflect.set(get() as any, prop, value, recv);\n      },\n      has(_t, prop) {\n        return prop in (get() as any);\n      },\n      ownKeys() {\n        return Reflect.ownKeys(get() as any);\n      },\n      getOwnPropertyDescriptor(_t, prop) {\n        return Object.getOwnPropertyDescriptor(get() as any, prop);\n      },\n      getPrototypeOf() {\n        // makes `instanceof TypeBuilder` work if you care about it\n        return Object.getPrototypeOf(get() as any);\n      },\n    }) as B;\n\n    return proxy;\n  },\n\n  /**\n   * This is a special helper function for conveniently creating {@link ScheduleAt} type columns.\n   * @returns A new ColumnBuilder instance with the {@link ScheduleAt} type.\n   */\n  scheduleAt: (): ScheduleAtBuilder => {\n    return new ScheduleAtBuilder();\n  },\n\n  /**\n   * This is a convenience method for creating a column with the {@link Option} type.\n   * You can create a column of the same type by constructing an enum with a `some` and `none` variant.\n   * @param value The type of the value contained in the `some` variant of the `Option`.\n   * @returns A new {@link OptionBuilder} instance with the {@link Option} type.\n   */\n  option<Value extends TypeBuilder<any, any>>(\n    value: Value\n  ): OptionBuilder<Value> {\n    return new OptionBuilder(value);\n  },\n\n  /**\n   * This is a convenience method for creating a column with the {@link Result} type.\n   * You can create a column of the same type by constructing an enum with an `ok` and `err` variant.\n   * @param ok The type of the value contained in the `ok` variant of the `Result`.\n   * @param err The type of the value contained in the `err` variant of the `Result`.\n   * @returns A new {@link ResultBuilder} instance with the {@link Result} type.\n   */\n  result<Ok extends TypeBuilder<any, any>, Err extends TypeBuilder<any, any>>(\n    ok: Ok,\n    err: Err\n  ): ResultBuilder<Ok, Err> {\n    return new ResultBuilder(ok, err);\n  },\n\n  /**\n   * This is a convenience method for creating a column with the {@link Identity} type.\n   * You can create a column of the same type by constructing an `object` with a single `__identity__` element.\n   * @returns A new {@link TypeBuilder} instance with the {@link Identity} type.\n   */\n  identity: (): IdentityBuilder => {\n    return new IdentityBuilder();\n  },\n\n  /**\n   * This is a convenience method for creating a column with the {@link ConnectionId} type.\n   * You can create a column of the same type by constructing an `object` with a single `__connection_id__` element.\n   * @returns A new {@link TypeBuilder} instance with the {@link ConnectionId} type.\n   */\n  connectionId: (): ConnectionIdBuilder => {\n    return new ConnectionIdBuilder();\n  },\n\n  /**\n   * This is a convenience method for creating a column with the {@link Timestamp} type.\n   * You can create a column of the same type by constructing an `object` with a single `__timestamp_micros_since_unix_epoch__` element.\n   * @returns A new {@link TypeBuilder} instance with the {@link Timestamp} type.\n   */\n  timestamp: (): TimestampBuilder => {\n    return new TimestampBuilder();\n  },\n\n  /**\n   * This is a convenience method for creating a column with the {@link TimeDuration} type.\n   * You can create a column of the same type by constructing an `object` with a single `__time_duration_micros__` element.\n   * @returns A new {@link TypeBuilder} instance with the {@link TimeDuration} type.\n   */\n  timeDuration: (): TimeDurationBuilder => {\n    return new TimeDurationBuilder();\n  },\n\n  /**\n   * This is a convenience method for creating a column with the {@link Uuid} type.\n   * You can create a column of the same type by constructing an `object` with a single `__uuid__` element.\n   * @returns A new {@link TypeBuilder} instance with the {@link Uuid} type.\n   */\n  uuid: (): UuidBuilder => {\n    return new UuidBuilder();\n  },\n\n  /**\n   * This is a convenience method for creating a column with the {@link ByteArray} type.\n   * You can create a column of the same type by constructing an `array` of `u8`.\n   * The TypeScript representation is {@link Uint8Array}.\n   * @returns A new {@link ByteArrayBuilder} instance with the {@link ByteArray} type.\n   */\n  byteArray: (): ByteArrayBuilder => {\n    return new ByteArrayBuilder();\n  },\n} as const;\nexport default t;\n","// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE\n// WILL NOT BE SAVED. MODIFY TABLES IN YOUR MODULE SOURCE CODE INSTEAD.\n\n/* eslint-disable */\n/* tslint:disable */\nimport {\n  TypeBuilder as __TypeBuilder,\n  t as __t,\n  type AlgebraicTypeType as __AlgebraicTypeType,\n  type Infer as __Infer,\n} from '../../lib/type_builders';\n\n// The tagged union or sum type for the algebraic type `RowSizeHint`.\nconst RowSizeHint = __t.enum('RowSizeHint', {\n  FixedSize: __t.u16(),\n  RowOffsets: __t.array(__t.u64()),\n});\n\nexport default RowSizeHint;\n","// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE\n// WILL NOT BE SAVED. MODIFY TABLES IN YOUR MODULE SOURCE CODE INSTEAD.\n\n/* eslint-disable */\n/* tslint:disable */\nimport {\n  TypeBuilder as __TypeBuilder,\n  t as __t,\n  type AlgebraicTypeType as __AlgebraicTypeType,\n  type Infer as __Infer,\n} from '../../lib/type_builders';\nimport RowSizeHint from './row_size_hint_type';\n\nexport default __t.object('BsatnRowList', {\n  get sizeHint() {\n    return RowSizeHint;\n  },\n  rowsData: __t.byteArray(),\n});\n","// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE\n// WILL NOT BE SAVED. MODIFY TABLES IN YOUR MODULE SOURCE CODE INSTEAD.\n\n/* eslint-disable */\n/* tslint:disable */\nimport {\n  TypeBuilder as __TypeBuilder,\n  t as __t,\n  type AlgebraicTypeType as __AlgebraicTypeType,\n  type Infer as __Infer,\n} from '../../lib/type_builders';\n\nexport default __t.object('CallReducer', {\n  reducer: __t.string(),\n  args: __t.byteArray(),\n  requestId: __t.u32(),\n  flags: __t.u8(),\n});\n","// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE\n// WILL NOT BE SAVED. MODIFY TABLES IN YOUR MODULE SOURCE CODE INSTEAD.\n\n/* eslint-disable */\n/* tslint:disable */\nimport {\n  TypeBuilder as __TypeBuilder,\n  t as __t,\n  type AlgebraicTypeType as __AlgebraicTypeType,\n  type Infer as __Infer,\n} from '../../lib/type_builders';\n\nexport default __t.object('Subscribe', {\n  queryStrings: __t.array(__t.string()),\n  requestId: __t.u32(),\n});\n","// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE\n// WILL NOT BE SAVED. MODIFY TABLES IN YOUR MODULE SOURCE CODE INSTEAD.\n\n/* eslint-disable */\n/* tslint:disable */\nimport {\n  TypeBuilder as __TypeBuilder,\n  t as __t,\n  type AlgebraicTypeType as __AlgebraicTypeType,\n  type Infer as __Infer,\n} from '../../lib/type_builders';\n\nexport default __t.object('OneOffQuery', {\n  messageId: __t.byteArray(),\n  queryString: __t.string(),\n});\n","// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE\n// WILL NOT BE SAVED. MODIFY TABLES IN YOUR MODULE SOURCE CODE INSTEAD.\n\n/* eslint-disable */\n/* tslint:disable */\nimport {\n  TypeBuilder as __TypeBuilder,\n  t as __t,\n  type AlgebraicTypeType as __AlgebraicTypeType,\n  type Infer as __Infer,\n} from '../../lib/type_builders';\n\nexport default __t.object('QueryId', {\n  id: __t.u32(),\n});\n","// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE\n// WILL NOT BE SAVED. MODIFY TABLES IN YOUR MODULE SOURCE CODE INSTEAD.\n\n/* eslint-disable */\n/* tslint:disable */\nimport {\n  TypeBuilder as __TypeBuilder,\n  t as __t,\n  type AlgebraicTypeType as __AlgebraicTypeType,\n  type Infer as __Infer,\n} from '../../lib/type_builders';\nimport QueryId from './query_id_type';\n\nexport default __t.object('SubscribeSingle', {\n  query: __t.string(),\n  requestId: __t.u32(),\n  get queryId() {\n    return QueryId;\n  },\n});\n","// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE\n// WILL NOT BE SAVED. MODIFY TABLES IN YOUR MODULE SOURCE CODE INSTEAD.\n\n/* eslint-disable */\n/* tslint:disable */\nimport {\n  TypeBuilder as __TypeBuilder,\n  t as __t,\n  type AlgebraicTypeType as __AlgebraicTypeType,\n  type Infer as __Infer,\n} from '../../lib/type_builders';\nimport QueryId from './query_id_type';\n\nexport default __t.object('SubscribeMulti', {\n  queryStrings: __t.array(__t.string()),\n  requestId: __t.u32(),\n  get queryId() {\n    return QueryId;\n  },\n});\n","// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE\n// WILL NOT BE SAVED. MODIFY TABLES IN YOUR MODULE SOURCE CODE INSTEAD.\n\n/* eslint-disable */\n/* tslint:disable */\nimport {\n  TypeBuilder as __TypeBuilder,\n  t as __t,\n  type AlgebraicTypeType as __AlgebraicTypeType,\n  type Infer as __Infer,\n} from '../../lib/type_builders';\nimport QueryId from './query_id_type';\n\nexport default __t.object('Unsubscribe', {\n  requestId: __t.u32(),\n  get queryId() {\n    return QueryId;\n  },\n});\n","// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE\n// WILL NOT BE SAVED. MODIFY TABLES IN YOUR MODULE SOURCE CODE INSTEAD.\n\n/* eslint-disable */\n/* tslint:disable */\nimport {\n  TypeBuilder as __TypeBuilder,\n  t as __t,\n  type AlgebraicTypeType as __AlgebraicTypeType,\n  type Infer as __Infer,\n} from '../../lib/type_builders';\nimport QueryId from './query_id_type';\n\nexport default __t.object('UnsubscribeMulti', {\n  requestId: __t.u32(),\n  get queryId() {\n    return QueryId;\n  },\n});\n","// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE\n// WILL NOT BE SAVED. MODIFY TABLES IN YOUR MODULE SOURCE CODE INSTEAD.\n\n/* eslint-disable */\n/* tslint:disable */\nimport {\n  TypeBuilder as __TypeBuilder,\n  t as __t,\n  type AlgebraicTypeType as __AlgebraicTypeType,\n  type Infer as __Infer,\n} from '../../lib/type_builders';\n\nexport default __t.object('CallProcedure', {\n  procedure: __t.string(),\n  args: __t.byteArray(),\n  requestId: __t.u32(),\n  flags: __t.u8(),\n});\n","// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE\n// WILL NOT BE SAVED. MODIFY TABLES IN YOUR MODULE SOURCE CODE INSTEAD.\n\n/* eslint-disable */\n/* tslint:disable */\nimport {\n  TypeBuilder as __TypeBuilder,\n  t as __t,\n  type AlgebraicTypeType as __AlgebraicTypeType,\n  type Infer as __Infer,\n} from '../../lib/type_builders';\nimport CallReducer from './call_reducer_type';\nimport Subscribe from './subscribe_type';\nimport OneOffQuery from './one_off_query_type';\nimport SubscribeSingle from './subscribe_single_type';\nimport SubscribeMulti from './subscribe_multi_type';\nimport Unsubscribe from './unsubscribe_type';\nimport UnsubscribeMulti from './unsubscribe_multi_type';\nimport CallProcedure from './call_procedure_type';\n\n// The tagged union or sum type for the algebraic type `ClientMessage`.\nconst ClientMessage = __t.enum('ClientMessage', {\n  get CallReducer() {\n    return CallReducer;\n  },\n  get Subscribe() {\n    return Subscribe;\n  },\n  get OneOffQuery() {\n    return OneOffQuery;\n  },\n  get SubscribeSingle() {\n    return SubscribeSingle;\n  },\n  get SubscribeMulti() {\n    return SubscribeMulti;\n  },\n  get Unsubscribe() {\n    return Unsubscribe;\n  },\n  get UnsubscribeMulti() {\n    return UnsubscribeMulti;\n  },\n  get CallProcedure() {\n    return CallProcedure;\n  },\n});\n\nexport default ClientMessage;\n","// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE\n// WILL NOT BE SAVED. MODIFY TABLES IN YOUR MODULE SOURCE CODE INSTEAD.\n\n/* eslint-disable */\n/* tslint:disable */\nimport {\n  TypeBuilder as __TypeBuilder,\n  t as __t,\n  type AlgebraicTypeType as __AlgebraicTypeType,\n  type Infer as __Infer,\n} from '../../lib/type_builders';\nimport BsatnRowList from './bsatn_row_list_type';\n\nexport default __t.object('QueryUpdate', {\n  get deletes() {\n    return BsatnRowList;\n  },\n  get inserts() {\n    return BsatnRowList;\n  },\n});\n","// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE\n// WILL NOT BE SAVED. MODIFY TABLES IN YOUR MODULE SOURCE CODE INSTEAD.\n\n/* eslint-disable */\n/* tslint:disable */\nimport {\n  TypeBuilder as __TypeBuilder,\n  t as __t,\n  type AlgebraicTypeType as __AlgebraicTypeType,\n  type Infer as __Infer,\n} from '../../lib/type_builders';\nimport QueryUpdate from './query_update_type';\n\n// The tagged union or sum type for the algebraic type `CompressableQueryUpdate`.\nconst CompressableQueryUpdate = __t.enum('CompressableQueryUpdate', {\n  get Uncompressed() {\n    return QueryUpdate;\n  },\n  Brotli: __t.byteArray(),\n  Gzip: __t.byteArray(),\n});\n\nexport default CompressableQueryUpdate;\n","// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE\n// WILL NOT BE SAVED. MODIFY TABLES IN YOUR MODULE SOURCE CODE INSTEAD.\n\n/* eslint-disable */\n/* tslint:disable */\nimport {\n  TypeBuilder as __TypeBuilder,\n  t as __t,\n  type AlgebraicTypeType as __AlgebraicTypeType,\n  type Infer as __Infer,\n} from '../../lib/type_builders';\nimport CompressableQueryUpdate from './compressable_query_update_type';\n\nexport default __t.object('TableUpdate', {\n  tableId: __t.u32(),\n  tableName: __t.string(),\n  numRows: __t.u64(),\n  get updates() {\n    return __t.array(CompressableQueryUpdate);\n  },\n});\n","// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE\n// WILL NOT BE SAVED. MODIFY TABLES IN YOUR MODULE SOURCE CODE INSTEAD.\n\n/* eslint-disable */\n/* tslint:disable */\nimport {\n  TypeBuilder as __TypeBuilder,\n  t as __t,\n  type AlgebraicTypeType as __AlgebraicTypeType,\n  type Infer as __Infer,\n} from '../../lib/type_builders';\nimport TableUpdate from './table_update_type';\n\nexport default __t.object('DatabaseUpdate', {\n  get tables() {\n    return __t.array(TableUpdate);\n  },\n});\n","// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE\n// WILL NOT BE SAVED. MODIFY TABLES IN YOUR MODULE SOURCE CODE INSTEAD.\n\n/* eslint-disable */\n/* tslint:disable */\nimport {\n  TypeBuilder as __TypeBuilder,\n  t as __t,\n  type AlgebraicTypeType as __AlgebraicTypeType,\n  type Infer as __Infer,\n} from '../../lib/type_builders';\nimport DatabaseUpdate from './database_update_type';\n\nexport default __t.object('InitialSubscription', {\n  get databaseUpdate() {\n    return DatabaseUpdate;\n  },\n  requestId: __t.u32(),\n  totalHostExecutionDuration: __t.timeDuration(),\n});\n","// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE\n// WILL NOT BE SAVED. MODIFY TABLES IN YOUR MODULE SOURCE CODE INSTEAD.\n\n/* eslint-disable */\n/* tslint:disable */\nimport {\n  TypeBuilder as __TypeBuilder,\n  t as __t,\n  type AlgebraicTypeType as __AlgebraicTypeType,\n  type Infer as __Infer,\n} from '../../lib/type_builders';\nimport DatabaseUpdate from './database_update_type';\n\n// The tagged union or sum type for the algebraic type `UpdateStatus`.\nconst UpdateStatus = __t.enum('UpdateStatus', {\n  get Committed() {\n    return DatabaseUpdate;\n  },\n  Failed: __t.string(),\n  OutOfEnergy: __t.unit(),\n});\n\nexport default UpdateStatus;\n","// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE\n// WILL NOT BE SAVED. MODIFY TABLES IN YOUR MODULE SOURCE CODE INSTEAD.\n\n/* eslint-disable */\n/* tslint:disable */\nimport {\n  TypeBuilder as __TypeBuilder,\n  t as __t,\n  type AlgebraicTypeType as __AlgebraicTypeType,\n  type Infer as __Infer,\n} from '../../lib/type_builders';\n\nexport default __t.object('ReducerCallInfo', {\n  reducerName: __t.string(),\n  reducerId: __t.u32(),\n  args: __t.byteArray(),\n  requestId: __t.u32(),\n});\n","// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE\n// WILL NOT BE SAVED. MODIFY TABLES IN YOUR MODULE SOURCE CODE INSTEAD.\n\n/* eslint-disable */\n/* tslint:disable */\nimport {\n  TypeBuilder as __TypeBuilder,\n  t as __t,\n  type AlgebraicTypeType as __AlgebraicTypeType,\n  type Infer as __Infer,\n} from '../../lib/type_builders';\n\nexport default __t.object('EnergyQuanta', {\n  quanta: __t.u128(),\n});\n","// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE\n// WILL NOT BE SAVED. MODIFY TABLES IN YOUR MODULE SOURCE CODE INSTEAD.\n\n/* eslint-disable */\n/* tslint:disable */\nimport {\n  TypeBuilder as __TypeBuilder,\n  t as __t,\n  type AlgebraicTypeType as __AlgebraicTypeType,\n  type Infer as __Infer,\n} from '../../lib/type_builders';\nimport UpdateStatus from './update_status_type';\nimport ReducerCallInfo from './reducer_call_info_type';\nimport EnergyQuanta from './energy_quanta_type';\n\nexport default __t.object('TransactionUpdate', {\n  get status() {\n    return UpdateStatus;\n  },\n  timestamp: __t.timestamp(),\n  callerIdentity: __t.identity(),\n  callerConnectionId: __t.connectionId(),\n  get reducerCall() {\n    return ReducerCallInfo;\n  },\n  get energyQuantaUsed() {\n    return EnergyQuanta;\n  },\n  totalHostExecutionDuration: __t.timeDuration(),\n});\n","// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE\n// WILL NOT BE SAVED. MODIFY TABLES IN YOUR MODULE SOURCE CODE INSTEAD.\n\n/* eslint-disable */\n/* tslint:disable */\nimport {\n  TypeBuilder as __TypeBuilder,\n  t as __t,\n  type AlgebraicTypeType as __AlgebraicTypeType,\n  type Infer as __Infer,\n} from '../../lib/type_builders';\nimport DatabaseUpdate from './database_update_type';\n\nexport default __t.object('TransactionUpdateLight', {\n  requestId: __t.u32(),\n  get update() {\n    return DatabaseUpdate;\n  },\n});\n","// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE\n// WILL NOT BE SAVED. MODIFY TABLES IN YOUR MODULE SOURCE CODE INSTEAD.\n\n/* eslint-disable */\n/* tslint:disable */\nimport {\n  TypeBuilder as __TypeBuilder,\n  t as __t,\n  type AlgebraicTypeType as __AlgebraicTypeType,\n  type Infer as __Infer,\n} from '../../lib/type_builders';\n\nexport default __t.object('IdentityToken', {\n  identity: __t.identity(),\n  token: __t.string(),\n  connectionId: __t.connectionId(),\n});\n","// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE\n// WILL NOT BE SAVED. MODIFY TABLES IN YOUR MODULE SOURCE CODE INSTEAD.\n\n/* eslint-disable */\n/* tslint:disable */\nimport {\n  TypeBuilder as __TypeBuilder,\n  t as __t,\n  type AlgebraicTypeType as __AlgebraicTypeType,\n  type Infer as __Infer,\n} from '../../lib/type_builders';\nimport BsatnRowList from './bsatn_row_list_type';\n\nexport default __t.object('OneOffTable', {\n  tableName: __t.string(),\n  get rows() {\n    return BsatnRowList;\n  },\n});\n","// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE\n// WILL NOT BE SAVED. MODIFY TABLES IN YOUR MODULE SOURCE CODE INSTEAD.\n\n/* eslint-disable */\n/* tslint:disable */\nimport {\n  TypeBuilder as __TypeBuilder,\n  t as __t,\n  type AlgebraicTypeType as __AlgebraicTypeType,\n  type Infer as __Infer,\n} from '../../lib/type_builders';\nimport OneOffTable from './one_off_table_type';\n\nexport default __t.object('OneOffQueryResponse', {\n  messageId: __t.byteArray(),\n  error: __t.option(__t.string()),\n  get tables() {\n    return __t.array(OneOffTable);\n  },\n  totalHostExecutionDuration: __t.timeDuration(),\n});\n","// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE\n// WILL NOT BE SAVED. MODIFY TABLES IN YOUR MODULE SOURCE CODE INSTEAD.\n\n/* eslint-disable */\n/* tslint:disable */\nimport {\n  TypeBuilder as __TypeBuilder,\n  t as __t,\n  type AlgebraicTypeType as __AlgebraicTypeType,\n  type Infer as __Infer,\n} from '../../lib/type_builders';\nimport TableUpdate from './table_update_type';\n\nexport default __t.object('SubscribeRows', {\n  tableId: __t.u32(),\n  tableName: __t.string(),\n  get tableRows() {\n    return TableUpdate;\n  },\n});\n","// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE\n// WILL NOT BE SAVED. MODIFY TABLES IN YOUR MODULE SOURCE CODE INSTEAD.\n\n/* eslint-disable */\n/* tslint:disable */\nimport {\n  TypeBuilder as __TypeBuilder,\n  t as __t,\n  type AlgebraicTypeType as __AlgebraicTypeType,\n  type Infer as __Infer,\n} from '../../lib/type_builders';\nimport QueryId from './query_id_type';\nimport SubscribeRows from './subscribe_rows_type';\n\nexport default __t.object('SubscribeApplied', {\n  requestId: __t.u32(),\n  totalHostExecutionDurationMicros: __t.u64(),\n  get queryId() {\n    return QueryId;\n  },\n  get rows() {\n    return SubscribeRows;\n  },\n});\n","// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE\n// WILL NOT BE SAVED. MODIFY TABLES IN YOUR MODULE SOURCE CODE INSTEAD.\n\n/* eslint-disable */\n/* tslint:disable */\nimport {\n  TypeBuilder as __TypeBuilder,\n  t as __t,\n  type AlgebraicTypeType as __AlgebraicTypeType,\n  type Infer as __Infer,\n} from '../../lib/type_builders';\nimport QueryId from './query_id_type';\nimport SubscribeRows from './subscribe_rows_type';\n\nexport default __t.object('UnsubscribeApplied', {\n  requestId: __t.u32(),\n  totalHostExecutionDurationMicros: __t.u64(),\n  get queryId() {\n    return QueryId;\n  },\n  get rows() {\n    return SubscribeRows;\n  },\n});\n","// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE\n// WILL NOT BE SAVED. MODIFY TABLES IN YOUR MODULE SOURCE CODE INSTEAD.\n\n/* eslint-disable */\n/* tslint:disable */\nimport {\n  TypeBuilder as __TypeBuilder,\n  t as __t,\n  type AlgebraicTypeType as __AlgebraicTypeType,\n  type Infer as __Infer,\n} from '../../lib/type_builders';\n\nexport default __t.object('SubscriptionError', {\n  totalHostExecutionDurationMicros: __t.u64(),\n  requestId: __t.option(__t.u32()),\n  queryId: __t.option(__t.u32()),\n  tableId: __t.option(__t.u32()),\n  error: __t.string(),\n});\n","// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE\n// WILL NOT BE SAVED. MODIFY TABLES IN YOUR MODULE SOURCE CODE INSTEAD.\n\n/* eslint-disable */\n/* tslint:disable */\nimport {\n  TypeBuilder as __TypeBuilder,\n  t as __t,\n  type AlgebraicTypeType as __AlgebraicTypeType,\n  type Infer as __Infer,\n} from '../../lib/type_builders';\nimport QueryId from './query_id_type';\nimport DatabaseUpdate from './database_update_type';\n\nexport default __t.object('SubscribeMultiApplied', {\n  requestId: __t.u32(),\n  totalHostExecutionDurationMicros: __t.u64(),\n  get queryId() {\n    return QueryId;\n  },\n  get update() {\n    return DatabaseUpdate;\n  },\n});\n","// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE\n// WILL NOT BE SAVED. MODIFY TABLES IN YOUR MODULE SOURCE CODE INSTEAD.\n\n/* eslint-disable */\n/* tslint:disable */\nimport {\n  TypeBuilder as __TypeBuilder,\n  t as __t,\n  type AlgebraicTypeType as __AlgebraicTypeType,\n  type Infer as __Infer,\n} from '../../lib/type_builders';\nimport QueryId from './query_id_type';\nimport DatabaseUpdate from './database_update_type';\n\nexport default __t.object('UnsubscribeMultiApplied', {\n  requestId: __t.u32(),\n  totalHostExecutionDurationMicros: __t.u64(),\n  get queryId() {\n    return QueryId;\n  },\n  get update() {\n    return DatabaseUpdate;\n  },\n});\n","// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE\n// WILL NOT BE SAVED. MODIFY TABLES IN YOUR MODULE SOURCE CODE INSTEAD.\n\n/* eslint-disable */\n/* tslint:disable */\nimport {\n  TypeBuilder as __TypeBuilder,\n  t as __t,\n  type AlgebraicTypeType as __AlgebraicTypeType,\n  type Infer as __Infer,\n} from '../../lib/type_builders';\n\n// The tagged union or sum type for the algebraic type `ProcedureStatus`.\nconst ProcedureStatus = __t.enum('ProcedureStatus', {\n  Returned: __t.byteArray(),\n  OutOfEnergy: __t.unit(),\n  InternalError: __t.string(),\n});\n\nexport default ProcedureStatus;\n","// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE\n// WILL NOT BE SAVED. MODIFY TABLES IN YOUR MODULE SOURCE CODE INSTEAD.\n\n/* eslint-disable */\n/* tslint:disable */\nimport {\n  TypeBuilder as __TypeBuilder,\n  t as __t,\n  type AlgebraicTypeType as __AlgebraicTypeType,\n  type Infer as __Infer,\n} from '../../lib/type_builders';\nimport ProcedureStatus from './procedure_status_type';\n\nexport default __t.object('ProcedureResult', {\n  get status() {\n    return ProcedureStatus;\n  },\n  timestamp: __t.timestamp(),\n  totalHostExecutionDuration: __t.timeDuration(),\n  requestId: __t.u32(),\n});\n","// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE\n// WILL NOT BE SAVED. MODIFY TABLES IN YOUR MODULE SOURCE CODE INSTEAD.\n\n/* eslint-disable */\n/* tslint:disable */\nimport {\n  TypeBuilder as __TypeBuilder,\n  t as __t,\n  type AlgebraicTypeType as __AlgebraicTypeType,\n  type Infer as __Infer,\n} from '../../lib/type_builders';\nimport InitialSubscription from './initial_subscription_type';\nimport TransactionUpdate from './transaction_update_type';\nimport TransactionUpdateLight from './transaction_update_light_type';\nimport IdentityToken from './identity_token_type';\nimport OneOffQueryResponse from './one_off_query_response_type';\nimport SubscribeApplied from './subscribe_applied_type';\nimport UnsubscribeApplied from './unsubscribe_applied_type';\nimport SubscriptionError from './subscription_error_type';\nimport SubscribeMultiApplied from './subscribe_multi_applied_type';\nimport UnsubscribeMultiApplied from './unsubscribe_multi_applied_type';\nimport ProcedureResult from './procedure_result_type';\n\n// The tagged union or sum type for the algebraic type `ServerMessage`.\nconst ServerMessage = __t.enum('ServerMessage', {\n  get InitialSubscription() {\n    return InitialSubscription;\n  },\n  get TransactionUpdate() {\n    return TransactionUpdate;\n  },\n  get TransactionUpdateLight() {\n    return TransactionUpdateLight;\n  },\n  get IdentityToken() {\n    return IdentityToken;\n  },\n  get OneOffQueryResponse() {\n    return OneOffQueryResponse;\n  },\n  get SubscribeApplied() {\n    return SubscribeApplied;\n  },\n  get UnsubscribeApplied() {\n    return UnsubscribeApplied;\n  },\n  get SubscriptionError() {\n    return SubscriptionError;\n  },\n  get SubscribeMultiApplied() {\n    return SubscribeMultiApplied;\n  },\n  get UnsubscribeMultiApplied() {\n    return UnsubscribeMultiApplied;\n  },\n  get ProcedureResult() {\n    return ProcedureResult;\n  },\n});\n\nexport default ServerMessage;\n","// eslint-disable-next-line @typescript-eslint/no-unsafe-function-type\nexport class EventEmitter<Key, Callback extends Function = Function> {\n  #events: Map<Key, Set<Callback>> = new Map();\n\n  on(event: Key, callback: Callback): void {\n    let callbacks = this.#events.get(event);\n    if (!callbacks) {\n      callbacks = new Set();\n      this.#events.set(event, callbacks);\n    }\n    callbacks.add(callback);\n  }\n\n  off(event: Key, callback: Callback): void {\n    const callbacks = this.#events.get(event);\n    if (!callbacks) {\n      return;\n    }\n    callbacks.delete(callback);\n  }\n\n  emit(event: Key, ...args: any[]): void {\n    const callbacks = this.#events.get(event);\n    if (!callbacks) {\n      return;\n    }\n\n    for (const callback of callbacks) {\n      callback(...args);\n    }\n  }\n}\n","type LogLevel = 'info' | 'warn' | 'error' | 'debug';\n\nconst LogLevelIdentifierIcon = {\n  component: '',\n  info: '',\n  warn: '',\n  error: '',\n  debug: '',\n};\n\nconst LogStyle = {\n  component:\n    'color: #fff; background-color: #8D6FDD; padding: 2px 5px; border-radius: 3px;',\n  info: 'color: #fff; background-color: #007bff; padding: 2px 5px; border-radius: 3px;',\n  warn: 'color: #fff; background-color: #ffc107; padding: 2px 5px; border-radius: 3px;',\n  error:\n    'color: #fff; background-color: #dc3545; padding: 2px 5px; border-radius: 3px;',\n  debug:\n    'color: #fff; background-color: #28a745; padding: 2px 5px; border-radius: 3px;',\n};\n\nconst LogTextStyle = {\n  component: 'color: #8D6FDD;',\n  info: 'color: #007bff;',\n  warn: 'color: #ffc107;',\n  error: 'color: #dc3545;',\n  debug: 'color: #28a745;',\n};\n\nexport const stdbLogger = (level: LogLevel, message: any): void => {\n  console.log(\n    `%c${LogLevelIdentifierIcon[level]} ${level.toUpperCase()}%c ${message}`,\n    LogStyle[level],\n    LogTextStyle[level]\n  );\n};\n","import { EventEmitter } from './event_emitter.ts';\n\nimport { stdbLogger } from './logger.ts';\nimport { deepEqual, type ComparablePrimitive } from '../';\nimport type { EventContextInterface, TableDefForTableName } from './index.ts';\nimport type { RowType, TableIndexes, UntypedTableDef } from '../lib/table.ts';\nimport type { ClientTableCoreImplementable } from './client_table.ts';\nimport type { UntypedRemoteModule } from './spacetime_module.ts';\nimport type { TableNamesOf } from '../lib/schema.ts';\nimport type {\n  ReadonlyIndex,\n  ReadonlyIndexes,\n  ReadonlyRangedIndex,\n  ReadonlyUniqueIndex,\n  UntypedIndex,\n} from '../lib/indexes.ts';\nimport type { Bound } from '../server/range.ts';\nimport type { Prettify } from '../lib/type_util.ts';\n\nexport type Operation<\n  RowType extends Record<string, any> = Record<string, any>,\n> = {\n  type: 'insert' | 'delete';\n  // For tables with a primary key, this is the primary key value, as a primitive or string.\n  // Otherwise, it is an encoding of the full row.\n  rowId: ComparablePrimitive;\n  row: RowType;\n};\n\nexport type TableUpdate<TableDef extends UntypedTableDef> = {\n  tableName: string;\n  operations: Operation<RowType<TableDef>>[];\n};\n\nexport type PendingCallback = {\n  type: 'insert' | 'delete' | 'update';\n  table: string;\n  cb: () => void;\n};\n\n// Strict scalar compare for index term values.\nconst scalarCompare = (x: any, y: any): number => {\n  if (x === y) return 0;\n  // Compare booleans/numbers/bigints/strings with JS ordering.\n  return x < y ? -1 : 1;\n};\n\nexport type TableIndexView<\n  RemoteModule extends UntypedRemoteModule,\n  TableName extends TableNamesOf<RemoteModule>,\n> = ReadonlyIndexes<\n  TableDefForTableName<RemoteModule, TableName>,\n  TableIndexes<TableDefForTableName<RemoteModule, TableName>>\n>;\n\nexport type TableCache<\n  RemoteModule extends UntypedRemoteModule,\n  TableName extends TableNamesOf<RemoteModule>,\n> = TableCacheImpl<RemoteModule, TableName> &\n  TableIndexView<RemoteModule, TableName>;\n\n/**\n * Builder to generate calls to query a `table` in the database\n */\nexport class TableCacheImpl<\n  RemoteModule extends UntypedRemoteModule,\n  TableName extends TableNamesOf<RemoteModule>,\n> implements ClientTableCoreImplementable<RemoteModule, TableName>\n{\n  private rows: Map<\n    ComparablePrimitive,\n    [RowType<TableDefForTableName<RemoteModule, TableName>>, number]\n  >;\n  private tableDef: TableDefForTableName<RemoteModule, TableName>;\n  private emitter: EventEmitter<'insert' | 'delete' | 'update'>;\n\n  /**\n   * @param name the table name\n   * @param primaryKeyCol column index designated as `#[primarykey]`\n   * @param primaryKey column name designated as `#[primarykey]`\n   * @param entityClass the entityClass\n   */\n  constructor(tableDef: TableDefForTableName<RemoteModule, TableName>) {\n    this.tableDef = tableDef;\n    this.rows = new Map();\n    this.emitter = new EventEmitter();\n    // Build indexes\n    const indexesDef = this.tableDef.indexes || [];\n    for (const idx of indexesDef) {\n      // TODO: don't do this. See comment in `tableToSchema` in `schema.ts`\n      const idxDef = idx as UntypedIndex<\n        keyof TableDefForTableName<RemoteModule, TableName>['columns'] & string\n      >;\n      const index = this.#makeReadonlyIndex(this.tableDef, idxDef);\n      (this as any)[idx.name!] = index;\n    }\n  }\n\n  // TODO: this just scans the whole table; we should build proper index structures\n  #makeReadonlyIndex<\n    I extends UntypedIndex<\n      keyof TableDefForTableName<RemoteModule, TableName>['columns'] & string\n    >,\n  >(\n    tableDef: TableDefForTableName<RemoteModule, TableName>,\n    idx: I\n  ): ReadonlyIndex<TableDefForTableName<RemoteModule, TableName>, I> {\n    type TableDef = TableDefForTableName<RemoteModule, TableName>;\n    type Row = Prettify<RowType<TableDef>>;\n\n    // We do not yet support non-btree indexes\n    if (idx.algorithm !== 'btree') {\n      throw new Error('Only btree indexes are supported in TableCacheImpl');\n    }\n\n    const columns = idx.columns;\n\n    // Extract the tuple key for this btree index (column order preserved)\n    const getKey = (row: Row): readonly unknown[] => columns.map(c => row[c]);\n\n    // The servers ranged scan fixes all prefix cols to equality and applies\n    // the bound only to the *last* term. We mirror that.\n    //\n    // rangeArg for multi-col index is:\n    //   [...prefixEqualValues, (lastTerm | Range<lastTerm>)]\n    //\n    // If only one element is provided, its the last term (scalar or Range).\n    const matchRange = (row: Row, rangeArg: any): boolean => {\n      const key = getKey(row);\n\n      // Normalize rangeArg into an array.\n      // With multi-col b-tree, IndexScanRangeBounds always yields at least one element.\n      const arr = Array.isArray(rangeArg) ? rangeArg : [rangeArg];\n\n      const prefixLen = Math.max(0, arr.length - 1);\n      // Check equality over the prefix (all but the last provided element)\n      for (let i = 0; i < prefixLen; i++) {\n        if (!deepEqual(key[i], arr[i])) return false;\n      }\n\n      const lastProvided = arr[arr.length - 1];\n      const kLast = key[prefixLen];\n\n      // If the last provided is a Range<T>, apply bounds; otherwise equality.\n      if (\n        lastProvided &&\n        typeof lastProvided === 'object' &&\n        'from' in lastProvided &&\n        'to' in lastProvided\n      ) {\n        // Range<T>\n        const from = lastProvided.from as Bound<any>;\n        const to = lastProvided.to as Bound<any>;\n\n        // Lower bound\n        if (from.tag !== 'unbounded') {\n          const c = scalarCompare(kLast, from.value);\n          if (c < 0) return false;\n          if (c === 0 && from.tag === 'excluded') return false;\n        }\n\n        // Upper bound\n        if (to.tag !== 'unbounded') {\n          const c = scalarCompare(kLast, to.value);\n          if (c > 0) return false;\n          if (c === 0 && to.tag === 'excluded') return false;\n        }\n\n        // All good on last term; any remaining columns (if any) are unconstrained,\n        // which matches server behavior for a prefix scan.\n        return true;\n      } else {\n        // Equality on the last provided element\n        if (!deepEqual(kLast, lastProvided)) return false;\n        // Any remaining columns are unconstrained (prefix equality only).\n        return true;\n      }\n    };\n\n    // An index is unique if it shares all columns with a unique constraint\n    const isUnique = tableDef.constraints.some(constraint => {\n      if (constraint.constraint !== 'unique') {\n        return false;\n      }\n      return deepEqual(constraint.columns, idx.columns);\n    });\n\n    // eslint-disable-next-line @typescript-eslint/no-this-alias\n    const self = this;\n    if (isUnique) {\n      const impl: ReadonlyUniqueIndex<TableDef, I> = {\n        find: (colVal: any): Row | null => {\n          // For unique btree, caller supplies the *full* key (tuple if multi-col).\n          const expected = Array.isArray(colVal) ? colVal : [colVal];\n          for (const row of self.iter()) {\n            if (deepEqual(getKey(row), expected)) return row;\n          }\n          return null;\n        },\n      };\n      return impl as ReadonlyIndex<TableDef, I>;\n    } else {\n      const impl: ReadonlyRangedIndex<TableDef, I> = {\n        *filter(range: any): IteratorObject<Row, undefined> {\n          for (const row of self.iter()) {\n            if (matchRange(row, range)) yield row;\n          }\n        },\n      };\n      return impl as ReadonlyIndex<TableDef, I>;\n    }\n  }\n\n  /**\n   * @returns number of rows in the table\n   */\n  count(): bigint {\n    return BigInt(this.rows.size);\n  }\n\n  /**\n   * @returns The values of the rows in the table\n   */\n  iter(): IteratorObject<\n    Prettify<RowType<TableDefForTableName<RemoteModule, TableName>>>,\n    undefined\n  > {\n    function* generator(\n      rows: Map<\n        ComparablePrimitive,\n        [RowType<TableDefForTableName<RemoteModule, TableName>>, number]\n      >\n    ): IteratorObject<\n      Prettify<RowType<TableDefForTableName<RemoteModule, TableName>>>,\n      undefined\n    > {\n      for (const [row] of rows.values()) {\n        yield row as Prettify<\n          RowType<TableDefForTableName<RemoteModule, TableName>>\n        >;\n      }\n    }\n    return generator(this.rows);\n  }\n\n  /**\n   * Allows iteration over the rows in the table\n   * @returns An iterator over the rows in the table\n   */\n  [Symbol.iterator](): IteratorObject<\n    Prettify<RowType<TableDefForTableName<RemoteModule, TableName>>>,\n    undefined\n  > {\n    return this.iter();\n  }\n\n  applyOperations = (\n    operations: Operation<\n      RowType<TableDefForTableName<RemoteModule, TableName>>\n    >[],\n    ctx: EventContextInterface<RemoteModule>\n  ): PendingCallback[] => {\n    const pendingCallbacks: PendingCallback[] = [];\n    // TODO: performance\n    const hasPrimaryKey = Object.values(this.tableDef.columns).some(\n      col => col.columnMetadata.isPrimaryKey === true\n    );\n    if (hasPrimaryKey) {\n      const insertMap = new Map<\n        ComparablePrimitive,\n        [\n          Operation<RowType<TableDefForTableName<RemoteModule, TableName>>>,\n          number,\n        ]\n      >();\n      const deleteMap = new Map<\n        ComparablePrimitive,\n        [\n          Operation<RowType<TableDefForTableName<RemoteModule, TableName>>>,\n          number,\n        ]\n      >();\n      for (const op of operations) {\n        if (op.type === 'insert') {\n          const [_, prevCount] = insertMap.get(op.rowId) || [op, 0];\n          insertMap.set(op.rowId, [op, prevCount + 1]);\n        } else {\n          const [_, prevCount] = deleteMap.get(op.rowId) || [op, 0];\n          deleteMap.set(op.rowId, [op, prevCount + 1]);\n        }\n      }\n      for (const [primaryKey, [insertOp, refCount]] of insertMap) {\n        const deleteEntry = deleteMap.get(primaryKey);\n        if (deleteEntry) {\n          const [_, deleteCount] = deleteEntry;\n          // In most cases the refCountDelta will be either 0 or refCount, but if\n          // an update moves a row in or out of the result set of different queries, then\n          // other deltas are possible.\n          const refCountDelta = refCount - deleteCount;\n          const maybeCb = this.update(\n            ctx,\n            primaryKey,\n            insertOp.row,\n            refCountDelta\n          );\n          if (maybeCb) {\n            pendingCallbacks.push(maybeCb);\n          }\n          deleteMap.delete(primaryKey);\n        } else {\n          const maybeCb = this.insert(ctx, insertOp, refCount);\n          if (maybeCb) {\n            pendingCallbacks.push(maybeCb);\n          }\n        }\n      }\n      for (const [deleteOp, refCount] of deleteMap.values()) {\n        const maybeCb = this.delete(ctx, deleteOp, refCount);\n        if (maybeCb) {\n          pendingCallbacks.push(maybeCb);\n        }\n      }\n    } else {\n      for (const op of operations) {\n        if (op.type === 'insert') {\n          const maybeCb = this.insert(ctx, op);\n          if (maybeCb) {\n            pendingCallbacks.push(maybeCb);\n          }\n        } else {\n          const maybeCb = this.delete(ctx, op);\n          if (maybeCb) {\n            pendingCallbacks.push(maybeCb);\n          }\n        }\n      }\n    }\n    return pendingCallbacks;\n  };\n\n  update = (\n    ctx: EventContextInterface<RemoteModule>,\n    rowId: ComparablePrimitive,\n    newRow: RowType<TableDefForTableName<RemoteModule, TableName>>,\n    refCountDelta: number = 0\n  ): PendingCallback | undefined => {\n    const existingEntry = this.rows.get(rowId);\n    if (!existingEntry) {\n      // TODO: this should throw an error and kill the connection.\n      stdbLogger(\n        'error',\n        `Updating a row that was not present in the cache. Table: ${this.tableDef.name}, RowId: ${rowId}`\n      );\n      return undefined;\n    }\n    const [oldRow, previousCount] = existingEntry;\n    const refCount = Math.max(1, previousCount + refCountDelta);\n    if (previousCount + refCountDelta <= 0) {\n      stdbLogger(\n        'error',\n        `Negative reference count for in table ${this.tableDef.name} row ${rowId} (${previousCount} + ${refCountDelta})`\n      );\n      return undefined;\n    }\n    this.rows.set(rowId, [newRow, refCount]);\n    // This indicates something is wrong, so we could arguably crash here.\n    if (previousCount === 0) {\n      stdbLogger(\n        'error',\n        `Updating a row id in table ${this.tableDef.name} which was not present in the cache (rowId: ${rowId})`\n      );\n      return {\n        type: 'insert',\n        table: this.tableDef.name,\n        cb: () => {\n          this.emitter.emit('insert', ctx, newRow);\n        },\n      };\n    }\n    return {\n      type: 'update',\n      table: this.tableDef.name,\n      cb: () => {\n        this.emitter.emit('update', ctx, oldRow, newRow);\n      },\n    };\n  };\n\n  insert = (\n    ctx: EventContextInterface<RemoteModule>,\n    operation: Operation<\n      RowType<TableDefForTableName<RemoteModule, TableName>>\n    >,\n    count: number = 1\n  ): PendingCallback | undefined => {\n    const [_, previousCount] = this.rows.get(operation.rowId) || [\n      operation.row,\n      0,\n    ];\n    this.rows.set(operation.rowId, [operation.row, previousCount + count]);\n    if (previousCount === 0) {\n      return {\n        type: 'insert',\n        table: this.tableDef.name,\n        cb: () => {\n          this.emitter.emit('insert', ctx, operation.row);\n        },\n      };\n    }\n    // It's possible to get a duplicate insert because rows can be returned from multiple queries.\n    return undefined;\n  };\n\n  delete = (\n    ctx: EventContextInterface<RemoteModule>,\n    operation: Operation<\n      RowType<TableDefForTableName<RemoteModule, TableName>>\n    >,\n    count: number = 1\n  ): PendingCallback | undefined => {\n    const [_, previousCount] = this.rows.get(operation.rowId) || [\n      operation.row,\n      0,\n    ];\n    // This should never happen.\n    if (previousCount === 0) {\n      stdbLogger('warn', 'Deleting a row that was not present in the cache');\n      return undefined;\n    }\n    // If this was the last reference, we are actually deleting the row.\n    if (previousCount <= count) {\n      // TODO: Log a warning/error if previousCount is less than count.\n      this.rows.delete(operation.rowId);\n      return {\n        type: 'delete',\n        table: this.tableDef.name,\n        cb: () => {\n          this.emitter.emit('delete', ctx, operation.row);\n        },\n      };\n    }\n    this.rows.set(operation.rowId, [operation.row, previousCount - count]);\n    return undefined;\n  };\n\n  /**\n   * Register a callback for when a row is newly inserted into the database.\n   *\n   * ```ts\n   * ctx.db.user.onInsert((reducerEvent, user) => {\n   *   if (reducerEvent) {\n   *      console.log(\"New user on reducer\", reducerEvent, user);\n   *   } else {\n   *      console.log(\"New user received during subscription update on insert\", user);\n   *  }\n   * });\n   * ```\n   *\n   * @param cb Callback to be called when a new row is inserted\n   */\n  onInsert = (\n    cb: (\n      ctx: EventContextInterface<RemoteModule>,\n      row: Prettify<RowType<TableDefForTableName<RemoteModule, TableName>>>\n    ) => void\n  ): void => {\n    this.emitter.on('insert', cb);\n  };\n\n  /**\n   * Register a callback for when a row is deleted from the database.\n   *\n   * ```ts\n   * ctx.db.user.onDelete((reducerEvent, user) => {\n   *   if (reducerEvent) {\n   *      console.log(\"Deleted user on reducer\", reducerEvent, user);\n   *   } else {\n   *      console.log(\"Deleted user received during subscription update on update\", user);\n   *  }\n   * });\n   * ```\n   *\n   * @param cb Callback to be called when a new row is inserted\n   */\n  onDelete = (\n    cb: (\n      ctx: EventContextInterface<RemoteModule>,\n      row: Prettify<RowType<TableDefForTableName<RemoteModule, TableName>>>\n    ) => void\n  ): void => {\n    this.emitter.on('delete', cb);\n  };\n\n  /**\n   * Register a callback for when a row is updated into the database.\n   *\n   * ```ts\n   * ctx.db.user.onInsert((reducerEvent, oldUser, user) => {\n   *   if (reducerEvent) {\n   *      console.log(\"Updated user on reducer\", reducerEvent, user);\n   *   } else {\n   *      console.log(\"Updated user received during subscription update on delete\", user);\n   *  }\n   * });\n   * ```\n   *\n   * @param cb Callback to be called when a new row is inserted\n   */\n  onUpdate = (\n    cb: (\n      ctx: EventContextInterface<RemoteModule>,\n      oldRow: Prettify<RowType<TableDefForTableName<RemoteModule, TableName>>>,\n      row: Prettify<RowType<TableDefForTableName<RemoteModule, TableName>>>\n    ) => void\n  ): void => {\n    this.emitter.on('update', cb);\n  };\n\n  /**\n   * Remove a callback for when a row is newly inserted into the database.\n   *\n   * @param cb Callback to be removed\n   */\n  removeOnInsert = (\n    cb: (\n      ctx: EventContextInterface<RemoteModule>,\n      row: Prettify<RowType<TableDefForTableName<RemoteModule, TableName>>>\n    ) => void\n  ): void => {\n    this.emitter.off('insert', cb);\n  };\n\n  /**\n   * Remove a callback for when a row is deleted from the database.\n   *\n   * @param cb Callback to be removed\n   */\n  removeOnDelete = (\n    cb: (\n      ctx: EventContextInterface<RemoteModule>,\n      row: Prettify<RowType<TableDefForTableName<RemoteModule, TableName>>>\n    ) => void\n  ): void => {\n    this.emitter.off('delete', cb);\n  };\n\n  /**\n   * Remove a callback for when a row is updated into the database.\n   *\n   * @param cb Callback to be removed\n   */\n  removeOnUpdate = (\n    cb: (\n      ctx: EventContextInterface<RemoteModule>,\n      oldRow: Prettify<RowType<TableDefForTableName<RemoteModule, TableName>>>,\n      row: Prettify<RowType<TableDefForTableName<RemoteModule, TableName>>>\n    ) => void\n  ): void => {\n    this.emitter.off('update', cb);\n  };\n}\n","import type { TableNamesOf, UntypedSchemaDef } from '../lib/schema.ts';\nimport type { UntypedTableDef } from '../lib/table.ts';\nimport type { UntypedRemoteModule } from './spacetime_module.ts';\nimport { type TableCache, TableCacheImpl } from './table_cache.ts';\n\ntype TableName<SchemaDef> = [SchemaDef] extends [UntypedSchemaDef]\n  ? TableNamesOf<SchemaDef>\n  : string;\n\nexport type TableDefForTableName<\n  SchemaDef extends UntypedSchemaDef,\n  N extends TableName<SchemaDef>,\n> = [SchemaDef] extends [UntypedSchemaDef]\n  ? SchemaDef['tables'][number] & { name: N }\n  : UntypedTableDef;\n\ntype TableCacheForTableName<\n  RemoteModule extends UntypedRemoteModule,\n  TableName extends TableNamesOf<RemoteModule>,\n> = TableCache<RemoteModule, TableName>;\n\n/**\n * This is a helper class that provides a mapping from table names to their corresponding TableCache instances\n * while preserving the correspondence between the key and value type.\n */\nclass TableMap<RemoteModule extends UntypedRemoteModule> {\n  private readonly map: Map<\n    string,\n    TableCacheForTableName<RemoteModule, TableName<RemoteModule>>\n  > = new Map();\n\n  get<K extends TableName<RemoteModule>>(\n    key: K\n  ): TableCacheForTableName<RemoteModule, K> | undefined {\n    // Cast required: a Map<string, Union> can't refine the union to the exact K-specific member on get<K>(key: K).\n    return this.map.get(key) as\n      | TableCacheForTableName<RemoteModule, K>\n      | undefined;\n  }\n\n  set<K extends TableName<RemoteModule>>(\n    key: K,\n    value: TableCacheForTableName<RemoteModule, K>\n  ): this {\n    this.map.set(key, value);\n    return this;\n  }\n\n  has(key: TableName<RemoteModule>): boolean {\n    return this.map.has(key);\n  }\n\n  delete(key: TableName<RemoteModule>): boolean {\n    return this.map.delete(key);\n  }\n\n  // optional: iteration stays broadly typed (cannot express per-key relation here)\n  keys(): IterableIterator<string> {\n    return this.map.keys();\n  }\n  values(): IterableIterator<\n    TableCacheForTableName<RemoteModule, TableName<RemoteModule>>\n  > {\n    return this.map.values();\n  }\n  entries(): IterableIterator<\n    [string, TableCacheForTableName<RemoteModule, TableName<RemoteModule>>]\n  > {\n    return this.map.entries();\n  }\n  [Symbol.iterator]() {\n    return this.entries();\n  }\n}\n\n/**\n * ClientCache maintains a cache of TableCache instances for each table in the database.\n * It provides methods to get or create TableCache instances by table name,\n * ensuring type safety based on the provided SchemaDef.\n */\nexport class ClientCache<RemoteModule extends UntypedRemoteModule> {\n  /**\n   * The tables in the database.\n   */\n  readonly tables = new TableMap<RemoteModule>();\n\n  /**\n   * Returns the table with the given name.\n   * - If SchemaDef is a concrete schema, `name` is constrained to known table names,\n   *   and the return type matches that table.\n   * - If SchemaDef is undefined, `name` is string and the return type is untyped.\n   */\n  getTable<N extends TableName<RemoteModule>>(\n    name: N\n  ): TableCacheForTableName<RemoteModule, N> {\n    const table = this.tables.get(name);\n    if (!table) {\n      console.error(\n        'The table has not been registered for this client. Please register the table before using it. If you have registered global tables using the SpacetimeDBClient.registerTables() or `registerTable()` method, please make sure that is executed first!'\n      );\n      throw new Error(`Table ${String(name)} does not exist`);\n    }\n    return table;\n  }\n\n  /**\n   * Returns the table with the given name, creating it if needed.\n   * - Typed mode: `tableTypeInfo.tableName` is constrained to known names and\n   *   the return type matches that table.\n   * - Untyped mode: accepts any string and returns an untyped TableCache.\n   */\n  getOrCreateTable<N extends TableName<RemoteModule>>(\n    tableDef: TableDefForTableName<RemoteModule, N>\n  ): TableCacheForTableName<RemoteModule, N> {\n    const name = tableDef.name as N;\n\n    const table = this.tables.get(name);\n    if (table) {\n      return table;\n    }\n\n    const newTable = new TableCacheImpl<RemoteModule, N>(\n      tableDef\n    ) as TableCache<RemoteModule, N>;\n    this.tables.set(name, newTable);\n    return newTable;\n  }\n}\n","export type PrereleaseId = string | number;\n\nexport type PreRelease = PrereleaseId[];\n\n// Compare pre-release identifiers according to the semver spec (https://semver.org/#spec-item-11).\nfunction comparePreReleases(a: PreRelease, b: PreRelease): number {\n  const len = Math.min(a.length, b.length);\n  for (let i = 0; i < len; i++) {\n    const aPart = a[i];\n    const bPart = b[i];\n    if (aPart === bPart) continue;\n    if (typeof aPart === 'number' && typeof bPart === 'number') {\n      return aPart - bPart;\n    }\n    if (typeof aPart === 'string' && typeof bPart === 'string') {\n      return aPart.localeCompare(bPart);\n    }\n    // According to item 11.4.3, numeric identifiers always have lower precedence than non-numeric identifiers.\n    // So if `a` is a string, it has higher precedence than `b`.\n    return typeof aPart === 'string' ? 1 : -1;\n  }\n  // See rule 11.4.4 in the semver spec.\n  return a.length - b.length;\n}\n\n// We don't use these, and they don't matter for version ordering, so I'm not going to parse it to spec.\nexport type BuildInfo = string;\n\n// This is exported for tests.\nexport class SemanticVersion {\n  major: number;\n  minor: number;\n  patch: number;\n  preRelease: PreRelease | null;\n  buildInfo: BuildInfo | null;\n\n  constructor(\n    major: number,\n    minor: number,\n    patch: number,\n    preRelease: PreRelease | null = null,\n    buildInfo: BuildInfo | null = null\n  ) {\n    this.major = major;\n    this.minor = minor;\n    this.patch = patch;\n    this.preRelease = preRelease;\n    this.buildInfo = buildInfo;\n  }\n\n  toString(): string {\n    let versionString = `${this.major}.${this.minor}.${this.patch}`;\n    if (this.preRelease) {\n      versionString += `-${this.preRelease.join('.')}`;\n    }\n    if (this.buildInfo) {\n      versionString += `+${this.buildInfo}`;\n    }\n    return versionString;\n  }\n\n  compare(other: SemanticVersion): number {\n    if (this.major !== other.major) {\n      return this.major - other.major;\n    }\n    if (this.minor !== other.minor) {\n      return this.minor - other.minor;\n    }\n    if (this.patch !== other.patch) {\n      return this.patch - other.patch;\n    }\n    if (this.preRelease && other.preRelease) {\n      return comparePreReleases(this.preRelease, other.preRelease);\n    }\n    if (this.preRelease) {\n      return -1; // The version without a pre-release is greater.\n    }\n    if (other.preRelease) {\n      return -1; // Since we don't have a pre-release, this version is greater.\n    }\n    return 0; // versions are equal\n  }\n\n  clone(): SemanticVersion {\n    return new SemanticVersion(\n      this.major,\n      this.minor,\n      this.patch,\n      this.preRelease ? [...this.preRelease] : null,\n      this.buildInfo\n    );\n  }\n\n  static parseVersionString(version: string): SemanticVersion {\n    const regex =\n      /^(0|[1-9]\\d*)\\.(0|[1-9]\\d*)\\.(0|[1-9]\\d*)(?:-([\\da-zA-Z-]+(?:\\.[\\da-zA-Z-]+)*))?(?:\\+([\\da-zA-Z-]+(?:\\.[\\da-zA-Z-]+)*))?$/;\n    const match = version.match(regex);\n    if (!match) {\n      throw new Error(`Invalid version string: ${version}`);\n    }\n\n    const major = parseInt(match[1], 10);\n    const minor = parseInt(match[2], 10);\n    const patch = parseInt(match[3], 10);\n    const preRelease = match[4]\n      ? match[4].split('.').map(id => (isNaN(Number(id)) ? id : Number(id)))\n      : null;\n    const buildInfo = match[5] || null;\n\n    return new SemanticVersion(major, minor, patch, preRelease, buildInfo);\n  }\n}\n\n// The SDK depends on some module information that was not generated before this version.\nexport const _MINIMUM_CLI_VERSION: SemanticVersion = new SemanticVersion(\n  1,\n  4,\n  0\n);\n\nexport function ensureMinimumVersionOrThrow(versionString?: string): void {\n  if (versionString === undefined) {\n    throw new Error(versionErrorMessage(versionString));\n  }\n  const version = SemanticVersion.parseVersionString(versionString);\n  if (version.compare(_MINIMUM_CLI_VERSION) < 0) {\n    throw new Error(versionErrorMessage(versionString));\n  }\n}\n\nfunction versionErrorMessage(incompatibleVersion?: string): string {\n  return `Module code was generated with an incompatible version of the spacetimedb cli (${incompatibleVersion}). Update the cli version to at least ${_MINIMUM_CLI_VERSION.toString()} and regenerate the bindings. You can upgrade to the latest cli version by running: spacetime version upgrade`;\n}\n","export async function decompress(\n  buffer: Uint8Array,\n  // Leaving it here to expand to brotli when it lands in the browsers and NodeJS\n  type: 'gzip',\n  chunkSize: number = 128 * 1024 // 128KB\n): Promise<Uint8Array> {\n  // Create a single ReadableStream to handle chunks\n  let offset = 0;\n  const readableStream = new ReadableStream({\n    pull(controller) {\n      if (offset < buffer.length) {\n        // Slice a chunk of the buffer and enqueue it\n        const chunk = buffer.subarray(\n          offset,\n          Math.min(offset + chunkSize, buffer.length)\n        );\n        controller.enqueue(chunk);\n        offset += chunkSize;\n      } else {\n        controller.close();\n      }\n    },\n  });\n\n  // Create a single DecompressionStream\n  const decompressionStream = new DecompressionStream(type);\n\n  // Pipe the ReadableStream through the DecompressionStream\n  const decompressedStream = readableStream.pipeThrough(decompressionStream);\n\n  // Collect the decompressed chunks efficiently\n  const reader = decompressedStream.getReader();\n  const chunks: Uint8Array[] = [];\n  let totalLength = 0;\n  let result: any;\n\n  while (!(result = await reader.read()).done) {\n    chunks.push(result.value);\n    totalLength += result.value.length;\n  }\n\n  // Allocate a single Uint8Array for the decompressed data\n  const decompressedArray = new Uint8Array(totalLength);\n  let chunkOffset = 0;\n\n  for (const chunk of chunks) {\n    decompressedArray.set(chunk, chunkOffset);\n    chunkOffset += chunk.length;\n  }\n\n  return decompressedArray;\n}\n","export async function resolveWS(): Promise<typeof WebSocket> {\n  // Browser or Node >= 22 (or any env that exposes global WebSocket)\n  if (typeof (globalThis as any).WebSocket !== 'undefined') {\n    return (globalThis as any).WebSocket as typeof WebSocket;\n  }\n\n  // Node without a global WebSocket: lazily load undici's polyfill.\n  // Use an unstatable dynamic import so bundlers don't prebundle it.\n  const dynamicImport = new Function('m', 'return import(m)') as (\n    m: string\n  ) => Promise<any>;\n\n  try {\n    const { WebSocket: UndiciWS } = await dynamicImport('undici');\n    return UndiciWS as unknown as typeof WebSocket;\n  } catch (err) {\n    console.warn(\n      '[spacetimedb-sdk] No global WebSocket found. ' +\n        'On Node 1821, please install `undici` (npm install undici) ' +\n        'to enable WebSocket support.'\n    );\n    throw err;\n  }\n}\n","import { decompress } from './decompress';\nimport { resolveWS } from './ws';\n\nexport class WebsocketDecompressAdapter {\n  onclose?: (...ev: any[]) => void;\n  onopen?: (...ev: any[]) => void;\n  onmessage?: (msg: { data: Uint8Array }) => void;\n  onerror?: (msg: ErrorEvent) => void;\n\n  #ws: WebSocket;\n\n  async #handleOnMessage(msg: MessageEvent) {\n    const buffer = new Uint8Array(msg.data);\n    let decompressed: Uint8Array;\n\n    if (buffer[0] === 0) {\n      decompressed = buffer.slice(1);\n    } else if (buffer[0] === 1) {\n      throw new Error(\n        'Brotli Compression not supported. Please use gzip or none compression in withCompression method on DbConnection.'\n      );\n    } else if (buffer[0] === 2) {\n      decompressed = await decompress(buffer.slice(1), 'gzip');\n    } else {\n      throw new Error(\n        'Unexpected Compression Algorithm. Please use `gzip` or `none`'\n      );\n    }\n\n    this.onmessage?.({ data: decompressed });\n  }\n\n  #handleOnOpen(msg: any) {\n    this.onopen?.(msg);\n  }\n\n  #handleOnError(msg: any) {\n    this.onerror?.(msg);\n  }\n\n  #handleOnClose(msg: any) {\n    this.onclose?.(msg);\n  }\n\n  send(msg: any): void {\n    this.#ws.send(msg);\n  }\n\n  close(): void {\n    this.#ws.close();\n  }\n\n  constructor(ws: WebSocket) {\n    this.onmessage = undefined;\n    this.onopen = undefined;\n    this.onmessage = undefined;\n    this.onerror = undefined;\n\n    ws.onmessage = this.#handleOnMessage.bind(this);\n    ws.onerror = this.#handleOnError.bind(this);\n    ws.onclose = this.#handleOnClose.bind(this);\n    ws.onopen = this.#handleOnOpen.bind(this);\n\n    ws.binaryType = 'arraybuffer';\n\n    this.#ws = ws;\n  }\n\n  static async createWebSocketFn({\n    url,\n    nameOrAddress,\n    wsProtocol,\n    authToken,\n    compression,\n    lightMode,\n    confirmedReads,\n  }: {\n    url: URL;\n    wsProtocol: string;\n    nameOrAddress: string;\n    authToken?: string;\n    compression: 'gzip' | 'none';\n    lightMode: boolean;\n    confirmedReads?: boolean;\n  }): Promise<WebsocketDecompressAdapter> {\n    const headers = new Headers();\n\n    const WS = await resolveWS();\n\n    // We swap our original token to a shorter-lived token\n    // to avoid sending the original via query params.\n    let temporaryAuthToken: string | undefined = undefined;\n    if (authToken) {\n      headers.set('Authorization', `Bearer ${authToken}`);\n      const tokenUrl = new URL('v1/identity/websocket-token', url);\n      tokenUrl.protocol = url.protocol === 'wss:' ? 'https:' : 'http:';\n\n      const response = await fetch(tokenUrl, { method: 'POST', headers });\n      if (response.ok) {\n        const { token } = await response.json();\n        temporaryAuthToken = token;\n      } else {\n        return Promise.reject(\n          new Error(`Failed to verify token: ${response.statusText}`)\n        );\n      }\n    }\n\n    const databaseUrl = new URL(`v1/database/${nameOrAddress}/subscribe`, url);\n    if (temporaryAuthToken) {\n      databaseUrl.searchParams.set('token', temporaryAuthToken);\n    }\n    databaseUrl.searchParams.set(\n      'compression',\n      compression === 'gzip' ? 'Gzip' : 'None'\n    );\n    if (lightMode) {\n      databaseUrl.searchParams.set('light', 'true');\n    }\n    if (confirmedReads !== undefined) {\n      databaseUrl.searchParams.set('confirmed', confirmedReads.toString());\n    }\n\n    const ws = new WS(databaseUrl.toString(), wsProtocol);\n\n    return new WebsocketDecompressAdapter(ws);\n  }\n}\n","import { DbConnectionImpl, type ConnectionEvent } from './db_connection_impl';\nimport { EventEmitter } from './event_emitter';\nimport type {\n  DbConnectionConfig,\n  ErrorContextInterface,\n  Identity,\n  RemoteModuleOf,\n} from '../';\nimport { ensureMinimumVersionOrThrow } from './version';\nimport { WebsocketDecompressAdapter } from './websocket_decompress_adapter';\n\n/**\n * The database client connection to a SpacetimeDB server.\n * NOTE: DbConnectionImpl<any> is used here because UntypedRemoteModule causes\n * variance issues with function paramters, and the end user will never be\n * constructing a DbConnectionBuilder directly since it's code generated. We will\n * always have a concrete RemoteModule type in those cases. Even if they user\n * did do this, they would just lose type safety on the RemoteModule.\n */\nexport class DbConnectionBuilder<DbConnection extends DbConnectionImpl<any>> {\n  #uri?: URL;\n  #nameOrAddress?: string;\n  #identity?: Identity;\n  #token?: string;\n  #emitter: EventEmitter<ConnectionEvent> = new EventEmitter();\n  #compression: 'gzip' | 'none' = 'gzip';\n  #lightMode: boolean = false;\n  #confirmedReads?: boolean;\n  #createWSFn: typeof WebsocketDecompressAdapter.createWebSocketFn;\n\n  /**\n   * Creates a new `DbConnectionBuilder` database client and set the initial parameters.\n   *\n   * Users are not expected to call this constructor directly. Instead, use the static method `DbConnection.builder()`.\n   *\n   * @param remoteModule The remote module to use to connect to the SpacetimeDB server.\n   * @param dbConnectionConstructor The constructor to use to create a new `DbConnection`.\n   */\n  constructor(\n    private remoteModule: RemoteModuleOf<DbConnection>,\n    private dbConnectionCtor: (\n      config: DbConnectionConfig<RemoteModuleOf<DbConnection>>\n    ) => DbConnection\n  ) {\n    this.#createWSFn = WebsocketDecompressAdapter.createWebSocketFn;\n  }\n\n  /**\n   * Set the URI of the SpacetimeDB server to connect to.\n   *\n   * @param uri The URI of the SpacetimeDB server to connect to.\n   *\n   **/\n  withUri(uri: string | URL): this {\n    this.#uri = new URL(uri);\n    return this;\n  }\n\n  /**\n   * Set the name or Identity of the database module to connect to.\n   *\n   * @param nameOrAddress\n   *\n   * @returns The `DbConnectionBuilder` instance.\n   */\n  withModuleName(nameOrAddress: string): this {\n    this.#nameOrAddress = nameOrAddress;\n    return this;\n  }\n\n  /**\n   * Set the identity of the client to connect to the database.\n   *\n   * @param token The credentials to use to authenticate with SpacetimeDB. This\n   * is optional. You can store the token returned by the `onConnect` callback\n   * to use in future connections.\n   *\n   * @returns The `DbConnectionBuilder` instance.\n   */\n  withToken(token?: string): this {\n    this.#token = token;\n    return this;\n  }\n\n  withWSFn(\n    createWSFn: (args: {\n      url: URL;\n      wsProtocol: string;\n      authToken?: string;\n    }) => Promise<WebsocketDecompressAdapter>\n  ): this {\n    this.#createWSFn = createWSFn;\n    return this;\n  }\n\n  /**\n   * Set the compression algorithm to use for the connection.\n   *\n   * @param compression The compression algorithm to use for the connection.\n   */\n  withCompression(compression: 'gzip' | 'none'): this {\n    this.#compression = compression;\n    return this;\n  }\n\n  /**\n   * Sets the connection to operate in light mode.\n   *\n   * Light mode is a mode that reduces the amount of data sent over the network.\n   *\n   * @param lightMode The light mode for the connection.\n   */\n  withLightMode(lightMode: boolean): this {\n    this.#lightMode = lightMode;\n    return this;\n  }\n\n  /**\n   * Sets the connection to use confirmed reads.\n   *\n   * When enabled, the server will send query results only after they are\n   * confirmed to be durable.\n   *\n   * What durable means depends on the server configuration: a single node\n   * server may consider a transaction durable once it is `fsync`'ed to disk,\n   * whereas a cluster may require that some number of replicas have\n   * acknowledge that they have stored the transactions.\n   *\n   * Note that enabling confirmed reads will increase the latency between a\n   * reducer call and the corresponding subscription update arriving at the\n   * client.\n   *\n   * If this method is not called, not preference is sent to the server, and\n   * the server will choose the default.\n   *\n   * @param confirmedReads `true` to enable confirmed reads, `false` to disable.\n   */\n  withConfirmedReads(confirmedReads: boolean): this {\n    this.#confirmedReads = confirmedReads;\n    return this;\n  }\n\n  /**\n   * Register a callback to be invoked upon authentication with the database.\n   *\n   * @param identity A unique identifier for a client connected to a database.\n   * @param token The credentials to use to authenticate with SpacetimeDB.\n   *\n   * @returns The `DbConnectionBuilder` instance.\n   *\n   * The callback will be invoked with the `Identity` and private authentication `token` provided by the database to identify this connection.\n   *\n   * If credentials were supplied to connect, those passed to the callback will be equivalent to the ones used to connect.\n   *\n   * If the initial connection was anonymous, a new set of credentials will be generated by the database to identify this user.\n   *\n   * The credentials passed to the callback can be saved and used to authenticate the same user in future connections.\n   *\n   * @example\n   *\n   * ```ts\n   * DbConnection.builder().onConnect((ctx, identity, token) => {\n   *  console.log(\"Connected to SpacetimeDB with identity:\", identity.toHexString());\n   * });\n   * ```\n   */\n  onConnect(\n    callback: (\n      connection: DbConnection,\n      identity: Identity,\n      token: string\n    ) => void\n  ): this {\n    this.#emitter.on('connect', callback);\n    return this;\n  }\n\n  /**\n   * Register a callback to be invoked upon an error.\n   *\n   * @example\n   *\n   * ```ts\n   * DbConnection.builder().onConnectError((ctx, error) => {\n   *   console.log(\"Error connecting to SpacetimeDB:\", error);\n   * });\n   * ```\n   */\n  onConnectError(\n    callback: (\n      ctx: ErrorContextInterface<RemoteModuleOf<DbConnection>>,\n      error: Error\n    ) => void\n  ): this {\n    this.#emitter.on('connectError', callback);\n    return this;\n  }\n\n  /**\n   * Registers a callback to run when a {@link DbConnection} whose connection initially succeeded\n   * is disconnected, either after a {@link DbConnection.disconnect} call or due to an error.\n   *\n   * If the connection ended because of an error, the error is passed to the callback.\n   *\n   * The `callback` will be installed on the `DbConnection` created by `build`\n   * before initiating the connection, ensuring there's no opportunity for the disconnect to happen\n   * before the callback is installed.\n   *\n   * Note that this does not trigger if `build` fails\n   * or in cases where {@link DbConnectionBuilder.onConnectError} would trigger.\n   * This callback only triggers if the connection closes after `build` returns successfully\n   * and {@link DbConnectionBuilder.onConnect} is invoked, i.e., after the `IdentityToken` is received.\n   *\n   * To simplify SDK implementation, at most one such callback can be registered.\n   * Calling `onDisconnect` on the same `DbConnectionBuilder` multiple times throws an error.\n   *\n   * Unlike callbacks registered via {@link DbConnection},\n   * no mechanism is provided to unregister the provided callback.\n   * This is a concession to ergonomics; there's no clean place to return a `CallbackId` from this method\n   * or from `build`.\n   *\n   * @param {function(error?: Error): void} callback - The callback to invoke upon disconnection.\n   * @throws {Error} Throws an error if called multiple times on the same `DbConnectionBuilder`.\n   */\n  onDisconnect(\n    callback: (\n      ctx: ErrorContextInterface<RemoteModuleOf<DbConnection>>,\n      error?: Error | undefined\n    ) => void\n  ): this {\n    this.#emitter.on('disconnect', callback);\n    return this;\n  }\n\n  /**\n   * Builds a new `DbConnection` with the parameters set on this `DbConnectionBuilder` and attempts to connect to the SpacetimeDB server.\n   *\n   * @returns A new `DbConnection` with the parameters set on this `DbConnectionBuilder`.\n   *\n   * @example\n   *\n   * ```ts\n   * const host = \"http://localhost:3000\";\n   * const name_or_address = \"database_name\"\n   * const auth_token = undefined;\n   * DbConnection.builder().withUri(host).withModuleName(name_or_address).withToken(auth_token).build();\n   * ```\n   */\n  build(): DbConnection {\n    if (!this.#uri) {\n      throw new Error('URI is required to connect to SpacetimeDB');\n    }\n\n    if (!this.#nameOrAddress) {\n      throw new Error(\n        'Database name or address is required to connect to SpacetimeDB'\n      );\n    }\n    // We could consider making this an `onConnectError` instead of throwing here.\n    // Ideally, it would be a compile time error, but I'm not sure how to accomplish that.\n    ensureMinimumVersionOrThrow(this.remoteModule.versionInfo?.cliVersion);\n\n    return this.dbConnectionCtor({\n      uri: this.#uri,\n      nameOrAddress: this.#nameOrAddress,\n      identity: this.#identity,\n      token: this.#token,\n      emitter: this.#emitter,\n      compression: this.#compression,\n      lightMode: this.#lightMode,\n      confirmedReads: this.#confirmedReads,\n      createWSFn: this.#createWSFn,\n      remoteModule: this.remoteModule,\n    });\n  }\n}\n","import type { DbConnectionImpl } from './db_connection_impl';\nimport type {\n  ErrorContextInterface,\n  SubscriptionEventContextInterface,\n} from './event_context';\nimport { EventEmitter } from './event_emitter';\nimport type { UntypedRemoteModule } from './spacetime_module';\n\nexport class SubscriptionBuilderImpl<RemoteModule extends UntypedRemoteModule> {\n  #onApplied?: (ctx: SubscriptionEventContextInterface<RemoteModule>) => void =\n    undefined;\n  #onError?: (ctx: ErrorContextInterface<RemoteModule>) => void = undefined;\n  constructor(private db: DbConnectionImpl<RemoteModule>) {}\n\n  /**\n   * Registers `callback` to run when this query is successfully added to our subscribed set,\n   * I.e. when its `SubscriptionApplied` message is received.\n   *\n   * The database state exposed via the `&EventContext` argument\n   * includes all the rows added to the client cache as a result of the new subscription.\n   *\n   * The event in the `&EventContext` argument is `Event::SubscribeApplied`.\n   *\n   * Multiple `on_applied` callbacks for the same query may coexist.\n   * No mechanism for un-registering `on_applied` callbacks is exposed.\n   *\n   * @param cb - Callback to run when the subscription is applied.\n   * @returns The current `SubscriptionBuilder` instance.\n   */\n  onApplied(\n    cb: (ctx: SubscriptionEventContextInterface<RemoteModule>) => void\n  ): SubscriptionBuilderImpl<RemoteModule> {\n    this.#onApplied = cb;\n    return this;\n  }\n\n  /**\n   * Registers `callback` to run when this query either:\n   * - Fails to be added to our subscribed set.\n   * - Is unexpectedly removed from our subscribed set.\n   *\n   * If the subscription had previously started and has been unexpectedly removed,\n   * the database state exposed via the `&EventContext` argument contains no rows\n   * from any subscriptions removed within the same error event.\n   * As proposed, it must therefore contain no rows.\n   *\n   * The event in the `&EventContext` argument is `Event::SubscribeError`,\n   * containing a dynamic error object with a human-readable description of the error\n   * for diagnostic purposes.\n   *\n   * Multiple `on_error` callbacks for the same query may coexist.\n   * No mechanism for un-registering `on_error` callbacks is exposed.\n   *\n   * @param cb - Callback to run when there is an error in subscription.\n   * @returns The current `SubscriptionBuilder` instance.\n   */\n  onError(\n    cb: (ctx: ErrorContextInterface<RemoteModule>) => void\n  ): SubscriptionBuilderImpl<RemoteModule> {\n    this.#onError = cb;\n    return this;\n  }\n\n  /**\n   * Subscribe to a single query. The results of the query will be merged into the client\n   * cache and deduplicated on the client.\n   *\n   * @param query_sql A `SQL` query to subscribe to.\n   *\n   * @example\n   *\n   * ```ts\n   * const subscription = connection.subscriptionBuilder().onApplied(() => {\n   *   console.log(\"SDK client cache initialized.\");\n   * }).subscribe(\"SELECT * FROM User\");\n   *\n   * subscription.unsubscribe();\n   * ```\n   */\n  subscribe(\n    query_sql: string | string[]\n  ): SubscriptionHandleImpl<RemoteModule> {\n    const queries = Array.isArray(query_sql) ? query_sql : [query_sql];\n    if (queries.length === 0) {\n      throw new Error('Subscriptions must have at least one query');\n    }\n    return new SubscriptionHandleImpl(\n      this.db,\n      queries,\n      this.#onApplied,\n      this.#onError\n    );\n  }\n\n  /**\n   * Subscribes to all rows from all tables.\n   *\n   * This method is intended as a convenience\n   * for applications where client-side memory use and network bandwidth are not concerns.\n   * Applications where these resources are a constraint\n   * should register more precise queries via `subscribe`\n   * in order to replicate only the subset of data which the client needs to function.\n   *\n   * This method should not be combined with `subscribe` on the same `DbConnection`.\n   * A connection may either `subscribe` to particular queries,\n   * or `subscribeToAllTables`, but not both.\n   * Attempting to call `subscribe`\n   * on a `DbConnection` that has previously used `subscribeToAllTables`,\n   * or vice versa, may misbehave in any number of ways,\n   * including dropping subscriptions, corrupting the client cache, or throwing errors.\n   */\n  subscribeToAllTables(): void {\n    this.subscribe('SELECT * FROM *');\n  }\n}\n\nexport type SubscribeEvent = 'applied' | 'error' | 'end';\n\nexport class SubscriptionManager<RemoteModule extends UntypedRemoteModule> {\n  subscriptions: Map<\n    number,\n    {\n      handle: SubscriptionHandleImpl<RemoteModule>;\n      emitter: EventEmitter<SubscribeEvent>;\n    }\n  > = new Map();\n}\n\nexport class SubscriptionHandleImpl<RemoteModule extends UntypedRemoteModule> {\n  #queryId: number;\n  #unsubscribeCalled: boolean = false;\n  #endedState: boolean = false;\n  #activeState: boolean = false;\n  #emitter: EventEmitter<SubscribeEvent, (...args: any[]) => void> =\n    new EventEmitter();\n\n  constructor(\n    private db: DbConnectionImpl<RemoteModule>,\n    querySql: string[],\n    onApplied?: (ctx: SubscriptionEventContextInterface<RemoteModule>) => void,\n    onError?: (ctx: ErrorContextInterface<RemoteModule>, error: Error) => void\n  ) {\n    this.#emitter.on(\n      'applied',\n      (ctx: SubscriptionEventContextInterface<RemoteModule>) => {\n        this.#activeState = true;\n        if (onApplied) {\n          onApplied(ctx);\n        }\n      }\n    );\n    this.#emitter.on(\n      'error',\n      (ctx: ErrorContextInterface<RemoteModule>, error: Error) => {\n        this.#activeState = false;\n        this.#endedState = true;\n        if (onError) {\n          onError(ctx, error);\n        }\n      }\n    );\n    this.#queryId = this.db.registerSubscription(this, this.#emitter, querySql);\n  }\n\n  /**\n   * Consumes self and issues an `Unsubscribe` message,\n   * removing this query from the client's set of subscribed queries.\n   * It is only valid to call this method if `is_active()` is `true`.\n   */\n  unsubscribe(): void {\n    if (this.#unsubscribeCalled) {\n      throw new Error('Unsubscribe has already been called');\n    }\n    this.#unsubscribeCalled = true;\n    this.db.unregisterSubscription(this.#queryId);\n    this.#emitter.on(\n      'end',\n      (_ctx: SubscriptionEventContextInterface<RemoteModule>) => {\n        this.#endedState = true;\n        this.#activeState = false;\n      }\n    );\n  }\n\n  /**\n   * Unsubscribes and also registers a callback to run upon success.\n   * I.e. when an `UnsubscribeApplied` message is received.\n   *\n   * If `Unsubscribe` returns an error,\n   * or if the `on_error` callback(s) are invoked before this subscription would end normally,\n   * the `on_end` callback is not invoked.\n   *\n   * @param onEnd - Callback to run upon successful unsubscribe.\n   */\n  unsubscribeThen(\n    onEnd: (ctx: SubscriptionEventContextInterface<RemoteModule>) => void\n  ): void {\n    if (this.#endedState) {\n      throw new Error('Subscription has already ended');\n    }\n    if (this.#unsubscribeCalled) {\n      throw new Error('Unsubscribe has already been called');\n    }\n    this.#unsubscribeCalled = true;\n    this.db.unregisterSubscription(this.#queryId);\n    this.#emitter.on(\n      'end',\n      (ctx: SubscriptionEventContextInterface<RemoteModule>) => {\n        this.#endedState = true;\n        this.#activeState = false;\n        onEnd(ctx);\n      }\n    );\n  }\n\n  /**\n   * True if this `SubscriptionHandle` has ended,\n   * either due to an error or a call to `unsubscribe`.\n   *\n   * This is initially false, and becomes true when either the `on_end` or `on_error` callback is invoked.\n   * A subscription which has not yet been applied is not active, but is also not ended.\n   */\n  isEnded(): boolean {\n    return this.#endedState;\n  }\n\n  /**\n   * True if this `SubscriptionHandle` is active, meaning it has been successfully applied\n   * and has not since ended, either due to an error or a complete `unsubscribe` request-response pair.\n   *\n   * This corresponds exactly to the interval bounded at the start by the `on_applied` callback\n   * and at the end by either the `on_end` or `on_error` callback.\n   */\n  isActive(): boolean {\n    return this.#activeState;\n  }\n}\n","import { ConnectionId, ProductBuilder, ProductType } from '../';\nimport { AlgebraicType, type ComparablePrimitive } from '../';\nimport { BinaryReader } from '../';\nimport { BinaryWriter } from '../';\nimport BsatnRowList from './client_api/bsatn_row_list_type.ts';\nimport ClientMessage from './client_api/client_message_type.ts';\nimport DatabaseUpdate from './client_api/database_update_type.ts';\nimport QueryUpdate from './client_api/query_update_type.ts';\nimport ServerMessage from './client_api/server_message_type.ts';\nimport RawTableUpdate from './client_api/table_update_type.ts';\nimport { ClientCache } from './client_cache.ts';\nimport { DbConnectionBuilder } from './db_connection_builder.ts';\nimport { type DbContext } from './db_context.ts';\nimport type { Event } from './event.ts';\nimport {\n  type ErrorContextInterface,\n  type EventContextInterface,\n  type ReducerEventContextInterface,\n  type SubscriptionEventContextInterface,\n} from './event_context.ts';\nimport { EventEmitter } from './event_emitter.ts';\nimport { decompress } from './decompress.ts';\nimport type { Identity, Infer, InferTypeOfRow } from '../';\nimport type {\n  IdentityTokenMessage,\n  Message,\n  ProcedureResultMessage,\n  SubscribeAppliedMessage,\n  UnsubscribeAppliedMessage,\n} from './message_types.ts';\nimport type { ReducerEvent } from './reducer_event.ts';\nimport { type UntypedRemoteModule } from './spacetime_module.ts';\nimport {\n  type TableCache,\n  type Operation,\n  type PendingCallback,\n  type TableUpdate as CacheTableUpdate,\n} from './table_cache.ts';\nimport { WebsocketDecompressAdapter } from './websocket_decompress_adapter.ts';\nimport type { WebsocketTestAdapter } from './websocket_test_adapter.ts';\nimport {\n  SubscriptionBuilderImpl,\n  SubscriptionHandleImpl,\n  SubscriptionManager,\n  type SubscribeEvent,\n} from './subscription_builder_impl.ts';\nimport { stdbLogger } from './logger.ts';\nimport { fromByteArray } from 'base64-js';\nimport type {\n  ReducerEventCallback,\n  ReducerEventInfo,\n  ReducersView,\n  SetReducerFlags,\n  SubscriptionEventCallback,\n  UntypedReducerDef,\n} from './reducers.ts';\nimport type { ClientDbView } from './db_view.ts';\nimport type { UntypedTableDef } from '../lib/table.ts';\nimport { toCamelCase, toPascalCase } from '../lib/util.ts';\nimport type { ProceduresView } from './procedures.ts';\n\nexport {\n  DbConnectionBuilder,\n  SubscriptionBuilderImpl,\n  SubscriptionHandleImpl,\n  type TableCache,\n  type Event,\n};\n\nexport type RemoteModuleOf<C> =\n  C extends DbConnectionImpl<infer RM> ? RM : never;\n\nexport type {\n  DbContext,\n  EventContextInterface,\n  ReducerEventContextInterface,\n  SubscriptionEventContextInterface,\n  ErrorContextInterface,\n  ReducerEvent,\n};\n\nexport type ConnectionEvent = 'connect' | 'disconnect' | 'connectError';\nexport type CallReducerFlags = 'FullUpdate' | 'NoSuccessNotify';\n\nfunction callReducerFlagsToNumber(flags: CallReducerFlags): number {\n  switch (flags) {\n    case 'FullUpdate':\n      return 0;\n    case 'NoSuccessNotify':\n      return 1;\n  }\n}\n\nexport type DbConnectionConfig<RemoteModule extends UntypedRemoteModule> = {\n  uri: URL;\n  nameOrAddress: string;\n  identity?: Identity;\n  token?: string;\n  emitter: EventEmitter<ConnectionEvent>;\n  createWSFn: typeof WebsocketDecompressAdapter.createWebSocketFn;\n  compression: 'gzip' | 'none';\n  lightMode: boolean;\n  confirmedReads?: boolean;\n  remoteModule: RemoteModule;\n};\n\ntype ProcedureCallback = (result: ProcedureResultMessage['result']) => void;\n\nexport class DbConnectionImpl<RemoteModule extends UntypedRemoteModule>\n  implements DbContext<RemoteModule>\n{\n  /**\n   * Whether or not the connection is active.\n   */\n  isActive = false;\n\n  /**\n   * This connection's public identity.\n   */\n  identity?: Identity = undefined;\n\n  /**\n   * This connection's private authentication token.\n   */\n  token?: string = undefined;\n\n  /**\n   * The accessor field to access the tables in the database and associated\n   * callback functions.\n   */\n  db: ClientDbView<RemoteModule>;\n\n  /**\n   * The accessor field to access the reducers in the database and associated\n   * callback functions.\n   */\n  reducers: ReducersView<RemoteModule>;\n\n  /**\n   * The accessor field to access functions related to setting flags on\n   * reducers regarding how the server should handle the reducer call and\n   * the events that it sends back to the client.\n   */\n  setReducerFlags: SetReducerFlags<RemoteModule>;\n\n  /**\n   * The accessor field to access the reducers in the database and associated\n   * callback functions.\n   */\n  procedures: ProceduresView<RemoteModule>;\n\n  /**\n   * The `ConnectionId` of the connection to to the database.\n   */\n  connectionId: ConnectionId = ConnectionId.random();\n\n  // These fields are meant to be strictly private.\n  #queryId = 0;\n  #requestId = 0;\n  #emitter: EventEmitter<ConnectionEvent>;\n  #reducerEmitter: EventEmitter<string, ReducerEventCallback<RemoteModule>> =\n    new EventEmitter();\n  #onApplied?: SubscriptionEventCallback<RemoteModule>;\n  #messageQueue = Promise.resolve();\n  #subscriptionManager = new SubscriptionManager<RemoteModule>();\n  #remoteModule: RemoteModule;\n  #callReducerFlags = new Map<string, CallReducerFlags>();\n  #procedureCallbacks = new Map<number, ProcedureCallback>();\n\n  // These fields are not part of the public API, but in a pinch you\n  // could use JavaScript to access them by bypassing TypeScript's\n  // private fields.\n  // We use them in testing.\n  private clientCache: ClientCache<RemoteModule>;\n  private ws?: WebsocketDecompressAdapter | WebsocketTestAdapter;\n  private wsPromise: Promise<\n    WebsocketDecompressAdapter | WebsocketTestAdapter | undefined\n  >;\n\n  constructor({\n    uri,\n    nameOrAddress,\n    identity,\n    token,\n    emitter,\n    remoteModule,\n    createWSFn,\n    compression,\n    lightMode,\n    confirmedReads,\n  }: DbConnectionConfig<RemoteModule>) {\n    stdbLogger('info', 'Connecting to SpacetimeDB WS...');\n\n    // We use .toString() here because some versions of React Native contain a bug where the URL constructor\n    // incorrectly treats a URL instance as a plain string.\n    // This results in an attempt to call .endsWith() on it, leading to an error.\n    const url = new URL(uri.toString());\n    if (!/^wss?:/.test(uri.protocol)) {\n      url.protocol = url.protocol === 'https:' ? 'wss:' : 'ws:';\n    }\n\n    this.identity = identity;\n    this.token = token;\n\n    this.#remoteModule = remoteModule;\n    this.#emitter = emitter;\n\n    const connectionId = this.connectionId.toHexString();\n    url.searchParams.set('connection_id', connectionId);\n\n    this.clientCache = new ClientCache<RemoteModule>();\n    this.db = this.#makeDbView(remoteModule);\n    this.reducers = this.#makeReducers(remoteModule);\n    this.setReducerFlags = this.#makeSetReducerFlags(remoteModule);\n    this.procedures = this.#makeProcedures(remoteModule);\n\n    this.wsPromise = createWSFn({\n      url,\n      nameOrAddress,\n      wsProtocol: 'v1.bsatn.spacetimedb',\n      authToken: token,\n      compression: compression,\n      lightMode: lightMode,\n      confirmedReads: confirmedReads,\n    })\n      .then(v => {\n        this.ws = v;\n\n        this.ws.onclose = () => {\n          this.#emitter.emit('disconnect', this);\n          this.isActive = false;\n        };\n        this.ws.onerror = (e: ErrorEvent) => {\n          this.#emitter.emit('connectError', this, e);\n          this.isActive = false;\n        };\n        this.ws.onopen = this.#handleOnOpen.bind(this);\n        this.ws.onmessage = this.#handleOnMessage.bind(this);\n        return v;\n      })\n      .catch(e => {\n        stdbLogger('error', 'Error connecting to SpacetimeDB WS');\n        this.#emitter.emit('connectError', this, e);\n\n        return undefined;\n      });\n  }\n\n  #getNextQueryId = () => {\n    const queryId = this.#queryId;\n    this.#queryId += 1;\n    return queryId;\n  };\n\n  #getNextRequestId = () => this.#requestId++;\n\n  #makeDbView(def: RemoteModule): ClientDbView<RemoteModule> {\n    const view = Object.create(null) as ClientDbView<RemoteModule>;\n\n    for (const tbl of def.tables) {\n      // ClientDbView uses this name verbatim\n      const key = tbl.accessorName;\n      Object.defineProperty(view, key, {\n        enumerable: true,\n        configurable: false,\n        get: () => {\n          return this.clientCache.getOrCreateTable(tbl);\n        },\n      });\n    }\n\n    return view;\n  }\n\n  #makeReducers(def: RemoteModule): ReducersView<RemoteModule> {\n    const out: Record<string, unknown> = {};\n\n    for (const reducer of def.reducers) {\n      const key = toCamelCase(reducer.name);\n\n      (out as any)[key] = (params: InferTypeOfRow<typeof reducer.params>) => {\n        const flags = this.#callReducerFlags.get(reducer.name) ?? 'FullUpdate';\n        this.callReducerWithParams(\n          reducer.name,\n          reducer.paramsType,\n          params,\n          flags\n        );\n      };\n\n      const onReducerEventKey = `on${toPascalCase(reducer.name)}`;\n      (out as any)[onReducerEventKey] = (\n        callback: ReducerEventCallback<\n          RemoteModule,\n          InferTypeOfRow<typeof reducer.params>\n        >\n      ) => {\n        this.onReducer(reducer.name, callback);\n      };\n\n      const offReducerEventKey = `removeOn${toPascalCase(reducer.name)}`;\n      (out as any)[offReducerEventKey] = (\n        callback: ReducerEventCallback<\n          RemoteModule,\n          InferTypeOfRow<typeof reducer.params>\n        >\n      ) => {\n        this.offReducer(reducer.name, callback);\n      };\n    }\n\n    return out as ReducersView<RemoteModule>;\n  }\n\n  #makeSetReducerFlags(defs: RemoteModule): SetReducerFlags<RemoteModule> {\n    const out = Object.create(null) as SetReducerFlags<RemoteModule>;\n    for (const r of defs.reducers) {\n      const key = toCamelCase(r.name);\n      Object.defineProperty(out, key, {\n        enumerable: true,\n        configurable: false,\n        value: (flags: CallReducerFlags) => {\n          this.#callReducerFlags.set(r.name, flags);\n        },\n      });\n    }\n    return out;\n  }\n\n  #makeProcedures(def: RemoteModule): ProceduresView<RemoteModule> {\n    const out: Record<string, unknown> = {};\n\n    for (const procedure of def.procedures) {\n      const key = toCamelCase(procedure.name);\n\n      const paramsType = new ProductBuilder(procedure.params).algebraicType\n        .value;\n\n      const returnType = procedure.returnType.algebraicType;\n\n      (out as any)[key] = (\n        params: InferTypeOfRow<typeof procedure.params>\n      ): Promise<any> =>\n        this.callProcedureWithParams(\n          procedure.name,\n          paramsType,\n          params,\n          returnType\n        );\n    }\n\n    return out as ProceduresView<RemoteModule>;\n  }\n\n  #makeEventContext(\n    event: Event<\n      ReducerEventInfo<\n        RemoteModule['reducers'][number]['name'],\n        InferTypeOfRow<RemoteModule['reducers'][number]['params']>\n      >\n    >\n  ): EventContextInterface<RemoteModule> {\n    // Bind methods to preserve `this` (#private fields safe)\n    return {\n      db: this.db,\n      reducers: this.reducers,\n      setReducerFlags: this.setReducerFlags,\n      isActive: this.isActive,\n      subscriptionBuilder: this.subscriptionBuilder.bind(this),\n      disconnect: this.disconnect.bind(this),\n      event,\n    };\n  }\n\n  // NOTE: This is very important!!! This is the actual function that\n  // gets called when you call `connection.subscriptionBuilder()`.\n  // The `subscriptionBuilder` function which is generated, just shadows\n  // this function in the type system, but not the actual implementation!\n  // Do not remove this function, or shoot yourself in the foot please.\n  // It's not clear what would be a better way to do this at this exact\n  // moment.\n  subscriptionBuilder = (): SubscriptionBuilderImpl<RemoteModule> => {\n    return new SubscriptionBuilderImpl(this);\n  };\n\n  registerSubscription(\n    handle: SubscriptionHandleImpl<RemoteModule>,\n    handleEmitter: EventEmitter<\n      SubscribeEvent,\n      SubscriptionEventCallback<RemoteModule>\n    >,\n    querySql: string[]\n  ): number {\n    const queryId = this.#getNextQueryId();\n    this.#subscriptionManager.subscriptions.set(queryId, {\n      handle,\n      emitter: handleEmitter,\n    });\n    this.#sendMessage(\n      ClientMessage.SubscribeMulti({\n        queryStrings: querySql,\n        queryId: { id: queryId },\n        // The TypeScript SDK doesn't currently track `request_id`s,\n        // so always use 0.\n        requestId: 0,\n      })\n    );\n    return queryId;\n  }\n\n  unregisterSubscription(queryId: number): void {\n    this.#sendMessage(\n      ClientMessage.UnsubscribeMulti({\n        queryId: { id: queryId },\n        // The TypeScript SDK doesn't currently track `request_id`s,\n        // so always use 0.\n        requestId: 0,\n      })\n    );\n  }\n\n  // This function is async because we decompress the message async\n  async #processParsedMessage(\n    message: Infer<typeof ServerMessage>\n  ): Promise<Message | undefined> {\n    const parseRowList = (\n      type: 'insert' | 'delete',\n      tableName: string,\n      rowList: Infer<typeof BsatnRowList>\n    ): Operation[] => {\n      const buffer = rowList.rowsData;\n      const reader = new BinaryReader(buffer);\n      const rows: Operation[] = [];\n\n      // TODO: performance\n      const table = this.#remoteModule.tables.find(t => t.name === tableName);\n      const rowType = table!.rowType;\n      const columnsArray = Object.entries(table!.columns);\n      const primaryKeyColumnEntry = columnsArray.find(\n        col => col[1].columnMetadata.isPrimaryKey\n      );\n      let previousOffset = 0;\n      while (reader.remaining > 0) {\n        const row = ProductType.deserializeValue(reader, rowType);\n        let rowId: ComparablePrimitive | undefined = undefined;\n        if (primaryKeyColumnEntry !== undefined) {\n          const primaryKeyColName = primaryKeyColumnEntry[0];\n          const primaryKeyColType =\n            primaryKeyColumnEntry[1].typeBuilder.algebraicType;\n          rowId = AlgebraicType.intoMapKey(\n            primaryKeyColType,\n            row[primaryKeyColName]\n          );\n        } else {\n          // Get a view of the bytes for this row.\n          const rowBytes = buffer.subarray(previousOffset, reader.offset);\n          // Convert it to a base64 string, so we can use it as a map key.\n          const asBase64 = fromByteArray(rowBytes);\n          rowId = asBase64;\n        }\n        previousOffset = reader.offset;\n\n        rows.push({\n          type,\n          rowId,\n          row,\n        });\n      }\n      return rows;\n    };\n\n    const parseTableUpdate = async (\n      rawTableUpdate: Infer<typeof RawTableUpdate>\n    ): Promise<CacheTableUpdate<UntypedTableDef>> => {\n      const tableName = rawTableUpdate.tableName;\n      let operations: Operation[] = [];\n      for (const update of rawTableUpdate.updates) {\n        let decompressed: Infer<typeof QueryUpdate>;\n        if (update.tag === 'Gzip') {\n          const decompressedBuffer = await decompress(update.value, 'gzip');\n          decompressed = AlgebraicType.deserializeValue(\n            new BinaryReader(decompressedBuffer),\n            QueryUpdate.algebraicType\n          );\n        } else if (update.tag === 'Brotli') {\n          throw new Error(\n            'Brotli compression not supported. Please use gzip or none compression in withCompression method on DbConnection.'\n          );\n        } else {\n          decompressed = update.value;\n        }\n        operations = operations.concat(\n          parseRowList('insert', tableName, decompressed.inserts)\n        );\n        operations = operations.concat(\n          parseRowList('delete', tableName, decompressed.deletes)\n        );\n      }\n      return {\n        tableName,\n        operations,\n      };\n    };\n\n    const parseDatabaseUpdate = async (\n      dbUpdate: Infer<typeof DatabaseUpdate>\n    ): Promise<CacheTableUpdate<UntypedTableDef>[]> => {\n      const tableUpdates: CacheTableUpdate<UntypedTableDef>[] = [];\n      for (const rawTableUpdate of dbUpdate.tables) {\n        tableUpdates.push(await parseTableUpdate(rawTableUpdate));\n      }\n      return tableUpdates;\n    };\n\n    switch (message.tag) {\n      case 'InitialSubscription': {\n        const dbUpdate = message.value.databaseUpdate;\n        const tableUpdates = await parseDatabaseUpdate(dbUpdate);\n        const subscriptionUpdate: Message = {\n          tag: 'InitialSubscription',\n          tableUpdates,\n        };\n        return subscriptionUpdate;\n      }\n\n      case 'TransactionUpdateLight': {\n        const dbUpdate = message.value.update;\n        const tableUpdates = await parseDatabaseUpdate(dbUpdate);\n        const subscriptionUpdate: Message = {\n          tag: 'TransactionUpdateLight',\n          tableUpdates,\n        };\n        return subscriptionUpdate;\n      }\n\n      case 'TransactionUpdate': {\n        const txUpdate = message.value;\n        const identity = txUpdate.callerIdentity;\n        const connectionId = ConnectionId.nullIfZero(\n          txUpdate.callerConnectionId\n        );\n        const reducerName: string = txUpdate.reducerCall.reducerName;\n        const args = txUpdate.reducerCall.args;\n        const energyQuantaUsed = txUpdate.energyQuantaUsed;\n\n        let tableUpdates: CacheTableUpdate<UntypedTableDef>[] = [];\n        let errMessage = '';\n        switch (txUpdate.status.tag) {\n          case 'Committed':\n            tableUpdates = await parseDatabaseUpdate(txUpdate.status.value);\n            break;\n          case 'Failed':\n            tableUpdates = [];\n            errMessage = txUpdate.status.value;\n            break;\n          case 'OutOfEnergy':\n            tableUpdates = [];\n            break;\n        }\n\n        // TODO: Can `reducerName` be '<none>'?\n        // See: https://github.com/clockworklabs/SpacetimeDB/blob/a2a1b5d9b2e0ebaaf753d074db056d319952d442/crates/core/src/client/message_handlers.rs#L155\n        if (reducerName === '<none>') {\n          const errorMessage = errMessage;\n          console.error(`Received an error from the database: ${errorMessage}`);\n          return;\n        }\n\n        let reducerInfo:\n          | {\n              reducerName: string;\n              args: Uint8Array;\n            }\n          | undefined;\n        if (reducerName !== '') {\n          reducerInfo = {\n            reducerName,\n            args,\n          };\n        }\n\n        const transactionUpdate: Message = {\n          tag: 'TransactionUpdate',\n          tableUpdates,\n          identity,\n          connectionId,\n          reducerInfo,\n          status: txUpdate.status,\n          energyConsumed: energyQuantaUsed.quanta,\n          message: errMessage,\n          timestamp: txUpdate.timestamp,\n        };\n        return transactionUpdate;\n      }\n\n      case 'IdentityToken': {\n        const identityTokenMessage: IdentityTokenMessage = {\n          tag: 'IdentityToken',\n          identity: message.value.identity,\n          token: message.value.token,\n          connectionId: message.value.connectionId,\n        };\n        return identityTokenMessage;\n      }\n\n      case 'OneOffQueryResponse': {\n        throw new Error(\n          `TypeScript SDK never sends one-off queries, but got OneOffQueryResponse ${message}`\n        );\n      }\n\n      case 'SubscribeMultiApplied': {\n        const parsedTableUpdates = await parseDatabaseUpdate(\n          message.value.update\n        );\n        const subscribeAppliedMessage: SubscribeAppliedMessage = {\n          tag: 'SubscribeApplied',\n          queryId: message.value.queryId.id,\n          tableUpdates: parsedTableUpdates,\n        };\n        return subscribeAppliedMessage;\n      }\n\n      case 'UnsubscribeMultiApplied': {\n        const parsedTableUpdates = await parseDatabaseUpdate(\n          message.value.update\n        );\n        const unsubscribeAppliedMessage: UnsubscribeAppliedMessage = {\n          tag: 'UnsubscribeApplied',\n          queryId: message.value.queryId.id,\n          tableUpdates: parsedTableUpdates,\n        };\n        return unsubscribeAppliedMessage;\n      }\n\n      case 'SubscriptionError': {\n        return {\n          tag: 'SubscriptionError',\n          queryId: message.value.queryId,\n          error: message.value.error,\n        };\n      }\n\n      case 'ProcedureResult': {\n        const { status, requestId } = message.value;\n        return {\n          tag: 'ProcedureResult',\n          requestId,\n          result:\n            status.tag === 'Returned'\n              ? { tag: 'Ok', value: status.value }\n              : status.tag === 'OutOfEnergy'\n                ? {\n                    tag: 'Err',\n                    value:\n                      'Procedure execution aborted due to insufficient energy',\n                  }\n                : { tag: 'Err', value: status.value },\n        };\n      }\n    }\n  }\n\n  #sendMessage(message: Infer<typeof ClientMessage>): void {\n    this.wsPromise.then(wsResolved => {\n      if (wsResolved) {\n        const writer = new BinaryWriter(1024);\n        AlgebraicType.serializeValue(\n          writer,\n          ClientMessage.algebraicType,\n          message\n        );\n        const encoded = writer.getBuffer();\n        wsResolved.send(encoded);\n      }\n    });\n  }\n\n  /**\n   * Handles WebSocket onOpen event.\n   */\n  #handleOnOpen(): void {\n    this.isActive = true;\n  }\n\n  #applyTableUpdates(\n    tableUpdates: CacheTableUpdate<UntypedTableDef>[],\n    eventContext: EventContextInterface<RemoteModule>\n  ): PendingCallback[] {\n    const pendingCallbacks: PendingCallback[] = [];\n    for (const tableUpdate of tableUpdates) {\n      // Get table information for the table being updated\n      const tableName = tableUpdate.tableName;\n      // TODO: performance\n      const tableDef = this.#remoteModule.tables.find(\n        t => t.name === tableName\n      )!;\n      const table = this.clientCache.getOrCreateTable(tableDef);\n      const newCallbacks = table.applyOperations(\n        tableUpdate.operations,\n        eventContext\n      );\n      for (const callback of newCallbacks) {\n        pendingCallbacks.push(callback);\n      }\n    }\n    return pendingCallbacks;\n  }\n\n  async #processMessage(data: Uint8Array): Promise<void> {\n    const serverMessage = AlgebraicType.deserializeValue(\n      new BinaryReader(data),\n      ServerMessage.algebraicType\n    );\n    const message = await this.#processParsedMessage(serverMessage);\n    if (!message) {\n      return;\n    }\n    switch (message.tag) {\n      case 'InitialSubscription': {\n        const event: Event<never> = { tag: 'SubscribeApplied' };\n        const eventContext = this.#makeEventContext(event);\n        // Remove the event from the subscription event context\n        // It is not a field in the type narrowed SubscriptionEventContext\n        const { event: _, ...subscriptionEventContext } = eventContext;\n        const callbacks = this.#applyTableUpdates(\n          message.tableUpdates,\n          eventContext\n        );\n\n        if (this.#emitter) {\n          this.#onApplied?.(subscriptionEventContext);\n        }\n        for (const callback of callbacks) {\n          callback.cb();\n        }\n        break;\n      }\n      case 'TransactionUpdateLight': {\n        const event: Event<never> = { tag: 'UnknownTransaction' };\n        const eventContext = this.#makeEventContext(event);\n        const callbacks = this.#applyTableUpdates(\n          message.tableUpdates,\n          eventContext\n        );\n        for (const callback of callbacks) {\n          callback.cb();\n        }\n        break;\n      }\n      case 'TransactionUpdate': {\n        let reducerInfo = message.reducerInfo;\n\n        const reducer: UntypedReducerDef | undefined =\n          reducerInfo === undefined\n            ? undefined\n            : this.#remoteModule.reducers.find(\n                t => t.name === reducerInfo!.reducerName\n              );\n        let reducerArgs: UntypedReducerDef['params'] | undefined = undefined;\n\n        let unknownTransaction = reducer === undefined;\n        if (reducer) {\n          try {\n            const reader = new BinaryReader(reducerInfo!.args as Uint8Array);\n            reducerArgs = ProductType.deserializeValue(\n              reader,\n              reducer.paramsType\n            );\n          } catch {\n            // This should only be printed in development, since it's\n            // possible for clients to receive new reducers that they don't\n            // know about.\n            console.debug('Failed to deserialize reducer arguments');\n            unknownTransaction = true;\n          }\n        }\n\n        if (unknownTransaction) {\n          const event: Event<never> = { tag: 'UnknownTransaction' };\n          const eventContext = this.#makeEventContext(event);\n          const callbacks = this.#applyTableUpdates(\n            message.tableUpdates,\n            eventContext\n          );\n\n          for (const callback of callbacks) {\n            callback.cb();\n          }\n          return;\n        }\n        // At this point, we know that `reducerInfo` is not null because\n        // we return if `unknownTransaction` is true.\n        reducerInfo = reducerInfo!;\n        reducerArgs = reducerArgs!;\n\n        // Thus this must be a reducer event create it and emit it.\n        const reducerEvent = {\n          callerIdentity: message.identity,\n          status: message.status,\n          callerConnectionId: message.connectionId as ConnectionId,\n          timestamp: message.timestamp,\n          energyConsumed: message.energyConsumed,\n          reducer: {\n            name: reducerInfo.reducerName,\n            args: reducerArgs,\n          },\n        };\n        const event: Event<typeof reducerEvent.reducer> = {\n          tag: 'Reducer',\n          value: reducerEvent,\n        };\n        const eventContext = this.#makeEventContext(event as any);\n        const reducerEventContext = {\n          ...eventContext,\n          event: reducerEvent,\n        };\n\n        const callbacks = this.#applyTableUpdates(\n          message.tableUpdates,\n          eventContext\n        );\n\n        this.#reducerEmitter.emit(\n          reducerInfo.reducerName,\n          reducerEventContext,\n          reducerArgs\n        );\n        for (const callback of callbacks) {\n          callback.cb();\n        }\n        break;\n      }\n      case 'IdentityToken': {\n        this.identity = message.identity;\n        if (!this.token && message.token) {\n          this.token = message.token;\n        }\n        this.connectionId = message.connectionId;\n        this.#emitter.emit('connect', this, this.identity, this.token);\n        break;\n      }\n      case 'SubscribeApplied': {\n        const subscription = this.#subscriptionManager.subscriptions.get(\n          message.queryId\n        );\n        if (subscription === undefined) {\n          stdbLogger(\n            'error',\n            `Received SubscribeApplied for unknown queryId ${message.queryId}.`\n          );\n          // If we don't know about the subscription, we won't apply the table updates.\n          break;\n        }\n        const event: Event<never> = { tag: 'SubscribeApplied' };\n        const eventContext = this.#makeEventContext(event);\n        const { event: _, ...subscriptionEventContext } = eventContext;\n        const callbacks = this.#applyTableUpdates(\n          message.tableUpdates,\n          eventContext\n        );\n        subscription?.emitter.emit('applied', subscriptionEventContext);\n        for (const callback of callbacks) {\n          callback.cb();\n        }\n        break;\n      }\n      case 'UnsubscribeApplied': {\n        const subscription = this.#subscriptionManager.subscriptions.get(\n          message.queryId\n        );\n        if (subscription === undefined) {\n          stdbLogger(\n            'error',\n            `Received UnsubscribeApplied for unknown queryId ${message.queryId}.`\n          );\n          // If we don't know about the subscription, we won't apply the table updates.\n          break;\n        }\n        const event: Event<never> = { tag: 'UnsubscribeApplied' };\n        const eventContext = this.#makeEventContext(event);\n        const { event: _, ...subscriptionEventContext } = eventContext;\n        const callbacks = this.#applyTableUpdates(\n          message.tableUpdates,\n          eventContext\n        );\n        subscription?.emitter.emit('end', subscriptionEventContext);\n        this.#subscriptionManager.subscriptions.delete(message.queryId);\n        for (const callback of callbacks) {\n          callback.cb();\n        }\n        break;\n      }\n      case 'SubscriptionError': {\n        const error = Error(message.error);\n        const event: Event<never> = { tag: 'Error', value: error };\n        const eventContext = this.#makeEventContext(event);\n        const errorContext = {\n          ...eventContext,\n          event: error,\n        };\n        if (message.queryId !== undefined) {\n          this.#subscriptionManager.subscriptions\n            .get(message.queryId)\n            ?.emitter.emit('error', errorContext, error);\n          this.#subscriptionManager.subscriptions.delete(message.queryId);\n        } else {\n          console.error('Received an error message without a queryId: ', error);\n          // TODO: This should actually kill the connection.\n          // A subscription error without a specific subscription means we aren't receiving\n          // updates for all of our subscriptions, so our cache is out of sync.\n\n          // Send it to all of them:\n          this.#subscriptionManager.subscriptions.forEach(({ emitter }) => {\n            emitter.emit('error', errorContext, error);\n          });\n        }\n        break;\n      }\n      case 'ProcedureResult': {\n        const { requestId, result } = message;\n        const cb = this.#procedureCallbacks.get(requestId);\n        this.#procedureCallbacks.delete(requestId);\n        cb?.(result);\n        break;\n      }\n    }\n  }\n\n  /**\n   * Handles WebSocket onMessage event.\n   * @param wsMessage MessageEvent object.\n   */\n  #handleOnMessage(wsMessage: { data: Uint8Array }): void {\n    // Utilize promise chaining to ensure that we process messages in order\n    // even though we are processing them asyncronously. This will not begin\n    // processing the next message until we await the processing of the\n    // current message.\n    this.#messageQueue = this.#messageQueue.then(() => {\n      return this.#processMessage(wsMessage.data);\n    });\n  }\n\n  /**\n   * Call a reducer on your SpacetimeDB module.\n   *\n   * @param reducerName The name of the reducer to call\n   * @param argsSerializer The arguments to pass to the reducer\n   */\n  callReducer(\n    reducerName: string,\n    argsBuffer: Uint8Array,\n    flags: CallReducerFlags\n  ): void {\n    const message = ClientMessage.CallReducer({\n      reducer: reducerName,\n      args: argsBuffer,\n      // The TypeScript SDK doesn't currently track `request_id`s,\n      // so always use 0.\n      requestId: 0,\n      flags: callReducerFlagsToNumber(flags),\n    });\n    this.#sendMessage(message);\n  }\n\n  /**\n   * Call a reducer on your SpacetimeDB module with typed arguments.\n   * @param reducerSchema The schema of the reducer to call\n   * @param callReducerFlags The flags for the reducer call\n   * @param params The arguments to pass to the reducer\n   */\n  callReducerWithParams(\n    reducerName: string,\n    paramsType: ProductType,\n    params: object,\n    flags: CallReducerFlags\n  ) {\n    const writer = new BinaryWriter(1024);\n    ProductType.serializeValue(writer, paramsType, params);\n    const argsBuffer = writer.getBuffer();\n    this.callReducer(reducerName, argsBuffer, flags);\n  }\n\n  /**\n   * Call a reducer on your SpacetimeDB module.\n   *\n   * @param procedureName The name of the reducer to call\n   * @param argsBuffer The arguments to pass to the reducer\n   */\n  callProcedure(\n    procedureName: string,\n    argsBuffer: Uint8Array\n  ): Promise<Uint8Array> {\n    const { promise, resolve, reject } = Promise.withResolvers<Uint8Array>();\n    const requestId = this.#getNextRequestId();\n    const message = ClientMessage.CallProcedure({\n      procedure: procedureName,\n      args: argsBuffer,\n      requestId,\n      // reserved for future use - 0 is the only valid value\n      flags: 0,\n    });\n    this.#sendMessage(message);\n    this.#procedureCallbacks.set(requestId, result => {\n      if (result.tag === 'Ok') {\n        resolve(result.value);\n      } else {\n        reject(result.value);\n      }\n    });\n    return promise;\n  }\n\n  /**\n   * Call a reducer on your SpacetimeDB module with typed arguments.\n   * @param reducerSchema The schema of the reducer to call\n   * @param callReducerFlags The flags for the reducer call\n   * @param params The arguments to pass to the reducer\n   */\n  callProcedureWithParams(\n    procedureName: string,\n    paramsType: ProductType,\n    params: object,\n    returnType: AlgebraicType\n  ): Promise<any> {\n    const writer = new BinaryWriter(1024);\n    ProductType.serializeValue(writer, paramsType, params);\n    const argsBuffer = writer.getBuffer();\n    return this.callProcedure(procedureName, argsBuffer).then(returnBuf => {\n      return AlgebraicType.deserializeValue(\n        new BinaryReader(returnBuf),\n        returnType\n      );\n    });\n  }\n\n  /**\n   * Close the current connection.\n   *\n   * @example\n   *\n   * ```ts\n   * const connection = DbConnection.builder().build();\n   * connection.disconnect()\n   * ```\n   */\n  disconnect(): void {\n    this.wsPromise.then(wsResolved => {\n      if (wsResolved) {\n        wsResolved.close();\n      }\n    });\n  }\n\n  private on(\n    eventName: ConnectionEvent,\n    callback: (ctx: DbConnectionImpl<RemoteModule>, ...args: any[]) => void\n  ): void {\n    this.#emitter.on(eventName, callback);\n  }\n\n  private off(\n    eventName: ConnectionEvent,\n    callback: (ctx: DbConnectionImpl<RemoteModule>, ...args: any[]) => void\n  ): void {\n    this.#emitter.off(eventName, callback);\n  }\n\n  private onConnect(\n    callback: (ctx: DbConnectionImpl<RemoteModule>, ...args: any[]) => void\n  ): void {\n    this.#emitter.on('connect', callback);\n  }\n\n  private onDisconnect(\n    callback: (ctx: DbConnectionImpl<RemoteModule>, ...args: any[]) => void\n  ): void {\n    this.#emitter.on('disconnect', callback);\n  }\n\n  private onConnectError(\n    callback: (ctx: DbConnectionImpl<RemoteModule>, ...args: any[]) => void\n  ): void {\n    this.#emitter.on('connectError', callback);\n  }\n\n  removeOnConnect(\n    callback: (ctx: DbConnectionImpl<RemoteModule>, ...args: any[]) => void\n  ): void {\n    this.#emitter.off('connect', callback);\n  }\n\n  removeOnDisconnect(\n    callback: (ctx: DbConnectionImpl<RemoteModule>, ...args: any[]) => void\n  ): void {\n    this.#emitter.off('disconnect', callback);\n  }\n\n  removeOnConnectError(\n    callback: (ctx: DbConnectionImpl<RemoteModule>, ...args: any[]) => void\n  ): void {\n    this.#emitter.off('connectError', callback);\n  }\n\n  // Note: This is required to be public because it needs to be\n  // called from the `RemoteReducers` class.\n  onReducer(\n    reducerName: string,\n    callback: ReducerEventCallback<RemoteModule>\n  ): void {\n    this.#reducerEmitter.on(reducerName, callback);\n  }\n\n  // Note: This is required to be public because it needs to be\n  // called from the `RemoteReducers` class.\n  offReducer(\n    reducerName: string,\n    callback: ReducerEventCallback<RemoteModule>\n  ): void {\n    this.#reducerEmitter.off(reducerName, callback);\n  }\n}\n","// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE\n// WILL NOT BE SAVED. MODIFY TABLES IN YOUR MODULE SOURCE CODE INSTEAD.\n\n/* eslint-disable */\n/* tslint:disable */\nimport {\n  TypeBuilder as __TypeBuilder,\n  t as __t,\n  type AlgebraicTypeType as __AlgebraicTypeType,\n  type Infer as __Infer,\n} from '../../lib/type_builders';\n\n// The tagged union or sum type for the algebraic type `Lifecycle`.\nconst Lifecycle = __t.enum('Lifecycle', {\n  Init: __t.unit(),\n  OnConnect: __t.unit(),\n  OnDisconnect: __t.unit(),\n});\n\nexport default Lifecycle;\n","import { ProductType } from './algebraic_type';\nimport Lifecycle from './autogen/lifecycle_type';\nimport type RawReducerDefV9 from './autogen/raw_reducer_def_v_9_type';\nimport type { ConnectionId } from './connection_id';\nimport type { Identity } from './identity';\nimport { type Timestamp } from './timestamp';\nimport type { UntypedReducersDef } from '../sdk/reducers';\nimport type { DbView } from '../server/db_view';\nimport {\n  MODULE_DEF,\n  registerTypesRecursively,\n  resolveType,\n  type UntypedSchemaDef,\n} from './schema';\nimport {\n  ColumnBuilder,\n  RowBuilder,\n  type Infer,\n  type InferTypeOfRow,\n  type RowObj,\n  type TypeBuilder,\n} from './type_builders';\nimport type { ReducerSchema } from './reducer_schema';\nimport { toCamelCase, toPascalCase } from './util';\nimport type { CamelCase } from './type_util';\nimport { Uuid } from './uuid.ts';\n\n/**\n * Helper to extract the parameter types from an object type\n */\nexport type ParamsObj = Record<\n  string,\n  TypeBuilder<any, any> | ColumnBuilder<any, any, any>\n>;\n\n/**\n * Helper to convert a ParamsObj or RowObj into an object type\n */\ntype ParamsAsObject<ParamDef extends ParamsObj> = InferTypeOfRow<ParamDef>;\n\n/**\n * Defines a SpacetimeDB reducer function.\n * Reducers are the primary way to modify the state of your SpacetimeDB application.\n * They are atomic, meaning that either all operations within a reducer succeed,\n * or none of them do.\n * @template S - The inferred schema type of the SpacetimeDB module.\n * @template Params - The type of the parameters object expected by the reducer.\n * @param ctx - The reducer context, providing access to `sender`, `timestamp`, `connection_id`, and `db`.\n * @param payload - An object containing the arguments passed to the reducer, typed according to `params`.\n * @example\n * ```typescript\n * // Define a reducer named 'create_user' that takes 'username' (string) and 'email' (string)\n * reducer(\n *   'create_user',\n *   {\n *    username: t.string(),\n *    email: t.string(),\n *   },\n *   (ctx, { username, email }) => {\n *     // Access the 'user' table from the database view in the context\n *     ctx.db.user.insert({ username, email, created_at: ctx.timestamp });\n *     console.log(`User ${username} created by ${ctx.sender.identityId}`);\n *   }\n * );\n * ```\n */\nexport type Reducer<S extends UntypedSchemaDef, Params extends ParamsObj> = (\n  ctx: ReducerCtx<S>,\n  payload: ParamsAsObject<Params>\n) => void | { tag: 'ok' } | { tag: 'err'; value: string };\n\n/**\n * Authentication information for the caller of a reducer.\n */\nexport type AuthCtx = Readonly<{\n  /** Whether the caller is an internal system process. */\n  isInternal: boolean;\n  /** Whether the caller has authenticated with a JWT token. */\n  hasJWT: boolean;\n  /** The JWT claims associated with the caller, or null if hasJWT == false. */\n  jwt: JwtClaims | null;\n}>;\n\nexport type JsonValue =\n  | string\n  | number\n  | boolean\n  | null\n  | Array<JsonValue>\n  | JsonObject;\n\nexport interface JsonObject {\n  [key: string]: JsonValue;\n}\n\n/**\n * Auth Claims extracted from the payload of a JWT token\n */\nexport interface JwtClaims {\n  /** The full payload as a JSON string */\n  readonly rawPayload: string;\n  /** The subject of the JWT token ('sub') */\n  readonly subject: string;\n  /** The issuer of the JWT token ('iss') */\n  readonly issuer: string;\n  /** The audience of the JWT token ('aud') */\n  readonly audience: readonly string[];\n  /** The identity associated with the JWT token, which is based on the sub and iss */\n  readonly identity: Identity;\n  /** The full payload as a JsonObject */\n  readonly fullPayload: JsonObject;\n}\n\n/**\n * Reducer context parametrized by the inferred Schema\n */\nexport type ReducerCtx<SchemaDef extends UntypedSchemaDef> = Readonly<{\n  sender: Identity;\n  identity: Identity;\n  timestamp: Timestamp;\n  connectionId: ConnectionId | null;\n  db: DbView<SchemaDef>;\n  senderAuth: AuthCtx;\n  newUuidV4(): Uuid;\n  newUuidV7(): Uuid;\n}>;\n\n/**\n * internal: pushReducer() helper used by reducer() and lifecycle wrappers\n *\n * @param name - The name of the reducer.\n * @param params - The parameters for the reducer.\n * @param fn - The reducer function.\n * @param lifecycle - Optional lifecycle hooks for the reducer.\n */\nexport function pushReducer(\n  name: string,\n  params: RowObj | RowBuilder<RowObj>,\n  fn: Reducer<any, any>,\n  lifecycle?: Infer<typeof RawReducerDefV9>['lifecycle']\n): void {\n  if (existingReducers.has(name)) {\n    throw new TypeError(`There is already a reducer with the name '${name}'`);\n  }\n  existingReducers.add(name);\n\n  if (!(params instanceof RowBuilder)) {\n    params = new RowBuilder(params);\n  }\n\n  if (params.typeName === undefined) {\n    params.typeName = toPascalCase(name);\n  }\n\n  const ref = registerTypesRecursively(params);\n  const paramsType = resolveType(MODULE_DEF.typespace, ref).value;\n\n  MODULE_DEF.reducers.push({\n    name,\n    params: paramsType,\n    lifecycle, // <- lifecycle flag lands here\n  });\n\n  // If the function isn't named (e.g. `function foobar() {}`), give it the same\n  // name as the reducer so that it's clear what it is in in backtraces.\n  if (!fn.name) {\n    Object.defineProperty(fn, 'name', { value: name, writable: false });\n  }\n\n  REDUCERS.push(fn);\n}\n\nconst existingReducers = new Set<string>();\nexport const REDUCERS: Reducer<any, any>[] = [];\n\n/**\n * Defines a SpacetimeDB reducer function.\n *\n * Reducers are the primary way to modify the state of your SpacetimeDB application.\n * They are atomic, meaning that either all operations within a reducer succeed,\n * or none of them do.\n *\n * @template S - The inferred schema type of the SpacetimeDB module.\n * @template Params - The type of the parameters object expected by the reducer.\n *\n * @param {string} name - The name of the reducer. This name will be used to call the reducer from clients.\n * @param {Params} params - An object defining the parameters that the reducer accepts.\n *                          Each key-value pair represents a parameter name and its corresponding\n *                          {@link TypeBuilder} or {@link ColumnBuilder}.\n * @param {(ctx: ReducerCtx<S>, payload: ParamsAsObject<Params>) => void} fn - The reducer function itself.\n *   - `ctx`: The reducer context, providing access to `sender`, `timestamp`, `connection_id`, and `db`.\n *   - `payload`: An object containing the arguments passed to the reducer, typed according to `params`.\n *\n * @example\n * ```typescript\n * // Define a reducer named 'create_user' that takes 'username' (string) and 'email' (string)\n * reducer(\n *   'create_user',\n *   {\n *     username: t.string(),\n *     email: t.string(),\n *   },\n *   (ctx, { username, email }) => {\n *     // Access the 'user' table from the database view in the context\n *     ctx.db.user.insert({ username, email, created_at: ctx.timestamp });\n *     console.log(`User ${username} created by ${ctx.sender.identityId}`);\n *   }\n * );\n * ```\n */\nexport function reducer<S extends UntypedSchemaDef, Params extends ParamsObj>(\n  name: string,\n  params: Params,\n  fn: (ctx: ReducerCtx<S>, payload: ParamsAsObject<Params>) => void\n): void {\n  pushReducer(name, params, fn);\n}\n\n/**\n * Registers an initialization reducer that runs when the SpacetimeDB module is published\n * for the first time.\n * This function is useful to set up any initial state of your database that is guaranteed\n * to run only once, and before any other reducers or client connections.\n * @template S - The inferred schema type of the SpacetimeDB module.\n * @template Params - The type of the parameters object expected by the initialization reducer.\n *\n * @param params - The parameters object defining the expected input for the initialization reducer.\n * @param fn - The initialization reducer function.\n * - `ctx`: The reducer context, providing access to `sender`, `timestamp`, `connection_id`, and `db`.\n */\nexport function init<S extends UntypedSchemaDef, Params extends ParamsObj>(\n  name: string,\n  params: Params,\n  fn: Reducer<S, Params>\n): void {\n  pushReducer(name, params, fn, Lifecycle.Init);\n}\n\n/**\n * Registers a reducer to be called when a client connects to the SpacetimeDB module.\n * This function allows you to define custom logic that should execute\n * whenever a new client establishes a connection.\n * @template S - The inferred schema type of the SpacetimeDB module.\n * @template Params - The type of the parameters object expected by the connection reducer.\n * @param params - The parameters object defining the expected input for the connection reducer.\n * @param fn - The connection reducer function itself.\n */\nexport function clientConnected<\n  S extends UntypedSchemaDef,\n  Params extends ParamsObj,\n>(name: string, params: Params, fn: Reducer<S, Params>): void {\n  pushReducer(name, params, fn, Lifecycle.OnConnect);\n}\n\n/**\n * Registers a reducer to be called when a client disconnects from the SpacetimeDB module.\n * This function allows you to define custom logic that should execute\n * whenever a client disconnects.\n *\n * @template S - The inferred schema type of the SpacetimeDB module.\n * @template Params - The type of the parameters object expected by the disconnection reducer.\n * @param params - The parameters object defining the expected input for the disconnection reducer.\n * @param fn - The disconnection reducer function itself.\n * @example\n * ```typescript\n * spacetime.clientDisconnected(\n *   { reason: t.string() },\n *   (ctx, { reason }) => {\n *      console.log(`Client ${ctx.connection_id} disconnected: ${reason}`);\n *   }\n * );\n * ```\n */\nexport function clientDisconnected<\n  S extends UntypedSchemaDef,\n  Params extends ParamsObj,\n>(name: string, params: Params, fn: Reducer<S, Params>): void {\n  pushReducer(name, params, fn, Lifecycle.OnDisconnect);\n}\n\nclass Reducers<ReducersDef extends UntypedReducersDef> {\n  reducersType: ReducersDef;\n\n  constructor(handles: readonly ReducerSchema<any, any>[]) {\n    this.reducersType = reducersToSchema(handles) as ReducersDef;\n  }\n}\n\n/**\n * Helper type to convert an array of TableSchema into a schema definition\n */\ntype ReducersToSchema<T extends readonly ReducerSchema<any, any>[]> = {\n  reducers: {\n    /** @type {UntypedReducerDef} */\n    readonly [i in keyof T]: {\n      name: T[i]['reducerName'];\n      accessorName: CamelCase<T[i]['accessorName']>;\n      params: T[i]['params']['row'];\n      paramsType: T[i]['paramsSpacetimeType'];\n    };\n  };\n};\n\nexport function reducersToSchema<\n  const T extends readonly ReducerSchema<any, any>[],\n>(reducers: T): ReducersToSchema<T> {\n  const mapped = reducers.map(r => {\n    const paramsRow = r.params.row;\n\n    return {\n      name: r.reducerName,\n      // Prefer the schema's own accessorName if present at runtime; otherwise derive it.\n      accessorName: r.accessorName,\n      params: paramsRow,\n      paramsType: r.paramsSpacetimeType,\n    } as const;\n  }) as {\n    readonly [I in keyof T]: {\n      name: T[I]['reducerName'];\n      accessorName: T[I]['accessorName'];\n      params: T[I]['params']['row'];\n      paramsType: T[I]['paramsSpacetimeType'];\n    };\n  };\n\n  const result = { reducers: mapped } satisfies ReducersToSchema<T>;\n  return result;\n}\n\n/**\n * Creates a schema from table definitions\n * @param handles - Array of table handles created by table() function\n * @returns ColumnBuilder representing the complete database schema\n * @example\n * ```ts\n * const s = schema(\n *   table({ name: 'user' }, userType),\n *   table({ name: 'post' }, postType)\n * );\n * ```\n */\nexport function reducers<const H extends readonly ReducerSchema<any, any>[]>(\n  ...handles: H\n): Reducers<ReducersToSchema<H>>;\n\n/**\n * Creates a schema from table definitions (array overload)\n * @param handles - Array of table handles created by table() function\n * @returns ColumnBuilder representing the complete database schema\n */\nexport function reducers<const H extends readonly ReducerSchema<any, any>[]>(\n  handles: H\n): Reducers<ReducersToSchema<H>>;\n\nexport function reducers<const H extends readonly ReducerSchema<any, any>[]>(\n  ...args: [H] | H\n): Reducers<ReducersToSchema<H>> {\n  const handles = (\n    args.length === 1 && Array.isArray(args[0]) ? args[0] : args\n  ) as H;\n  return new Reducers(handles);\n}\n\nexport function reducerSchema<\n  ReducerName extends string,\n  Params extends ParamsObj,\n>(name: ReducerName, params: Params): ReducerSchema<ReducerName, Params> {\n  const paramType: ProductType = {\n    elements: Object.entries(params).map(([n, c]) => ({\n      name: n,\n      algebraicType:\n        'typeBuilder' in c ? c.typeBuilder.algebraicType : c.algebraicType,\n    })),\n  };\n  return {\n    reducerName: name,\n    accessorName: toCamelCase(name),\n    params: new RowBuilder<Params>(params),\n    paramsSpacetimeType: paramType,\n    reducerDef: {\n      name,\n      params: paramType,\n      lifecycle: undefined,\n    },\n  };\n}\n","import {\n  AlgebraicType,\n  type AlgebraicTypeVariants,\n  type ProductType,\n} from '../lib/algebraic_type';\nimport type { Identity } from '../lib/identity';\nimport type { OptionAlgebraicType } from '../lib/option';\nimport type { ParamsObj } from './reducers';\nimport {\n  MODULE_DEF,\n  registerTypesRecursively,\n  resolveType,\n  type UntypedSchemaDef,\n} from './schema';\nimport type { ReadonlyTable } from './table';\nimport {\n  RowBuilder,\n  type Infer,\n  type InferSpacetimeTypeOfTypeBuilder,\n  type InferTypeOfRow,\n  type TypeBuilder,\n} from './type_builders';\nimport { bsatnBaseSize, toPascalCase } from './util';\nimport { type QueryBuilder, type RowTypedQuery } from '../server/query';\n\nexport type ViewCtx<S extends UntypedSchemaDef> = Readonly<{\n  sender: Identity;\n  db: ReadonlyDbView<S>;\n  from: QueryBuilder<S>;\n}>;\n\nexport type AnonymousViewCtx<S extends UntypedSchemaDef> = Readonly<{\n  db: ReadonlyDbView<S>;\n  from: QueryBuilder<S>;\n}>;\n\nexport type ReadonlyDbView<SchemaDef extends UntypedSchemaDef> = {\n  readonly [Tbl in SchemaDef['tables'][number] as Tbl['name']]: ReadonlyTable<Tbl>;\n};\n\nexport type ViewOpts = {\n  name: string;\n  public: true;\n};\n\ntype FlattenedArray<T> = T extends readonly (infer E)[] ? E : never;\n\n// // If we allowed functions to return either.\n// type ViewReturn<Ret extends ViewReturnTypeBuilder> =\n//   | Infer<Ret>\n//   | RowTypedQuery<FlattenedArray<Infer<Ret>>>;\n\nexport type ViewFn<\n  S extends UntypedSchemaDef,\n  Params extends ParamsObj,\n  Ret extends ViewReturnTypeBuilder,\n> =\n  | ((ctx: ViewCtx<S>, params: InferTypeOfRow<Params>) => Infer<Ret>)\n  | ((\n      ctx: ViewCtx<S>,\n      params: InferTypeOfRow<Params>\n    ) => RowTypedQuery<FlattenedArray<Infer<Ret>>, ExtractArrayProduct<Ret>>);\n\nexport type AnonymousViewFn<\n  S extends UntypedSchemaDef,\n  Params extends ParamsObj,\n  Ret extends ViewReturnTypeBuilder,\n> =\n  | ((ctx: AnonymousViewCtx<S>, params: InferTypeOfRow<Params>) => Infer<Ret>)\n  | ((\n      ctx: AnonymousViewCtx<S>,\n      params: InferTypeOfRow<Params>\n    ) => RowTypedQuery<FlattenedArray<Infer<Ret>>, ExtractArrayProduct<Ret>>);\n\nexport type ViewReturnTypeBuilder =\n  | TypeBuilder<\n      readonly object[],\n      { tag: 'Array'; value: AlgebraicTypeVariants.Product }\n    >\n  | TypeBuilder<\n      object | undefined,\n      OptionAlgebraicType<AlgebraicTypeVariants.Product>\n    >;\n\nexport function defineView<\n  S extends UntypedSchemaDef,\n  const Anonymous extends boolean,\n  Params extends ParamsObj,\n  Ret extends ViewReturnTypeBuilder,\n>(\n  opts: ViewOpts,\n  anon: Anonymous,\n  params: Params,\n  ret: Ret,\n  fn: Anonymous extends true\n    ? AnonymousViewFn<S, Params, Ret>\n    : ViewFn<S, Params, Ret>\n) {\n  const paramsBuilder = new RowBuilder(params, toPascalCase(opts.name));\n\n  // Register return types if they are product types\n  let returnType = registerTypesRecursively(ret).algebraicType;\n\n  const { value: paramType } = resolveType(\n    MODULE_DEF.typespace,\n    registerTypesRecursively(paramsBuilder)\n  );\n\n  MODULE_DEF.miscExports.push({\n    tag: 'View',\n    value: {\n      name: opts.name,\n      index: (anon ? ANON_VIEWS : VIEWS).length,\n      isPublic: opts.public,\n      isAnonymous: anon,\n      params: paramType,\n      returnType,\n    },\n  });\n\n  // If it is an option, we wrap the function to make the return look like an array.\n  if (returnType.tag == 'Sum') {\n    const originalFn = fn;\n    fn = ((ctx: ViewCtx<S>, args: InferTypeOfRow<Params>) => {\n      const ret = originalFn(ctx, args);\n      return ret == null ? [] : [ret];\n    }) as any;\n    returnType = AlgebraicType.Array(\n      returnType.value.variants[0].algebraicType\n    );\n  }\n\n  (anon ? ANON_VIEWS : VIEWS).push({\n    fn,\n    params: paramType,\n    returnType,\n    returnTypeBaseSize: bsatnBaseSize(MODULE_DEF.typespace, returnType),\n  });\n}\n\ntype ViewInfo<F> = {\n  fn: F;\n  params: ProductType;\n  returnType: AlgebraicType;\n  returnTypeBaseSize: number;\n};\n\nexport const VIEWS: ViewInfo<ViewFn<any, any, any>>[] = [];\nexport const ANON_VIEWS: ViewInfo<AnonymousViewFn<any, any, any>>[] = [];\n\n// A helper to get the product type out of a type builder.\n// This is only non-never if the type builder is an array.\ntype ExtractArrayProduct<T extends TypeBuilder<any, any>> =\n  InferSpacetimeTypeOfTypeBuilder<T> extends { tag: 'Array'; value: infer V }\n    ? V extends { tag: 'Product'; value: infer P }\n      ? P\n      : never\n    : never;\n","import { AlgebraicType, ProductType } from '../lib/algebraic_type';\nimport type { ConnectionId } from '../lib/connection_id';\nimport type { Identity } from '../lib/identity';\nimport type { Timestamp } from '../lib/timestamp';\nimport type { HttpClient } from '../server/http_internal';\nimport type { ParamsObj, ReducerCtx } from './reducers';\nimport {\n  MODULE_DEF,\n  registerTypesRecursively,\n  type UntypedSchemaDef,\n} from './schema';\nimport {\n  type Infer,\n  type InferTypeOfRow,\n  type TypeBuilder,\n} from './type_builders';\nimport type { CamelCase } from './type_util';\nimport {\n  bsatnBaseSize,\n  coerceParams,\n  toCamelCase,\n  type CoerceParams,\n} from './util';\nimport type { Uuid } from './uuid';\n\nexport type ProcedureFn<\n  S extends UntypedSchemaDef,\n  Params extends ParamsObj,\n  Ret extends TypeBuilder<any, any>,\n> = (ctx: ProcedureCtx<S>, args: InferTypeOfRow<Params>) => Infer<Ret>;\n\nexport interface ProcedureCtx<S extends UntypedSchemaDef> {\n  readonly sender: Identity;\n  readonly identity: Identity;\n  readonly timestamp: Timestamp;\n  readonly connectionId: ConnectionId | null;\n  readonly http: HttpClient;\n  readonly counter_uuid: { value: number };\n  withTx<T>(body: (ctx: TransactionCtx<S>) => T): T;\n  newUuidV4(): Uuid;\n  newUuidV7(): Uuid;\n}\n\n// eslint-disable-next-line @typescript-eslint/no-empty-object-type\nexport interface TransactionCtx<S extends UntypedSchemaDef>\n  extends ReducerCtx<S> {}\n\nexport function procedure<\n  S extends UntypedSchemaDef,\n  Params extends ParamsObj,\n  Ret extends TypeBuilder<any, any>,\n>(name: string, params: Params, ret: Ret, fn: ProcedureFn<S, Params, Ret>) {\n  const paramsType: ProductType = {\n    elements: Object.entries(params).map(([n, c]) => ({\n      name: n,\n      algebraicType: registerTypesRecursively(\n        'typeBuilder' in c ? c.typeBuilder : c\n      ).algebraicType,\n    })),\n  };\n  const returnType = registerTypesRecursively(ret).algebraicType;\n\n  MODULE_DEF.miscExports.push({\n    tag: 'Procedure',\n    value: {\n      name,\n      params: paramsType,\n      returnType,\n    },\n  });\n\n  PROCEDURES.push({\n    fn,\n    paramsType,\n    returnType,\n    returnTypeBaseSize: bsatnBaseSize(MODULE_DEF.typespace, returnType),\n  });\n}\n\nexport const PROCEDURES: Array<{\n  fn: ProcedureFn<any, any, any>;\n  paramsType: ProductType;\n  returnType: AlgebraicType;\n  returnTypeBaseSize: number;\n}> = [];\n\nexport type UntypedProcedureDef = {\n  name: string;\n  accessorName: string;\n  params: CoerceParams<ParamsObj>;\n  returnType: TypeBuilder<any, any>;\n};\n\nexport type UntypedProceduresDef = {\n  procedures: readonly UntypedProcedureDef[];\n};\n\nexport function procedures<const H extends readonly UntypedProcedureDef[]>(\n  ...handles: H\n): { procedures: H };\n\nexport function procedures<const H extends readonly UntypedProcedureDef[]>(\n  handles: H\n): { procedures: H };\n\nexport function procedures<const H extends readonly UntypedProcedureDef[]>(\n  ...args: [H] | H\n): { procedures: H } {\n  const procedures = (\n    args.length === 1 && Array.isArray(args[0]) ? args[0] : args\n  ) as H;\n  return { procedures };\n}\n\ntype ProcedureDef<\n  Name extends string,\n  Params extends ParamsObj,\n  ReturnType extends TypeBuilder<any, any>,\n> = {\n  name: Name;\n  accessorName: CamelCase<Name>;\n  params: CoerceParams<Params>;\n  returnType: ReturnType;\n};\n\nexport function procedureSchema<\n  ProcedureName extends string,\n  Params extends ParamsObj,\n  ReturnType extends TypeBuilder<any, any>,\n>(\n  name: ProcedureName,\n  params: Params,\n  returnType: ReturnType\n): ProcedureDef<ProcedureName, Params, ReturnType> {\n  return {\n    name,\n    accessorName: toCamelCase(name),\n    params: coerceParams(params),\n    returnType,\n  };\n}\n","import type RawTableDefV9 from './autogen/raw_table_def_v_9_type';\nimport type Typespace from './autogen/typespace_type';\nimport {\n  ArrayBuilder,\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  ColumnBuilder,\n  OptionBuilder,\n  ProductBuilder,\n  RefBuilder,\n  RowBuilder,\n  SumBuilder,\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  TypeBuilder,\n  type ElementsObj,\n  type Infer,\n  type InferSpacetimeTypeOfTypeBuilder,\n  type RowObj,\n  type VariantsObj,\n  ResultBuilder,\n} from './type_builders';\nimport type { UntypedTableDef } from './table';\nimport {\n  clientConnected,\n  clientDisconnected,\n  init,\n  reducer,\n  type ParamsObj,\n  type Reducer,\n} from './reducers';\nimport type RawModuleDefV9 from './autogen/raw_module_def_v_9_type';\nimport {\n  AlgebraicType,\n  ProductType,\n  SumType,\n  type AlgebraicTypeType,\n  type AlgebraicTypeVariants,\n} from './algebraic_type';\nimport type RawScopedTypeNameV9 from './autogen/raw_scoped_type_name_v_9_type';\nimport type { CamelCase } from './type_util';\nimport type { UntypedTableSchema } from './table_schema';\nimport { toCamelCase } from './util';\nimport {\n  defineView,\n  type AnonymousViewFn,\n  type ViewFn,\n  type ViewOpts,\n  type ViewReturnTypeBuilder,\n} from './views';\nimport type { UntypedIndex } from './indexes';\nimport { procedure, type ProcedureFn } from './procedures';\n\nexport type TableNamesOf<S extends UntypedSchemaDef> =\n  S['tables'][number]['name'];\n\n/**\n * An untyped representation of the database schema.\n */\nexport type UntypedSchemaDef = {\n  tables: readonly UntypedTableDef[];\n};\n\nlet REGISTERED_SCHEMA: UntypedSchemaDef | null = null;\n\nexport function getRegisteredSchema(): UntypedSchemaDef {\n  if (REGISTERED_SCHEMA == null) {\n    throw new Error('Schema has not been registered yet. Call schema() first.');\n  }\n  return REGISTERED_SCHEMA;\n}\n\n/**\n * Helper type to convert an array of TableSchema into a schema definition\n */\ntype TablesToSchema<T extends readonly UntypedTableSchema[]> = {\n  tables: {\n    readonly [i in keyof T]: TableToSchema<T[i]>;\n  };\n};\n\ninterface TableToSchema<T extends UntypedTableSchema> extends UntypedTableDef {\n  name: T['tableName'];\n  accessorName: CamelCase<T['tableName']>;\n  columns: T['rowType']['row'];\n  rowType: T['rowSpacetimeType'];\n  indexes: T['idxs'];\n  constraints: T['constraints'];\n}\n\nexport function tablesToSchema<const T extends readonly UntypedTableSchema[]>(\n  tables: T\n): TablesToSchema<T> {\n  return { tables: tables.map(tableToSchema) as TablesToSchema<T>['tables'] };\n}\n\nfunction tableToSchema<T extends UntypedTableSchema>(\n  schema: T\n): TableToSchema<T> {\n  const getColName = (i: number) =>\n    schema.rowType.algebraicType.value.elements[i].name;\n\n  type AllowedCol = keyof T['rowType']['row'] & string;\n  return {\n    name: schema.tableName,\n    accessorName: toCamelCase(schema.tableName as T['tableName']),\n    columns: schema.rowType.row, // typed as T[i]['rowType']['row'] under TablesToSchema<T>\n    rowType: schema.rowSpacetimeType,\n    constraints: schema.tableDef.constraints.map(c => ({\n      name: c.name,\n      constraint: 'unique',\n      columns: c.data.value.columns.map(getColName) as [string],\n    })),\n    // TODO: horrible horrible horrible. we smuggle this `Array<UntypedIndex>`\n    // by casting it to an `Array<IndexOpts>` as `TableToSchema` expects.\n    // This is then used in `TableCacheImpl.constructor` and who knows where else.\n    // We should stop lying about our types.\n    indexes: schema.tableDef.indexes.map((idx): UntypedIndex<AllowedCol> => {\n      const columnIds =\n        idx.algorithm.tag === 'Direct'\n          ? [idx.algorithm.value]\n          : idx.algorithm.value;\n      return {\n        name: idx.accessorName!,\n        unique: schema.tableDef.constraints.some(c =>\n          c.data.value.columns.every(col => columnIds.includes(col))\n        ),\n        algorithm: idx.algorithm.tag.toLowerCase() as 'btree',\n        columns: columnIds.map(getColName),\n      };\n    }) as T['idxs'],\n  };\n}\n\n/**\n * The global module definition that gets populated by calls to `reducer()` and lifecycle hooks.\n */\nexport const MODULE_DEF: Infer<typeof RawModuleDefV9> = {\n  typespace: { types: [] },\n  tables: [],\n  reducers: [],\n  types: [],\n  miscExports: [],\n  rowLevelSecurity: [],\n};\n\nconst COMPOUND_TYPES = new Map<\n  AlgebraicTypeVariants.Product | AlgebraicTypeVariants.Sum,\n  RefBuilder<any, any>\n>();\n\n/**\n * Resolves the actual type of a TypeBuilder by following its references until it reaches a non-ref type.\n * @param typespace The typespace to resolve types against.\n * @param typeBuilder The TypeBuilder to resolve.\n * @returns The resolved algebraic type.\n */\nexport function resolveType<AT extends AlgebraicTypeType>(\n  typespace: Infer<typeof Typespace>,\n  typeBuilder: RefBuilder<any, AT>\n): AT {\n  let ty: AlgebraicType = typeBuilder.algebraicType;\n  while (ty.tag === 'Ref') {\n    ty = typespace.types[ty.value];\n  }\n  return ty as AT;\n}\n\n/**\n * Adds a type to the module definition's typespace as a `Ref` if it is a named compound type (Product or Sum).\n * Otherwise, returns the type as is.\n * @param name\n * @param ty\n * @returns\n */\nexport function registerTypesRecursively<\n  T extends TypeBuilder<any, AlgebraicType>,\n>(\n  typeBuilder: T\n): T extends SumBuilder<any> | ProductBuilder<any> | RowBuilder<any>\n  ? RefBuilder<Infer<T>, InferSpacetimeTypeOfTypeBuilder<T>>\n  : T {\n  if (\n    (typeBuilder instanceof ProductBuilder && !isUnit(typeBuilder)) ||\n    typeBuilder instanceof SumBuilder ||\n    typeBuilder instanceof RowBuilder\n  ) {\n    return registerCompoundTypeRecursively(typeBuilder) as any;\n  } else if (typeBuilder instanceof OptionBuilder) {\n    return new OptionBuilder(\n      registerTypesRecursively(typeBuilder.value)\n    ) as any;\n  } else if (typeBuilder instanceof ResultBuilder) {\n    return new ResultBuilder(\n      registerTypesRecursively(typeBuilder.ok),\n      registerTypesRecursively(typeBuilder.err)\n    ) as any;\n  } else if (typeBuilder instanceof ArrayBuilder) {\n    return new ArrayBuilder(\n      registerTypesRecursively(typeBuilder.element)\n    ) as any;\n  } else {\n    return typeBuilder as any;\n  }\n}\n\nfunction registerCompoundTypeRecursively<\n  T extends\n    | SumBuilder<VariantsObj>\n    | ProductBuilder<ElementsObj>\n    | RowBuilder<RowObj>,\n>(typeBuilder: T): RefBuilder<Infer<T>, InferSpacetimeTypeOfTypeBuilder<T>> {\n  const ty = typeBuilder.algebraicType;\n  // NB! You must ensure that all TypeBuilder passed into this function\n  // have a name. This function ensures that nested types always have a\n  // name by assigning them one if they are missing it.\n  const name = typeBuilder.typeName;\n  if (name === undefined) {\n    throw new Error(\n      `Missing type name for ${typeBuilder.constructor.name ?? 'TypeBuilder'} ${JSON.stringify(typeBuilder)}`\n    );\n  }\n\n  let r = COMPOUND_TYPES.get(ty);\n  if (r != null) {\n    // Already added to typespace\n    return r;\n  }\n\n  // Recursively register nested compound types\n  const newTy =\n    typeBuilder instanceof RowBuilder || typeBuilder instanceof ProductBuilder\n      ? ({\n          tag: 'Product',\n          value: { elements: [] },\n        } as AlgebraicTypeVariants.Product)\n      : ({ tag: 'Sum', value: { variants: [] } } as AlgebraicTypeVariants.Sum);\n\n  r = new RefBuilder(MODULE_DEF.typespace.types.length);\n  MODULE_DEF.typespace.types.push(newTy);\n\n  COMPOUND_TYPES.set(ty, r);\n\n  if (typeBuilder instanceof RowBuilder) {\n    for (const [name, elem] of Object.entries(typeBuilder.row)) {\n      (newTy.value as ProductType).elements.push({\n        name,\n        algebraicType: registerTypesRecursively(elem.typeBuilder).algebraicType,\n      });\n    }\n  } else if (typeBuilder instanceof ProductBuilder) {\n    for (const [name, elem] of Object.entries(typeBuilder.elements)) {\n      (newTy.value as ProductType).elements.push({\n        name,\n        algebraicType: registerTypesRecursively(elem).algebraicType,\n      });\n    }\n  } else if (typeBuilder instanceof SumBuilder) {\n    for (const [name, variant] of Object.entries(typeBuilder.variants)) {\n      (newTy.value as SumType).variants.push({\n        name,\n        algebraicType: registerTypesRecursively(variant).algebraicType,\n      });\n    }\n  }\n\n  MODULE_DEF.types.push({\n    name: splitName(name),\n    ty: r.ref,\n    customOrdering: true,\n  });\n\n  return r;\n}\n\nfunction isUnit(typeBuilder: ProductBuilder<ElementsObj>): boolean {\n  return (\n    typeBuilder.typeName == null &&\n    typeBuilder.algebraicType.value.elements.length === 0\n  );\n}\n\nexport function splitName(name: string): Infer<typeof RawScopedTypeNameV9> {\n  const scope = name.split('.');\n  return { name: scope.pop()!, scope };\n}\n\n/**\n * The Schema class represents the database schema for a SpacetimeDB application.\n * It encapsulates the table definitions and typespace, and provides methods to define\n * reducers and lifecycle hooks.\n *\n * Schema has a generic parameter S which represents the inferred schema type. This type\n * is automatically inferred when creating a schema using the `schema()` function and is\n * used to type the database view in reducer contexts.\n *\n * The methods on this class are used to register reducers and lifecycle hooks\n * with the SpacetimeDB runtime. Theey forward to free functions that handle the actual\n * registration logic, but having them as methods on the Schema class helps with type inference.\n *\n * @template S - The inferred schema type of the SpacetimeDB module.\n *\n * @example\n * ```typescript\n * const spacetime = schema(\n *   table({ name: 'user' }, userType),\n *   table({ name: 'post' }, postType)\n * );\n * spacetime.reducer(\n *   'create_user',\n *   {  username: t.string(), email: t.string() },\n *   (ctx, { username, email }) => {\n *     ctx.db.user.insert({ username, email, created_at: ctx.timestamp });\n *     console.log(`User ${username} created by ${ctx.sender.identityId}`);\n *   }\n * );\n * ```\n */\n// TODO(cloutiertyler): It might be nice to have a way to access the types\n// for the tables from the schema object, e.g. `spacetimedb.user.type` would\n// be the type of the user table.\nclass Schema<S extends UntypedSchemaDef> {\n  readonly tablesDef: { tables: Infer<typeof RawTableDefV9>[] };\n  readonly typespace: Infer<typeof Typespace>;\n  readonly schemaType: S;\n\n  constructor(\n    tables: Infer<typeof RawTableDefV9>[],\n    typespace: Infer<typeof Typespace>,\n    handles: readonly UntypedTableSchema[]\n  ) {\n    this.tablesDef = { tables };\n    this.typespace = typespace;\n    // TODO: TableSchema and TableDef should really be unified\n    this.schemaType = tablesToSchema(handles) as S;\n  }\n\n  /**\n   * Defines a SpacetimeDB reducer function.\n   *\n   * Reducers are the primary way to modify the state of your SpacetimeDB application.\n   * They are atomic, meaning that either all operations within a reducer succeed,\n   * or none of them do.\n   *\n   * @template S - The inferred schema type of the SpacetimeDB module.\n   * @template Params - The type of the parameters object expected by the reducer.\n   *\n   * @param {string} name - The name of the reducer. This name will be used to call the reducer from clients.\n   * @param {Params} params - An object defining the parameters that the reducer accepts.\n   *                          Each key-value pair represents a parameter name and its corresponding\n   *                          {@link TypeBuilder} or {@link ColumnBuilder}.\n   * @param {(ctx: ReducerCtx<S>, payload: ParamsAsObject<Params>) => void} fn - The reducer function itself.\n   *   - `ctx`: The reducer context, providing access to `sender`, `timestamp`, `connection_id`, and `db`.\n   *   - `payload`: An object containing the arguments passed to the reducer, typed according to `params`.\n   *\n   * @example\n   * ```typescript\n   * // Define a reducer named 'create_user' that takes 'username' (string) and 'email' (string)\n   * spacetime.reducer(\n   *   'create_user',\n   *   {\n   *     username: t.string(),\n   *     email: t.string(),\n   *   },\n   *   (ctx, { username, email }) => {\n   *     // Access the 'user' table from the database view in the context\n   *     ctx.db.user.insert({ username, email, created_at: ctx.timestamp });\n   *     console.log(`User ${username} created by ${ctx.sender.identityId}`);\n   *   }\n   * );\n   * ```\n   */\n  reducer<Params extends ParamsObj>(\n    name: string,\n    params: Params,\n    fn: Reducer<S, Params>\n  ): Reducer<S, Params>;\n  reducer(name: string, fn: Reducer<S, {}>): Reducer<S, {}>;\n  reducer<Params extends ParamsObj>(\n    name: string,\n    paramsOrFn: Params | Reducer<S, any>,\n    fn?: Reducer<S, Params>\n  ): Reducer<S, Params> {\n    if (typeof paramsOrFn === 'function') {\n      // This is the case where params are omitted.\n      // The second argument is the reducer function.\n      // We pass an empty object for the params.\n      reducer(name, {}, paramsOrFn);\n      return paramsOrFn;\n    } else {\n      // This is the case where params are provided.\n      // The second argument is the params object, and the third is the function.\n      // The `fn` parameter is guaranteed to be defined here.\n      reducer(name, paramsOrFn, fn!);\n      return fn!;\n    }\n  }\n\n  /**\n   * Registers an initialization reducer that runs when the SpacetimeDB module is published\n   * for the first time.\n   *\n   * This function is useful to set up any initial state of your database that is guaranteed\n   * to run only once, and before any other reducers or client connections.\n   *\n   * @template S - The inferred schema type of the SpacetimeDB module.\n   * @param {Reducer<S, {}>} fn - The initialization reducer function.\n   *  - `ctx`: The reducer context, providing access to `sender`, `timestamp`, `connection_id`, and `db`.\n   * @example\n   * ```typescript\n   * spacetime.init((ctx) => {\n   *   ctx.db.user.insert({ username: 'admin', email: 'admin@example.com' });\n   * });\n   * ```\n   */\n  init(fn: Reducer<S, {}>): void;\n  init(name: string, fn: Reducer<S, {}>): void;\n  init(nameOrFn: any, maybeFn?: Reducer<S, {}>): void {\n    const [name, fn] =\n      typeof nameOrFn === 'string' ? [nameOrFn, maybeFn] : ['init', nameOrFn];\n    init(name, {}, fn);\n  }\n\n  /**\n   * Registers a reducer to be called when a client connects to the SpacetimeDB module.\n   * This function allows you to define custom logic that should execute\n   * whenever a new client establishes a connection.\n   * @template S - The inferred schema type of the SpacetimeDB module.\n   *\n   * @param fn - The reducer function to execute on client connection.\n   *\n   * @example\n   * ```typescript\n   * spacetime.clientConnected(\n   *   (ctx) => {\n   *     console.log(`Client ${ctx.connectionId} connected`);\n   *   }\n   * );\n   */\n  clientConnected(fn: Reducer<S, {}>): void;\n  clientConnected(name: string, fn: Reducer<S, {}>): void;\n  clientConnected(nameOrFn: any, maybeFn?: Reducer<S, {}>): void {\n    const [name, fn] =\n      typeof nameOrFn === 'string'\n        ? [nameOrFn, maybeFn]\n        : ['on_connect', nameOrFn];\n    clientConnected(name, {}, fn);\n  }\n\n  /**\n   * Registers a reducer to be called when a client disconnects from the SpacetimeDB module.\n   * This function allows you to define custom logic that should execute\n   * whenever a client disconnects.\n   * @template S - The inferred schema type of the SpacetimeDB module.\n   *\n   * @param fn - The reducer function to execute on client disconnection.\n   *\n   * @example\n   * ```typescript\n   * spacetime.clientDisconnected(\n   *   (ctx) => {\n   *     console.log(`Client ${ctx.connectionId} disconnected`);\n   *   }\n   * );\n   * ```\n   */\n  clientDisconnected(fn: Reducer<S, {}>): void;\n  clientDisconnected(name: string, fn: Reducer<S, {}>): void;\n  clientDisconnected(nameOrFn: any, maybeFn?: Reducer<S, {}>): void {\n    const [name, fn] =\n      typeof nameOrFn === 'string'\n        ? [nameOrFn, maybeFn]\n        : ['on_disconnect', nameOrFn];\n    clientDisconnected(name, {}, fn);\n  }\n\n  view<Ret extends ViewReturnTypeBuilder>(\n    opts: ViewOpts,\n    ret: Ret,\n    fn: ViewFn<S, {}, Ret>\n  ): void {\n    defineView(opts, false, {}, ret, fn);\n  }\n\n  // TODO: re-enable once parameterized views are supported in SQL\n  // view<Ret extends ViewReturnTypeBuilder>(\n  //   opts: ViewOpts,\n  //   ret: Ret,\n  //   fn: ViewFn<S, {}, Ret>\n  // ): void;\n  // view<Params extends ParamsObj, Ret extends ViewReturnTypeBuilder>(\n  //   opts: ViewOpts,\n  //   params: Params,\n  //   ret: Ret,\n  //   fn: ViewFn<S, {}, Ret>\n  // ): void;\n  // view<Params extends ParamsObj, Ret extends ViewReturnTypeBuilder>(\n  //   opts: ViewOpts,\n  //   paramsOrRet: Ret | Params,\n  //   retOrFn: ViewFn<S, {}, Ret> | Ret,\n  //   maybeFn?: ViewFn<S, Params, Ret>\n  // ): void {\n  //   if (typeof retOrFn === 'function') {\n  //     defineView(name, false, {}, paramsOrRet as Ret, retOrFn);\n  //   } else {\n  //     defineView(name, false, paramsOrRet as Params, retOrFn, maybeFn!);\n  //   }\n  // }\n\n  anonymousView<Ret extends ViewReturnTypeBuilder>(\n    opts: ViewOpts,\n    ret: Ret,\n    fn: AnonymousViewFn<S, {}, Ret>\n  ): void {\n    defineView(opts, true, {}, ret, fn);\n  }\n\n  // TODO: re-enable once parameterized views are supported in SQL\n  // anonymousView<Ret extends ViewReturnTypeBuilder>(\n  //   opts: ViewOpts,\n  //   ret: Ret,\n  //   fn: AnonymousViewFn<S, {}, Ret>\n  // ): void;\n  // anonymousView<Params extends ParamsObj, Ret extends ViewReturnTypeBuilder>(\n  //   opts: ViewOpts,\n  //   params: Params,\n  //   ret: Ret,\n  //   fn: AnonymousViewFn<S, {}, Ret>\n  // ): void;\n  // anonymousView<Params extends ParamsObj, Ret extends ViewReturnTypeBuilder>(\n  //   opts: ViewOpts,\n  //   paramsOrRet: Ret | Params,\n  //   retOrFn: AnonymousViewFn<S, {}, Ret> | Ret,\n  //   maybeFn?: AnonymousViewFn<S, Params, Ret>\n  // ): void {\n  //   if (typeof retOrFn === 'function') {\n  //     defineView(name, true, {}, paramsOrRet as Ret, retOrFn);\n  //   } else {\n  //     defineView(name, true, paramsOrRet as Params, retOrFn, maybeFn!);\n  //   }\n  // }\n\n  procedure<Params extends ParamsObj, Ret extends TypeBuilder<any, any>>(\n    name: string,\n    params: Params,\n    ret: Ret,\n    fn: ProcedureFn<S, Params, Ret>\n  ): ProcedureFn<S, Params, Ret>;\n  procedure<Ret extends TypeBuilder<any, any>>(\n    name: string,\n    ret: Ret,\n    fn: ProcedureFn<S, {}, Ret>\n  ): ProcedureFn<S, {}, Ret>;\n  procedure<Params extends ParamsObj, Ret extends TypeBuilder<any, any>>(\n    name: string,\n    paramsOrRet: Ret | Params,\n    retOrFn: ProcedureFn<S, {}, Ret> | Ret,\n    maybeFn?: ProcedureFn<S, Params, Ret>\n  ): ProcedureFn<S, Params, Ret> {\n    if (typeof retOrFn === 'function') {\n      procedure(name, {}, paramsOrRet as Ret, retOrFn);\n      return retOrFn;\n    } else {\n      procedure(name, paramsOrRet as Params, retOrFn, maybeFn!);\n      return maybeFn!;\n    }\n  }\n\n  clientVisibilityFilter = {\n    sql(filter: string): void {\n      MODULE_DEF.rowLevelSecurity.push({ sql: filter });\n    },\n  };\n}\n\n/**\n * Extracts the inferred schema type from a Schema instance\n */\nexport type InferSchema<SchemaDef extends Schema<any>> =\n  SchemaDef extends Schema<infer S> ? S : never;\n\n/**\n * Creates a schema from table definitions\n * @param handles - Array of table handles created by table() function\n * @returns ColumnBuilder representing the complete database schema\n * @example\n * ```ts\n * const s = schema(\n *   table({ name: 'user' }, userType),\n *   table({ name: 'post' }, postType)\n * );\n * ```\n */\nexport function schema<const H extends readonly UntypedTableSchema[]>(\n  ...handles: H\n): Schema<TablesToSchema<H>>;\n\n/**\n * Creates a schema from table definitions (array overload)\n * @param handles - Array of table handles created by table() function\n * @returns ColumnBuilder representing the complete database schema\n */\nexport function schema<const H extends readonly UntypedTableSchema[]>(\n  handles: H\n): Schema<TablesToSchema<H>>;\n\n/**\n * Creates a schema from table definitions\n * @param args - Either an array of table handles or a variadic list of table handles\n * @returns ColumnBuilder representing the complete database schema\n * @example\n * ```ts\n * const s = schema(\n *  table({ name: 'user' }, userType),\n *  table({ name: 'post' }, postType)\n * );\n * ```\n */\nexport function schema<const H extends readonly UntypedTableSchema[]>(\n  ...args: [H] | H\n): Schema<TablesToSchema<H>> {\n  const handles = (\n    args.length === 1 && Array.isArray(args[0]) ? args[0] : args\n  ) as H;\n  const tableDefs = handles.map(h => h.tableDef);\n\n  // Side-effect:\n  // Modify the `MODULE_DEF` which will be read by\n  // __describe_module__\n  MODULE_DEF.tables.push(...tableDefs);\n  REGISTERED_SCHEMA = {\n    tables: handles.map(handle => ({\n      name: handle.tableName,\n      accessorName: handle.tableName,\n      columns: handle.rowType.row,\n      rowType: handle.rowSpacetimeType,\n      indexes: handle.idxs,\n      constraints: handle.constraints,\n    })),\n  };\n  // MODULE_DEF.typespace = typespace;\n  // throw new Error(\n  //   MODULE_DEF.tables\n  //     .map(t => {\n  //       const p = MODULE_DEF.typespace.types[t.productTypeRef];\n  //       return `${t.name}: ${t.productTypeRef} ${p && (p as AlgebraicTypeVariants.Product).value.elements.map(x => x.name)}`;\n  //     })\n  //     .join('\\n')\n  // );\n\n  return new Schema(tableDefs, MODULE_DEF.typespace, handles);\n}\n\ntype HasAccessor = { accessorName: PropertyKey };\n\nexport type ConvertToAccessorMap<TableDefs extends readonly HasAccessor[]> = {\n  [Tbl in TableDefs[number] as Tbl['accessorName']]: Tbl;\n};\n\nexport function convertToAccessorMap<T extends readonly HasAccessor[]>(\n  arr: T\n): ConvertToAccessorMap<T> {\n  return Object.fromEntries(\n    arr.map(v => [v.accessorName, v])\n  ) as ConvertToAccessorMap<T>;\n}\n","// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE\n// WILL NOT BE SAVED. MODIFY TABLES IN YOUR MODULE SOURCE CODE INSTEAD.\n\n/* eslint-disable */\n/* tslint:disable */\nimport {\n  TypeBuilder as __TypeBuilder,\n  t as __t,\n  type AlgebraicTypeType as __AlgebraicTypeType,\n  type Infer as __Infer,\n} from '../../lib/type_builders';\n\n// The tagged union or sum type for the algebraic type `RawIndexAlgorithm`.\nconst RawIndexAlgorithm = __t.enum('RawIndexAlgorithm', {\n  BTree: __t.array(__t.u16()),\n  Hash: __t.array(__t.u16()),\n  Direct: __t.u16(),\n});\n\nexport default RawIndexAlgorithm;\n","import type RawConstraintDefV9 from './autogen/raw_constraint_def_v_9_type';\nimport RawIndexAlgorithm from './autogen/raw_index_algorithm_type';\nimport type RawIndexDefV9 from './autogen/raw_index_def_v_9_type';\nimport type RawSequenceDefV9 from './autogen/raw_sequence_def_v_9_type';\nimport type RawTableDefV9 from './autogen/raw_table_def_v_9_type';\nimport type { AllUnique, ConstraintOpts } from './constraints';\nimport type {\n  ColumnIndex,\n  IndexColumns,\n  Indexes,\n  IndexOpts,\n  ReadonlyIndexes,\n} from './indexes';\nimport ScheduleAt from './schedule_at';\nimport { registerTypesRecursively } from './schema';\nimport type { TableSchema } from './table_schema';\nimport {\n  RowBuilder,\n  type ColumnBuilder,\n  type ColumnMetadata,\n  type Infer,\n  type InferTypeOfRow,\n  type RowObj,\n  type TypeBuilder,\n} from './type_builders';\nimport type { Prettify } from './type_util';\nimport { toPascalCase } from './util';\n\nexport type AlgebraicTypeRef = number;\ntype ColId = number;\ntype ColList = ColId[];\n\n/**\n * A helper type to extract the row type from a TableDef\n */\nexport type RowType<TableDef extends Pick<UntypedTableDef, 'columns'>> =\n  InferTypeOfRow<TableDef['columns']>;\n\n/**\n * Coerces a column which may be a TypeBuilder or ColumnBuilder into a ColumnBuilder\n */\nexport type CoerceColumn<\n  Col extends TypeBuilder<any, any> | ColumnBuilder<any, any, any>,\n> =\n  Col extends TypeBuilder<infer T, infer U>\n    ? ColumnBuilder<T, U, ColumnMetadata<any>>\n    : Col;\n\n/**\n * Coerces a RowObj where TypeBuilders are replaced with ColumnBuilders\n */\nexport type CoerceRow<Row extends RowObj> = {\n  [k in keyof Row & string]: CoerceColumn<Row[k]>;\n};\n\n/**\n * Helper type to coerce an array of IndexOpts\n */\ntype CoerceArray<X extends IndexOpts<any>[]> = X;\n\n/**\n * An untyped representation of a table's schema.\n */\nexport type UntypedTableDef = {\n  name: string;\n  accessorName: string;\n  columns: Record<string, ColumnBuilder<any, any, ColumnMetadata<any>>>;\n  // This is really just a ProductType where all the elements have names.\n  rowType: RowBuilder<RowObj>['algebraicType']['value'];\n  indexes: readonly IndexOpts<any>[];\n  constraints: readonly ConstraintOpts<any>[];\n};\n\n/**\n * A type representing the indexes defined on a table.\n */\nexport type TableIndexes<TableDef extends UntypedTableDef> = {\n  [K in keyof TableDef['columns'] & string as ColumnIndex<\n    K,\n    TableDef['columns'][K]['columnMetadata']\n  > extends never\n    ? never\n    : K]: ColumnIndex<K, TableDef['columns'][K]['columnMetadata']>;\n} & {\n  [I in TableDef['indexes'][number] as I['name'] & {}]: TableIndexFromDef<\n    TableDef,\n    I\n  >;\n};\n\ntype TableIndexFromDef<\n  TableDef extends UntypedTableDef,\n  I extends IndexOpts<keyof TableDef['columns'] & string>,\n> =\n  NormalizeIndexColumns<TableDef, I> extends infer Cols extends ReadonlyArray<\n    keyof TableDef['columns'] & string\n  >\n    ? {\n        name: I['name'];\n        unique: AllUnique<TableDef, Cols>;\n        algorithm: Lowercase<I['algorithm']>;\n        columns: Cols;\n      }\n    : never;\n\ntype NormalizeIndexColumns<\n  TableDef extends UntypedTableDef,\n  I extends IndexOpts<keyof TableDef['columns'] & string>,\n> =\n  IndexColumns<I> extends ReadonlyArray<keyof TableDef['columns'] & string>\n    ? IndexColumns<I>\n    : never;\n\n/**\n * Options for configuring a database table.\n * - `name`: The name of the table.\n * - `public`: Whether the table is publicly accessible. Defaults to `false`.\n * - `indexes`: An array of index configurations for the table.\n * - `constraints`: An array of constraint configurations for the table.\n * - `scheduled`: The name of the reducer to be executed based on the scheduled rows in this table.\n */\nexport type TableOpts<Row extends RowObj> = {\n  name: string;\n  public?: boolean;\n  indexes?: IndexOpts<keyof Row & string>[]; // declarative multicolumn indexes\n  constraints?: ConstraintOpts<keyof Row & string>[];\n  scheduled?: string;\n};\n\n/**\n * Extracts the indices from TableOpts, defaulting to an empty array if none are provided.\n */\ntype OptsIndices<Opts extends TableOpts<any>> = Opts extends {\n  indexes: infer Ixs extends NonNullable<any[]>;\n}\n  ? Ixs\n  : CoerceArray<[]>;\n\n/**\n * Extracts the constraints from TableOpts, defaulting to an empty array if none are provided.\n */\ntype OptsConstraints<Opts extends TableOpts<any>> = Opts extends {\n  constraints: infer Constraints extends NonNullable<any[]>;\n}\n  ? Constraints\n  : CoerceArray<[]>;\n\n/**\n * Table<Row, UniqueConstraintViolation = never, AutoIncOverflow = never>\n *\n * - Row: row shape\n * - UCV: unique-constraint violation error type (never if none)\n * - AIO: auto-increment overflow error type (never if none)\n */\nexport type Table<TableDef extends UntypedTableDef> = Prettify<\n  TableMethods<TableDef> & Indexes<TableDef, TableIndexes<TableDef>>\n>;\n\nexport type ReadonlyTable<TableDef extends UntypedTableDef> = Prettify<\n  ReadonlyTableMethods<TableDef> &\n    ReadonlyIndexes<TableDef, TableIndexes<TableDef>>\n>;\n\nexport interface ReadonlyTableMethods<TableDef extends UntypedTableDef> {\n  /** Returns the number of rows in the TX state. */\n  count(): bigint;\n\n  /** Iterate over all rows in the TX state. Rust Iterator<Item=Row>  TS IterableIterator<Row>. */\n  iter(): IteratorObject<Prettify<RowType<TableDef>>, undefined>;\n  [Symbol.iterator](): IteratorObject<Prettify<RowType<TableDef>>, undefined>;\n}\n\n/**\n * A type representing the methods available on a table.\n */\nexport interface TableMethods<TableDef extends UntypedTableDef>\n  extends ReadonlyTableMethods<TableDef> {\n  /**\n   * Insert and return the inserted row (auto-increment fields filled).\n   *\n   * May throw on error:\n   * * If there are any unique or primary key columns in this table, may throw {@link UniqueAlreadyExists}.\n   * * If there are any auto-incrementing columns in this table, may throw {@link AutoIncOverflow}.\n   * */\n  insert(row: Prettify<RowType<TableDef>>): Prettify<RowType<TableDef>>;\n\n  /** Delete a row equal to `row`. Returns true if something was deleted. */\n  delete(row: Prettify<RowType<TableDef>>): boolean;\n}\n\n/**\n * Defines a database table with schema and options\n * @param opts - Table configuration including name, indexes, and access control\n * @param row - Product type defining the table's row structure\n * @returns Table handle for use in schema() function\n * @example\n * ```ts\n * const playerTable = table(\n *   { name: 'player', public: true },\n *   t.object({\n *     id: t.u32().primaryKey(),\n *     name: t.string().index('btree')\n *   })\n * );\n * ```\n */\nexport function table<Row extends RowObj, const Opts extends TableOpts<Row>>(\n  opts: Opts,\n  row: Row | RowBuilder<Row>\n): TableSchema<Opts['name'], CoerceRow<Row>, OptsIndices<Opts>> {\n  const {\n    name,\n    public: isPublic = false,\n    indexes: userIndexes = [],\n    scheduled,\n  } = opts;\n\n  // 1. column catalogue + helpers\n  const colIds = new Map<keyof Row & string, ColId>();\n  const colNameList: string[] = [];\n\n  if (!(row instanceof RowBuilder)) {\n    row = new RowBuilder(row);\n  }\n\n  if (row.typeName === undefined) {\n    row.typeName = toPascalCase(name);\n  }\n\n  const rowTypeRef = registerTypesRecursively(row);\n\n  row.algebraicType.value.elements.forEach((elem, i) => {\n    colIds.set(elem.name, i);\n    colNameList.push(elem.name);\n  });\n\n  // gather primary keys, percolumn indexes, uniques, sequences\n  const pk: ColList = [];\n  const indexes: Infer<typeof RawIndexDefV9>[] = [];\n  const constraints: Infer<typeof RawConstraintDefV9>[] = [];\n  const sequences: Infer<typeof RawSequenceDefV9>[] = [];\n\n  let scheduleAtCol: ColId | undefined;\n\n  for (const [name, builder] of Object.entries(row.row)) {\n    const meta: ColumnMetadata<any> = builder.columnMetadata;\n\n    if (meta.isPrimaryKey) {\n      pk.push(colIds.get(name)!);\n    }\n\n    const isUnique = meta.isUnique || meta.isPrimaryKey;\n\n    // implicit 1column indexes\n    if (meta.indexType || isUnique) {\n      const algo = meta.indexType ?? 'btree';\n      const id = colIds.get(name)!;\n      let algorithm: Infer<typeof RawIndexAlgorithm>;\n      switch (algo) {\n        case 'btree':\n          algorithm = RawIndexAlgorithm.BTree([id]);\n          break;\n        case 'direct':\n          algorithm = RawIndexAlgorithm.Direct(id);\n          break;\n      }\n      indexes.push({\n        name: undefined, // Unnamed indexes will be assigned a globally unique name\n        accessorName: name, // The name of this column will be used as the accessor name\n        algorithm,\n      });\n    }\n\n    if (isUnique) {\n      constraints.push({\n        name: undefined,\n        data: { tag: 'Unique', value: { columns: [colIds.get(name)!] } },\n      });\n    }\n\n    if (meta.isAutoIncrement) {\n      sequences.push({\n        name: undefined,\n        start: undefined,\n        minValue: undefined,\n        maxValue: undefined,\n        column: colIds.get(name)!,\n        increment: 1n,\n      });\n    }\n\n    // If this column is shaped like ScheduleAtAlgebraicType, mark it as the scheduleat column\n    if (scheduled) {\n      const algebraicType = builder.typeBuilder.algebraicType;\n      if (ScheduleAt.isScheduleAt(algebraicType)) {\n        scheduleAtCol = colIds.get(name)!;\n      }\n    }\n  }\n\n  // convert explicit multicolumn indexes coming from options.indexes\n  for (const indexOpts of userIndexes ?? []) {\n    let algorithm: Infer<typeof RawIndexAlgorithm>;\n    switch (indexOpts.algorithm) {\n      case 'btree':\n        algorithm = {\n          tag: 'BTree',\n          value: indexOpts.columns.map(c => colIds.get(c)!),\n        };\n        break;\n      case 'direct':\n        algorithm = { tag: 'Direct', value: colIds.get(indexOpts.column)! };\n        break;\n    }\n    // unnamed indexes will be assigned a globally unique name\n    // The name users supply is actually the accessor name which will be used\n    // in TypeScript to access the index. This will be used verbatim.\n    // This is confusing because it is not the index name and there is\n    // no actual way for the user to set the actual index name.\n    // I think we should standardize: name and accessorName as the way to set\n    // the name and accessor name of an index across all SDKs.\n    indexes.push({ name: undefined, accessorName: indexOpts.name, algorithm });\n  }\n\n  // add explicit constraints from options.constraints\n  for (const constraintOpts of opts.constraints ?? []) {\n    if (constraintOpts.constraint === 'unique') {\n      const data: Infer<typeof RawConstraintDefV9>['data'] = {\n        tag: 'Unique',\n        value: { columns: constraintOpts.columns.map(c => colIds.get(c)!) },\n      };\n      constraints.push({ name: constraintOpts.name, data });\n      continue;\n    }\n  }\n\n  for (const index of indexes) {\n    const cols =\n      index.algorithm.tag === 'Direct'\n        ? [index.algorithm.value]\n        : index.algorithm.value;\n    const colS = cols.map(i => colNameList[i]).join('_');\n    index.name = `${name}_${colS}_idx_${index.algorithm.tag.toLowerCase()}`;\n  }\n\n  // Temporarily set the type ref to 0. We will set this later\n  // in the schema function.\n\n  const tableDef: Infer<typeof RawTableDefV9> = {\n    name,\n    productTypeRef: rowTypeRef.ref,\n    primaryKey: pk,\n    indexes,\n    constraints,\n    sequences,\n    schedule:\n      scheduled && scheduleAtCol !== undefined\n        ? {\n            name: undefined,\n            reducerName: scheduled,\n            scheduledAtColumn: scheduleAtCol,\n          }\n        : undefined,\n    tableType: { tag: 'User' },\n    tableAccess: { tag: isPublic ? 'Public' : 'Private' },\n  };\n\n  const productType = row.algebraicType.value as RowBuilder<\n    CoerceRow<Row>\n  >['algebraicType']['value'];\n\n  return {\n    rowType: row as RowBuilder<CoerceRow<Row>>,\n    tableName: name,\n    rowSpacetimeType: productType,\n    tableDef,\n    idxs: {} as OptsIndices<Opts>,\n    constraints: constraints as OptsConstraints<Opts>,\n  };\n}\n"]}