import type { AllUnique, ConstraintOpts } from './constraints';
import type { ColumnIndex, IndexColumns, Indexes, IndexOpts, ReadonlyIndexes } from './indexes';
import type { TableSchema } from './table_schema';
import { RowBuilder, type ColumnBuilder, type ColumnMetadata, type InferTypeOfRow, type RowObj, type TypeBuilder } from './type_builders';
import type { Prettify } from './type_util';
export type AlgebraicTypeRef = number;
/**
 * A helper type to extract the row type from a TableDef
 */
export type RowType<TableDef extends Pick<UntypedTableDef, 'columns'>> = InferTypeOfRow<TableDef['columns']>;
/**
 * Coerces a column which may be a TypeBuilder or ColumnBuilder into a ColumnBuilder
 */
export type CoerceColumn<Col extends TypeBuilder<any, any> | ColumnBuilder<any, any, any>> = Col extends TypeBuilder<infer T, infer U> ? ColumnBuilder<T, U, ColumnMetadata<any>> : Col;
/**
 * Coerces a RowObj where TypeBuilders are replaced with ColumnBuilders
 */
export type CoerceRow<Row extends RowObj> = {
    [k in keyof Row & string]: CoerceColumn<Row[k]>;
};
/**
 * Helper type to coerce an array of IndexOpts
 */
type CoerceArray<X extends IndexOpts<any>[]> = X;
/**
 * An untyped representation of a table's schema.
 */
export type UntypedTableDef = {
    name: string;
    accessorName: string;
    columns: Record<string, ColumnBuilder<any, any, ColumnMetadata<any>>>;
    rowType: RowBuilder<RowObj>['algebraicType']['value'];
    indexes: readonly IndexOpts<any>[];
    constraints: readonly ConstraintOpts<any>[];
};
/**
 * A type representing the indexes defined on a table.
 */
export type TableIndexes<TableDef extends UntypedTableDef> = {
    [K in keyof TableDef['columns'] & string as ColumnIndex<K, TableDef['columns'][K]['columnMetadata']> extends never ? never : K]: ColumnIndex<K, TableDef['columns'][K]['columnMetadata']>;
} & {
    [I in TableDef['indexes'][number] as I['name'] & {}]: TableIndexFromDef<TableDef, I>;
};
type TableIndexFromDef<TableDef extends UntypedTableDef, I extends IndexOpts<keyof TableDef['columns'] & string>> = NormalizeIndexColumns<TableDef, I> extends infer Cols extends ReadonlyArray<keyof TableDef['columns'] & string> ? {
    name: I['name'];
    unique: AllUnique<TableDef, Cols>;
    algorithm: Lowercase<I['algorithm']>;
    columns: Cols;
} : never;
type NormalizeIndexColumns<TableDef extends UntypedTableDef, I extends IndexOpts<keyof TableDef['columns'] & string>> = IndexColumns<I> extends ReadonlyArray<keyof TableDef['columns'] & string> ? IndexColumns<I> : never;
/**
 * Options for configuring a database table.
 * - `name`: The name of the table.
 * - `public`: Whether the table is publicly accessible. Defaults to `false`.
 * - `indexes`: An array of index configurations for the table.
 * - `constraints`: An array of constraint configurations for the table.
 * - `scheduled`: The name of the reducer to be executed based on the scheduled rows in this table.
 */
export type TableOpts<Row extends RowObj> = {
    name: string;
    public?: boolean;
    indexes?: IndexOpts<keyof Row & string>[];
    constraints?: ConstraintOpts<keyof Row & string>[];
    scheduled?: string;
};
/**
 * Extracts the indices from TableOpts, defaulting to an empty array if none are provided.
 */
type OptsIndices<Opts extends TableOpts<any>> = Opts extends {
    indexes: infer Ixs extends NonNullable<any[]>;
} ? Ixs : CoerceArray<[]>;
/**
 * Table<Row, UniqueConstraintViolation = never, AutoIncOverflow = never>
 *
 * - Row: row shape
 * - UCV: unique-constraint violation error type (never if none)
 * - AIO: auto-increment overflow error type (never if none)
 */
export type Table<TableDef extends UntypedTableDef> = Prettify<TableMethods<TableDef> & Indexes<TableDef, TableIndexes<TableDef>>>;
export type ReadonlyTable<TableDef extends UntypedTableDef> = Prettify<ReadonlyTableMethods<TableDef> & ReadonlyIndexes<TableDef, TableIndexes<TableDef>>>;
export interface ReadonlyTableMethods<TableDef extends UntypedTableDef> {
    /** Returns the number of rows in the TX state. */
    count(): bigint;
    /** Iterate over all rows in the TX state. Rust Iterator<Item=Row> â†’ TS IterableIterator<Row>. */
    iter(): IteratorObject<Prettify<RowType<TableDef>>, undefined>;
    [Symbol.iterator](): IteratorObject<Prettify<RowType<TableDef>>, undefined>;
}
/**
 * A type representing the methods available on a table.
 */
export interface TableMethods<TableDef extends UntypedTableDef> extends ReadonlyTableMethods<TableDef> {
    /**
     * Insert and return the inserted row (auto-increment fields filled).
     *
     * May throw on error:
     * * If there are any unique or primary key columns in this table, may throw {@link UniqueAlreadyExists}.
     * * If there are any auto-incrementing columns in this table, may throw {@link AutoIncOverflow}.
     * */
    insert(row: Prettify<RowType<TableDef>>): Prettify<RowType<TableDef>>;
    /** Delete a row equal to `row`. Returns true if something was deleted. */
    delete(row: Prettify<RowType<TableDef>>): boolean;
}
/**
 * Defines a database table with schema and options
 * @param opts - Table configuration including name, indexes, and access control
 * @param row - Product type defining the table's row structure
 * @returns Table handle for use in schema() function
 * @example
 * ```ts
 * const playerTable = table(
 *   { name: 'player', public: true },
 *   t.object({
 *     id: t.u32().primaryKey(),
 *     name: t.string().index('btree')
 *   })
 * );
 * ```
 */
export declare function table<Row extends RowObj, const Opts extends TableOpts<Row>>(opts: Opts, row: Row | RowBuilder<Row>): TableSchema<Opts['name'], CoerceRow<Row>, OptsIndices<Opts>>;
export {};
//# sourceMappingURL=table.d.ts.map