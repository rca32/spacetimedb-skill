import { Timestamp } from './timestamp';
export type UuidAlgebraicType = {
    tag: 'Product';
    value: {
        elements: [
            {
                name: '__uuid__';
                algebraicType: {
                    tag: 'U128';
                };
            }
        ];
    };
};
/**
 * Supported UUID versions.
 *
 * - `Nil` – The "Nil" UUID (all zeros)
 * - `V4`  – Version 4: random
 * - `V7`  – Version 7: timestamp + counter + random
 * - `Max` – The "Max" UUID (all ones)
 */
type UuidVersion = 'Nil' | 'V4' | 'V7' | 'Max';
/**
 * A universally unique identifier (UUID).
 *
 * Supports UUID `Nil`, `Max`, `V4` (random), and `V7`
 * (timestamp + counter + random).
 *
 * Internally represented as an unsigned 128-bit between 0 and `MAX_UUID_BIGINT`.
 */
export declare class Uuid {
    __uuid__: bigint;
    /**
     * The nil UUID (all zeros).
     *
     * @example
     * ```ts
     * const uuid = Uuid.NIL;
     * console.assert(
     *   uuid.toString() === "00000000-0000-0000-0000-000000000000"
     * );
     * ```
     */
    static readonly NIL: Uuid;
    static readonly MAX_UUID_BIGINT = 340282366920938463463374607431768211455n;
    /**
     * The max UUID (all ones).
     *
     * @example
     * ```ts
     * const uuid = Uuid.MAX;
     * console.assert(
     *   uuid.toString() === "ffffffff-ffff-ffff-ffff-ffffffffffff"
     * );
     * ```
     */
    static readonly MAX: Uuid;
    /**
     * Create a UUID from a raw 128-bit value.
     *
     * @param u - Unsigned 128-bit integer
     * @throws {Error} If the value is outside the valid UUID range
     */
    constructor(u: bigint);
    /**
     * Create a UUID `v4` from explicit random bytes.
     *
     * This method assumes the bytes are already sufficiently random.
     * It only sets the appropriate bits for the UUID version and variant.
     *
     * @param bytes - Exactly 16 random bytes
     * @returns A UUID `v4`
     * @throws {Error} If `bytes.length !== 16`
     *
     * @example
     * ```ts
     * const randomBytes = new Uint8Array(16);
     * const uuid = Uuid.fromRandomBytesV4(randomBytes);
     *
     * console.assert(
     *   uuid.toString() === "00000000-0000-4000-8000-000000000000"
     * );
     * ```
     */
    static fromRandomBytesV4(bytes: Uint8Array): Uuid;
    /**
     * Generate a UUID `v7` using a monotonic counter from `0` to `2^31 - 1`,
     * a timestamp, and 4 random bytes.
     *
     * The counter wraps around on overflow.
     *
     * The UUID `v7` is structured as follows:
     *
     * ```ascii
     * ┌───────────────────────────────────────────────┬───────────────────┐
     * | B0  | B1  | B2  | B3  | B4  | B5              |         B6        |
     * ├───────────────────────────────────────────────┼───────────────────┤
     * |                 unix_ts_ms                    |      version 7    |
     * └───────────────────────────────────────────────┴───────────────────┘
     * ┌──────────────┬─────────┬──────────────────┬───────────────────────┐
     * | B7           | B8      | B9  | B10 | B11  | B12 | B13 | B14 | B15 |
     * ├──────────────┼─────────┼──────────────────┼───────────────────────┤
     * | counter_high | variant |    counter_low   |        random         |
     * └──────────────┴─────────┴──────────────────┴───────────────────────┘
     * ```
     *
     * @param counter - Mutable monotonic counter (31-bit)
     * @param now - Timestamp since the Unix epoch
     * @param randomBytes - Exactly 4 random bytes
     * @returns A UUID `v7`
     *
     * @throws {Error} If the `counter` is negative
     * @throws {Error} If the `timestamp` is before the Unix epoch
     * @throws {Error} If `randomBytes.length !== 4`
     *
     * @example
     * ```ts
     * const now = Timestamp.fromMillis(1_686_000_000_000n);
     * const counter = { value: 1 };
     * const randomBytes = new Uint8Array(4);
     *
     * const uuid = Uuid.fromCounterV7(counter, now, randomBytes);
     *
     * console.assert(
     *   uuid.toString() === "0000647e-5180-7000-8000-000200000000"
     * );
     * ```
     */
    static fromCounterV7(counter: {
        value: number;
    }, now: Timestamp, randomBytes: Uint8Array): Uuid;
    /**
     * Parse a UUID from a string representation.
     *
     * @param s - UUID string
     * @returns Parsed UUID
     * @throws {Error} If the string is not a valid UUID
     *
     * @example
     * ```ts
     * const s = "01888d6e-5c00-7000-8000-000000000000";
     * const uuid = Uuid.parse(s);
     *
     * console.assert(uuid.toString() === s);
     * ```
     */
    static parse(s: string): Uuid;
    /** Convert to string (hyphenated form). */
    toString(): string;
    /** Convert to bigint (u128). */
    asBigInt(): bigint;
    /** Return a `Uint8Array` of 16 bytes. */
    toBytes(): Uint8Array;
    private static bytesToBigInt;
    private static bigIntToBytes;
    /**
     * Returns the version of this UUID.
     *
     * This represents the algorithm used to generate the value.
     *
     * @returns A `UuidVersion`
     * @throws {Error} If the version field is not recognized
     */
    getVersion(): UuidVersion;
    /**
     * Extract the monotonic counter from a UUIDv7.
     *
     * Intended for testing and diagnostics.
     * Behavior is undefined if called on a non-V7 UUID.
     *
     * @returns 31-bit counter value
     */
    getCounter(): number;
    compareTo(other: Uuid): number;
    static getAlgebraicType(): UuidAlgebraicType;
}
export {};
//# sourceMappingURL=uuid.d.ts.map