import { AlgebraicType, ProductType } from '../lib/algebraic_type';
import type { ConnectionId } from '../lib/connection_id';
import type { Identity } from '../lib/identity';
import type { Timestamp } from '../lib/timestamp';
import type { HttpClient } from '../server/http_internal';
import type { ParamsObj, ReducerCtx } from './reducers';
import { type UntypedSchemaDef } from './schema';
import { type Infer, type InferTypeOfRow, type TypeBuilder } from './type_builders';
import type { CamelCase } from './type_util';
import { type CoerceParams } from './util';
import type { Uuid } from './uuid';
export type ProcedureFn<S extends UntypedSchemaDef, Params extends ParamsObj, Ret extends TypeBuilder<any, any>> = (ctx: ProcedureCtx<S>, args: InferTypeOfRow<Params>) => Infer<Ret>;
export interface ProcedureCtx<S extends UntypedSchemaDef> {
    readonly sender: Identity;
    readonly identity: Identity;
    readonly timestamp: Timestamp;
    readonly connectionId: ConnectionId | null;
    readonly http: HttpClient;
    readonly counter_uuid: {
        value: number;
    };
    withTx<T>(body: (ctx: TransactionCtx<S>) => T): T;
    newUuidV4(): Uuid;
    newUuidV7(): Uuid;
}
export interface TransactionCtx<S extends UntypedSchemaDef> extends ReducerCtx<S> {
}
export declare function procedure<S extends UntypedSchemaDef, Params extends ParamsObj, Ret extends TypeBuilder<any, any>>(name: string, params: Params, ret: Ret, fn: ProcedureFn<S, Params, Ret>): void;
export declare const PROCEDURES: Array<{
    fn: ProcedureFn<any, any, any>;
    paramsType: ProductType;
    returnType: AlgebraicType;
    returnTypeBaseSize: number;
}>;
export type UntypedProcedureDef = {
    name: string;
    accessorName: string;
    params: CoerceParams<ParamsObj>;
    returnType: TypeBuilder<any, any>;
};
export type UntypedProceduresDef = {
    procedures: readonly UntypedProcedureDef[];
};
export declare function procedures<const H extends readonly UntypedProcedureDef[]>(...handles: H): {
    procedures: H;
};
export declare function procedures<const H extends readonly UntypedProcedureDef[]>(handles: H): {
    procedures: H;
};
type ProcedureDef<Name extends string, Params extends ParamsObj, ReturnType extends TypeBuilder<any, any>> = {
    name: Name;
    accessorName: CamelCase<Name>;
    params: CoerceParams<Params>;
    returnType: ReturnType;
};
export declare function procedureSchema<ProcedureName extends string, Params extends ParamsObj, ReturnType extends TypeBuilder<any, any>>(name: ProcedureName, params: Params, returnType: ReturnType): ProcedureDef<ProcedureName, Params, ReturnType>;
export {};
//# sourceMappingURL=procedures.d.ts.map