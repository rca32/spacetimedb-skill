import { AlgebraicType, type AlgebraicTypeVariants } from './algebraic_type';
import type BinaryReader from './binary_reader';
import type BinaryWriter from './binary_writer';
import { ConnectionId, type ConnectionIdAlgebraicType } from './connection_id';
import { Identity, type IdentityAlgebraicType } from './identity';
import { type OptionAlgebraicType } from './option';
import { type ResultAlgebraicType } from './result';
import ScheduleAt, { type ScheduleAtAlgebraicType } from './schedule_at';
import type { CoerceRow } from './table';
import { TimeDuration, type TimeDurationAlgebraicType } from './time_duration';
import { Timestamp, type TimestampAlgebraicType } from './timestamp';
import { type Prettify, type SetField } from './type_util';
import { Uuid, type UuidAlgebraicType } from './uuid';
export { type AlgebraicTypeType } from './algebraic_type';
/**
 * Helper type to extract the TypeScript type from a TypeBuilder
 */
export type InferTypeOfTypeBuilder<T extends TypeBuilder<any, any>> = T extends TypeBuilder<infer U, any> ? Prettify<U> : never;
/**
 * Helper type to extract the Spacetime type from a TypeBuilder
 */
export type InferSpacetimeTypeOfTypeBuilder<T extends TypeBuilder<any, any>> = T extends TypeBuilder<any, infer U> ? U : never;
/**
 * Helper type to extract the TypeScript type from a TypeBuilder
 */
export type Infer<T> = T extends RowObj ? InferTypeOfRow<T> : T extends TypeBuilder<any, any> ? InferTypeOfTypeBuilder<T> : never;
/**
 * Helper type to extract the type of a row from an object.
 */
export type InferTypeOfRow<T extends RowObj> = {
    [K in keyof T & string]: InferTypeOfTypeBuilder<CollapseColumn<T[K]>>;
};
/**
 * Helper type to extract the type of a row from an object.
 */
export type InferSpacetimeTypeOfRow<T extends RowObj> = {
    [K in keyof T & string]: InferSpacetimeTypeOfTypeBuilder<CollapseColumn<T[K]>>;
};
/**
 * Helper type to extract the Spacetime type from a row object.
 */
type CollapseColumn<T extends TypeBuilder<any, any> | ColumnBuilder<any, any, any>> = T extends ColumnBuilder<any, any, any> ? T['typeBuilder'] : T;
/**
 * A type representing an object which is used to define the type of
 * a row in a table.
 */
export type RowObj = Record<string, TypeBuilder<any, any> | ColumnBuilder<any, any, ColumnMetadata<any>>>;
/**
 * Type which converts the elements of RowObj to a ProductType elements array
 */
type ElementsArrayFromRowObj<Obj extends RowObj> = Array<{
    [N in keyof Obj & string]: {
        name: N;
        algebraicType: InferSpacetimeTypeOfTypeBuilder<CollapseColumn<Obj[N]>>;
    };
}[keyof Obj & string]>;
/**
 * A type which converts the elements of RowObj to a TypeScript object type.
 * It works by `Infer`ing the types of the column builders which are the values of
 * the keys in the object passed in.
 *
 * e.g. { a: I32TypeBuilder, b: StringBuilder } -> { a: number, b: string }
 */
type RowType<Row extends RowObj> = {
    [K in keyof Row]: InferTypeOfTypeBuilder<CollapseColumn<Row[K]>>;
};
/**
 * Type which represents a valid argument to the ProductColumnBuilder
 */
export type ElementsObj = Record<string, TypeBuilder<any, any>>;
/**
 * Type which converts the elements of ElementsObj to a ProductType elements array
 */
type ElementsArrayFromElementsObj<Obj extends ElementsObj> = Array<{
    [N in keyof Obj & string]: {
        name: N;
        algebraicType: InferSpacetimeTypeOfTypeBuilder<Obj[N]>;
    };
}[keyof Obj & string]>;
/**
 * A type which converts the elements of ElementsObj to a TypeScript object type.
 * It works by `Infer`ing the types of the column builders which are the values of
 * the keys in the object passed in.
 *
 * e.g. { a: I32TypeBuilder, b: StringBuilder } -> { a: number, b: string }
 */
type ObjectType<Elements extends ElementsObj> = {
    [K in keyof Elements]: InferTypeOfTypeBuilder<Elements[K]>;
};
export type VariantsObj = Record<string, TypeBuilder<any, any>>;
type SimpleVariantsObj = Record<string, UnitBuilder>;
type IsUnit<B> = B extends UnitBuilder ? true : false;
/**
 * A type which converts the elements of ElementsObj to a TypeScript object type.
 * It works by `Infer`ing the types of the column builders which are the values of
 * the keys in the object passed in.
 *
 * e.g. { A: I32TypeBuilder, B: StringBuilder } -> { tag: "A", value: number } | { tag: "B", value: string }
 */
type EnumType<Variants extends VariantsObj> = {
    [K in keyof Variants & string]: IsUnit<Variants[K]> extends true ? {
        tag: K;
    } : {
        tag: K;
        value: InferTypeOfTypeBuilder<Variants[K]>;
    };
}[keyof Variants & string];
/**
 * Type which converts the elements of VariantsObj to a SumType variants array
 */
type VariantsArrayFromVariantsObj<Obj extends VariantsObj> = {
    name: keyof Obj & string;
    algebraicType: InferSpacetimeTypeOfTypeBuilder<Obj[keyof Obj & string]>;
}[];
/**
 * A generic type builder that captures both the TypeScript type
 * and the corresponding `AlgebraicType`.
 */
export declare class TypeBuilder<Type, SpacetimeType extends AlgebraicType> implements Optional<Type, SpacetimeType> {
    /**
     * The TypeScript phantom type. This is not stored at runtime,
     * but is visible to the compiler
     */
    readonly type: Type;
    /**
     * The SpacetimeDB algebraic type (runâ€‘time value). In addition to storing
     * the runtime representation of the `AlgebraicType`, it also captures
     * the TypeScript type information of the `AlgebraicType`. That is to say
     * the value is not merely an `AlgebraicType`, but is constructed to be
     * the corresponding concrete `AlgebraicType` for the TypeScript type `Type`.
     *
     * e.g. `string` corresponds to `AlgebraicType.String`
     */
    readonly algebraicType: SpacetimeType;
    constructor(algebraicType: SpacetimeType);
    optional(): OptionBuilder<typeof this>;
    serialize(writer: BinaryWriter, value: Type): void;
    deserialize(reader: BinaryReader): Type;
}
/**
 * Interface for types that can be converted into a column builder with primary key metadata.
 *
 * Implementing this interface allows a type to be marked as the primary key of a table column
 * in a type-safe manner. The `primaryKey()` method returns a new `ColumnBuilder` instance
 * with the metadata updated to indicate that the column is a primary key.
 *
 * @typeParam Type - The TypeScript type of the column's value.
 * @typeParam SpacetimeType - The corresponding SpacetimeDB algebraic type.
 * @typeParam M - The metadata type for the column, defaulting to `DefaultMetadata`.
 *
 * @remarks
 * - This interface is typically implemented by type builders for primitive and complex types.
 * - The returned `ColumnBuilder` will have its metadata extended with `{ isPrimaryKey: true }`.
 * - Marking a column as a primary key is mutually exclusive with certain other metadata flags,
 *   such as `isAutoIncrement` or `isUnique`, depending on the database schema rules.
 */
interface PrimaryKeyable<Type, SpacetimeType extends AlgebraicType, M extends ColumnMetadata<Type> = DefaultMetadata> {
    /**
     * Specify this column as primary key
     */
    primaryKey(): ColumnBuilder<Type, SpacetimeType, SetField<M, 'isPrimaryKey', true>>;
}
/**
 * Interface for types that can be converted into a column builder with unique metadata.
 *
 * Implementing this interface allows a type to be marked as unique in a table column
 * in a type-safe manner. The `unique()` method returns a new `ColumnBuilder` instance
 * with the metadata updated to indicate that the column is unique.
 *
 * @typeParam Type - The TypeScript type of the column's value.
 * @typeParam SpacetimeType - The corresponding SpacetimeDB algebraic type.
 * @typeParam M - The metadata type for the column, defaulting to `DefaultMetadata`.
 *
 * @remarks
 * - This interface is typically implemented by type builders for primitive and complex types.
 * - The returned `ColumnBuilder` will have its metadata extended with `{ isUnique: true }`.
 * - Marking a column as unique is mutually exclusive with certain other metadata flags,
 *   such as `isAutoIncrement` or `isPrimaryKey`, depending on the database schema rules.
 */
interface Uniqueable<Type, SpacetimeType extends AlgebraicType, M extends ColumnMetadata<Type> = DefaultMetadata> {
    /**
     * Specify this column as unique
     */
    unique(): ColumnBuilder<Type, SpacetimeType, SetField<M, 'isUnique', true>>;
}
/**
 * Interface for types that can be converted into a column builder with index metadata.
 *
 * Implementing this interface allows a type to be indexed in a table column
 * in a type-safe manner. The `index()` method returns a new `ColumnBuilder` instance
 * with the metadata updated to indicate the index type.
 *
 * @typeParam Type - The TypeScript type of the column's value.
 * @typeParam SpacetimeType - The corresponding SpacetimeDB algebraic type.
 * @typeParam M - The metadata type for the column, defaulting to `DefaultMetadata`.
 *
 * @remarks
 * - This interface is typically implemented by type builders for primitive and complex types.
 * - The returned `ColumnBuilder` will have its metadata extended with `{ indexType: N }`.
 * - Indexing a column may have implications for performance and query optimization.
 */
interface Indexable<Type, SpacetimeType extends AlgebraicType, M extends ColumnMetadata<Type> = DefaultMetadata> {
    /**
     * Specify the index type for this column
     * @param algorithm The index algorithm to use
     */
    index(): ColumnBuilder<Type, SpacetimeType, SetField<M, 'indexType', 'btree'>>;
    index<N extends NonNullable<IndexTypes>>(algorithm: N): ColumnBuilder<Type, SpacetimeType, SetField<M, 'indexType', N>>;
}
/**
 * Interface for types that can be converted into a column builder with auto-increment metadata.
 *
 * Implementing this interface allows a type to be marked as auto-incrementing in a table column
 * in a type-safe manner. The `autoInc()` method returns a new `ColumnBuilder` instance
 * with the metadata updated to indicate that the column is auto-incrementing.
 *
 * @typeParam Type - The TypeScript type of the column's value.
 * @typeParam SpacetimeType - The corresponding SpacetimeDB algebraic type.
 * @typeParam M - The metadata type for the column, defaulting to `DefaultMetadata`.
 *
 * @remarks
 * - This interface is typically implemented by type builders for primitive and complex types.
 * - The returned `ColumnBuilder` will have its metadata extended with `{ isAutoIncrement: true }`.
 * - Marking a column as auto-incrementing is mutually exclusive with certain other metadata flags,
 *   such as `isUnique` or `isPrimaryKey`, depending on the database schema rules.
 */
interface AutoIncrementable<Type, SpacetimeType extends AlgebraicType, M extends ColumnMetadata<Type> = DefaultMetadata> {
    /**
     * Specify this column as auto-incrementing
     */
    autoInc(): ColumnBuilder<Type, SpacetimeType, SetField<M, 'isAutoIncrement', true>>;
}
/**
 * Interface for types that can be converted into an optional type.
 * All {@link TypeBuilder}s implement this interface, however since the `optional()` method
 * returns an {@link OptionBuilder}, {@link OptionBuilder} controls what metadata is allowed
 * to be configured for the column. This allows us to restrict whether things like indexes
 * or unique constraints can be applied to optional columns.
 *
 * For this reason {@link ColumnBuilder} does not implement this interface.
 */
interface Optional<Type, SpacetimeType extends AlgebraicType> {
    /**
     * Specify this column as optional
     */
    optional(this: TypeBuilder<Type, SpacetimeType>): OptionBuilder<typeof this>;
}
/**
 * Interface for types that can be converted into a column builder with default value metadata.
 * Implementing this interface allows a type to have a default value specified in a table column
 * in a type-safe manner. The `default()` method returns a new `ColumnBuilder` instance
 * with the metadata updated to include the specified default value.
 *
 * @typeParam Type - The TypeScript type of the column's value.
 * @typeParam SpacetimeType - The corresponding SpacetimeDB algebraic type.
 * @typeParam M - The metadata type for the column, defaulting to `DefaultMetadata`.
 *
 * @remarks
 * - This interface is typically implemented by type builders for primitive and complex types.
 * - The returned `ColumnBuilder` will have its metadata extended with `{ default: value }`.
 * - The default value must be of the same type as the column's TypeScript type.
 * - This method can be called multiple times; the last call takes precedence.
 */
interface Defaultable<Type, SpacetimeType extends AlgebraicType, M extends ColumnMetadata<Type> = DefaultMetadata> {
    /**
     * Specify a default value for this column
     * @param value The default value for the column
     * @example
     * ```typescript
     * const col = t.i32().default(42);
     * ```
     * @remarks
     * - This method can be called multiple times; the last call takes precedence.
     * - The default value must be of the same type as the column's TypeScript type.
     */
    default(value: Type): ColumnBuilder<Type, SpacetimeType, SetField<M, 'defaultValue', Type>>;
}
interface Nameable<Type, SpacetimeType extends AlgebraicType, M extends ColumnMetadata<Type> = DefaultMetadata> {
    /**
     * Specify the in-database name for this column.
     */
    name<const Name extends string>(name: Name): Nameable<Type, SpacetimeType, SetField<M, 'name', Name>>;
}
export declare class U8Builder extends TypeBuilder<number, AlgebraicTypeVariants.U8> implements Indexable<number, AlgebraicTypeVariants.U8>, Uniqueable<number, AlgebraicTypeVariants.U8>, PrimaryKeyable<number, AlgebraicTypeVariants.U8>, AutoIncrementable<number, AlgebraicTypeVariants.U8>, Defaultable<number, AlgebraicTypeVariants.U8>, Nameable<number, AlgebraicTypeVariants.U8> {
    constructor();
    index(): U8ColumnBuilder<SetField<DefaultMetadata, 'indexType', 'btree'>>;
    index<N extends NonNullable<IndexTypes>>(algorithm: N): U8ColumnBuilder<SetField<DefaultMetadata, 'indexType', N>>;
    unique(): U8ColumnBuilder<SetField<DefaultMetadata, 'isUnique', true>>;
    primaryKey(): U8ColumnBuilder<SetField<DefaultMetadata, 'isPrimaryKey', true>>;
    autoInc(): U8ColumnBuilder<SetField<DefaultMetadata, 'isAutoIncrement', true>>;
    default(value: number): U8ColumnBuilder<SetField<DefaultMetadata, 'defaultValue', number>>;
    name<const Name extends string>(name: Name): U8ColumnBuilder<SetField<DefaultMetadata, 'name', Name>>;
}
export declare class U16Builder extends TypeBuilder<number, AlgebraicTypeVariants.U16> implements Indexable<number, AlgebraicTypeVariants.U16>, Uniqueable<number, AlgebraicTypeVariants.U16>, PrimaryKeyable<number, AlgebraicTypeVariants.U16>, AutoIncrementable<number, AlgebraicTypeVariants.U16>, Defaultable<number, AlgebraicTypeVariants.U16>, Nameable<number, AlgebraicTypeVariants.U16> {
    constructor();
    index(): U16ColumnBuilder<SetField<DefaultMetadata, 'indexType', 'btree'>>;
    index<N extends NonNullable<IndexTypes>>(algorithm: N): U16ColumnBuilder<SetField<DefaultMetadata, 'indexType', N>>;
    unique(): U16ColumnBuilder<SetField<DefaultMetadata, 'isUnique', true>>;
    primaryKey(): U16ColumnBuilder<SetField<DefaultMetadata, 'isPrimaryKey', true>>;
    autoInc(): U16ColumnBuilder<SetField<DefaultMetadata, 'isAutoIncrement', true>>;
    default(value: number): U16ColumnBuilder<SetField<DefaultMetadata, 'defaultValue', number>>;
    name<const Name extends string>(name: Name): U16ColumnBuilder<SetField<DefaultMetadata, 'name', Name>>;
}
export declare class U32Builder extends TypeBuilder<number, AlgebraicTypeVariants.U32> implements Indexable<number, AlgebraicTypeVariants.U32>, Uniqueable<number, AlgebraicTypeVariants.U32>, PrimaryKeyable<number, AlgebraicTypeVariants.U32>, AutoIncrementable<number, AlgebraicTypeVariants.U32>, Defaultable<number, AlgebraicTypeVariants.U32>, Nameable<number, AlgebraicTypeVariants.U32> {
    constructor();
    index(): U32ColumnBuilder<SetField<DefaultMetadata, 'indexType', 'btree'>>;
    index<N extends NonNullable<IndexTypes>>(algorithm: N): U32ColumnBuilder<SetField<DefaultMetadata, 'indexType', N>>;
    unique(): U32ColumnBuilder<SetField<DefaultMetadata, 'isUnique', true>>;
    primaryKey(): U32ColumnBuilder<SetField<DefaultMetadata, 'isPrimaryKey', true>>;
    autoInc(): U32ColumnBuilder<SetField<DefaultMetadata, 'isAutoIncrement', true>>;
    default(value: number): U32ColumnBuilder<SetField<DefaultMetadata, 'defaultValue', number>>;
    name<const Name extends string>(name: Name): U32ColumnBuilder<SetField<DefaultMetadata, 'name', Name>>;
}
export declare class U64Builder extends TypeBuilder<bigint, AlgebraicTypeVariants.U64> implements Indexable<bigint, AlgebraicTypeVariants.U64>, Uniqueable<bigint, AlgebraicTypeVariants.U64>, PrimaryKeyable<bigint, AlgebraicTypeVariants.U64>, AutoIncrementable<bigint, AlgebraicTypeVariants.U64>, Defaultable<bigint, AlgebraicTypeVariants.U64>, Nameable<bigint, AlgebraicTypeVariants.U64> {
    constructor();
    index(): U64ColumnBuilder<SetField<DefaultMetadata, 'indexType', 'btree'>>;
    index<N extends NonNullable<IndexTypes>>(algorithm: N): U64ColumnBuilder<SetField<DefaultMetadata, 'indexType', N>>;
    unique(): U64ColumnBuilder<SetField<DefaultMetadata, 'isUnique', true>>;
    primaryKey(): U64ColumnBuilder<SetField<DefaultMetadata, 'isPrimaryKey', true>>;
    autoInc(): U64ColumnBuilder<SetField<DefaultMetadata, 'isAutoIncrement', true>>;
    default(value: bigint): U64ColumnBuilder<SetField<DefaultMetadata, 'defaultValue', bigint>>;
    name<const Name extends string>(name: Name): U64ColumnBuilder<SetField<DefaultMetadata, 'name', Name>>;
}
export declare class U128Builder extends TypeBuilder<bigint, AlgebraicTypeVariants.U128> implements Indexable<bigint, AlgebraicTypeVariants.U128>, Uniqueable<bigint, AlgebraicTypeVariants.U128>, PrimaryKeyable<bigint, AlgebraicTypeVariants.U128>, AutoIncrementable<bigint, AlgebraicTypeVariants.U128>, Defaultable<bigint, AlgebraicTypeVariants.U128>, Nameable<bigint, AlgebraicTypeVariants.U128> {
    constructor();
    index(): U128ColumnBuilder<SetField<DefaultMetadata, 'indexType', 'btree'>>;
    index<N extends NonNullable<IndexTypes>>(algorithm: N): U128ColumnBuilder<SetField<DefaultMetadata, 'indexType', N>>;
    unique(): U128ColumnBuilder<SetField<DefaultMetadata, 'isUnique', true>>;
    primaryKey(): U128ColumnBuilder<SetField<DefaultMetadata, 'isPrimaryKey', true>>;
    autoInc(): U128ColumnBuilder<SetField<DefaultMetadata, 'isAutoIncrement', true>>;
    default(value: bigint): U128ColumnBuilder<SetField<DefaultMetadata, 'defaultValue', bigint>>;
    name<const Name extends string>(name: Name): U128ColumnBuilder<SetField<DefaultMetadata, 'name', Name>>;
}
export declare class U256Builder extends TypeBuilder<bigint, AlgebraicTypeVariants.U256> implements Indexable<bigint, AlgebraicTypeVariants.U256>, Uniqueable<bigint, AlgebraicTypeVariants.U256>, PrimaryKeyable<bigint, AlgebraicTypeVariants.U256>, AutoIncrementable<bigint, AlgebraicTypeVariants.U256>, Defaultable<bigint, AlgebraicTypeVariants.U256>, Nameable<bigint, AlgebraicTypeVariants.U256> {
    constructor();
    index(): U256ColumnBuilder<SetField<DefaultMetadata, 'indexType', 'btree'>>;
    index<N extends NonNullable<IndexTypes>>(algorithm: N): U256ColumnBuilder<SetField<DefaultMetadata, 'indexType', N>>;
    unique(): U256ColumnBuilder<SetField<DefaultMetadata, 'isUnique', true>>;
    primaryKey(): U256ColumnBuilder<SetField<DefaultMetadata, 'isPrimaryKey', true>>;
    autoInc(): U256ColumnBuilder<SetField<DefaultMetadata, 'isAutoIncrement', true>>;
    default(value: bigint): U256ColumnBuilder<SetField<DefaultMetadata, 'defaultValue', bigint>>;
    name<const Name extends string>(name: Name): U256ColumnBuilder<SetField<DefaultMetadata, 'name', Name>>;
}
export declare class I8Builder extends TypeBuilder<number, AlgebraicTypeVariants.I8> implements Indexable<number, AlgebraicTypeVariants.I8>, Uniqueable<number, AlgebraicTypeVariants.I8>, PrimaryKeyable<number, AlgebraicTypeVariants.I8>, AutoIncrementable<number, AlgebraicTypeVariants.I8>, Defaultable<number, AlgebraicTypeVariants.I8>, Nameable<number, AlgebraicTypeVariants.I8> {
    constructor();
    index(): I8ColumnBuilder<SetField<DefaultMetadata, 'indexType', 'btree'>>;
    index<N extends NonNullable<IndexTypes>>(algorithm: N): I8ColumnBuilder<SetField<DefaultMetadata, 'indexType', N>>;
    unique(): I8ColumnBuilder<SetField<DefaultMetadata, 'isUnique', true>>;
    primaryKey(): I8ColumnBuilder<SetField<DefaultMetadata, 'isPrimaryKey', true>>;
    autoInc(): I8ColumnBuilder<SetField<DefaultMetadata, 'isAutoIncrement', true>>;
    default(value: number): I8ColumnBuilder<SetField<DefaultMetadata, 'defaultValue', number>>;
    name<const Name extends string>(name: Name): I8ColumnBuilder<SetField<DefaultMetadata, 'name', Name>>;
}
export declare class I16Builder extends TypeBuilder<number, AlgebraicTypeVariants.I16> implements Indexable<number, AlgebraicTypeVariants.I16>, Uniqueable<number, AlgebraicTypeVariants.I16>, PrimaryKeyable<number, AlgebraicTypeVariants.I16>, AutoIncrementable<number, AlgebraicTypeVariants.I16>, Defaultable<number, AlgebraicTypeVariants.I16>, Nameable<number, AlgebraicTypeVariants.I16> {
    constructor();
    index(): I16ColumnBuilder<SetField<DefaultMetadata, 'indexType', 'btree'>>;
    index<N extends NonNullable<IndexTypes>>(algorithm: N): I16ColumnBuilder<SetField<DefaultMetadata, 'indexType', N>>;
    unique(): I16ColumnBuilder<SetField<DefaultMetadata, 'isUnique', true>>;
    primaryKey(): I16ColumnBuilder<SetField<DefaultMetadata, 'isPrimaryKey', true>>;
    autoInc(): I16ColumnBuilder<SetField<DefaultMetadata, 'isAutoIncrement', true>>;
    default(value: number): I16ColumnBuilder<SetField<DefaultMetadata, 'defaultValue', number>>;
    name<const Name extends string>(name: Name): I16ColumnBuilder<SetField<DefaultMetadata, 'name', Name>>;
}
export declare class I32Builder extends TypeBuilder<number, AlgebraicTypeVariants.I32> implements TypeBuilder<number, AlgebraicTypeVariants.I32>, Indexable<number, AlgebraicTypeVariants.I32>, Uniqueable<number, AlgebraicTypeVariants.I32>, PrimaryKeyable<number, AlgebraicTypeVariants.I32>, AutoIncrementable<number, AlgebraicTypeVariants.I32>, Defaultable<number, AlgebraicTypeVariants.I32>, Nameable<number, AlgebraicTypeVariants.I32> {
    constructor();
    index(): I32ColumnBuilder<SetField<DefaultMetadata, 'indexType', 'btree'>>;
    index<N extends NonNullable<IndexTypes>>(algorithm: N): I32ColumnBuilder<SetField<DefaultMetadata, 'indexType', N>>;
    unique(): I32ColumnBuilder<SetField<DefaultMetadata, 'isUnique', true>>;
    primaryKey(): I32ColumnBuilder<SetField<DefaultMetadata, 'isPrimaryKey', true>>;
    autoInc(): I32ColumnBuilder<SetField<DefaultMetadata, 'isAutoIncrement', true>>;
    default(value: number): I32ColumnBuilder<SetField<DefaultMetadata, 'defaultValue', number>>;
    name<const Name extends string>(name: Name): I32ColumnBuilder<SetField<DefaultMetadata, 'name', Name>>;
}
export declare class I64Builder extends TypeBuilder<bigint, AlgebraicTypeVariants.I64> implements Indexable<bigint, AlgebraicTypeVariants.I64>, Uniqueable<bigint, AlgebraicTypeVariants.I64>, PrimaryKeyable<bigint, AlgebraicTypeVariants.I64>, AutoIncrementable<bigint, AlgebraicTypeVariants.I64>, Defaultable<bigint, AlgebraicTypeVariants.I64>, Nameable<bigint, AlgebraicTypeVariants.I64> {
    constructor();
    index(): I64ColumnBuilder<SetField<DefaultMetadata, 'indexType', 'btree'>>;
    index<N extends NonNullable<IndexTypes>>(algorithm: N): I64ColumnBuilder<SetField<DefaultMetadata, 'indexType', N>>;
    unique(): I64ColumnBuilder<SetField<DefaultMetadata, 'isUnique', true>>;
    primaryKey(): I64ColumnBuilder<SetField<DefaultMetadata, 'isPrimaryKey', true>>;
    autoInc(): I64ColumnBuilder<SetField<DefaultMetadata, 'isAutoIncrement', true>>;
    default(value: bigint): I64ColumnBuilder<SetField<DefaultMetadata, 'defaultValue', bigint>>;
    name<const Name extends string>(name: Name): I64ColumnBuilder<SetField<DefaultMetadata, 'name', Name>>;
}
export declare class I128Builder extends TypeBuilder<bigint, AlgebraicTypeVariants.I128> implements Indexable<bigint, AlgebraicTypeVariants.I128>, Uniqueable<bigint, AlgebraicTypeVariants.I128>, PrimaryKeyable<bigint, AlgebraicTypeVariants.I128>, AutoIncrementable<bigint, AlgebraicTypeVariants.I128>, Defaultable<bigint, AlgebraicTypeVariants.I128>, Nameable<bigint, AlgebraicTypeVariants.I128> {
    constructor();
    index(): I128ColumnBuilder<SetField<DefaultMetadata, 'indexType', 'btree'>>;
    index<N extends NonNullable<IndexTypes>>(algorithm: N): I128ColumnBuilder<SetField<DefaultMetadata, 'indexType', N>>;
    unique(): I128ColumnBuilder<SetField<DefaultMetadata, 'isUnique', true>>;
    primaryKey(): I128ColumnBuilder<SetField<DefaultMetadata, 'isPrimaryKey', true>>;
    autoInc(): I128ColumnBuilder<SetField<DefaultMetadata, 'isAutoIncrement', true>>;
    default(value: bigint): I128ColumnBuilder<SetField<DefaultMetadata, 'defaultValue', bigint>>;
    name<const Name extends string>(name: Name): I128ColumnBuilder<SetField<DefaultMetadata, 'name', Name>>;
}
export declare class I256Builder extends TypeBuilder<bigint, AlgebraicTypeVariants.I256> implements Indexable<bigint, AlgebraicTypeVariants.I256>, Uniqueable<bigint, AlgebraicTypeVariants.I256>, PrimaryKeyable<bigint, AlgebraicTypeVariants.I256>, AutoIncrementable<bigint, AlgebraicTypeVariants.I256>, Defaultable<bigint, AlgebraicTypeVariants.I256>, Nameable<bigint, AlgebraicTypeVariants.I256> {
    constructor();
    index(): I256ColumnBuilder<SetField<DefaultMetadata, 'indexType', 'btree'>>;
    index<N extends NonNullable<IndexTypes>>(algorithm: N): I256ColumnBuilder<SetField<DefaultMetadata, 'indexType', N>>;
    unique(): I256ColumnBuilder<SetField<DefaultMetadata, 'isUnique', true>>;
    primaryKey(): I256ColumnBuilder<SetField<DefaultMetadata, 'isPrimaryKey', true>>;
    autoInc(): I256ColumnBuilder<SetField<DefaultMetadata, 'isAutoIncrement', true>>;
    default(value: bigint): I256ColumnBuilder<SetField<DefaultMetadata, 'defaultValue', bigint>>;
    name<const Name extends string>(name: Name): I256ColumnBuilder<SetField<DefaultMetadata, 'name', Name>>;
}
export declare class F32Builder extends TypeBuilder<number, AlgebraicTypeVariants.F32> implements Defaultable<number, AlgebraicTypeVariants.F32>, Nameable<number, AlgebraicTypeVariants.F32> {
    constructor();
    default(value: number): F32ColumnBuilder<SetField<DefaultMetadata, 'defaultValue', number>>;
    name<const Name extends string>(name: Name): F32ColumnBuilder<SetField<DefaultMetadata, 'name', Name>>;
}
export declare class F64Builder extends TypeBuilder<number, AlgebraicTypeVariants.F64> implements Defaultable<number, AlgebraicTypeVariants.F64>, Nameable<number, AlgebraicTypeVariants.F64> {
    constructor();
    default(value: number): F64ColumnBuilder<SetField<DefaultMetadata, 'defaultValue', number>>;
    name<const Name extends string>(name: Name): F64ColumnBuilder<SetField<DefaultMetadata, 'name', Name>>;
}
export declare class BoolBuilder extends TypeBuilder<boolean, AlgebraicTypeVariants.Bool> implements Indexable<boolean, AlgebraicTypeVariants.Bool>, Uniqueable<boolean, AlgebraicTypeVariants.Bool>, PrimaryKeyable<boolean, AlgebraicTypeVariants.Bool>, Defaultable<boolean, AlgebraicTypeVariants.Bool>, Nameable<boolean, AlgebraicTypeVariants.Bool> {
    constructor();
    index(): BoolColumnBuilder<SetField<DefaultMetadata, 'indexType', 'btree'>>;
    index<N extends NonNullable<IndexTypes>>(algorithm: N): BoolColumnBuilder<SetField<DefaultMetadata, 'indexType', N>>;
    unique(): BoolColumnBuilder<SetField<DefaultMetadata, 'isUnique', true>>;
    primaryKey(): BoolColumnBuilder<SetField<DefaultMetadata, 'isPrimaryKey', true>>;
    default(value: boolean): BoolColumnBuilder<SetField<DefaultMetadata, 'defaultValue', boolean>>;
    name<const Name extends string>(name: Name): BoolColumnBuilder<SetField<DefaultMetadata, 'name', Name>>;
}
export declare class StringBuilder extends TypeBuilder<string, AlgebraicTypeVariants.String> implements Indexable<string, AlgebraicTypeVariants.String>, Uniqueable<string, AlgebraicTypeVariants.String>, PrimaryKeyable<string, AlgebraicTypeVariants.String>, Defaultable<string, AlgebraicTypeVariants.String>, Nameable<string, AlgebraicTypeVariants.String> {
    constructor();
    index(): StringColumnBuilder<SetField<DefaultMetadata, 'indexType', 'btree'>>;
    index<N extends NonNullable<IndexTypes>>(algorithm: N): StringColumnBuilder<SetField<DefaultMetadata, 'indexType', N>>;
    unique(): StringColumnBuilder<SetField<DefaultMetadata, 'isUnique', true>>;
    primaryKey(): StringColumnBuilder<SetField<DefaultMetadata, 'isPrimaryKey', true>>;
    default(value: string): StringColumnBuilder<SetField<DefaultMetadata, 'defaultValue', string>>;
    name<const Name extends string>(name: Name): StringColumnBuilder<SetField<DefaultMetadata, 'name', Name>>;
}
export declare class ArrayBuilder<Element extends TypeBuilder<any, any>> extends TypeBuilder<Array<InferTypeOfTypeBuilder<Element>>, {
    tag: 'Array';
    value: InferSpacetimeTypeOfTypeBuilder<Element>;
}> implements Defaultable<Array<InferTypeOfTypeBuilder<Element>>, any>, Nameable<Array<InferTypeOfTypeBuilder<Element>>, any> {
    element: Element;
    constructor(element: Element);
    default(value: Array<InferTypeOfTypeBuilder<Element>>): ArrayColumnBuilder<Element, SetField<DefaultMetadata, 'defaultValue', any>>;
    name<const Name extends string>(name: Name): ArrayColumnBuilder<Element, SetField<DefaultMetadata, 'name', Name>>;
}
export declare class ByteArrayBuilder extends TypeBuilder<Uint8Array, {
    tag: 'Array';
    value: AlgebraicTypeVariants.U8;
}> implements Defaultable<Uint8Array, any>, Nameable<Uint8Array, any> {
    constructor();
    default(value: Uint8Array): ByteArrayColumnBuilder<SetField<DefaultMetadata, 'defaultValue', any>>;
    name<const Name extends string>(name: Name): ByteArrayColumnBuilder<SetField<DefaultMetadata, 'name', Name>>;
}
export declare class OptionBuilder<Value extends TypeBuilder<any, any>> extends TypeBuilder<InferTypeOfTypeBuilder<Value> | undefined, OptionAlgebraicType<InferSpacetimeTypeOfTypeBuilder<Value>>> implements Defaultable<InferTypeOfTypeBuilder<Value> | undefined, OptionAlgebraicType<InferSpacetimeTypeOfTypeBuilder<Value>>>, Nameable<InferTypeOfTypeBuilder<Value> | undefined, OptionAlgebraicType<InferSpacetimeTypeOfTypeBuilder<Value>>> {
    value: Value;
    constructor(value: Value);
    default(value: InferTypeOfTypeBuilder<Value> | undefined): OptionColumnBuilder<Value, SetField<DefaultMetadata, 'defaultValue', InferTypeOfTypeBuilder<Value> | undefined>>;
    name<const Name extends string>(name: Name): OptionColumnBuilder<Value, SetField<DefaultMetadata, 'name', Name>>;
}
type ElementsToProductType<Elements extends ElementsObj> = {
    tag: 'Product';
    value: {
        elements: ElementsArrayFromElementsObj<Elements>;
    };
};
export declare class ProductBuilder<Elements extends ElementsObj> extends TypeBuilder<ObjectType<Elements>, ElementsToProductType<Elements>> implements Defaultable<ObjectType<Elements>, ElementsToProductType<Elements>>, Nameable<ObjectType<Elements>, ElementsToProductType<Elements>> {
    readonly typeName: string | undefined;
    readonly elements: Elements;
    constructor(elements: Elements, name?: string);
    default(value: ObjectType<Elements>): ProductColumnBuilder<Elements, SetField<DefaultMetadata, 'defaultValue', any>>;
    name<const Name extends string>(name: Name): ProductColumnBuilder<Elements, SetField<DefaultMetadata, 'name', Name>>;
}
export declare class ResultBuilder<Ok extends TypeBuilder<any, any>, Err extends TypeBuilder<any, any>> extends TypeBuilder<InferTypeOfTypeBuilder<Ok> | InferTypeOfTypeBuilder<Err>, ResultAlgebraicType<InferSpacetimeTypeOfTypeBuilder<Ok>, InferSpacetimeTypeOfTypeBuilder<Err>>> implements Defaultable<InferTypeOfTypeBuilder<Ok> | InferTypeOfTypeBuilder<Err>, ResultAlgebraicType<InferSpacetimeTypeOfTypeBuilder<Ok>, InferSpacetimeTypeOfTypeBuilder<Err>>> {
    ok: Ok;
    err: Err;
    constructor(ok: Ok, err: Err);
    default(value: InferTypeOfTypeBuilder<Ok> | InferTypeOfTypeBuilder<Err>): ResultColumnBuilder<Ok, Err, SetField<DefaultMetadata, 'defaultValue', InferTypeOfTypeBuilder<Ok> | InferTypeOfTypeBuilder<Err>>>;
}
declare class UnitBuilder extends TypeBuilder<{}, {
    tag: 'Product';
    value: {
        elements: [];
    };
}> {
    constructor();
}
export declare class RowBuilder<Row extends RowObj> extends TypeBuilder<RowType<CoerceRow<Row>>, {
    tag: 'Product';
    value: {
        elements: ElementsArrayFromRowObj<CoerceRow<Row>>;
    };
}> {
    readonly row: CoerceRow<Row>;
    typeName: string | undefined;
    constructor(row: Row, name?: string);
}
type EnumValue<K extends string, B extends TypeBuilder<any, any>> = IsUnit<B> extends true ? {
    tag: K;
} : {
    tag: K;
    value: InferTypeOfTypeBuilder<B>;
};
type VariantConstructor<K extends string, V extends TypeBuilder<any, any>> = IsUnit<V> extends true ? EnumValue<K, V> : (value: InferTypeOfTypeBuilder<V>) => EnumValue<K, V>;
type SumBuilderVariantConstructors<Variants extends VariantsObj> = {
    [K in keyof Variants & string]: VariantConstructor<K, Variants[K]>;
};
export type SumBuilder<Variants extends VariantsObj> = SumBuilderImpl<Variants> & SumBuilderVariantConstructors<Variants>;
type VariantsToSumType<Variants extends VariantsObj> = {
    tag: 'Sum';
    value: {
        variants: VariantsArrayFromVariantsObj<Variants>;
    };
};
declare class SumBuilderImpl<Variants extends VariantsObj> extends TypeBuilder<EnumType<Variants>, VariantsToSumType<Variants>> implements Defaultable<EnumType<Variants>, VariantsToSumType<Variants>>, Nameable<EnumType<Variants>, VariantsToSumType<Variants>> {
    readonly variants: Variants;
    readonly typeName: string | undefined;
    constructor(variants: Variants, name?: string);
    /**
     * Create a value of this sum type.
     * - Unit variants: create('bar')
     * - Payload variants: create('foo', value)
     */
    private create;
    default(value: EnumType<Variants>): SumColumnBuilder<Variants, SetField<DefaultMetadata, 'defaultValue', any>>;
    name<const Name extends string>(name: Name): SumColumnBuilder<Variants, SetField<DefaultMetadata, 'name', Name>>;
}
export declare const SumBuilder: {
    new <Variants extends VariantsObj>(variants: Variants, name?: string): SumBuilder<Variants>;
    [Symbol.hasInstance](x: any): x is SumBuilder<VariantsObj>;
};
declare class SimpleSumBuilderImpl<Variants extends SimpleVariantsObj> extends SumBuilderImpl<Variants> implements Indexable<EnumType<Variants>, {
    tag: 'Sum';
    value: {
        variants: VariantsArrayFromVariantsObj<Variants>;
    };
}>, PrimaryKeyable<EnumType<Variants>, {
    tag: 'Sum';
    value: {
        variants: VariantsArrayFromVariantsObj<Variants>;
    };
}> {
    index(): SimpleSumColumnBuilder<Variants, SetField<DefaultMetadata, 'indexType', 'btree'>>;
    index<N extends NonNullable<IndexTypes>>(algorithm: N): SimpleSumColumnBuilder<Variants, SetField<DefaultMetadata, 'indexType', N>>;
    primaryKey(): SimpleSumColumnBuilder<Variants, SetField<DefaultMetadata, 'isPrimaryKey', true>>;
}
export declare const SimpleSumBuilder: {
    new <Variants extends SimpleVariantsObj>(variants: Variants, name?: string): SimpleSumBuilderImpl<Variants> & SumBuilderVariantConstructors<Variants>;
};
export type SimpleSumBuilder<Variants extends SimpleVariantsObj> = SimpleSumBuilderImpl<Variants> & SumBuilderVariantConstructors<Variants>;
export declare class ScheduleAtBuilder extends TypeBuilder<ScheduleAt, ScheduleAtAlgebraicType> implements Defaultable<ScheduleAt, ScheduleAtAlgebraicType>, Nameable<ScheduleAt, ScheduleAtAlgebraicType> {
    constructor();
    default(value: ScheduleAt): ScheduleAtColumnBuilder<SetField<DefaultMetadata, 'defaultValue', ScheduleAt>>;
    name<const Name extends string>(name: Name): ScheduleAtColumnBuilder<SetField<DefaultMetadata, 'name', Name>>;
}
export declare class IdentityBuilder extends TypeBuilder<Identity, IdentityAlgebraicType> implements Indexable<Identity, IdentityAlgebraicType>, Uniqueable<Identity, IdentityAlgebraicType>, PrimaryKeyable<Identity, IdentityAlgebraicType>, Defaultable<Identity, IdentityAlgebraicType>, Nameable<Identity, IdentityAlgebraicType> {
    constructor();
    index(): IdentityColumnBuilder<SetField<DefaultMetadata, 'indexType', 'btree'>>;
    index<N extends NonNullable<IndexTypes>>(algorithm: N): IdentityColumnBuilder<SetField<DefaultMetadata, 'indexType', N>>;
    unique(): IdentityColumnBuilder<SetField<DefaultMetadata, 'isUnique', true>>;
    primaryKey(): IdentityColumnBuilder<SetField<DefaultMetadata, 'isPrimaryKey', true>>;
    autoInc(): IdentityColumnBuilder<SetField<DefaultMetadata, 'isAutoIncrement', true>>;
    default(value: Identity): IdentityColumnBuilder<SetField<DefaultMetadata, 'defaultValue', Identity>>;
    name<const Name extends string>(name: Name): IdentityColumnBuilder<SetField<DefaultMetadata, 'name', Name>>;
}
export declare class ConnectionIdBuilder extends TypeBuilder<ConnectionId, ConnectionIdAlgebraicType> implements Indexable<ConnectionId, ConnectionIdAlgebraicType>, Uniqueable<ConnectionId, ConnectionIdAlgebraicType>, PrimaryKeyable<ConnectionId, ConnectionIdAlgebraicType>, Defaultable<ConnectionId, ConnectionIdAlgebraicType>, Nameable<ConnectionId, ConnectionIdAlgebraicType> {
    constructor();
    index(): ConnectionIdColumnBuilder<SetField<DefaultMetadata, 'indexType', 'btree'>>;
    index<N extends NonNullable<IndexTypes>>(algorithm: N): ConnectionIdColumnBuilder<SetField<DefaultMetadata, 'indexType', N>>;
    unique(): ConnectionIdColumnBuilder<SetField<DefaultMetadata, 'isUnique', true>>;
    primaryKey(): ConnectionIdColumnBuilder<SetField<DefaultMetadata, 'isPrimaryKey', true>>;
    autoInc(): ConnectionIdColumnBuilder<SetField<DefaultMetadata, 'isAutoIncrement', true>>;
    default(value: ConnectionId): ConnectionIdColumnBuilder<SetField<DefaultMetadata, 'defaultValue', ConnectionId>>;
    name<const Name extends string>(name: Name): ConnectionIdColumnBuilder<SetField<DefaultMetadata, 'name', Name>>;
}
export declare class TimestampBuilder extends TypeBuilder<Timestamp, TimestampAlgebraicType> implements Indexable<Timestamp, TimestampAlgebraicType>, Uniqueable<Timestamp, TimestampAlgebraicType>, PrimaryKeyable<Timestamp, TimestampAlgebraicType>, Defaultable<Timestamp, TimestampAlgebraicType>, Nameable<Timestamp, TimestampAlgebraicType> {
    constructor();
    index(): TimestampColumnBuilder<SetField<DefaultMetadata, 'indexType', 'btree'>>;
    index<N extends NonNullable<IndexTypes>>(algorithm: N): TimestampColumnBuilder<SetField<DefaultMetadata, 'indexType', N>>;
    unique(): TimestampColumnBuilder<SetField<DefaultMetadata, 'isUnique', true>>;
    primaryKey(): TimestampColumnBuilder<SetField<DefaultMetadata, 'isPrimaryKey', true>>;
    autoInc(): TimestampColumnBuilder<SetField<DefaultMetadata, 'isAutoIncrement', true>>;
    default(value: Timestamp): TimestampColumnBuilder<SetField<DefaultMetadata, 'defaultValue', Timestamp>>;
    name<const Name extends string>(name: Name): TimestampColumnBuilder<SetField<DefaultMetadata, 'name', Name>>;
}
export declare class TimeDurationBuilder extends TypeBuilder<TimeDuration, TimeDurationAlgebraicType> implements Indexable<TimeDuration, TimeDurationAlgebraicType>, Uniqueable<TimeDuration, TimeDurationAlgebraicType>, PrimaryKeyable<TimeDuration, TimeDurationAlgebraicType>, Defaultable<TimeDuration, TimeDurationAlgebraicType>, Nameable<TimeDuration, TimeDurationAlgebraicType> {
    constructor();
    index(): TimeDurationColumnBuilder<SetField<DefaultMetadata, 'indexType', 'btree'>>;
    index<N extends NonNullable<IndexTypes>>(algorithm: N): TimeDurationColumnBuilder<SetField<DefaultMetadata, 'indexType', N>>;
    unique(): TimeDurationColumnBuilder<SetField<DefaultMetadata, 'isUnique', true>>;
    primaryKey(): TimeDurationColumnBuilder<SetField<DefaultMetadata, 'isPrimaryKey', true>>;
    autoInc(): TimeDurationColumnBuilder<SetField<DefaultMetadata, 'isAutoIncrement', true>>;
    default(value: TimeDuration): TimeDurationColumnBuilder<SetField<DefaultMetadata, 'defaultValue', TimeDuration>>;
    name<const Name extends string>(name: Name): TimeDurationColumnBuilder<SetField<DefaultMetadata, 'name', Name>>;
}
export declare class UuidBuilder extends TypeBuilder<Uuid, UuidAlgebraicType> implements Indexable<Uuid, UuidAlgebraicType>, Uniqueable<Uuid, UuidAlgebraicType>, PrimaryKeyable<Uuid, UuidAlgebraicType>, Defaultable<Uuid, UuidAlgebraicType> {
    constructor();
    index(): UuidColumnBuilder<SetField<DefaultMetadata, 'indexType', 'btree'>>;
    index<N extends NonNullable<IndexTypes>>(algorithm: N): UuidColumnBuilder<SetField<DefaultMetadata, 'indexType', N>>;
    unique(): UuidColumnBuilder<SetField<DefaultMetadata, 'isUnique', true>>;
    primaryKey(): UuidColumnBuilder<SetField<DefaultMetadata, 'isPrimaryKey', true>>;
    autoInc(): UuidColumnBuilder<SetField<DefaultMetadata, 'isAutoIncrement', true>>;
    default(value: Uuid): UuidColumnBuilder<SetField<DefaultMetadata, 'defaultValue', Uuid>>;
}
/**
 * The type of index types that can be applied to a column.
 * `undefined` is the default
 */
export type IndexTypes = 'btree' | 'direct' | undefined;
/**
 * Metadata describing column constraints and index type
 */
export type ColumnMetadata<Type = any> = {
    isPrimaryKey?: true;
    isUnique?: true;
    isAutoIncrement?: true;
    indexType?: IndexTypes;
    defaultValue?: Type;
    name?: string;
};
/**
 * Default metadata state type for a newly created column
 */
type DefaultMetadata = object;
/**
 * A column builder allows you to incrementally specify constraints
 * and metadata for a column in a type-safe way.
 *
 * It carries both a phantom TypeScript type (the `Type`) and
 * runtime algebraic type information.
 *
 * IMPORTANT! We have deliberately chosen to not have {@link ColumnBuilder}
 * extend {@link TypeBuilder} so that you cannot pass a {@link ColumnBuilder}
 * where a {@link TypeBuilder} is expected. i.e. We want to maintain
 * contravariance for functions that accept {@link TypeBuilder} parameters.
 */
export declare class ColumnBuilder<Type, SpacetimeType extends AlgebraicType, M extends ColumnMetadata<Type> = DefaultMetadata> {
    typeBuilder: TypeBuilder<Type, SpacetimeType>;
    columnMetadata: M;
    constructor(typeBuilder: TypeBuilder<Type, SpacetimeType>, metadata: M);
    serialize(writer: BinaryWriter, value: Type): void;
    deserialize(reader: BinaryReader): Type;
}
export declare class U8ColumnBuilder<M extends ColumnMetadata<number> = DefaultMetadata> extends ColumnBuilder<number, AlgebraicTypeVariants.U8, M> implements Indexable<number, AlgebraicTypeVariants.U8>, Uniqueable<number, AlgebraicTypeVariants.U8>, PrimaryKeyable<number, AlgebraicTypeVariants.U8>, AutoIncrementable<number, AlgebraicTypeVariants.U8>, Defaultable<number, AlgebraicTypeVariants.U8>, Nameable<number, AlgebraicTypeVariants.U8> {
    index(): U8ColumnBuilder<SetField<M, 'indexType', 'btree'>>;
    index<N extends NonNullable<IndexTypes>>(algorithm: N): U8ColumnBuilder<SetField<M, 'indexType', N>>;
    unique(): U8ColumnBuilder<SetField<M, 'isUnique', true>>;
    primaryKey(): U8ColumnBuilder<SetField<M, 'isPrimaryKey', true>>;
    autoInc(): U8ColumnBuilder<SetField<M, 'isAutoIncrement', true>>;
    default(value: number): U8ColumnBuilder<SetField<M, 'defaultValue', number>>;
    name<const Name extends string>(name: Name): U8ColumnBuilder<SetField<M, 'name', Name>>;
}
export declare class U16ColumnBuilder<M extends ColumnMetadata<number> = DefaultMetadata> extends ColumnBuilder<number, AlgebraicTypeVariants.U16, M> implements Indexable<number, AlgebraicTypeVariants.U16>, Uniqueable<number, AlgebraicTypeVariants.U16>, PrimaryKeyable<number, AlgebraicTypeVariants.U16>, AutoIncrementable<number, AlgebraicTypeVariants.U16>, Defaultable<number, AlgebraicTypeVariants.U16>, Nameable<number, AlgebraicTypeVariants.U16> {
    index(): U16ColumnBuilder<SetField<M, 'indexType', 'btree'>>;
    index<N extends NonNullable<IndexTypes>>(algorithm: N): U16ColumnBuilder<SetField<M, 'indexType', N>>;
    unique(): U16ColumnBuilder<SetField<M, 'isUnique', true>>;
    primaryKey(): U16ColumnBuilder<SetField<M, 'isPrimaryKey', true>>;
    autoInc(): U16ColumnBuilder<SetField<M, 'isAutoIncrement', true>>;
    default(value: number): U16ColumnBuilder<SetField<M, 'defaultValue', number>>;
    name<const Name extends string>(name: Name): U16ColumnBuilder<SetField<M, 'name', Name>>;
}
export declare class U32ColumnBuilder<M extends ColumnMetadata<number> = DefaultMetadata> extends ColumnBuilder<number, AlgebraicTypeVariants.U32, M> implements Indexable<number, AlgebraicTypeVariants.U32>, Uniqueable<number, AlgebraicTypeVariants.U32>, PrimaryKeyable<number, AlgebraicTypeVariants.U32>, AutoIncrementable<number, AlgebraicTypeVariants.U32>, Defaultable<number, AlgebraicTypeVariants.U32>, Nameable<number, AlgebraicTypeVariants.U32> {
    index(): U32ColumnBuilder<SetField<M, 'indexType', 'btree'>>;
    index<N extends NonNullable<IndexTypes>>(algorithm: N): U32ColumnBuilder<SetField<M, 'indexType', N>>;
    unique(): U32ColumnBuilder<SetField<M, 'isUnique', true>>;
    primaryKey(): U32ColumnBuilder<SetField<M, 'isPrimaryKey', true>>;
    autoInc(): U32ColumnBuilder<SetField<M, 'isAutoIncrement', true>>;
    default(value: number): U32ColumnBuilder<SetField<M, 'defaultValue', number>>;
    name<const Name extends string>(name: Name): U32ColumnBuilder<SetField<M, 'name', Name>>;
}
export declare class U64ColumnBuilder<M extends ColumnMetadata<bigint> = DefaultMetadata> extends ColumnBuilder<bigint, AlgebraicTypeVariants.U64, M> implements Indexable<bigint, AlgebraicTypeVariants.U64>, Uniqueable<bigint, AlgebraicTypeVariants.U64>, PrimaryKeyable<bigint, AlgebraicTypeVariants.U64>, AutoIncrementable<bigint, AlgebraicTypeVariants.U64>, Defaultable<bigint, AlgebraicTypeVariants.U64>, Nameable<bigint, AlgebraicTypeVariants.U64> {
    index(): U64ColumnBuilder<SetField<M, 'indexType', 'btree'>>;
    index<N extends NonNullable<IndexTypes>>(algorithm: N): U64ColumnBuilder<SetField<M, 'indexType', N>>;
    unique(): U64ColumnBuilder<SetField<M, 'isUnique', true>>;
    primaryKey(): U64ColumnBuilder<SetField<M, 'isPrimaryKey', true>>;
    autoInc(): U64ColumnBuilder<SetField<M, 'isAutoIncrement', true>>;
    default(value: bigint): U64ColumnBuilder<SetField<M, 'defaultValue', bigint>>;
    name<const Name extends string>(name: Name): U64ColumnBuilder<SetField<M, 'name', Name>>;
}
export declare class U128ColumnBuilder<M extends ColumnMetadata<bigint> = DefaultMetadata> extends ColumnBuilder<bigint, AlgebraicTypeVariants.U128, M> implements Indexable<bigint, AlgebraicTypeVariants.U128>, Uniqueable<bigint, AlgebraicTypeVariants.U128>, PrimaryKeyable<bigint, AlgebraicTypeVariants.U128>, AutoIncrementable<bigint, AlgebraicTypeVariants.U128>, Defaultable<bigint, AlgebraicTypeVariants.U128>, Nameable<bigint, AlgebraicTypeVariants.U128> {
    index(): U128ColumnBuilder<SetField<M, 'indexType', 'btree'>>;
    index<N extends NonNullable<IndexTypes>>(algorithm: N): U128ColumnBuilder<SetField<M, 'indexType', N>>;
    unique(): U128ColumnBuilder<SetField<M, 'isUnique', true>>;
    primaryKey(): U128ColumnBuilder<SetField<M, 'isPrimaryKey', true>>;
    autoInc(): U128ColumnBuilder<SetField<M, 'isAutoIncrement', true>>;
    default(value: bigint): U128ColumnBuilder<SetField<M, 'defaultValue', bigint>>;
    name<const Name extends string>(name: Name): U128ColumnBuilder<SetField<M, 'name', Name>>;
}
export declare class U256ColumnBuilder<M extends ColumnMetadata<bigint> = DefaultMetadata> extends ColumnBuilder<bigint, AlgebraicTypeVariants.U256, M> implements Indexable<bigint, AlgebraicTypeVariants.U256>, Uniqueable<bigint, AlgebraicTypeVariants.U256>, PrimaryKeyable<bigint, AlgebraicTypeVariants.U256>, AutoIncrementable<bigint, AlgebraicTypeVariants.U256>, Defaultable<bigint, AlgebraicTypeVariants.U256>, Nameable<bigint, AlgebraicTypeVariants.U256> {
    index(): U256ColumnBuilder<SetField<M, 'indexType', 'btree'>>;
    index<N extends NonNullable<IndexTypes>>(algorithm: N): U256ColumnBuilder<SetField<M, 'indexType', N>>;
    unique(): U256ColumnBuilder<SetField<M, 'isUnique', true>>;
    primaryKey(): U256ColumnBuilder<SetField<M, 'isPrimaryKey', true>>;
    autoInc(): U256ColumnBuilder<SetField<M, 'isAutoIncrement', true>>;
    default(value: bigint): U256ColumnBuilder<SetField<M, 'defaultValue', bigint>>;
    name<const Name extends string>(name: Name): U256ColumnBuilder<SetField<M, 'name', Name>>;
}
export declare class I8ColumnBuilder<M extends ColumnMetadata<number> = DefaultMetadata> extends ColumnBuilder<number, AlgebraicTypeVariants.I8, M> implements Indexable<number, AlgebraicTypeVariants.I8>, Uniqueable<number, AlgebraicTypeVariants.I8>, PrimaryKeyable<number, AlgebraicTypeVariants.I8>, AutoIncrementable<number, AlgebraicTypeVariants.I8>, Defaultable<number, AlgebraicTypeVariants.I8>, Nameable<number, AlgebraicTypeVariants.I8> {
    index(): I8ColumnBuilder<SetField<M, 'indexType', 'btree'>>;
    index<N extends NonNullable<IndexTypes>>(algorithm: N): I8ColumnBuilder<SetField<M, 'indexType', N>>;
    unique(): I8ColumnBuilder<SetField<M, 'isUnique', true>>;
    primaryKey(): I8ColumnBuilder<SetField<M, 'isPrimaryKey', true>>;
    autoInc(): I8ColumnBuilder<SetField<M, 'isAutoIncrement', true>>;
    default(value: number): I8ColumnBuilder<SetField<M, 'defaultValue', number>>;
    name<const Name extends string>(name: Name): I8ColumnBuilder<SetField<M, 'name', Name>>;
}
export declare class I16ColumnBuilder<M extends ColumnMetadata<number> = DefaultMetadata> extends ColumnBuilder<number, AlgebraicTypeVariants.I16, M> implements Indexable<number, AlgebraicTypeVariants.I16>, Uniqueable<number, AlgebraicTypeVariants.I16>, PrimaryKeyable<number, AlgebraicTypeVariants.I16>, AutoIncrementable<number, AlgebraicTypeVariants.I16>, Defaultable<number, AlgebraicTypeVariants.I16>, Nameable<number, AlgebraicTypeVariants.I16> {
    index(): I16ColumnBuilder<SetField<M, 'indexType', 'btree'>>;
    index<N extends NonNullable<IndexTypes>>(algorithm: N): I16ColumnBuilder<SetField<M, 'indexType', N>>;
    unique(): I16ColumnBuilder<SetField<M, 'isUnique', true>>;
    primaryKey(): I16ColumnBuilder<SetField<M, 'isPrimaryKey', true>>;
    autoInc(): I16ColumnBuilder<SetField<M, 'isAutoIncrement', true>>;
    default(value: number): I16ColumnBuilder<SetField<M, 'defaultValue', number>>;
    name<const Name extends string>(name: Name): I16ColumnBuilder<SetField<M, 'name', Name>>;
}
export declare class I32ColumnBuilder<M extends ColumnMetadata<number> = DefaultMetadata> extends ColumnBuilder<number, AlgebraicTypeVariants.I32, M> implements Indexable<number, AlgebraicTypeVariants.I32>, Uniqueable<number, AlgebraicTypeVariants.I32>, PrimaryKeyable<number, AlgebraicTypeVariants.I32>, AutoIncrementable<number, AlgebraicTypeVariants.I32>, Defaultable<number, AlgebraicTypeVariants.I32>, Nameable<number, AlgebraicTypeVariants.I32> {
    index(): I32ColumnBuilder<SetField<M, 'indexType', 'btree'>>;
    index<N extends NonNullable<IndexTypes>>(algorithm: N): I32ColumnBuilder<SetField<M, 'indexType', N>>;
    unique(): I32ColumnBuilder<SetField<M, 'isUnique', true>>;
    primaryKey(): I32ColumnBuilder<SetField<M, 'isPrimaryKey', true>>;
    autoInc(): I32ColumnBuilder<SetField<M, 'isAutoIncrement', true>>;
    default(value: number): I32ColumnBuilder<SetField<M, 'defaultValue', number>>;
    name<const Name extends string>(name: Name): I32ColumnBuilder<SetField<M, 'name', Name>>;
}
export declare class I64ColumnBuilder<M extends ColumnMetadata<bigint> = DefaultMetadata> extends ColumnBuilder<bigint, AlgebraicTypeVariants.I64, M> implements Indexable<bigint, AlgebraicTypeVariants.I64>, Uniqueable<bigint, AlgebraicTypeVariants.I64>, PrimaryKeyable<bigint, AlgebraicTypeVariants.I64>, AutoIncrementable<bigint, AlgebraicTypeVariants.I64>, Defaultable<bigint, AlgebraicTypeVariants.I64>, Nameable<bigint, AlgebraicTypeVariants.I64> {
    index(): I64ColumnBuilder<SetField<M, 'indexType', 'btree'>>;
    index<N extends NonNullable<IndexTypes>>(algorithm: N): I64ColumnBuilder<SetField<M, 'indexType', N>>;
    unique(): I64ColumnBuilder<SetField<M, 'isUnique', true>>;
    primaryKey(): I64ColumnBuilder<SetField<M, 'isPrimaryKey', true>>;
    autoInc(): I64ColumnBuilder<SetField<M, 'isAutoIncrement', true>>;
    default(value: bigint): I64ColumnBuilder<SetField<M, 'defaultValue', bigint>>;
    name<const Name extends string>(name: Name): I64ColumnBuilder<SetField<M, 'name', Name>>;
}
export declare class I128ColumnBuilder<M extends ColumnMetadata<bigint> = DefaultMetadata> extends ColumnBuilder<bigint, AlgebraicTypeVariants.I128, M> implements Indexable<bigint, AlgebraicTypeVariants.I128>, Uniqueable<bigint, AlgebraicTypeVariants.I128>, PrimaryKeyable<bigint, AlgebraicTypeVariants.I128>, AutoIncrementable<bigint, AlgebraicTypeVariants.I128>, Defaultable<bigint, AlgebraicTypeVariants.I128>, Nameable<bigint, AlgebraicTypeVariants.I128> {
    index(): I128ColumnBuilder<SetField<M, 'indexType', 'btree'>>;
    index<N extends NonNullable<IndexTypes>>(algorithm: N): I128ColumnBuilder<SetField<M, 'indexType', N>>;
    unique(): I128ColumnBuilder<SetField<M, 'isUnique', true>>;
    primaryKey(): I128ColumnBuilder<SetField<M, 'isPrimaryKey', true>>;
    autoInc(): I128ColumnBuilder<SetField<M, 'isAutoIncrement', true>>;
    default(value: bigint): I128ColumnBuilder<SetField<M, 'defaultValue', bigint>>;
    name<const Name extends string>(name: Name): I128ColumnBuilder<SetField<M, 'name', Name>>;
}
export declare class I256ColumnBuilder<M extends ColumnMetadata<bigint> = DefaultMetadata> extends ColumnBuilder<bigint, AlgebraicTypeVariants.I256, M> implements Indexable<bigint, AlgebraicTypeVariants.I256>, Uniqueable<bigint, AlgebraicTypeVariants.I256>, PrimaryKeyable<bigint, AlgebraicTypeVariants.I256>, AutoIncrementable<bigint, AlgebraicTypeVariants.I256>, Defaultable<bigint, AlgebraicTypeVariants.I256>, Nameable<bigint, AlgebraicTypeVariants.I256> {
    index(): I256ColumnBuilder<SetField<M, 'indexType', 'btree'>>;
    index<N extends NonNullable<IndexTypes>>(algorithm: N): I256ColumnBuilder<SetField<M, 'indexType', N>>;
    unique(): I256ColumnBuilder<SetField<M, 'isUnique', true>>;
    primaryKey(): I256ColumnBuilder<SetField<M, 'isPrimaryKey', true>>;
    autoInc(): I256ColumnBuilder<SetField<M, 'isAutoIncrement', true>>;
    default(value: bigint): I256ColumnBuilder<SetField<M, 'defaultValue', bigint>>;
    name<const Name extends string>(name: Name): I256ColumnBuilder<SetField<M, 'name', Name>>;
}
export declare class F32ColumnBuilder<M extends ColumnMetadata<number> = DefaultMetadata> extends ColumnBuilder<number, AlgebraicTypeVariants.F32, M> implements Defaultable<number, AlgebraicTypeVariants.F32>, Nameable<number, AlgebraicTypeVariants.F32> {
    default(value: number): F32ColumnBuilder<SetField<M, 'defaultValue', number>>;
    name<const Name extends string>(name: Name): F32ColumnBuilder<SetField<M, 'name', Name>>;
}
export declare class F64ColumnBuilder<M extends ColumnMetadata<number> = DefaultMetadata> extends ColumnBuilder<number, AlgebraicTypeVariants.F64, M> implements Defaultable<number, AlgebraicTypeVariants.F64>, Nameable<number, AlgebraicTypeVariants.F64> {
    default(value: number): F64ColumnBuilder<SetField<M, 'defaultValue', number>>;
    name<const Name extends string>(name: Name): F64ColumnBuilder<SetField<M, 'name', Name>>;
}
export declare class BoolColumnBuilder<M extends ColumnMetadata<boolean> = DefaultMetadata> extends ColumnBuilder<boolean, AlgebraicTypeVariants.Bool, M> implements Indexable<boolean, AlgebraicTypeVariants.Bool>, Uniqueable<boolean, AlgebraicTypeVariants.Bool>, PrimaryKeyable<boolean, AlgebraicTypeVariants.Bool>, Defaultable<boolean, AlgebraicTypeVariants.Bool>, Nameable<boolean, AlgebraicTypeVariants.Bool> {
    index(): BoolColumnBuilder<SetField<M, 'indexType', 'btree'>>;
    index<N extends NonNullable<IndexTypes>>(algorithm: N): BoolColumnBuilder<SetField<M, 'indexType', N>>;
    unique(): BoolColumnBuilder<SetField<M, 'isUnique', true>>;
    primaryKey(): BoolColumnBuilder<SetField<M, 'isPrimaryKey', true>>;
    default(value: boolean): BoolColumnBuilder<SetField<M, 'defaultValue', boolean>>;
    name<const Name extends string>(name: Name): BoolColumnBuilder<SetField<M, 'name', Name>>;
}
export declare class StringColumnBuilder<M extends ColumnMetadata<string> = DefaultMetadata> extends ColumnBuilder<string, AlgebraicTypeVariants.String, M> implements Indexable<string, AlgebraicTypeVariants.String>, Uniqueable<string, AlgebraicTypeVariants.String>, PrimaryKeyable<string, AlgebraicTypeVariants.String>, Defaultable<string, AlgebraicTypeVariants.String>, Nameable<string, AlgebraicTypeVariants.String> {
    index(): StringColumnBuilder<SetField<M, 'indexType', 'btree'>>;
    index<N extends NonNullable<IndexTypes>>(algorithm: N): StringColumnBuilder<SetField<M, 'indexType', N>>;
    unique(): StringColumnBuilder<SetField<M, 'isUnique', true>>;
    primaryKey(): StringColumnBuilder<SetField<M, 'isPrimaryKey', true>>;
    default(value: string): StringColumnBuilder<SetField<M, 'defaultValue', string>>;
    name<const Name extends string>(name: Name): StringColumnBuilder<SetField<M, 'name', Name>>;
}
export declare class ArrayColumnBuilder<Element extends TypeBuilder<any, any>, M extends ColumnMetadata<Array<InferTypeOfTypeBuilder<Element>>> = DefaultMetadata> extends ColumnBuilder<Array<InferTypeOfTypeBuilder<Element>>, {
    tag: 'Array';
    value: InferSpacetimeTypeOfTypeBuilder<Element>;
}, M> implements Defaultable<Array<InferTypeOfTypeBuilder<Element>>, AlgebraicTypeVariants.Array>, Nameable<Array<InferTypeOfTypeBuilder<Element>>, AlgebraicTypeVariants.Array> {
    default(value: Array<InferTypeOfTypeBuilder<Element>>): ArrayColumnBuilder<Element, SetField<M, 'defaultValue', Array<InferTypeOfTypeBuilder<Element>>>>;
    name<const Name extends string>(name: Name): ArrayColumnBuilder<Element, SetField<M, 'name', Name>>;
}
type ByteArrayType = {
    tag: 'Array';
    value: AlgebraicTypeVariants.U8;
};
export declare class ByteArrayColumnBuilder<M extends ColumnMetadata<Uint8Array> = DefaultMetadata> extends ColumnBuilder<Uint8Array, ByteArrayType, M> implements Defaultable<Uint8Array, ByteArrayType, M>, Nameable<Uint8Array, ByteArrayType, M> {
    constructor(metadata: M);
    default(value: Uint8Array): ByteArrayColumnBuilder<SetField<M, 'defaultValue', Uint8Array>>;
    name<const Name extends string>(name: Name): ByteArrayColumnBuilder<SetField<M, 'name', Name>>;
}
export declare class OptionColumnBuilder<Value extends TypeBuilder<any, any>, M extends ColumnMetadata<InferTypeOfTypeBuilder<Value> | undefined> = DefaultMetadata> extends ColumnBuilder<InferTypeOfTypeBuilder<Value> | undefined, OptionAlgebraicType<InferSpacetimeTypeOfTypeBuilder<Value>>, M> implements Defaultable<InferTypeOfTypeBuilder<Value> | undefined, OptionAlgebraicType<InferSpacetimeTypeOfTypeBuilder<Value>>>, Nameable<InferTypeOfTypeBuilder<Value> | undefined, OptionAlgebraicType<InferSpacetimeTypeOfTypeBuilder<Value>>> {
    default(value: InferTypeOfTypeBuilder<Value> | undefined): OptionColumnBuilder<Value, SetField<M, 'defaultValue', InferTypeOfTypeBuilder<Value> | undefined>>;
    name<const Name extends string>(name: Name): OptionColumnBuilder<Value, SetField<M, 'name', Name>>;
}
export declare class ResultColumnBuilder<Ok extends TypeBuilder<any, any>, Err extends TypeBuilder<any, any>, M extends ColumnMetadata<InferTypeOfTypeBuilder<Ok> | InferTypeOfTypeBuilder<Err>> = DefaultMetadata> extends ColumnBuilder<InferTypeOfTypeBuilder<Ok> | InferTypeOfTypeBuilder<Err>, ResultAlgebraicType<InferSpacetimeTypeOfTypeBuilder<Ok>, InferSpacetimeTypeOfTypeBuilder<Err>>, M> implements Defaultable<InferTypeOfTypeBuilder<Ok> | InferTypeOfTypeBuilder<Err>, ResultAlgebraicType<InferSpacetimeTypeOfTypeBuilder<Ok>, InferSpacetimeTypeOfTypeBuilder<Err>>> {
    constructor(typeBuilder: TypeBuilder<any, any>, metadata: M);
    default(value: InferTypeOfTypeBuilder<Ok> | InferTypeOfTypeBuilder<Err>): ResultColumnBuilder<Ok, Err, SetField<M, 'defaultValue', InferTypeOfTypeBuilder<Ok> | InferTypeOfTypeBuilder<Err>>>;
}
export declare class ProductColumnBuilder<Elements extends ElementsObj, M extends ColumnMetadata<ObjectType<Elements>> = DefaultMetadata> extends ColumnBuilder<ObjectType<Elements>, ElementsToProductType<Elements>, M> implements Defaultable<ObjectType<Elements>, ElementsToProductType<Elements>>, Nameable<ObjectType<Elements>, ElementsToProductType<Elements>> {
    default(value: ObjectType<Elements>): ProductColumnBuilder<Elements, SetField<DefaultMetadata, 'defaultValue', any>>;
    name<const Name extends string>(name: Name): ProductColumnBuilder<Elements, SetField<DefaultMetadata, 'name', Name>>;
}
export declare class SumColumnBuilder<Variants extends VariantsObj, M extends ColumnMetadata<EnumType<Variants>> = DefaultMetadata> extends ColumnBuilder<EnumType<Variants>, VariantsToSumType<Variants>, M> implements Defaultable<EnumType<Variants>, VariantsToSumType<Variants>>, Nameable<EnumType<Variants>, VariantsToSumType<Variants>> {
    default(value: EnumType<Variants>): SumColumnBuilder<Variants, SetField<DefaultMetadata, 'defaultValue', any>>;
    name<const Name extends string>(name: Name): SumColumnBuilder<Variants, SetField<DefaultMetadata, 'name', Name>>;
}
export declare class SimpleSumColumnBuilder<Variants extends VariantsObj, M extends ColumnMetadata<EnumType<Variants>> = DefaultMetadata> extends SumColumnBuilder<Variants, M> implements Indexable<EnumType<Variants>, AlgebraicTypeVariants.Sum>, PrimaryKeyable<EnumType<Variants>, AlgebraicTypeVariants.Sum> {
    index(): SimpleSumColumnBuilder<Variants, SetField<DefaultMetadata, 'indexType', 'btree'>>;
    index<N extends NonNullable<IndexTypes>>(algorithm: N): SimpleSumColumnBuilder<Variants, SetField<DefaultMetadata, 'indexType', N>>;
    primaryKey(): SimpleSumColumnBuilder<Variants, SetField<DefaultMetadata, 'isPrimaryKey', true>>;
}
export declare class ScheduleAtColumnBuilder<M extends ColumnMetadata<ScheduleAt> = DefaultMetadata> extends ColumnBuilder<ScheduleAt, ScheduleAtAlgebraicType, M> implements Defaultable<ScheduleAt, ScheduleAtAlgebraicType>, Nameable<ScheduleAt, ScheduleAtAlgebraicType> {
    default(value: ScheduleAt): ScheduleAtColumnBuilder<SetField<M, 'defaultValue', ScheduleAt>>;
    name<const Name extends string>(name: Name): ScheduleAtColumnBuilder<SetField<M, 'name', Name>>;
}
export declare class IdentityColumnBuilder<M extends ColumnMetadata<Identity> = DefaultMetadata> extends ColumnBuilder<Identity, IdentityAlgebraicType, M> implements Indexable<Identity, IdentityAlgebraicType>, Uniqueable<Identity, IdentityAlgebraicType>, PrimaryKeyable<Identity, IdentityAlgebraicType>, Defaultable<Identity, IdentityAlgebraicType>, Nameable<Identity, IdentityAlgebraicType> {
    index(): IdentityColumnBuilder<SetField<M, 'indexType', 'btree'>>;
    index<N extends NonNullable<IndexTypes>>(algorithm: N): IdentityColumnBuilder<SetField<M, 'indexType', N>>;
    unique(): IdentityColumnBuilder<SetField<M, 'isUnique', true>>;
    primaryKey(): IdentityColumnBuilder<SetField<M, 'isPrimaryKey', true>>;
    default(value: Identity): IdentityColumnBuilder<SetField<M, 'defaultValue', Identity>>;
    name<const Name extends string>(name: Name): IdentityColumnBuilder<SetField<M, 'name', Name>>;
}
export declare class ConnectionIdColumnBuilder<M extends ColumnMetadata<ConnectionId> = DefaultMetadata> extends ColumnBuilder<ConnectionId, ConnectionIdAlgebraicType, M> implements Indexable<ConnectionId, ConnectionIdAlgebraicType>, Uniqueable<ConnectionId, ConnectionIdAlgebraicType>, PrimaryKeyable<ConnectionId, ConnectionIdAlgebraicType>, Defaultable<ConnectionId, ConnectionIdAlgebraicType>, Nameable<ConnectionId, ConnectionIdAlgebraicType> {
    index(): ConnectionIdColumnBuilder<SetField<M, 'indexType', 'btree'>>;
    index<N extends NonNullable<IndexTypes>>(algorithm: N): ConnectionIdColumnBuilder<SetField<M, 'indexType', N>>;
    unique(): ConnectionIdColumnBuilder<SetField<M, 'isUnique', true>>;
    primaryKey(): ConnectionIdColumnBuilder<SetField<M, 'isPrimaryKey', true>>;
    default(value: ConnectionId): ConnectionIdColumnBuilder<SetField<M, 'defaultValue', ConnectionId>>;
    name<const Name extends string>(name: Name): ConnectionIdColumnBuilder<SetField<M, 'name', Name>>;
}
export declare class TimestampColumnBuilder<M extends ColumnMetadata<Timestamp> = DefaultMetadata> extends ColumnBuilder<Timestamp, TimestampAlgebraicType, M> implements Indexable<Timestamp, TimestampAlgebraicType>, Uniqueable<Timestamp, TimestampAlgebraicType>, PrimaryKeyable<Timestamp, TimestampAlgebraicType>, Defaultable<Timestamp, TimestampAlgebraicType>, Nameable<Timestamp, TimestampAlgebraicType> {
    index(): TimestampColumnBuilder<SetField<M, 'indexType', 'btree'>>;
    index<N extends NonNullable<IndexTypes>>(algorithm: N): TimestampColumnBuilder<SetField<M, 'indexType', N>>;
    unique(): TimestampColumnBuilder<SetField<M, 'isUnique', true>>;
    primaryKey(): TimestampColumnBuilder<SetField<M, 'isPrimaryKey', true>>;
    default(value: Timestamp): TimestampColumnBuilder<SetField<M, 'defaultValue', Timestamp>>;
    name<const Name extends string>(name: Name): TimestampColumnBuilder<SetField<M, 'name', Name>>;
}
export declare class TimeDurationColumnBuilder<M extends ColumnMetadata<TimeDuration> = DefaultMetadata> extends ColumnBuilder<TimeDuration, TimeDurationAlgebraicType, M> implements Indexable<TimeDuration, TimeDurationAlgebraicType>, Uniqueable<TimeDuration, TimeDurationAlgebraicType>, PrimaryKeyable<TimeDuration, TimeDurationAlgebraicType>, Defaultable<TimeDuration, TimeDurationAlgebraicType>, Nameable<TimeDuration, TimeDurationAlgebraicType> {
    index(): TimeDurationColumnBuilder<SetField<M, 'indexType', 'btree'>>;
    index<N extends NonNullable<IndexTypes>>(algorithm: N): TimeDurationColumnBuilder<SetField<M, 'indexType', N>>;
    unique(): TimeDurationColumnBuilder<SetField<M, 'isUnique', true>>;
    primaryKey(): TimeDurationColumnBuilder<SetField<M, 'isPrimaryKey', true>>;
    default(value: TimeDuration): TimeDurationColumnBuilder<SetField<M, 'defaultValue', TimeDuration>>;
    name<const Name extends string>(name: Name): TimeDurationColumnBuilder<SetField<M, 'name', Name>>;
}
export declare class UuidColumnBuilder<M extends ColumnMetadata<Uuid> = DefaultMetadata> extends ColumnBuilder<Uuid, UuidAlgebraicType, M> implements Indexable<Uuid, UuidAlgebraicType>, Uniqueable<Uuid, UuidAlgebraicType>, PrimaryKeyable<Uuid, UuidAlgebraicType>, Defaultable<Uuid, UuidAlgebraicType> {
    index(): UuidColumnBuilder<SetField<M, 'indexType', 'btree'>>;
    index<N extends NonNullable<IndexTypes>>(algorithm: N): UuidColumnBuilder<SetField<M, 'indexType', N>>;
    unique(): UuidColumnBuilder<SetField<M, 'isUnique', true>>;
    primaryKey(): UuidColumnBuilder<SetField<M, 'isPrimaryKey', true>>;
    default(value: Uuid): UuidColumnBuilder<SetField<M, 'defaultValue', Uuid>>;
}
export declare class RefBuilder<Type, SpacetimeType> extends TypeBuilder<Type, AlgebraicTypeVariants.Ref> {
    readonly ref: number;
    /** The phantom type of the pointee of this ref. */
    private readonly __spacetimeType;
    constructor(ref: number);
}
interface EnumFn {
    /**
     * Creates a simple sum type whose cases are all unit variants.
     * Each string in the array becomes a case of the enum.
     *
     * Example:
     * ```ts
     * t.enum("Color", ["red", "green", "blue"]);
     * ```
     */
    <Case extends string>(name: string, cases: readonly [Case, ...Case[]]): SimpleSumBuilderImpl<Record<Case, UnitBuilder>>;
    /**
     * Creates an empty simple sum type (no cases, equivalent to `never`).
     * This can be useful for code generation or placeholder types.
     * Example:
     * ```ts
     * t.enum("Never", []);
     * ```
     */
    (name: string, cases: []): SimpleSumBuilderImpl<Record<never, UnitBuilder>>;
    /**
     * Creates a full sum type, where each case can have a payload.
     * Each value in the object must be a {@link TypeBuilder}.
     *
     * Example:
     * ```ts
     * t.enum("Result", { Ok: t.unit(), Err: t.string() });
     * ```
     */
    <Obj extends VariantsObj>(name: string, obj: Obj): SumBuilder<Obj>;
}
/**
 * A collection of factory functions for creating various SpacetimeDB algebraic types
 * to be used in table definitions. Each function returns a corresponding builder
 * for a specific type, such as `BoolBuilder`, `StringBuilder`, or `F64Builder`.
 *
 * These builders are used to define the schema of tables in SpacetimeDB, and each
 * builder implements the {@link TypeBuilder} interface, allowing for type-safe
 * schema construction in TypeScript.
 *
 * @remarks
 * - Primitive types (e.g., `bool`, `string`, `number`) map to their respective TypeScript types.
 * - Integer and floating-point types (e.g., `i8`, `u64`, `f32`) are represented as `number` or `bigint` in TypeScript.
 * - Complex types such as `object`, `array`, and `enum` allow for nested and structured schemas.
 * - The `scheduleAt` builder is a special column type for scheduling.
 *
 * @see {@link TypeBuilder}
 */
export declare const t: {
    /**
     * Creates a new `Bool` {@link AlgebraicType} to be used in table definitions
     * Represented as `boolean` in TypeScript.
     * @returns A new {@link BoolBuilder} instance
     */
    readonly bool: () => BoolBuilder;
    /**
     * Creates a new `String` {@link AlgebraicType} to be used in table definitions
     * Represented as `string` in TypeScript.
     * @returns A new {@link StringBuilder} instance
     */
    readonly string: () => StringBuilder;
    /**
     * Creates a new `F64` {@link AlgebraicType} to be used in table definitions
     * Represented as `number` in TypeScript.
     * @returns A new {@link F64Builder} instance
     */
    readonly number: () => F64Builder;
    /**
     * Creates a new `I8` {@link AlgebraicType} to be used in table definitions
     * Represented as `number` in TypeScript.
     * @returns A new {@link I8Builder} instance
     */
    readonly i8: () => I8Builder;
    /**
     * Creates a new `U8` {@link AlgebraicType} to be used in table definitions
     * Represented as `number` in TypeScript.
     * @returns A new {@link U8Builder} instance
     */
    readonly u8: () => U8Builder;
    /**
     * Creates a new `I16` {@link AlgebraicType} to be used in table definitions
     * Represented as `number` in TypeScript.
     * @returns A new {@link I16Builder} instance
     */
    readonly i16: () => I16Builder;
    /**
     * Creates a new `U16` {@link AlgebraicType} to be used in table definitions
     * Represented as `number` in TypeScript.
     * @returns A new {@link U16Builder} instance
     */
    readonly u16: () => U16Builder;
    /**
     * Creates a new `I32` {@link AlgebraicType} to be used in table definitions
     * Represented as `number` in TypeScript.
     * @returns A new {@link I32Builder} instance
     */
    readonly i32: () => I32Builder;
    /**
     * Creates a new `U32` {@link AlgebraicType} to be used in table definitions
     * Represented as `number` in TypeScript.
     * @returns A new {@link U32Builder} instance
     */
    readonly u32: () => U32Builder;
    /**
     * Creates a new `I64` {@link AlgebraicType} to be used in table definitions
     * Represented as `bigint` in TypeScript.
     * @returns A new {@link I64Builder} instance
     */
    readonly i64: () => I64Builder;
    /**
     * Creates a new `U64` {@link AlgebraicType} to be used in table definitions
     * Represented as `bigint` in TypeScript.
     * @returns A new {@link U64Builder} instance
     */
    readonly u64: () => U64Builder;
    /**
     * Creates a new `I128` {@link AlgebraicType} to be used in table definitions
     * Represented as `bigint` in TypeScript.
     * @returns A new {@link I128Builder} instance
     */
    readonly i128: () => I128Builder;
    /**
     * Creates a new `U128` {@link AlgebraicType} to be used in table definitions
     * Represented as `bigint` in TypeScript.
     * @returns A new {@link U128Builder} instance
     */
    readonly u128: () => U128Builder;
    /**
     * Creates a new `I256` {@link AlgebraicType} to be used in table definitions
     * Represented as `bigint` in TypeScript.
     * @returns A new {@link I256Builder} instance
     */
    readonly i256: () => I256Builder;
    /**
     * Creates a new `U256` {@link AlgebraicType} to be used in table definitions
     * Represented as `bigint` in TypeScript.
     * @returns A new {@link U256Builder} instance
     */
    readonly u256: () => U256Builder;
    /**
     * Creates a new `F32` {@link AlgebraicType} to be used in table definitions
     * Represented as `number` in TypeScript.
     * @returns A new {@link F32Builder} instance
     */
    readonly f32: () => F32Builder;
    /**
     * Creates a new `F64` {@link AlgebraicType} to be used in table definitions
     * Represented as `number` in TypeScript.
     * @returns A new {@link F64Builder} instance
     */
    readonly f64: () => F64Builder;
    /**
     * Creates a new `Product` {@link AlgebraicType} to be used in table definitions. Product types in SpacetimeDB
     * are essentially the same as objects in JavaScript/TypeScript.
     * Properties of the object must also be {@link TypeBuilder}s.
     * Represented as an object with specific properties in TypeScript.
     *
     * @param name (optional) A display name for the product type. If omitted, an anonymous product type is created.
     * @param obj The object defining the properties of the type, whose property
     * values must be {@link TypeBuilder}s.
     * @returns A new {@link ProductBuilder} instance.
     */
    readonly object: {
        <Obj extends ElementsObj>(name: string, obj: Obj): ProductBuilder<Obj>;
    };
    /**
     * Creates a new `Row` {@link AlgebraicType} to be used in table definitions. Row types in SpacetimeDB
     * are similar to `Product` types, but are specifically used to define the schema of a table row.
     * Properties of the object must also be {@link TypeBuilder} or {@link ColumnBuilder}s.
     *
     * You can represent a `Row` as either a {@link RowObj} or an {@link RowBuilder} type when
     * defining a table schema.
     *
     * The {@link RowBuilder} type is useful when you want to create a type which can be used anywhere
     * a {@link TypeBuilder} is accepted, such as in nested objects or arrays, or as the argument
     * to a scheduled function.
     *
     * @param obj The object defining the properties of the row, whose property
     * values must be {@link TypeBuilder}s or {@link ColumnBuilder}s.
     * @returns A new {@link RowBuilder} instance
     */
    readonly row: {
        <Obj extends RowObj>(obj: Obj): RowBuilder<Obj>;
        <Obj extends RowObj>(name: string, obj: Obj): RowBuilder<Obj>;
    };
    /**
     * Creates a new `Array` {@link AlgebraicType} to be used in table definitions.
     * Represented as an array in TypeScript.
     * @param element The element type of the array, which must be a `TypeBuilder`.
     * @returns A new {@link ArrayBuilder} instance
     */
    readonly array: <Element extends TypeBuilder<any, any>>(e: Element) => ArrayBuilder<Element>;
    readonly enum: EnumFn;
    /**
     * This is a special helper function for conveniently creating {@link Product} type columns with no fields.
     *
     * @returns A new {@link ProductBuilder} instance with no fields.
     */
    readonly unit: () => UnitBuilder;
    /**
     * Creates a lazily-evaluated {@link TypeBuilder}. This is useful for creating
     * recursive types, such as a tree or linked list.
     * @param thunk A function that returns a {@link TypeBuilder}.
     * @returns A proxy {@link TypeBuilder} that evaluates the thunk on first access.
     */
    readonly lazy: <Build extends () => TypeBuilder<any, any>>(thunk: Build) => ReturnType<Build>;
    /**
     * This is a special helper function for conveniently creating {@link ScheduleAt} type columns.
     * @returns A new ColumnBuilder instance with the {@link ScheduleAt} type.
     */
    readonly scheduleAt: () => ScheduleAtBuilder;
    /**
     * This is a convenience method for creating a column with the {@link Option} type.
     * You can create a column of the same type by constructing an enum with a `some` and `none` variant.
     * @param value The type of the value contained in the `some` variant of the `Option`.
     * @returns A new {@link OptionBuilder} instance with the {@link Option} type.
     */
    readonly option: <Value extends TypeBuilder<any, any>>(value: Value) => OptionBuilder<Value>;
    /**
     * This is a convenience method for creating a column with the {@link Result} type.
     * You can create a column of the same type by constructing an enum with an `ok` and `err` variant.
     * @param ok The type of the value contained in the `ok` variant of the `Result`.
     * @param err The type of the value contained in the `err` variant of the `Result`.
     * @returns A new {@link ResultBuilder} instance with the {@link Result} type.
     */
    readonly result: <Ok extends TypeBuilder<any, any>, Err extends TypeBuilder<any, any>>(ok: Ok, err: Err) => ResultBuilder<Ok, Err>;
    /**
     * This is a convenience method for creating a column with the {@link Identity} type.
     * You can create a column of the same type by constructing an `object` with a single `__identity__` element.
     * @returns A new {@link TypeBuilder} instance with the {@link Identity} type.
     */
    readonly identity: () => IdentityBuilder;
    /**
     * This is a convenience method for creating a column with the {@link ConnectionId} type.
     * You can create a column of the same type by constructing an `object` with a single `__connection_id__` element.
     * @returns A new {@link TypeBuilder} instance with the {@link ConnectionId} type.
     */
    readonly connectionId: () => ConnectionIdBuilder;
    /**
     * This is a convenience method for creating a column with the {@link Timestamp} type.
     * You can create a column of the same type by constructing an `object` with a single `__timestamp_micros_since_unix_epoch__` element.
     * @returns A new {@link TypeBuilder} instance with the {@link Timestamp} type.
     */
    readonly timestamp: () => TimestampBuilder;
    /**
     * This is a convenience method for creating a column with the {@link TimeDuration} type.
     * You can create a column of the same type by constructing an `object` with a single `__time_duration_micros__` element.
     * @returns A new {@link TypeBuilder} instance with the {@link TimeDuration} type.
     */
    readonly timeDuration: () => TimeDurationBuilder;
    /**
     * This is a convenience method for creating a column with the {@link Uuid} type.
     * You can create a column of the same type by constructing an `object` with a single `__uuid__` element.
     * @returns A new {@link TypeBuilder} instance with the {@link Uuid} type.
     */
    readonly uuid: () => UuidBuilder;
    /**
     * This is a convenience method for creating a column with the {@link ByteArray} type.
     * You can create a column of the same type by constructing an `array` of `u8`.
     * The TypeScript representation is {@link Uint8Array}.
     * @returns A new {@link ByteArrayBuilder} instance with the {@link ByteArray} type.
     */
    readonly byteArray: () => ByteArrayBuilder;
};
export default t;
//# sourceMappingURL=type_builders.d.ts.map