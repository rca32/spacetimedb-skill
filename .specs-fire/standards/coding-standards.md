# Coding Standards

## Overview

Primary development is in Rust with a focus on explicit types, clear module boundaries, and predictable error handling. TypeScript examples should follow conventional lint/format rules in their local module configs.

## Code Formatting

**Tool**: rustfmt
**Config**: rustfmt.toml if present, otherwise defaults
**Enforcement**: Required before merge

### Key Settings

- **Edition**: 2021
- **Line Width**: Default rustfmt settings

## Linting

**Tool**: clippy
**Base Config**: default clippy lints with local crate overrides
**Strictness**: warn on new lints, allow where justified

### Key Rules

- `clippy::unwrap_used`: allow in tests, avoid in production paths
- `clippy::expect_used`: allow with clear error messages
- `clippy::result_large_err`: allow where ergonomics outweigh size

## Naming Conventions

### Variables and Functions

| Element | Convention | Example |
|---------|------------|---------|
| Variables | snake_case | `player_id` |
| Functions | snake_case | `load_world_state` |
| Types | PascalCase | `WorldState` |
| Constants | SCREAMING_SNAKE_CASE | `MAX_TICK_RATE` |

### Files and Folders

- **Rust modules**: snake_case (e.g., `world_state.rs`)
- **Tests**: snake_case (e.g., `reducers_tests.rs`)

## File Organization

### Project Structure

```
stitch-server/
  crates/
    game_server/
      src/
        tables/
        reducers/
        services/
        agents/
```

### Conventions

- **Public exports**: use `mod.rs` to re-export module items
- **Separation**: keep reducers, tables, services, and agents in their respective folders

## Import Order

```rust
use std::collections::HashMap;

use anyhow::Result;
use tracing::info;

use crate::services::world_state::WorldStateService;
```

**Rules**:
- Standard library first
- Third-party crates next
- Local crate imports last

## Error Handling

### Pattern

**Approach**: Return `Result<_, String>` for reducers; use `thiserror`/`anyhow` in services and tools as appropriate.

### Guidelines

- Prefer descriptive error messages at boundaries
- Convert internal errors into user-friendly reducer errors

### Example

```rust
pub fn load_world(ctx: &ReducerContext) -> Result<(), String> {
    ctx.db
        .world_state()
        .get()
        .ok_or_else(|| "world_state missing".to_string())?;
    Ok(())
}
```

## Logging

**Tool**: tracing
**Format**: structured logs with context fields

### Log Levels

| Level | Usage |
|-------|-------|
| error | user-facing failures, invariants broken |
| warn | unexpected but recoverable conditions |
| info | major state changes and lifecycle events |
| debug | detailed behavior for development |

### Guidelines

**Always log**:
- Reducer failures with key identifiers
- Lifecycle start/stop events for agents

**Never log**:
- Secrets, tokens, or credentials

## Comments and Documentation

### When to Comment

- Explain non-obvious reducer invariants
- Document time-based or decay rules

### Documentation Format

**Functions**: Rust doc comments for public APIs
**Classes**: Rust doc comments for public structs and enums

## Code Patterns

### Preferred Patterns

#### Newtype IDs

Wrap identifiers in newtypes to avoid mixing IDs across domains.

```rust
pub struct PlayerId(pub u64);
```

### Anti-Patterns to Avoid

- **Global mutable state**: hard to test and reason about
- **Reducer side effects outside DB**: keep reducers deterministic

---
*Generated by specs.md - fabriqa.ai FIRE Flow*
