//This file is auto-generated by bitcraft\build.rs. Do not edit.

use crate::messages::static_data::*;
use crate::*;
use spacetimedb::*;
use crate::game::handlers::authentication::has_role;

#[spacetimedb::reducer]
pub fn clear_staged_static_data(ctx: &ReducerContext) -> Result<(), String> {
    if !has_role(ctx, &ctx.sender, Role::Admin) {
        return Err("Invalid permissions".into());
    }

    for r in ctx.db.staged_ability_custom_desc().iter() {
        ctx.db.staged_ability_custom_desc().delete(r);
    }
    for r in ctx.db.staged_ability_unlock_desc().iter() {
        ctx.db.staged_ability_unlock_desc().delete(r);
    }
    for r in ctx.db.staged_achievement_desc().iter() {
        ctx.db.staged_achievement_desc().delete(r);
    }
    for r in ctx.db.staged_alert_desc().iter() {
        ctx.db.staged_alert_desc().delete(r);
    }
    for r in ctx.db.staged_biome_desc().iter() {
        ctx.db.staged_biome_desc().delete(r);
    }
    for r in ctx.db.staged_buff_desc().iter() {
        ctx.db.staged_buff_desc().delete(r);
    }
    for r in ctx.db.staged_buff_type_desc().iter() {
        ctx.db.staged_buff_type_desc().delete(r);
    }
    for r in ctx.db.staged_building_claim_desc().iter() {
        ctx.db.staged_building_claim_desc().delete(r);
    }
    for r in ctx.db.staged_building_desc().iter() {
        ctx.db.staged_building_desc().delete(r);
    }
    for r in ctx.db.staged_building_portal_desc_v2().iter() {
        ctx.db.staged_building_portal_desc_v2().delete(r);
    }
    for r in ctx.db.staged_building_repairs_desc().iter() {
        ctx.db.staged_building_repairs_desc().delete(r);
    }
    for r in ctx.db.staged_building_spawn_desc().iter() {
        ctx.db.staged_building_spawn_desc().delete(r);
    }
    for r in ctx.db.staged_building_type_desc().iter() {
        ctx.db.staged_building_type_desc().delete(r);
    }
    for r in ctx.db.staged_cargo_desc().iter() {
        ctx.db.staged_cargo_desc().delete(r);
    }
    for r in ctx.db.staged_character_stat_desc().iter() {
        ctx.db.staged_character_stat_desc().delete(r);
    }
    for r in ctx.db.staged_chest_rarity_desc().iter() {
        ctx.db.staged_chest_rarity_desc().delete(r);
    }
    for r in ctx.db.staged_claim_tech_desc_v2().iter() {
        ctx.db.staged_claim_tech_desc_v2().delete(r);
    }
    for r in ctx.db.staged_claim_tile_cost().iter() {
        ctx.db.staged_claim_tile_cost().delete(r);
    }
    for r in ctx.db.staged_climb_requirement_desc().iter() {
        ctx.db.staged_climb_requirement_desc().delete(r);
    }
    for r in ctx.db.staged_clothing_desc().iter() {
        ctx.db.staged_clothing_desc().delete(r);
    }
    for r in ctx.db.staged_collectible_desc().iter() {
        ctx.db.staged_collectible_desc().delete(r);
    }
    for r in ctx.db.staged_combat_action_desc_v3().iter() {
        ctx.db.staged_combat_action_desc_v3().delete(r);
    }
    for r in ctx.db.staged_combat_action_multi_hit_desc().iter() {
        ctx.db.staged_combat_action_multi_hit_desc().delete(r);
    }
    for r in ctx.db.staged_construction_recipe_desc_v2().iter() {
        ctx.db.staged_construction_recipe_desc_v2().delete(r);
    }
    for r in ctx.db.staged_contribution_loot_desc().iter() {
        ctx.db.staged_contribution_loot_desc().delete(r);
    }
    for r in ctx.db.staged_crafting_recipe_desc().iter() {
        ctx.db.staged_crafting_recipe_desc().delete(r);
    }
    for r in ctx.db.staged_deconstruction_recipe_desc().iter() {
        ctx.db.staged_deconstruction_recipe_desc().delete(r);
    }
    for r in ctx.db.staged_deployable_desc().iter() {
        ctx.db.staged_deployable_desc().delete(r);
    }
    for r in ctx.db.staged_distant_visible_entity_desc().iter() {
        ctx.db.staged_distant_visible_entity_desc().delete(r);
    }
    for r in ctx.db.staged_elevator_desc().iter() {
        ctx.db.staged_elevator_desc().delete(r);
    }
    for r in ctx.db.staged_emote_desc().iter() {
        ctx.db.staged_emote_desc().delete(r);
    }
    for r in ctx.db.staged_empire_colors_desc().iter() {
        ctx.db.staged_empire_colors_desc().delete(r);
    }
    for r in ctx.db.staged_empire_icon_desc().iter() {
        ctx.db.staged_empire_icon_desc().delete(r);
    }
    for r in ctx.db.staged_empire_notification_desc().iter() {
        ctx.db.staged_empire_notification_desc().delete(r);
    }
    for r in ctx.db.staged_empire_rank_desc().iter() {
        ctx.db.staged_empire_rank_desc().delete(r);
    }
    for r in ctx.db.staged_empire_supplies_desc().iter() {
        ctx.db.staged_empire_supplies_desc().delete(r);
    }
    for r in ctx.db.staged_empire_territory_desc().iter() {
        ctx.db.staged_empire_territory_desc().delete(r);
    }
    for r in ctx.db.staged_enemy_ai_params_desc().iter() {
        ctx.db.staged_enemy_ai_params_desc().delete(r);
    }
    for r in ctx.db.staged_enemy_desc().iter() {
        ctx.db.staged_enemy_desc().delete(r);
    }
    for r in ctx.db.staged_enemy_scaling_desc().iter() {
        ctx.db.staged_enemy_scaling_desc().delete(r);
    }
    for r in ctx.db.staged_environment_debuff_desc().iter() {
        ctx.db.staged_environment_debuff_desc().delete(r);
    }
    for r in ctx.db.staged_equipment_desc().iter() {
        ctx.db.staged_equipment_desc().delete(r);
    }
    for r in ctx.db.staged_extraction_recipe_desc().iter() {
        ctx.db.staged_extraction_recipe_desc().delete(r);
    }
    for r in ctx.db.staged_food_desc().iter() {
        ctx.db.staged_food_desc().delete(r);
    }
    for r in ctx.db.staged_gate_desc().iter() {
        ctx.db.staged_gate_desc().delete(r);
    }
    for r in ctx.db.staged_hexite_exchange_entry_desc().iter() {
        ctx.db.staged_hexite_exchange_entry_desc().delete(r);
    }
    for r in ctx.db.staged_interior_environment_desc().iter() {
        ctx.db.staged_interior_environment_desc().delete(r);
    }
    for r in ctx.db.staged_interior_instance_desc().iter() {
        ctx.db.staged_interior_instance_desc().delete(r);
    }
    for r in ctx.db.staged_interior_network_desc().iter() {
        ctx.db.staged_interior_network_desc().delete(r);
    }
    for r in ctx.db.staged_interior_portal_connections_desc().iter() {
        ctx.db.staged_interior_portal_connections_desc().delete(r);
    }
    for r in ctx.db.staged_interior_shape_desc().iter() {
        ctx.db.staged_interior_shape_desc().delete(r);
    }
    for r in ctx.db.staged_interior_spawn_desc().iter() {
        ctx.db.staged_interior_spawn_desc().delete(r);
    }
    for r in ctx.db.staged_item_conversion_recipe_desc().iter() {
        ctx.db.staged_item_conversion_recipe_desc().delete(r);
    }
    for r in ctx.db.staged_item_desc().iter() {
        ctx.db.staged_item_desc().delete(r);
    }
    for r in ctx.db.staged_item_list_desc().iter() {
        ctx.db.staged_item_list_desc().delete(r);
    }
    for r in ctx.db.staged_knowledge_scroll_desc().iter() {
        ctx.db.staged_knowledge_scroll_desc().delete(r);
    }
    for r in ctx.db.staged_knowledge_scroll_type_desc().iter() {
        ctx.db.staged_knowledge_scroll_type_desc().delete(r);
    }
    for r in ctx.db.staged_knowledge_stat_modifier_desc().iter() {
        ctx.db.staged_knowledge_stat_modifier_desc().delete(r);
    }
    for r in ctx.db.staged_loot_chest_desc().iter() {
        ctx.db.staged_loot_chest_desc().delete(r);
    }
    for r in ctx.db.staged_loot_rarity_desc().iter() {
        ctx.db.staged_loot_rarity_desc().delete(r);
    }
    for r in ctx.db.staged_loot_table_desc().iter() {
        ctx.db.staged_loot_table_desc().delete(r);
    }
    for r in ctx.db.staged_npc_desc().iter() {
        ctx.db.staged_npc_desc().delete(r);
    }
    for r in ctx.db.staged_onboarding_reward_desc().iter() {
        ctx.db.staged_onboarding_reward_desc().delete(r);
    }
    for r in ctx.db.staged_parameters_desc().iter() {
        ctx.db.staged_parameters_desc().delete(r);
    }
    for r in ctx.db.staged_pathfinding_desc().iter() {
        ctx.db.staged_pathfinding_desc().delete(r);
    }
    for r in ctx.db.staged_paving_tile_desc().iter() {
        ctx.db.staged_paving_tile_desc().delete(r);
    }
    for r in ctx.db.staged_pillar_shaping_desc().iter() {
        ctx.db.staged_pillar_shaping_desc().delete(r);
    }
    for r in ctx.db.staged_player_action_desc().iter() {
        ctx.db.staged_player_action_desc().delete(r);
    }
    for r in ctx.db.staged_player_housing_desc().iter() {
        ctx.db.staged_player_housing_desc().delete(r);
    }
    for r in ctx.db.staged_premium_item_desc().iter() {
        ctx.db.staged_premium_item_desc().delete(r);
    }
    for r in ctx.db.staged_premium_service_desc().iter() {
        ctx.db.staged_premium_service_desc().delete(r);
    }
    for r in ctx.db.staged_private_parameters_desc().iter() {
        ctx.db.staged_private_parameters_desc().delete(r);
    }
    for r in ctx.db.staged_prospecting_desc().iter() {
        ctx.db.staged_prospecting_desc().delete(r);
    }
    for r in ctx.db.staged_quest_chain_desc().iter() {
        ctx.db.staged_quest_chain_desc().delete(r);
    }
    for r in ctx.db.staged_quest_stage_desc().iter() {
        ctx.db.staged_quest_stage_desc().delete(r);
    }
    for r in ctx.db.staged_reserved_name_desc().iter() {
        ctx.db.staged_reserved_name_desc().delete(r);
    }
    for r in ctx.db.staged_resource_clump_desc().iter() {
        ctx.db.staged_resource_clump_desc().delete(r);
    }
    for r in ctx.db.staged_resource_desc().iter() {
        ctx.db.staged_resource_desc().delete(r);
    }
    for r in ctx.db.staged_resource_growth_recipe_desc().iter() {
        ctx.db.staged_resource_growth_recipe_desc().delete(r);
    }
    for r in ctx.db.staged_resource_placement_recipe_desc_v2().iter() {
        ctx.db.staged_resource_placement_recipe_desc_v2().delete(r);
    }
    for r in ctx.db.staged_secondary_knowledge_desc().iter() {
        ctx.db.staged_secondary_knowledge_desc().delete(r);
    }
    for r in ctx.db.staged_skill_desc().iter() {
        ctx.db.staged_skill_desc().delete(r);
    }
    for r in ctx.db.staged_stage_rewards_desc().iter() {
        ctx.db.staged_stage_rewards_desc().delete(r);
    }
    for r in ctx.db.staged_targeting_matrix_desc().iter() {
        ctx.db.staged_targeting_matrix_desc().delete(r);
    }
    for r in ctx.db.staged_teleport_item_desc().iter() {
        ctx.db.staged_teleport_item_desc().delete(r);
    }
    for r in ctx.db.staged_terraform_recipe_desc().iter() {
        ctx.db.staged_terraform_recipe_desc().delete(r);
    }
    for r in ctx.db.staged_tool_desc().iter() {
        ctx.db.staged_tool_desc().delete(r);
    }
    for r in ctx.db.staged_tool_type_desc().iter() {
        ctx.db.staged_tool_type_desc().delete(r);
    }
    for r in ctx.db.staged_traveler_task_desc().iter() {
        ctx.db.staged_traveler_task_desc().delete(r);
    }
    for r in ctx.db.staged_traveler_trade_order_desc().iter() {
        ctx.db.staged_traveler_trade_order_desc().delete(r);
    }
    for r in ctx.db.staged_wall_desc().iter() {
        ctx.db.staged_wall_desc().delete(r);
    }
    for r in ctx.db.staged_weapon_desc().iter() {
        ctx.db.staged_weapon_desc().delete(r);
    }
    for r in ctx.db.staged_weapon_type_desc().iter() {
        ctx.db.staged_weapon_type_desc().delete(r);
    }
    for r in ctx.db.staged_wind_params_desc().iter() {
        ctx.db.staged_wind_params_desc().delete(r);
    }

    Ok(())
}

#[spacetimedb::reducer]
pub fn stage_ability_custom_desc(ctx: &ReducerContext, records: Vec<AbilityCustomDesc>) -> Result<(), String> {
    if !has_role(ctx, &ctx.sender, Role::Admin) {
        return Err("Invalid permissions".into());
    }
    for r in records {
        if let Err(e) = ctx.db.staged_ability_custom_desc().try_insert(r.clone()) {
            spacetimedb::log::error!("Failed to stage record {:?}: {}", r, e);
            return Err(e.to_string());
        }
    }
    Ok(())
}

#[spacetimedb::reducer]
pub fn stage_ability_unlock_desc(ctx: &ReducerContext, records: Vec<AbilityUnlockDesc>) -> Result<(), String> {
    if !has_role(ctx, &ctx.sender, Role::Admin) {
        return Err("Invalid permissions".into());
    }
    for r in records {
        if let Err(e) = ctx.db.staged_ability_unlock_desc().try_insert(r.clone()) {
            spacetimedb::log::error!("Failed to stage record {:?}: {}", r, e);
            return Err(e.to_string());
        }
    }
    Ok(())
}

#[spacetimedb::reducer]
pub fn stage_achievement_desc(ctx: &ReducerContext, records: Vec<AchievementDesc>) -> Result<(), String> {
    if !has_role(ctx, &ctx.sender, Role::Admin) {
        return Err("Invalid permissions".into());
    }
    for r in records {
        if let Err(e) = ctx.db.staged_achievement_desc().try_insert(r.clone()) {
            spacetimedb::log::error!("Failed to stage record {:?}: {}", r, e);
            return Err(e.to_string());
        }
    }
    Ok(())
}

#[spacetimedb::reducer]
pub fn stage_alert_desc(ctx: &ReducerContext, records: Vec<AlertDesc>) -> Result<(), String> {
    if !has_role(ctx, &ctx.sender, Role::Admin) {
        return Err("Invalid permissions".into());
    }
    for r in records {
        if let Err(e) = ctx.db.staged_alert_desc().try_insert(r.clone()) {
            spacetimedb::log::error!("Failed to stage record {:?}: {}", r, e);
            return Err(e.to_string());
        }
    }
    Ok(())
}

#[spacetimedb::reducer]
pub fn stage_biome_desc(ctx: &ReducerContext, records: Vec<BiomeDesc>) -> Result<(), String> {
    if !has_role(ctx, &ctx.sender, Role::Admin) {
        return Err("Invalid permissions".into());
    }
    for r in records {
        if let Err(e) = ctx.db.staged_biome_desc().try_insert(r.clone()) {
            spacetimedb::log::error!("Failed to stage record {:?}: {}", r, e);
            return Err(e.to_string());
        }
    }
    Ok(())
}

#[spacetimedb::reducer]
pub fn stage_buff_desc(ctx: &ReducerContext, records: Vec<BuffDesc>) -> Result<(), String> {
    if !has_role(ctx, &ctx.sender, Role::Admin) {
        return Err("Invalid permissions".into());
    }
    for r in records {
        if let Err(e) = ctx.db.staged_buff_desc().try_insert(r.clone()) {
            spacetimedb::log::error!("Failed to stage record {:?}: {}", r, e);
            return Err(e.to_string());
        }
    }
    Ok(())
}

#[spacetimedb::reducer]
pub fn stage_buff_type_desc(ctx: &ReducerContext, records: Vec<BuffTypeDesc>) -> Result<(), String> {
    if !has_role(ctx, &ctx.sender, Role::Admin) {
        return Err("Invalid permissions".into());
    }
    for r in records {
        if let Err(e) = ctx.db.staged_buff_type_desc().try_insert(r.clone()) {
            spacetimedb::log::error!("Failed to stage record {:?}: {}", r, e);
            return Err(e.to_string());
        }
    }
    Ok(())
}

#[spacetimedb::reducer]
pub fn stage_building_claim_desc(ctx: &ReducerContext, records: Vec<BuildingClaimDesc>) -> Result<(), String> {
    if !has_role(ctx, &ctx.sender, Role::Admin) {
        return Err("Invalid permissions".into());
    }
    for r in records {
        if let Err(e) = ctx.db.staged_building_claim_desc().try_insert(r.clone()) {
            spacetimedb::log::error!("Failed to stage record {:?}: {}", r, e);
            return Err(e.to_string());
        }
    }
    Ok(())
}

#[spacetimedb::reducer]
pub fn stage_building_desc(ctx: &ReducerContext, records: Vec<BuildingDesc>) -> Result<(), String> {
    if !has_role(ctx, &ctx.sender, Role::Admin) {
        return Err("Invalid permissions".into());
    }
    for r in records {
        if let Err(e) = ctx.db.staged_building_desc().try_insert(r.clone()) {
            spacetimedb::log::error!("Failed to stage record {:?}: {}", r, e);
            return Err(e.to_string());
        }
    }
    Ok(())
}

#[spacetimedb::reducer]
pub fn stage_building_portal_desc_v2(ctx: &ReducerContext, records: Vec<BuildingPortalDescV2>) -> Result<(), String> {
    if !has_role(ctx, &ctx.sender, Role::Admin) {
        return Err("Invalid permissions".into());
    }
    for r in records {
        if let Err(e) = ctx.db.staged_building_portal_desc_v2().try_insert(r.clone()) {
            spacetimedb::log::error!("Failed to stage record {:?}: {}", r, e);
            return Err(e.to_string());
        }
    }
    Ok(())
}

#[spacetimedb::reducer]
pub fn stage_building_repairs_desc(ctx: &ReducerContext, records: Vec<BuildingRepairsDesc>) -> Result<(), String> {
    if !has_role(ctx, &ctx.sender, Role::Admin) {
        return Err("Invalid permissions".into());
    }
    for r in records {
        if let Err(e) = ctx.db.staged_building_repairs_desc().try_insert(r.clone()) {
            spacetimedb::log::error!("Failed to stage record {:?}: {}", r, e);
            return Err(e.to_string());
        }
    }
    Ok(())
}

#[spacetimedb::reducer]
pub fn stage_building_spawn_desc(ctx: &ReducerContext, records: Vec<BuildingSpawnDesc>) -> Result<(), String> {
    if !has_role(ctx, &ctx.sender, Role::Admin) {
        return Err("Invalid permissions".into());
    }
    for r in records {
        if let Err(e) = ctx.db.staged_building_spawn_desc().try_insert(r.clone()) {
            spacetimedb::log::error!("Failed to stage record {:?}: {}", r, e);
            return Err(e.to_string());
        }
    }
    Ok(())
}

#[spacetimedb::reducer]
pub fn stage_building_type_desc(ctx: &ReducerContext, records: Vec<BuildingTypeDesc>) -> Result<(), String> {
    if !has_role(ctx, &ctx.sender, Role::Admin) {
        return Err("Invalid permissions".into());
    }
    for r in records {
        if let Err(e) = ctx.db.staged_building_type_desc().try_insert(r.clone()) {
            spacetimedb::log::error!("Failed to stage record {:?}: {}", r, e);
            return Err(e.to_string());
        }
    }
    Ok(())
}

#[spacetimedb::reducer]
pub fn stage_cargo_desc(ctx: &ReducerContext, records: Vec<CargoDesc>) -> Result<(), String> {
    if !has_role(ctx, &ctx.sender, Role::Admin) {
        return Err("Invalid permissions".into());
    }
    for r in records {
        if let Err(e) = ctx.db.staged_cargo_desc().try_insert(r.clone()) {
            spacetimedb::log::error!("Failed to stage record {:?}: {}", r, e);
            return Err(e.to_string());
        }
    }
    Ok(())
}

#[spacetimedb::reducer]
pub fn stage_character_stat_desc(ctx: &ReducerContext, records: Vec<CharacterStatDesc>) -> Result<(), String> {
    if !has_role(ctx, &ctx.sender, Role::Admin) {
        return Err("Invalid permissions".into());
    }
    for r in records {
        if let Err(e) = ctx.db.staged_character_stat_desc().try_insert(r.clone()) {
            spacetimedb::log::error!("Failed to stage record {:?}: {}", r, e);
            return Err(e.to_string());
        }
    }
    Ok(())
}

#[spacetimedb::reducer]
pub fn stage_chest_rarity_desc(ctx: &ReducerContext, records: Vec<ChestRarityDesc>) -> Result<(), String> {
    if !has_role(ctx, &ctx.sender, Role::Admin) {
        return Err("Invalid permissions".into());
    }
    for r in records {
        if let Err(e) = ctx.db.staged_chest_rarity_desc().try_insert(r.clone()) {
            spacetimedb::log::error!("Failed to stage record {:?}: {}", r, e);
            return Err(e.to_string());
        }
    }
    Ok(())
}

#[spacetimedb::reducer]
pub fn stage_claim_tech_desc_v2(ctx: &ReducerContext, records: Vec<ClaimTechDescV2>) -> Result<(), String> {
    if !has_role(ctx, &ctx.sender, Role::Admin) {
        return Err("Invalid permissions".into());
    }
    for r in records {
        if let Err(e) = ctx.db.staged_claim_tech_desc_v2().try_insert(r.clone()) {
            spacetimedb::log::error!("Failed to stage record {:?}: {}", r, e);
            return Err(e.to_string());
        }
    }
    Ok(())
}

#[spacetimedb::reducer]
pub fn stage_claim_tile_cost(ctx: &ReducerContext, records: Vec<ClaimTileCost>) -> Result<(), String> {
    if !has_role(ctx, &ctx.sender, Role::Admin) {
        return Err("Invalid permissions".into());
    }
    for r in records {
        if let Err(e) = ctx.db.staged_claim_tile_cost().try_insert(r.clone()) {
            spacetimedb::log::error!("Failed to stage record {:?}: {}", r, e);
            return Err(e.to_string());
        }
    }
    Ok(())
}

#[spacetimedb::reducer]
pub fn stage_climb_requirement_desc(ctx: &ReducerContext, records: Vec<ClimbRequirementDesc>) -> Result<(), String> {
    if !has_role(ctx, &ctx.sender, Role::Admin) {
        return Err("Invalid permissions".into());
    }
    for r in records {
        if let Err(e) = ctx.db.staged_climb_requirement_desc().try_insert(r.clone()) {
            spacetimedb::log::error!("Failed to stage record {:?}: {}", r, e);
            return Err(e.to_string());
        }
    }
    Ok(())
}

#[spacetimedb::reducer]
pub fn stage_clothing_desc(ctx: &ReducerContext, records: Vec<ClothingDesc>) -> Result<(), String> {
    if !has_role(ctx, &ctx.sender, Role::Admin) {
        return Err("Invalid permissions".into());
    }
    for r in records {
        if let Err(e) = ctx.db.staged_clothing_desc().try_insert(r.clone()) {
            spacetimedb::log::error!("Failed to stage record {:?}: {}", r, e);
            return Err(e.to_string());
        }
    }
    Ok(())
}

#[spacetimedb::reducer]
pub fn stage_collectible_desc(ctx: &ReducerContext, records: Vec<CollectibleDesc>) -> Result<(), String> {
    if !has_role(ctx, &ctx.sender, Role::Admin) {
        return Err("Invalid permissions".into());
    }
    for r in records {
        if let Err(e) = ctx.db.staged_collectible_desc().try_insert(r.clone()) {
            spacetimedb::log::error!("Failed to stage record {:?}: {}", r, e);
            return Err(e.to_string());
        }
    }
    Ok(())
}

#[spacetimedb::reducer]
pub fn stage_combat_action_desc_v3(ctx: &ReducerContext, records: Vec<CombatActionDescV3>) -> Result<(), String> {
    if !has_role(ctx, &ctx.sender, Role::Admin) {
        return Err("Invalid permissions".into());
    }
    for r in records {
        if let Err(e) = ctx.db.staged_combat_action_desc_v3().try_insert(r.clone()) {
            spacetimedb::log::error!("Failed to stage record {:?}: {}", r, e);
            return Err(e.to_string());
        }
    }
    Ok(())
}

#[spacetimedb::reducer]
pub fn stage_combat_action_multi_hit_desc(ctx: &ReducerContext, records: Vec<CombatActionMultiHitDesc>) -> Result<(), String> {
    if !has_role(ctx, &ctx.sender, Role::Admin) {
        return Err("Invalid permissions".into());
    }
    for r in records {
        if let Err(e) = ctx.db.staged_combat_action_multi_hit_desc().try_insert(r.clone()) {
            spacetimedb::log::error!("Failed to stage record {:?}: {}", r, e);
            return Err(e.to_string());
        }
    }
    Ok(())
}

#[spacetimedb::reducer]
pub fn stage_construction_recipe_desc_v2(ctx: &ReducerContext, records: Vec<ConstructionRecipeDescV2>) -> Result<(), String> {
    if !has_role(ctx, &ctx.sender, Role::Admin) {
        return Err("Invalid permissions".into());
    }
    for r in records {
        if let Err(e) = ctx.db.staged_construction_recipe_desc_v2().try_insert(r.clone()) {
            spacetimedb::log::error!("Failed to stage record {:?}: {}", r, e);
            return Err(e.to_string());
        }
    }
    Ok(())
}

#[spacetimedb::reducer]
pub fn stage_contribution_loot_desc(ctx: &ReducerContext, records: Vec<ContributionLootDescV2>) -> Result<(), String> {
    if !has_role(ctx, &ctx.sender, Role::Admin) {
        return Err("Invalid permissions".into());
    }
    for r in records {
        if let Err(e) = ctx.db.staged_contribution_loot_desc().try_insert(r.clone()) {
            spacetimedb::log::error!("Failed to stage record {:?}: {}", r, e);
            return Err(e.to_string());
        }
    }
    Ok(())
}

#[spacetimedb::reducer]
pub fn stage_crafting_recipe_desc(ctx: &ReducerContext, records: Vec<CraftingRecipeDesc>) -> Result<(), String> {
    if !has_role(ctx, &ctx.sender, Role::Admin) {
        return Err("Invalid permissions".into());
    }
    for r in records {
        if let Err(e) = ctx.db.staged_crafting_recipe_desc().try_insert(r.clone()) {
            spacetimedb::log::error!("Failed to stage record {:?}: {}", r, e);
            return Err(e.to_string());
        }
    }
    Ok(())
}

#[spacetimedb::reducer]
pub fn stage_deconstruction_recipe_desc(ctx: &ReducerContext, records: Vec<DeconstructionRecipeDesc>) -> Result<(), String> {
    if !has_role(ctx, &ctx.sender, Role::Admin) {
        return Err("Invalid permissions".into());
    }
    for r in records {
        if let Err(e) = ctx.db.staged_deconstruction_recipe_desc().try_insert(r.clone()) {
            spacetimedb::log::error!("Failed to stage record {:?}: {}", r, e);
            return Err(e.to_string());
        }
    }
    Ok(())
}

#[spacetimedb::reducer]
pub fn stage_deployable_desc(ctx: &ReducerContext, records: Vec<DeployableDescV4>) -> Result<(), String> {
    if !has_role(ctx, &ctx.sender, Role::Admin) {
        return Err("Invalid permissions".into());
    }
    for r in records {
        if let Err(e) = ctx.db.staged_deployable_desc().try_insert(r.clone()) {
            spacetimedb::log::error!("Failed to stage record {:?}: {}", r, e);
            return Err(e.to_string());
        }
    }
    Ok(())
}

#[spacetimedb::reducer]
pub fn stage_distant_visible_entity_desc(ctx: &ReducerContext, records: Vec<DistantVisibleEntityDesc>) -> Result<(), String> {
    if !has_role(ctx, &ctx.sender, Role::Admin) {
        return Err("Invalid permissions".into());
    }
    for r in records {
        if let Err(e) = ctx.db.staged_distant_visible_entity_desc().try_insert(r.clone()) {
            spacetimedb::log::error!("Failed to stage record {:?}: {}", r, e);
            return Err(e.to_string());
        }
    }
    Ok(())
}

#[spacetimedb::reducer]
pub fn stage_elevator_desc(ctx: &ReducerContext, records: Vec<ElevatorDesc>) -> Result<(), String> {
    if !has_role(ctx, &ctx.sender, Role::Admin) {
        return Err("Invalid permissions".into());
    }
    for r in records {
        if let Err(e) = ctx.db.staged_elevator_desc().try_insert(r.clone()) {
            spacetimedb::log::error!("Failed to stage record {:?}: {}", r, e);
            return Err(e.to_string());
        }
    }
    Ok(())
}

#[spacetimedb::reducer]
pub fn stage_emote_desc(ctx: &ReducerContext, records: Vec<EmoteDescV2>) -> Result<(), String> {
    if !has_role(ctx, &ctx.sender, Role::Admin) {
        return Err("Invalid permissions".into());
    }
    for r in records {
        if let Err(e) = ctx.db.staged_emote_desc().try_insert(r.clone()) {
            spacetimedb::log::error!("Failed to stage record {:?}: {}", r, e);
            return Err(e.to_string());
        }
    }
    Ok(())
}

#[spacetimedb::reducer]
pub fn stage_empire_colors_desc(ctx: &ReducerContext, records: Vec<EmpireColorDesc>) -> Result<(), String> {
    if !has_role(ctx, &ctx.sender, Role::Admin) {
        return Err("Invalid permissions".into());
    }
    for r in records {
        if let Err(e) = ctx.db.staged_empire_colors_desc().try_insert(r.clone()) {
            spacetimedb::log::error!("Failed to stage record {:?}: {}", r, e);
            return Err(e.to_string());
        }
    }
    Ok(())
}

#[spacetimedb::reducer]
pub fn stage_empire_icon_desc(ctx: &ReducerContext, records: Vec<EmpireIconDesc>) -> Result<(), String> {
    if !has_role(ctx, &ctx.sender, Role::Admin) {
        return Err("Invalid permissions".into());
    }
    for r in records {
        if let Err(e) = ctx.db.staged_empire_icon_desc().try_insert(r.clone()) {
            spacetimedb::log::error!("Failed to stage record {:?}: {}", r, e);
            return Err(e.to_string());
        }
    }
    Ok(())
}

#[spacetimedb::reducer]
pub fn stage_empire_notification_desc(ctx: &ReducerContext, records: Vec<EmpireNotificationDesc>) -> Result<(), String> {
    if !has_role(ctx, &ctx.sender, Role::Admin) {
        return Err("Invalid permissions".into());
    }
    for r in records {
        if let Err(e) = ctx.db.staged_empire_notification_desc().try_insert(r.clone()) {
            spacetimedb::log::error!("Failed to stage record {:?}: {}", r, e);
            return Err(e.to_string());
        }
    }
    Ok(())
}

#[spacetimedb::reducer]
pub fn stage_empire_rank_desc(ctx: &ReducerContext, records: Vec<EmpireRankDesc>) -> Result<(), String> {
    if !has_role(ctx, &ctx.sender, Role::Admin) {
        return Err("Invalid permissions".into());
    }
    for r in records {
        if let Err(e) = ctx.db.staged_empire_rank_desc().try_insert(r.clone()) {
            spacetimedb::log::error!("Failed to stage record {:?}: {}", r, e);
            return Err(e.to_string());
        }
    }
    Ok(())
}

#[spacetimedb::reducer]
pub fn stage_empire_supplies_desc(ctx: &ReducerContext, records: Vec<EmpireSuppliesDesc>) -> Result<(), String> {
    if !has_role(ctx, &ctx.sender, Role::Admin) {
        return Err("Invalid permissions".into());
    }
    for r in records {
        if let Err(e) = ctx.db.staged_empire_supplies_desc().try_insert(r.clone()) {
            spacetimedb::log::error!("Failed to stage record {:?}: {}", r, e);
            return Err(e.to_string());
        }
    }
    Ok(())
}

#[spacetimedb::reducer]
pub fn stage_empire_territory_desc(ctx: &ReducerContext, records: Vec<EmpireTerritoryDesc>) -> Result<(), String> {
    if !has_role(ctx, &ctx.sender, Role::Admin) {
        return Err("Invalid permissions".into());
    }
    for r in records {
        if let Err(e) = ctx.db.staged_empire_territory_desc().try_insert(r.clone()) {
            spacetimedb::log::error!("Failed to stage record {:?}: {}", r, e);
            return Err(e.to_string());
        }
    }
    Ok(())
}

#[spacetimedb::reducer]
pub fn stage_enemy_ai_params_desc(ctx: &ReducerContext, records: Vec<EnemyAiParamsDesc>) -> Result<(), String> {
    if !has_role(ctx, &ctx.sender, Role::Admin) {
        return Err("Invalid permissions".into());
    }
    for r in records {
        if let Err(e) = ctx.db.staged_enemy_ai_params_desc().try_insert(r.clone()) {
            spacetimedb::log::error!("Failed to stage record {:?}: {}", r, e);
            return Err(e.to_string());
        }
    }
    Ok(())
}

#[spacetimedb::reducer]
pub fn stage_enemy_desc(ctx: &ReducerContext, records: Vec<EnemyDesc>) -> Result<(), String> {
    if !has_role(ctx, &ctx.sender, Role::Admin) {
        return Err("Invalid permissions".into());
    }
    for r in records {
        if let Err(e) = ctx.db.staged_enemy_desc().try_insert(r.clone()) {
            spacetimedb::log::error!("Failed to stage record {:?}: {}", r, e);
            return Err(e.to_string());
        }
    }
    Ok(())
}

#[spacetimedb::reducer]
pub fn stage_enemy_scaling_desc(ctx: &ReducerContext, records: Vec<EnemyScalingDesc>) -> Result<(), String> {
    if !has_role(ctx, &ctx.sender, Role::Admin) {
        return Err("Invalid permissions".into());
    }
    for r in records {
        if let Err(e) = ctx.db.staged_enemy_scaling_desc().try_insert(r.clone()) {
            spacetimedb::log::error!("Failed to stage record {:?}: {}", r, e);
            return Err(e.to_string());
        }
    }
    Ok(())
}

#[spacetimedb::reducer]
pub fn stage_environment_debuff_desc(ctx: &ReducerContext, records: Vec<EnvironmentDebuffDesc>) -> Result<(), String> {
    if !has_role(ctx, &ctx.sender, Role::Admin) {
        return Err("Invalid permissions".into());
    }
    for r in records {
        if let Err(e) = ctx.db.staged_environment_debuff_desc().try_insert(r.clone()) {
            spacetimedb::log::error!("Failed to stage record {:?}: {}", r, e);
            return Err(e.to_string());
        }
    }
    Ok(())
}

#[spacetimedb::reducer]
pub fn stage_equipment_desc(ctx: &ReducerContext, records: Vec<EquipmentDesc>) -> Result<(), String> {
    if !has_role(ctx, &ctx.sender, Role::Admin) {
        return Err("Invalid permissions".into());
    }
    for r in records {
        if let Err(e) = ctx.db.staged_equipment_desc().try_insert(r.clone()) {
            spacetimedb::log::error!("Failed to stage record {:?}: {}", r, e);
            return Err(e.to_string());
        }
    }
    Ok(())
}

#[spacetimedb::reducer]
pub fn stage_extraction_recipe_desc(ctx: &ReducerContext, records: Vec<ExtractionRecipeDesc>) -> Result<(), String> {
    if !has_role(ctx, &ctx.sender, Role::Admin) {
        return Err("Invalid permissions".into());
    }
    for r in records {
        if let Err(e) = ctx.db.staged_extraction_recipe_desc().try_insert(r.clone()) {
            spacetimedb::log::error!("Failed to stage record {:?}: {}", r, e);
            return Err(e.to_string());
        }
    }
    Ok(())
}

#[spacetimedb::reducer]
pub fn stage_food_desc(ctx: &ReducerContext, records: Vec<FoodDesc>) -> Result<(), String> {
    if !has_role(ctx, &ctx.sender, Role::Admin) {
        return Err("Invalid permissions".into());
    }
    for r in records {
        if let Err(e) = ctx.db.staged_food_desc().try_insert(r.clone()) {
            spacetimedb::log::error!("Failed to stage record {:?}: {}", r, e);
            return Err(e.to_string());
        }
    }
    Ok(())
}

#[spacetimedb::reducer]
pub fn stage_gate_desc(ctx: &ReducerContext, records: Vec<GateDesc>) -> Result<(), String> {
    if !has_role(ctx, &ctx.sender, Role::Admin) {
        return Err("Invalid permissions".into());
    }
    for r in records {
        if let Err(e) = ctx.db.staged_gate_desc().try_insert(r.clone()) {
            spacetimedb::log::error!("Failed to stage record {:?}: {}", r, e);
            return Err(e.to_string());
        }
    }
    Ok(())
}

#[spacetimedb::reducer]
pub fn stage_hexite_exchange_entry_desc(ctx: &ReducerContext, records: Vec<HexiteExchangeEntryDesc>) -> Result<(), String> {
    if !has_role(ctx, &ctx.sender, Role::Admin) {
        return Err("Invalid permissions".into());
    }
    for r in records {
        if let Err(e) = ctx.db.staged_hexite_exchange_entry_desc().try_insert(r.clone()) {
            spacetimedb::log::error!("Failed to stage record {:?}: {}", r, e);
            return Err(e.to_string());
        }
    }
    Ok(())
}

#[spacetimedb::reducer]
pub fn stage_interior_environment_desc(ctx: &ReducerContext, records: Vec<InteriorEnvironmentDesc>) -> Result<(), String> {
    if !has_role(ctx, &ctx.sender, Role::Admin) {
        return Err("Invalid permissions".into());
    }
    for r in records {
        if let Err(e) = ctx.db.staged_interior_environment_desc().try_insert(r.clone()) {
            spacetimedb::log::error!("Failed to stage record {:?}: {}", r, e);
            return Err(e.to_string());
        }
    }
    Ok(())
}

#[spacetimedb::reducer]
pub fn stage_interior_instance_desc(ctx: &ReducerContext, records: Vec<InteriorInstanceDesc>) -> Result<(), String> {
    if !has_role(ctx, &ctx.sender, Role::Admin) {
        return Err("Invalid permissions".into());
    }
    for r in records {
        if let Err(e) = ctx.db.staged_interior_instance_desc().try_insert(r.clone()) {
            spacetimedb::log::error!("Failed to stage record {:?}: {}", r, e);
            return Err(e.to_string());
        }
    }
    Ok(())
}

#[spacetimedb::reducer]
pub fn stage_interior_network_desc(ctx: &ReducerContext, records: Vec<InteriorNetworkDesc>) -> Result<(), String> {
    if !has_role(ctx, &ctx.sender, Role::Admin) {
        return Err("Invalid permissions".into());
    }
    for r in records {
        if let Err(e) = ctx.db.staged_interior_network_desc().try_insert(r.clone()) {
            spacetimedb::log::error!("Failed to stage record {:?}: {}", r, e);
            return Err(e.to_string());
        }
    }
    Ok(())
}

#[spacetimedb::reducer]
pub fn stage_interior_portal_connections_desc(ctx: &ReducerContext, records: Vec<InteriorPortalConnectionsDesc>) -> Result<(), String> {
    if !has_role(ctx, &ctx.sender, Role::Admin) {
        return Err("Invalid permissions".into());
    }
    for r in records {
        if let Err(e) = ctx.db.staged_interior_portal_connections_desc().try_insert(r.clone()) {
            spacetimedb::log::error!("Failed to stage record {:?}: {}", r, e);
            return Err(e.to_string());
        }
    }
    Ok(())
}

#[spacetimedb::reducer]
pub fn stage_interior_shape_desc(ctx: &ReducerContext, records: Vec<InteriorShapeDesc>) -> Result<(), String> {
    if !has_role(ctx, &ctx.sender, Role::Admin) {
        return Err("Invalid permissions".into());
    }
    for r in records {
        if let Err(e) = ctx.db.staged_interior_shape_desc().try_insert(r.clone()) {
            spacetimedb::log::error!("Failed to stage record {:?}: {}", r, e);
            return Err(e.to_string());
        }
    }
    Ok(())
}

#[spacetimedb::reducer]
pub fn stage_interior_spawn_desc(ctx: &ReducerContext, records: Vec<InteriorSpawnDesc>) -> Result<(), String> {
    if !has_role(ctx, &ctx.sender, Role::Admin) {
        return Err("Invalid permissions".into());
    }
    for r in records {
        if let Err(e) = ctx.db.staged_interior_spawn_desc().try_insert(r.clone()) {
            spacetimedb::log::error!("Failed to stage record {:?}: {}", r, e);
            return Err(e.to_string());
        }
    }
    Ok(())
}

#[spacetimedb::reducer]
pub fn stage_item_conversion_recipe_desc(ctx: &ReducerContext, records: Vec<ItemConversionRecipeDesc>) -> Result<(), String> {
    if !has_role(ctx, &ctx.sender, Role::Admin) {
        return Err("Invalid permissions".into());
    }
    for r in records {
        if let Err(e) = ctx.db.staged_item_conversion_recipe_desc().try_insert(r.clone()) {
            spacetimedb::log::error!("Failed to stage record {:?}: {}", r, e);
            return Err(e.to_string());
        }
    }
    Ok(())
}

#[spacetimedb::reducer]
pub fn stage_item_desc(ctx: &ReducerContext, records: Vec<ItemDesc>) -> Result<(), String> {
    if !has_role(ctx, &ctx.sender, Role::Admin) {
        return Err("Invalid permissions".into());
    }
    for r in records {
        if let Err(e) = ctx.db.staged_item_desc().try_insert(r.clone()) {
            spacetimedb::log::error!("Failed to stage record {:?}: {}", r, e);
            return Err(e.to_string());
        }
    }
    Ok(())
}

#[spacetimedb::reducer]
pub fn stage_item_list_desc(ctx: &ReducerContext, records: Vec<ItemListDesc>) -> Result<(), String> {
    if !has_role(ctx, &ctx.sender, Role::Admin) {
        return Err("Invalid permissions".into());
    }
    for r in records {
        if let Err(e) = ctx.db.staged_item_list_desc().try_insert(r.clone()) {
            spacetimedb::log::error!("Failed to stage record {:?}: {}", r, e);
            return Err(e.to_string());
        }
    }
    Ok(())
}

#[spacetimedb::reducer]
pub fn stage_knowledge_scroll_desc(ctx: &ReducerContext, records: Vec<KnowledgeScrollDesc>) -> Result<(), String> {
    if !has_role(ctx, &ctx.sender, Role::Admin) {
        return Err("Invalid permissions".into());
    }
    for r in records {
        if let Err(e) = ctx.db.staged_knowledge_scroll_desc().try_insert(r.clone()) {
            spacetimedb::log::error!("Failed to stage record {:?}: {}", r, e);
            return Err(e.to_string());
        }
    }
    Ok(())
}

#[spacetimedb::reducer]
pub fn stage_knowledge_scroll_type_desc(ctx: &ReducerContext, records: Vec<KnowledgeScrollTypeDesc>) -> Result<(), String> {
    if !has_role(ctx, &ctx.sender, Role::Admin) {
        return Err("Invalid permissions".into());
    }
    for r in records {
        if let Err(e) = ctx.db.staged_knowledge_scroll_type_desc().try_insert(r.clone()) {
            spacetimedb::log::error!("Failed to stage record {:?}: {}", r, e);
            return Err(e.to_string());
        }
    }
    Ok(())
}

#[spacetimedb::reducer]
pub fn stage_knowledge_stat_modifier_desc(ctx: &ReducerContext, records: Vec<KnowledgeStatModifierDesc>) -> Result<(), String> {
    if !has_role(ctx, &ctx.sender, Role::Admin) {
        return Err("Invalid permissions".into());
    }
    for r in records {
        if let Err(e) = ctx.db.staged_knowledge_stat_modifier_desc().try_insert(r.clone()) {
            spacetimedb::log::error!("Failed to stage record {:?}: {}", r, e);
            return Err(e.to_string());
        }
    }
    Ok(())
}

#[spacetimedb::reducer]
pub fn stage_loot_chest_desc(ctx: &ReducerContext, records: Vec<LootChestDesc>) -> Result<(), String> {
    if !has_role(ctx, &ctx.sender, Role::Admin) {
        return Err("Invalid permissions".into());
    }
    for r in records {
        if let Err(e) = ctx.db.staged_loot_chest_desc().try_insert(r.clone()) {
            spacetimedb::log::error!("Failed to stage record {:?}: {}", r, e);
            return Err(e.to_string());
        }
    }
    Ok(())
}

#[spacetimedb::reducer]
pub fn stage_loot_rarity_desc(ctx: &ReducerContext, records: Vec<LootRarityDesc>) -> Result<(), String> {
    if !has_role(ctx, &ctx.sender, Role::Admin) {
        return Err("Invalid permissions".into());
    }
    for r in records {
        if let Err(e) = ctx.db.staged_loot_rarity_desc().try_insert(r.clone()) {
            spacetimedb::log::error!("Failed to stage record {:?}: {}", r, e);
            return Err(e.to_string());
        }
    }
    Ok(())
}

#[spacetimedb::reducer]
pub fn stage_loot_table_desc(ctx: &ReducerContext, records: Vec<LootTableDesc>) -> Result<(), String> {
    if !has_role(ctx, &ctx.sender, Role::Admin) {
        return Err("Invalid permissions".into());
    }
    for r in records {
        if let Err(e) = ctx.db.staged_loot_table_desc().try_insert(r.clone()) {
            spacetimedb::log::error!("Failed to stage record {:?}: {}", r, e);
            return Err(e.to_string());
        }
    }
    Ok(())
}

#[spacetimedb::reducer]
pub fn stage_npc_desc(ctx: &ReducerContext, records: Vec<NpcDesc>) -> Result<(), String> {
    if !has_role(ctx, &ctx.sender, Role::Admin) {
        return Err("Invalid permissions".into());
    }
    for r in records {
        if let Err(e) = ctx.db.staged_npc_desc().try_insert(r.clone()) {
            spacetimedb::log::error!("Failed to stage record {:?}: {}", r, e);
            return Err(e.to_string());
        }
    }
    Ok(())
}

#[spacetimedb::reducer]
pub fn stage_onboarding_reward_desc(ctx: &ReducerContext, records: Vec<OnboardingRewardDesc>) -> Result<(), String> {
    if !has_role(ctx, &ctx.sender, Role::Admin) {
        return Err("Invalid permissions".into());
    }
    for r in records {
        if let Err(e) = ctx.db.staged_onboarding_reward_desc().try_insert(r.clone()) {
            spacetimedb::log::error!("Failed to stage record {:?}: {}", r, e);
            return Err(e.to_string());
        }
    }
    Ok(())
}

#[spacetimedb::reducer]
pub fn stage_parameters_desc(ctx: &ReducerContext, records: Vec<ParametersDescV2>) -> Result<(), String> {
    if !has_role(ctx, &ctx.sender, Role::Admin) {
        return Err("Invalid permissions".into());
    }
    for r in records {
        if let Err(e) = ctx.db.staged_parameters_desc().try_insert(r.clone()) {
            spacetimedb::log::error!("Failed to stage record {:?}: {}", r, e);
            return Err(e.to_string());
        }
    }
    Ok(())
}

#[spacetimedb::reducer]
pub fn stage_pathfinding_desc(ctx: &ReducerContext, records: Vec<PathfindingDesc>) -> Result<(), String> {
    if !has_role(ctx, &ctx.sender, Role::Admin) {
        return Err("Invalid permissions".into());
    }
    for r in records {
        if let Err(e) = ctx.db.staged_pathfinding_desc().try_insert(r.clone()) {
            spacetimedb::log::error!("Failed to stage record {:?}: {}", r, e);
            return Err(e.to_string());
        }
    }
    Ok(())
}

#[spacetimedb::reducer]
pub fn stage_paving_tile_desc(ctx: &ReducerContext, records: Vec<PavingTileDesc>) -> Result<(), String> {
    if !has_role(ctx, &ctx.sender, Role::Admin) {
        return Err("Invalid permissions".into());
    }
    for r in records {
        if let Err(e) = ctx.db.staged_paving_tile_desc().try_insert(r.clone()) {
            spacetimedb::log::error!("Failed to stage record {:?}: {}", r, e);
            return Err(e.to_string());
        }
    }
    Ok(())
}

#[spacetimedb::reducer]
pub fn stage_pillar_shaping_desc(ctx: &ReducerContext, records: Vec<PillarShapingDesc>) -> Result<(), String> {
    if !has_role(ctx, &ctx.sender, Role::Admin) {
        return Err("Invalid permissions".into());
    }
    for r in records {
        if let Err(e) = ctx.db.staged_pillar_shaping_desc().try_insert(r.clone()) {
            spacetimedb::log::error!("Failed to stage record {:?}: {}", r, e);
            return Err(e.to_string());
        }
    }
    Ok(())
}

#[spacetimedb::reducer]
pub fn stage_player_action_desc(ctx: &ReducerContext, records: Vec<PlayerActionDesc>) -> Result<(), String> {
    if !has_role(ctx, &ctx.sender, Role::Admin) {
        return Err("Invalid permissions".into());
    }
    for r in records {
        if let Err(e) = ctx.db.staged_player_action_desc().try_insert(r.clone()) {
            spacetimedb::log::error!("Failed to stage record {:?}: {}", r, e);
            return Err(e.to_string());
        }
    }
    Ok(())
}

#[spacetimedb::reducer]
pub fn stage_player_housing_desc(ctx: &ReducerContext, records: Vec<PlayerHousingDesc>) -> Result<(), String> {
    if !has_role(ctx, &ctx.sender, Role::Admin) {
        return Err("Invalid permissions".into());
    }
    for r in records {
        if let Err(e) = ctx.db.staged_player_housing_desc().try_insert(r.clone()) {
            spacetimedb::log::error!("Failed to stage record {:?}: {}", r, e);
            return Err(e.to_string());
        }
    }
    Ok(())
}

#[spacetimedb::reducer]
pub fn stage_premium_item_desc(ctx: &ReducerContext, records: Vec<PremiumItemDesc>) -> Result<(), String> {
    if !has_role(ctx, &ctx.sender, Role::Admin) {
        return Err("Invalid permissions".into());
    }
    for r in records {
        if let Err(e) = ctx.db.staged_premium_item_desc().try_insert(r.clone()) {
            spacetimedb::log::error!("Failed to stage record {:?}: {}", r, e);
            return Err(e.to_string());
        }
    }
    Ok(())
}

#[spacetimedb::reducer]
pub fn stage_premium_service_desc(ctx: &ReducerContext, records: Vec<PremiumServiceDesc>) -> Result<(), String> {
    if !has_role(ctx, &ctx.sender, Role::Admin) {
        return Err("Invalid permissions".into());
    }
    for r in records {
        if let Err(e) = ctx.db.staged_premium_service_desc().try_insert(r.clone()) {
            spacetimedb::log::error!("Failed to stage record {:?}: {}", r, e);
            return Err(e.to_string());
        }
    }
    Ok(())
}

#[spacetimedb::reducer]
pub fn stage_private_parameters_desc(ctx: &ReducerContext, records: Vec<PrivateParametersDesc>) -> Result<(), String> {
    if !has_role(ctx, &ctx.sender, Role::Admin) {
        return Err("Invalid permissions".into());
    }
    for r in records {
        if let Err(e) = ctx.db.staged_private_parameters_desc().try_insert(r.clone()) {
            spacetimedb::log::error!("Failed to stage record {:?}: {}", r, e);
            return Err(e.to_string());
        }
    }
    Ok(())
}

#[spacetimedb::reducer]
pub fn stage_prospecting_desc(ctx: &ReducerContext, records: Vec<ProspectingDesc>) -> Result<(), String> {
    if !has_role(ctx, &ctx.sender, Role::Admin) {
        return Err("Invalid permissions".into());
    }
    for r in records {
        if let Err(e) = ctx.db.staged_prospecting_desc().try_insert(r.clone()) {
            spacetimedb::log::error!("Failed to stage record {:?}: {}", r, e);
            return Err(e.to_string());
        }
    }
    Ok(())
}

#[spacetimedb::reducer]
pub fn stage_quest_chain_desc(ctx: &ReducerContext, records: Vec<QuestChainDesc>) -> Result<(), String> {
    if !has_role(ctx, &ctx.sender, Role::Admin) {
        return Err("Invalid permissions".into());
    }
    for r in records {
        if let Err(e) = ctx.db.staged_quest_chain_desc().try_insert(r.clone()) {
            spacetimedb::log::error!("Failed to stage record {:?}: {}", r, e);
            return Err(e.to_string());
        }
    }
    Ok(())
}

#[spacetimedb::reducer]
pub fn stage_quest_stage_desc(ctx: &ReducerContext, records: Vec<QuestStageDesc>) -> Result<(), String> {
    if !has_role(ctx, &ctx.sender, Role::Admin) {
        return Err("Invalid permissions".into());
    }
    for r in records {
        if let Err(e) = ctx.db.staged_quest_stage_desc().try_insert(r.clone()) {
            spacetimedb::log::error!("Failed to stage record {:?}: {}", r, e);
            return Err(e.to_string());
        }
    }
    Ok(())
}

#[spacetimedb::reducer]
pub fn stage_reserved_name_desc(ctx: &ReducerContext, records: Vec<ReservedNameDesc>) -> Result<(), String> {
    if !has_role(ctx, &ctx.sender, Role::Admin) {
        return Err("Invalid permissions".into());
    }
    for r in records {
        if let Err(e) = ctx.db.staged_reserved_name_desc().try_insert(r.clone()) {
            spacetimedb::log::error!("Failed to stage record {:?}: {}", r, e);
            return Err(e.to_string());
        }
    }
    Ok(())
}

#[spacetimedb::reducer]
pub fn stage_resource_clump_desc(ctx: &ReducerContext, records: Vec<ResourceClumpDesc>) -> Result<(), String> {
    if !has_role(ctx, &ctx.sender, Role::Admin) {
        return Err("Invalid permissions".into());
    }
    for r in records {
        if let Err(e) = ctx.db.staged_resource_clump_desc().try_insert(r.clone()) {
            spacetimedb::log::error!("Failed to stage record {:?}: {}", r, e);
            return Err(e.to_string());
        }
    }
    Ok(())
}

#[spacetimedb::reducer]
pub fn stage_resource_desc(ctx: &ReducerContext, records: Vec<ResourceDesc>) -> Result<(), String> {
    if !has_role(ctx, &ctx.sender, Role::Admin) {
        return Err("Invalid permissions".into());
    }
    for r in records {
        if let Err(e) = ctx.db.staged_resource_desc().try_insert(r.clone()) {
            spacetimedb::log::error!("Failed to stage record {:?}: {}", r, e);
            return Err(e.to_string());
        }
    }
    Ok(())
}

#[spacetimedb::reducer]
pub fn stage_resource_growth_recipe_desc(ctx: &ReducerContext, records: Vec<ResourceGrowthRecipeDesc>) -> Result<(), String> {
    if !has_role(ctx, &ctx.sender, Role::Admin) {
        return Err("Invalid permissions".into());
    }
    for r in records {
        if let Err(e) = ctx.db.staged_resource_growth_recipe_desc().try_insert(r.clone()) {
            spacetimedb::log::error!("Failed to stage record {:?}: {}", r, e);
            return Err(e.to_string());
        }
    }
    Ok(())
}

#[spacetimedb::reducer]
pub fn stage_resource_placement_recipe_desc_v2(ctx: &ReducerContext, records: Vec<ResourcePlacementRecipeDescV2>) -> Result<(), String> {
    if !has_role(ctx, &ctx.sender, Role::Admin) {
        return Err("Invalid permissions".into());
    }
    for r in records {
        if let Err(e) = ctx.db.staged_resource_placement_recipe_desc_v2().try_insert(r.clone()) {
            spacetimedb::log::error!("Failed to stage record {:?}: {}", r, e);
            return Err(e.to_string());
        }
    }
    Ok(())
}

#[spacetimedb::reducer]
pub fn stage_secondary_knowledge_desc(ctx: &ReducerContext, records: Vec<SecondaryKnowledgeDesc>) -> Result<(), String> {
    if !has_role(ctx, &ctx.sender, Role::Admin) {
        return Err("Invalid permissions".into());
    }
    for r in records {
        if let Err(e) = ctx.db.staged_secondary_knowledge_desc().try_insert(r.clone()) {
            spacetimedb::log::error!("Failed to stage record {:?}: {}", r, e);
            return Err(e.to_string());
        }
    }
    Ok(())
}

#[spacetimedb::reducer]
pub fn stage_skill_desc(ctx: &ReducerContext, records: Vec<SkillDesc>) -> Result<(), String> {
    if !has_role(ctx, &ctx.sender, Role::Admin) {
        return Err("Invalid permissions".into());
    }
    for r in records {
        if let Err(e) = ctx.db.staged_skill_desc().try_insert(r.clone()) {
            spacetimedb::log::error!("Failed to stage record {:?}: {}", r, e);
            return Err(e.to_string());
        }
    }
    Ok(())
}

#[spacetimedb::reducer]
pub fn stage_stage_rewards_desc(ctx: &ReducerContext, records: Vec<StageRewardsDesc>) -> Result<(), String> {
    if !has_role(ctx, &ctx.sender, Role::Admin) {
        return Err("Invalid permissions".into());
    }
    for r in records {
        if let Err(e) = ctx.db.staged_stage_rewards_desc().try_insert(r.clone()) {
            spacetimedb::log::error!("Failed to stage record {:?}: {}", r, e);
            return Err(e.to_string());
        }
    }
    Ok(())
}

#[spacetimedb::reducer]
pub fn stage_targeting_matrix_desc(ctx: &ReducerContext, records: Vec<TargetingMatrixDesc>) -> Result<(), String> {
    if !has_role(ctx, &ctx.sender, Role::Admin) {
        return Err("Invalid permissions".into());
    }
    for r in records {
        if let Err(e) = ctx.db.staged_targeting_matrix_desc().try_insert(r.clone()) {
            spacetimedb::log::error!("Failed to stage record {:?}: {}", r, e);
            return Err(e.to_string());
        }
    }
    Ok(())
}

#[spacetimedb::reducer]
pub fn stage_teleport_item_desc(ctx: &ReducerContext, records: Vec<TeleportItemDesc>) -> Result<(), String> {
    if !has_role(ctx, &ctx.sender, Role::Admin) {
        return Err("Invalid permissions".into());
    }
    for r in records {
        if let Err(e) = ctx.db.staged_teleport_item_desc().try_insert(r.clone()) {
            spacetimedb::log::error!("Failed to stage record {:?}: {}", r, e);
            return Err(e.to_string());
        }
    }
    Ok(())
}

#[spacetimedb::reducer]
pub fn stage_terraform_recipe_desc(ctx: &ReducerContext, records: Vec<TerraformRecipeDesc>) -> Result<(), String> {
    if !has_role(ctx, &ctx.sender, Role::Admin) {
        return Err("Invalid permissions".into());
    }
    for r in records {
        if let Err(e) = ctx.db.staged_terraform_recipe_desc().try_insert(r.clone()) {
            spacetimedb::log::error!("Failed to stage record {:?}: {}", r, e);
            return Err(e.to_string());
        }
    }
    Ok(())
}

#[spacetimedb::reducer]
pub fn stage_tool_desc(ctx: &ReducerContext, records: Vec<ToolDesc>) -> Result<(), String> {
    if !has_role(ctx, &ctx.sender, Role::Admin) {
        return Err("Invalid permissions".into());
    }
    for r in records {
        if let Err(e) = ctx.db.staged_tool_desc().try_insert(r.clone()) {
            spacetimedb::log::error!("Failed to stage record {:?}: {}", r, e);
            return Err(e.to_string());
        }
    }
    Ok(())
}

#[spacetimedb::reducer]
pub fn stage_tool_type_desc(ctx: &ReducerContext, records: Vec<ToolTypeDesc>) -> Result<(), String> {
    if !has_role(ctx, &ctx.sender, Role::Admin) {
        return Err("Invalid permissions".into());
    }
    for r in records {
        if let Err(e) = ctx.db.staged_tool_type_desc().try_insert(r.clone()) {
            spacetimedb::log::error!("Failed to stage record {:?}: {}", r, e);
            return Err(e.to_string());
        }
    }
    Ok(())
}

#[spacetimedb::reducer]
pub fn stage_traveler_task_desc(ctx: &ReducerContext, records: Vec<TravelerTaskDesc>) -> Result<(), String> {
    if !has_role(ctx, &ctx.sender, Role::Admin) {
        return Err("Invalid permissions".into());
    }
    for r in records {
        if let Err(e) = ctx.db.staged_traveler_task_desc().try_insert(r.clone()) {
            spacetimedb::log::error!("Failed to stage record {:?}: {}", r, e);
            return Err(e.to_string());
        }
    }
    Ok(())
}

#[spacetimedb::reducer]
pub fn stage_traveler_trade_order_desc(ctx: &ReducerContext, records: Vec<TravelerTradeOrderDesc>) -> Result<(), String> {
    if !has_role(ctx, &ctx.sender, Role::Admin) {
        return Err("Invalid permissions".into());
    }
    for r in records {
        if let Err(e) = ctx.db.staged_traveler_trade_order_desc().try_insert(r.clone()) {
            spacetimedb::log::error!("Failed to stage record {:?}: {}", r, e);
            return Err(e.to_string());
        }
    }
    Ok(())
}

#[spacetimedb::reducer]
pub fn stage_wall_desc(ctx: &ReducerContext, records: Vec<WallDesc>) -> Result<(), String> {
    if !has_role(ctx, &ctx.sender, Role::Admin) {
        return Err("Invalid permissions".into());
    }
    for r in records {
        if let Err(e) = ctx.db.staged_wall_desc().try_insert(r.clone()) {
            spacetimedb::log::error!("Failed to stage record {:?}: {}", r, e);
            return Err(e.to_string());
        }
    }
    Ok(())
}

#[spacetimedb::reducer]
pub fn stage_weapon_desc(ctx: &ReducerContext, records: Vec<WeaponDesc>) -> Result<(), String> {
    if !has_role(ctx, &ctx.sender, Role::Admin) {
        return Err("Invalid permissions".into());
    }
    for r in records {
        if let Err(e) = ctx.db.staged_weapon_desc().try_insert(r.clone()) {
            spacetimedb::log::error!("Failed to stage record {:?}: {}", r, e);
            return Err(e.to_string());
        }
    }
    Ok(())
}

#[spacetimedb::reducer]
pub fn stage_weapon_type_desc(ctx: &ReducerContext, records: Vec<WeaponTypeDesc>) -> Result<(), String> {
    if !has_role(ctx, &ctx.sender, Role::Admin) {
        return Err("Invalid permissions".into());
    }
    for r in records {
        if let Err(e) = ctx.db.staged_weapon_type_desc().try_insert(r.clone()) {
            spacetimedb::log::error!("Failed to stage record {:?}: {}", r, e);
            return Err(e.to_string());
        }
    }
    Ok(())
}

#[spacetimedb::reducer]
pub fn stage_wind_params_desc(ctx: &ReducerContext, records: Vec<WindParamsDesc>) -> Result<(), String> {
    if !has_role(ctx, &ctx.sender, Role::Admin) {
        return Err("Invalid permissions".into());
    }
    for r in records {
        if let Err(e) = ctx.db.staged_wind_params_desc().try_insert(r.clone()) {
            spacetimedb::log::error!("Failed to stage record {:?}: {}", r, e);
            return Err(e.to_string());
        }
    }
    Ok(())
}

pub fn validate_staged_data(ctx: &ReducerContext) -> Result<(), String> {
    if ctx.db.staged_ability_custom_desc().count() == 0 {
        return Err("Staged data for AbilityCustomDesc is empty, aborting.".into());
    }
    if ctx.db.staged_ability_unlock_desc().count() == 0 {
        return Err("Staged data for AbilityUnlockDesc is empty, aborting.".into());
    }
    if ctx.db.staged_achievement_desc().count() == 0 {
        return Err("Staged data for AchievementDesc is empty, aborting.".into());
    }
    if ctx.db.staged_alert_desc().count() == 0 {
        return Err("Staged data for AlertDesc is empty, aborting.".into());
    }
    if ctx.db.staged_biome_desc().count() == 0 {
        return Err("Staged data for BiomeDesc is empty, aborting.".into());
    }
    if ctx.db.staged_buff_desc().count() == 0 {
        return Err("Staged data for BuffDesc is empty, aborting.".into());
    }
    if ctx.db.staged_buff_type_desc().count() == 0 {
        return Err("Staged data for BuffTypeDesc is empty, aborting.".into());
    }
    if ctx.db.staged_building_claim_desc().count() == 0 {
        return Err("Staged data for BuildingClaimDesc is empty, aborting.".into());
    }
    if ctx.db.staged_building_desc().count() == 0 {
        return Err("Staged data for BuildingDesc is empty, aborting.".into());
    }
    if ctx.db.staged_building_portal_desc_v2().count() == 0 {
        return Err("Staged data for BuildingPortalDescV2 is empty, aborting.".into());
    }
    if ctx.db.staged_building_repairs_desc().count() == 0 {
        return Err("Staged data for BuildingRepairsDesc is empty, aborting.".into());
    }
    if ctx.db.staged_building_spawn_desc().count() == 0 {
        return Err("Staged data for BuildingSpawnDesc is empty, aborting.".into());
    }
    if ctx.db.staged_building_type_desc().count() == 0 {
        return Err("Staged data for BuildingTypeDesc is empty, aborting.".into());
    }
    if ctx.db.staged_cargo_desc().count() == 0 {
        return Err("Staged data for CargoDesc is empty, aborting.".into());
    }
    if ctx.db.staged_character_stat_desc().count() == 0 {
        return Err("Staged data for CharacterStatDesc is empty, aborting.".into());
    }
    if ctx.db.staged_chest_rarity_desc().count() == 0 {
        return Err("Staged data for ChestRarityDesc is empty, aborting.".into());
    }
    if ctx.db.staged_claim_tech_desc_v2().count() == 0 {
        return Err("Staged data for ClaimTechDescV2 is empty, aborting.".into());
    }
    if ctx.db.staged_claim_tile_cost().count() == 0 {
        return Err("Staged data for ClaimTileCost is empty, aborting.".into());
    }
    if ctx.db.staged_climb_requirement_desc().count() == 0 {
        return Err("Staged data for ClimbRequirementDesc is empty, aborting.".into());
    }
    if ctx.db.staged_clothing_desc().count() == 0 {
        return Err("Staged data for ClothingDesc is empty, aborting.".into());
    }
    if ctx.db.staged_collectible_desc().count() == 0 {
        return Err("Staged data for CollectibleDesc is empty, aborting.".into());
    }
    if ctx.db.staged_combat_action_desc_v3().count() == 0 {
        return Err("Staged data for CombatActionDescV3 is empty, aborting.".into());
    }
    if ctx.db.staged_combat_action_multi_hit_desc().count() == 0 {
        return Err("Staged data for CombatActionMultiHitDesc is empty, aborting.".into());
    }
    if ctx.db.staged_construction_recipe_desc_v2().count() == 0 {
        return Err("Staged data for ConstructionRecipeDescV2 is empty, aborting.".into());
    }
    if ctx.db.staged_contribution_loot_desc().count() == 0 {
        return Err("Staged data for ContributionLootDescV2 is empty, aborting.".into());
    }
    if ctx.db.staged_crafting_recipe_desc().count() == 0 {
        return Err("Staged data for CraftingRecipeDesc is empty, aborting.".into());
    }
    if ctx.db.staged_deconstruction_recipe_desc().count() == 0 {
        return Err("Staged data for DeconstructionRecipeDesc is empty, aborting.".into());
    }
    if ctx.db.staged_deployable_desc().count() == 0 {
        return Err("Staged data for DeployableDescV4 is empty, aborting.".into());
    }
    if ctx.db.staged_distant_visible_entity_desc().count() == 0 {
        return Err("Staged data for DistantVisibleEntityDesc is empty, aborting.".into());
    }
    if ctx.db.staged_elevator_desc().count() == 0 {
        return Err("Staged data for ElevatorDesc is empty, aborting.".into());
    }
    if ctx.db.staged_emote_desc().count() == 0 {
        return Err("Staged data for EmoteDescV2 is empty, aborting.".into());
    }
    if ctx.db.staged_empire_colors_desc().count() == 0 {
        return Err("Staged data for EmpireColorDesc is empty, aborting.".into());
    }
    if ctx.db.staged_empire_icon_desc().count() == 0 {
        return Err("Staged data for EmpireIconDesc is empty, aborting.".into());
    }
    if ctx.db.staged_empire_notification_desc().count() == 0 {
        return Err("Staged data for EmpireNotificationDesc is empty, aborting.".into());
    }
    if ctx.db.staged_empire_rank_desc().count() == 0 {
        return Err("Staged data for EmpireRankDesc is empty, aborting.".into());
    }
    if ctx.db.staged_empire_supplies_desc().count() == 0 {
        return Err("Staged data for EmpireSuppliesDesc is empty, aborting.".into());
    }
    if ctx.db.staged_empire_territory_desc().count() == 0 {
        return Err("Staged data for EmpireTerritoryDesc is empty, aborting.".into());
    }
    if ctx.db.staged_enemy_ai_params_desc().count() == 0 {
        return Err("Staged data for EnemyAiParamsDesc is empty, aborting.".into());
    }
    if ctx.db.staged_enemy_desc().count() == 0 {
        return Err("Staged data for EnemyDesc is empty, aborting.".into());
    }
    if ctx.db.staged_enemy_scaling_desc().count() == 0 {
        return Err("Staged data for EnemyScalingDesc is empty, aborting.".into());
    }
    if ctx.db.staged_environment_debuff_desc().count() == 0 {
        return Err("Staged data for EnvironmentDebuffDesc is empty, aborting.".into());
    }
    if ctx.db.staged_equipment_desc().count() == 0 {
        return Err("Staged data for EquipmentDesc is empty, aborting.".into());
    }
    if ctx.db.staged_extraction_recipe_desc().count() == 0 {
        return Err("Staged data for ExtractionRecipeDesc is empty, aborting.".into());
    }
    if ctx.db.staged_food_desc().count() == 0 {
        return Err("Staged data for FoodDesc is empty, aborting.".into());
    }
    if ctx.db.staged_gate_desc().count() == 0 {
        return Err("Staged data for GateDesc is empty, aborting.".into());
    }
    if ctx.db.staged_hexite_exchange_entry_desc().count() == 0 {
        return Err("Staged data for HexiteExchangeEntryDesc is empty, aborting.".into());
    }
    if ctx.db.staged_interior_environment_desc().count() == 0 {
        return Err("Staged data for InteriorEnvironmentDesc is empty, aborting.".into());
    }
    if ctx.db.staged_interior_instance_desc().count() == 0 {
        return Err("Staged data for InteriorInstanceDesc is empty, aborting.".into());
    }
    if ctx.db.staged_interior_network_desc().count() == 0 {
        return Err("Staged data for InteriorNetworkDesc is empty, aborting.".into());
    }
    if ctx.db.staged_interior_portal_connections_desc().count() == 0 {
        return Err("Staged data for InteriorPortalConnectionsDesc is empty, aborting.".into());
    }
    if ctx.db.staged_interior_shape_desc().count() == 0 {
        return Err("Staged data for InteriorShapeDesc is empty, aborting.".into());
    }
    if ctx.db.staged_interior_spawn_desc().count() == 0 {
        return Err("Staged data for InteriorSpawnDesc is empty, aborting.".into());
    }
    if ctx.db.staged_item_conversion_recipe_desc().count() == 0 {
        return Err("Staged data for ItemConversionRecipeDesc is empty, aborting.".into());
    }
    if ctx.db.staged_item_desc().count() == 0 {
        return Err("Staged data for ItemDesc is empty, aborting.".into());
    }
    if ctx.db.staged_item_list_desc().count() == 0 {
        return Err("Staged data for ItemListDesc is empty, aborting.".into());
    }
    if ctx.db.staged_knowledge_scroll_desc().count() == 0 {
        return Err("Staged data for KnowledgeScrollDesc is empty, aborting.".into());
    }
    if ctx.db.staged_knowledge_scroll_type_desc().count() == 0 {
        return Err("Staged data for KnowledgeScrollTypeDesc is empty, aborting.".into());
    }
    if ctx.db.staged_knowledge_stat_modifier_desc().count() == 0 {
        return Err("Staged data for KnowledgeStatModifierDesc is empty, aborting.".into());
    }
    if ctx.db.staged_loot_chest_desc().count() == 0 {
        return Err("Staged data for LootChestDesc is empty, aborting.".into());
    }
    if ctx.db.staged_loot_rarity_desc().count() == 0 {
        return Err("Staged data for LootRarityDesc is empty, aborting.".into());
    }
    if ctx.db.staged_loot_table_desc().count() == 0 {
        return Err("Staged data for LootTableDesc is empty, aborting.".into());
    }
    if ctx.db.staged_npc_desc().count() == 0 {
        return Err("Staged data for NpcDesc is empty, aborting.".into());
    }
    if ctx.db.staged_onboarding_reward_desc().count() == 0 {
        return Err("Staged data for OnboardingRewardDesc is empty, aborting.".into());
    }
    if ctx.db.staged_parameters_desc().count() == 0 {
        return Err("Staged data for ParametersDescV2 is empty, aborting.".into());
    }
    if ctx.db.staged_pathfinding_desc().count() == 0 {
        return Err("Staged data for PathfindingDesc is empty, aborting.".into());
    }
    if ctx.db.staged_paving_tile_desc().count() == 0 {
        return Err("Staged data for PavingTileDesc is empty, aborting.".into());
    }
    if ctx.db.staged_pillar_shaping_desc().count() == 0 {
        return Err("Staged data for PillarShapingDesc is empty, aborting.".into());
    }
    if ctx.db.staged_player_action_desc().count() == 0 {
        return Err("Staged data for PlayerActionDesc is empty, aborting.".into());
    }
    if ctx.db.staged_player_housing_desc().count() == 0 {
        return Err("Staged data for PlayerHousingDesc is empty, aborting.".into());
    }
    if ctx.db.staged_premium_item_desc().count() == 0 {
        return Err("Staged data for PremiumItemDesc is empty, aborting.".into());
    }
    if ctx.db.staged_premium_service_desc().count() == 0 {
        return Err("Staged data for PremiumServiceDesc is empty, aborting.".into());
    }
    if ctx.db.staged_private_parameters_desc().count() == 0 {
        return Err("Staged data for PrivateParametersDesc is empty, aborting.".into());
    }
    if ctx.db.staged_prospecting_desc().count() == 0 {
        return Err("Staged data for ProspectingDesc is empty, aborting.".into());
    }
    if ctx.db.staged_quest_chain_desc().count() == 0 {
        return Err("Staged data for QuestChainDesc is empty, aborting.".into());
    }
    if ctx.db.staged_quest_stage_desc().count() == 0 {
        return Err("Staged data for QuestStageDesc is empty, aborting.".into());
    }
    if ctx.db.staged_reserved_name_desc().count() == 0 {
        return Err("Staged data for ReservedNameDesc is empty, aborting.".into());
    }
    if ctx.db.staged_resource_clump_desc().count() == 0 {
        return Err("Staged data for ResourceClumpDesc is empty, aborting.".into());
    }
    if ctx.db.staged_resource_desc().count() == 0 {
        return Err("Staged data for ResourceDesc is empty, aborting.".into());
    }
    if ctx.db.staged_resource_growth_recipe_desc().count() == 0 {
        return Err("Staged data for ResourceGrowthRecipeDesc is empty, aborting.".into());
    }
    if ctx.db.staged_resource_placement_recipe_desc_v2().count() == 0 {
        return Err("Staged data for ResourcePlacementRecipeDescV2 is empty, aborting.".into());
    }
    if ctx.db.staged_secondary_knowledge_desc().count() == 0 {
        return Err("Staged data for SecondaryKnowledgeDesc is empty, aborting.".into());
    }
    if ctx.db.staged_skill_desc().count() == 0 {
        return Err("Staged data for SkillDesc is empty, aborting.".into());
    }
    if ctx.db.staged_stage_rewards_desc().count() == 0 {
        return Err("Staged data for StageRewardsDesc is empty, aborting.".into());
    }
    if ctx.db.staged_targeting_matrix_desc().count() == 0 {
        return Err("Staged data for TargetingMatrixDesc is empty, aborting.".into());
    }
    if ctx.db.staged_teleport_item_desc().count() == 0 {
        return Err("Staged data for TeleportItemDesc is empty, aborting.".into());
    }
    if ctx.db.staged_terraform_recipe_desc().count() == 0 {
        return Err("Staged data for TerraformRecipeDesc is empty, aborting.".into());
    }
    if ctx.db.staged_tool_desc().count() == 0 {
        return Err("Staged data for ToolDesc is empty, aborting.".into());
    }
    if ctx.db.staged_tool_type_desc().count() == 0 {
        return Err("Staged data for ToolTypeDesc is empty, aborting.".into());
    }
    if ctx.db.staged_traveler_task_desc().count() == 0 {
        return Err("Staged data for TravelerTaskDesc is empty, aborting.".into());
    }
    if ctx.db.staged_traveler_trade_order_desc().count() == 0 {
        return Err("Staged data for TravelerTradeOrderDesc is empty, aborting.".into());
    }
    if ctx.db.staged_wall_desc().count() == 0 {
        return Err("Staged data for WallDesc is empty, aborting.".into());
    }
    if ctx.db.staged_weapon_desc().count() == 0 {
        return Err("Staged data for WeaponDesc is empty, aborting.".into());
    }
    if ctx.db.staged_weapon_type_desc().count() == 0 {
        return Err("Staged data for WeaponTypeDesc is empty, aborting.".into());
    }
    if ctx.db.staged_wind_params_desc().count() == 0 {
        return Err("Staged data for WindParamsDesc is empty, aborting.".into());
    }
    Ok(())
}
