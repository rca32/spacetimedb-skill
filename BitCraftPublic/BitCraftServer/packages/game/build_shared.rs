#![allow(clippy::disallowed_macros)]

use glob::glob;
use std::collections::HashSet;
use std::fs;
use std::path::PathBuf;
use std::process::Command;

pub fn main_shared() {
    build_all_handlers_mods();
    build_gamestate_operations();
    build_version_reducer();
    build_shared_tables();
    build_static_data_staging_tables();
}

fn build_version_reducer() {
    let dest_path = "src/utils/version.rs";
    // Use `git` command to get the current commit hash.
    let output = Command::new("git")
        .args(["rev-parse", "HEAD"])
        .output()
        .expect("Failed to execute git");

    let git_hash = String::from_utf8(output.stdout).expect("Failed to read git output");

    // Create a new file and write the git commit hash into it.
    let mut version_file_content = String::new();
    version_file_content.push_str("//This file is auto-generated by bitcraft\\build.rs. Do not edit.\n\n");
    version_file_content.push_str("use spacetimedb::{log, ReducerContext};\n\n");
    version_file_content.push_str("#[spacetimedb::reducer]\n    pub fn current_version(_ctx: &ReducerContext) -> Result<(), String> {\n");
    version_file_content.push_str(&format!("    log::info!(\"{}\");\n", git_hash.trim()));
    version_file_content.push_str("    Ok(())\n}");

    write_if_file_changed(dest_path, version_file_content);
}

fn build_all_handlers_mods() {
    // Generate mod.rs for root folder
    build_handlers_mod("src/game/handlers");

    // Generate mod.rs for all sub-folder
    for e in glob("src/game/handlers/*").expect("Failed to read glob pattern") {
        if let Ok(path_buf) = e {
            if path_buf.is_dir() {
                let dir = path_buf.file_name().unwrap().to_str().unwrap();
                let path = format!("src/game/handlers/{dir}");
                build_handlers_mod(path.as_str());
            }
        }
    }
}

fn build_handlers_mod(dir: &str) {
    println!("cargo:rerun-if-changed={dir}");

    let mut output = String::new();
    output.push_str("//This file is auto-generated by bitcraft\\build.rs. Do not edit.\r\n\r\n");

    let mut path_bufs: Vec<PathBuf> = Vec::new();
    //Find sub-folders
    for e in glob(format!("{dir}/*").as_str()).expect("Failed to read glob pattern") {
        if let Ok(path_buf) = e {
            if path_buf.is_dir() {
                path_bufs.push(path_buf.clone());
            }
        }
    }
    //Find handlers
    for e in glob(format!("{dir}/*.rs").as_str()).expect("Failed to read glob pattern") {
        if let Ok(path_buf) = e {
            if path_buf.file_name().unwrap() == "mod.rs" {
                // Do nothing
            } else {
                path_bufs.push(path_buf.clone());
            }
        }
    }

    // mod definitions
    for path_buf in &path_bufs {
        output.push_str("pub mod ");
        output.push_str(path_buf.file_stem().unwrap().to_str().unwrap());
        output.push_str(";\r\n");
    }

    write_if_file_changed(format!("{dir}/mod.rs").as_str(), output);
}

fn build_gamestate_operations() {
    println!("cargo:rerun-if-changed=src/messages/components.rs");

    // table name: indexed
    let mut all_entity_tables: Vec<String> = Vec::new();
    let mut delete_table: Vec<String> = Vec::new();

    let mut output = "".to_string();
    let mut writeln = |s: &str| {
        output.push_str(s);
        output.push_str("\r\n");
    };

    // 1. Read GameState/mod.rs, parse all tables
    let input = fs::read_to_string("src/messages/components.rs").unwrap();

    let lines: Vec<&str> = input.split('\n').collect();
    let mut next_struct_is_table = false;
    let mut has_delete = false;
    let mut next_tables = Vec::new();

    for line in lines {
        if line.trim().contains("#[") {
            if line.to_ascii_lowercase().contains("spacetimedb::table") {
                if let Some(i) = line[0..].find("name = ").map(|i| i + 0) {
                    let i = i + 7;
                    if let Some(j) = line[i..].find(",").map(|k| k + i) {
                        let table_name = line[i..j].to_string();
                        next_tables.push(table_name);
                    } else {
                        if let Some(j) = line[i..].find(")").map(|k| k + i) {
                            let table_name = line[i..j].to_string();
                            next_tables.push(table_name);
                        }
                    }
                }
                next_struct_is_table = true;
            }
            has_delete |= line.to_ascii_lowercase().contains("delete");

            continue;
        }

        if let Some(ch) = line.chars().nth(0) {
            if ch == '}' {
                // End of table.
                next_tables.clear();
                has_delete = false;
                continue;
            }
        }

        if line.contains("pub struct") {
            if next_struct_is_table {
                next_struct_is_table = false;

                if has_delete {
                    for table in &next_tables {
                        delete_table.push(table.clone());
                    }
                }
            }
        }

        if next_tables.len() > 0 && line.contains(" entity_id: u64") {
            for table in &next_tables {
                all_entity_tables.push(table.clone());
            }
        }
    }

    // 2. Write delete module
    delete_table.sort();
    all_entity_tables.sort();
    all_entity_tables.dedup();

    writeln("//This file is auto-generated by bitcraft\\build.rs. Do not edit.\r\n");

    writeln("use spacetimedb::ReducerContext;");

    for k in &all_entity_tables {
        writeln(format!("use crate::{};", camel_to_snake(&k)).as_str());
    }

    writeln("\r\n\r\npub fn delete_entity(ctx: &ReducerContext, entity_id: u64) {");

    for k in &delete_table {
        writeln(format!("   ctx.db.{}().entity_id().delete(entity_id);", camel_to_snake(&k)).as_str());
    }
    writeln("}\r\n");

    writeln("/// Delete entity from ALL tables (even ones that don't have `delete` attribute)");
    writeln("pub fn clear_entity(ctx: &ReducerContext, entity_id: u64) {");

    for k in &all_entity_tables {
        writeln(format!("   ctx.db.{}().entity_id().delete(entity_id);", camel_to_snake(&k)).as_str());
    }
    writeln("}\r\n");

    write_if_file_changed("src/game/autogen/_delete_entity.rs", output);
}

fn camel_to_snake(str: &String) -> String {
    let mut output = String::new();
    for c in str.chars() {
        if c.is_uppercase() {
            if String::is_empty(&output) {
                output.push_str(c.to_ascii_lowercase().to_string().as_str());
            } else {
                output.push_str(format!("_{}", c.to_ascii_lowercase()).as_str());
            }
        } else {
            output.push_str(c.to_string().as_str());
        }
    }
    output
}

pub fn build_shared_tables() {
    println!("cargo:rerun-if-changed=src/messages/");
    // table name: indexed
    let mut all_shared_tables: Vec<(String, String)> = Vec::new(); //Key == table name, Value == PK name
    let mut custom_inter_module_insert_tables: HashSet<String> = HashSet::new();

    // 1. Read GameState/mod.rs, parse all tables
    let mut input: String = String::new();
    for e in glob(format!("src/messages/*.rs").as_str()).expect("Failed to read glob pattern") {
        if let Ok(path_buf) = e {
            if path_buf.file_name().unwrap() == "mod.rs" {
                // Do nothing
            } else {
                input = input + fs::read_to_string(path_buf.clone()).unwrap().as_str();
            }
        }
    }

    let lines: Vec<&str> = input.split('\n').collect();
    let mut next_struct_is_table = false;
    let mut is_next_line_pk = false;
    let mut cur_table: Option<String> = None;
    let mut has_custom_insert = false;

    for line in lines {
        let line = line.trim();
        if line.starts_with("//") {
            continue;
        }

        if line.contains("#[") && line.contains("shared_table") {
            next_struct_is_table = true;
        }
        if line.contains("#[") && line.contains("custom_inter_module_insert") {
            has_custom_insert = true;
        }

        //Find table names
        if line.contains("pub struct") {
            if next_struct_is_table {
                next_struct_is_table = false;

                if let Some(name_index) = line.find("pub struct ") {
                    let start = name_index + 11;
                    let line = &line[start..];

                    if let Some(index) = line.find(" ") {
                        cur_table = Some(line[..index].to_string());
                    }
                };
            }
        } else if cur_table.is_some() && line.contains("primary_key") {
            is_next_line_pk = true;
        }

        //Find PK names (need for deletes)
        if is_next_line_pk {
            if let Some(ind) = line.find(':') {
                let pk = line[..ind].trim();
                is_next_line_pk = false;
                if let Some(ind) = pk.rfind(' ') {
                    let pk = pk[(ind + 1)..].trim().to_string();
                    let table_name = cur_table.unwrap();
                    all_shared_tables.push((table_name.clone(), pk));
                    if has_custom_insert {
                        custom_inter_module_insert_tables.insert(table_name);
                        has_custom_insert = false;
                    }
                    cur_table = None;
                }
            }
        }
    }

    // 2. Write delete module
    all_shared_tables.sort();

    let mut output = String::new();
    let mut writeln = |s: &str| {
        output.push_str(s);
        output.push_str("\r\n");
    };
    writeln("//This file is auto-generated by bitcraft\\build.rs. Do not edit.\r\n");
    writeln("use spacetimedb::*;");
    writeln("use crate::messages::authentication::*;");
    writeln("use crate::messages::generic::*;");
    writeln("use crate::messages::empire_shared::*;");
    writeln("use crate::*;\r\n");

    //InterModuleTalbeUpdates
    {
        for (table, _pk) in &all_shared_tables {
            writeln("#[derive(SpacetimeType, Clone, Debug)]");
            writeln(format!("pub enum {table}Op {{").as_str());
            writeln(format!("    Insert({table}),").as_str());
            writeln(format!("    Delete({table}),").as_str());
            writeln("}");
        }
        writeln("");

        writeln("#[derive(SpacetimeType, Clone, Debug)]");
        writeln("pub struct InterModuleTableUpdates {");
        for (table, _pk) in &all_shared_tables {
            let snake = camel_to_snake(table);
            writeln(format!("    pub {snake}: Option<Vec<{table}Op>>,").as_str());
        }
        writeln("}\r\n");

        writeln("impl InterModuleTableUpdates {");
        writeln("    pub fn new() -> Self {");
        writeln("        Self {");
        for (table, _pk) in &all_shared_tables {
            let snake = camel_to_snake(table);
            writeln(format!("            {snake}: None,").as_str());
        }
        writeln("        }");
        writeln("    }"); // pub fn new()

        writeln("    pub fn apply_updates(self, ctx: &ReducerContext) {");
        for (table, pk) in &all_shared_tables {
            let snake = camel_to_snake(table);
            writeln(format!("        if let Some(v) = self.{} {{", snake).as_str());
            writeln("            for op in v {");
            writeln("                match op {");
            if custom_inter_module_insert_tables.contains(table) {
                writeln(format!("                    {table}Op::Insert(val) => _ = {table}::inter_module_insert(ctx, val),").as_str());
            } else {
                writeln(format!("                    {table}Op::Insert(val) => _ = ctx.db.{snake}().insert(val),").as_str());
            }
            writeln(format!("                    {table}Op::Delete(val) => _ = ctx.db.{snake}().{pk}().delete(val.{pk}),").as_str());
            writeln("                }");
            writeln("            }");
            writeln("        }");
        }
        writeln("    }"); // pub fn apply_updates()
        writeln("}"); //impl InterModuleTableUpdates
    }

    write_if_file_changed("src/inter_module/_autogen.rs", output);
}

pub fn write_if_file_changed(path: &str, content: String) {
    let old_text = fs::read_to_string(path).unwrap_or("".to_string());
    if old_text != content {
        fs::write(path, content).unwrap();
    }
}

fn build_static_data_staging_tables() {
    println!("cargo:rerun-if-changed=src/messages/");
    // table name: indexed
    let mut all_tables: Vec<(String, String, String)> = Vec::new(); //1 == provided name, 2 == ctx name, 3 == struct name

    // 1. Read GameState/mod.rs, parse all tables
    let mut input: String = String::new();
    for e in glob(format!("src/messages/*.rs").as_str()).expect("Failed to read glob pattern") {
        if let Ok(path_buf) = e {
            if path_buf.file_name().unwrap() == "mod.rs" {
                // Do nothing
            } else {
                input = input + fs::read_to_string(path_buf.clone()).unwrap().as_str();
            }
        }
    }

    let lines: Vec<&str> = input.split('\n').collect();
    let mut cur_provided_name: Option<String> = None;
    let mut cur_ctx_name: Option<String> = None;

    for line in lines {
        let line = line.trim();
        if line.starts_with("//") {
            continue;
        }

        if line.starts_with("#[") {
            if line.contains("static_data_staging_table") {
                cur_ctx_name = None;
                match (line.find('('), line.find(')')) {
                    (Some(start), Some(end)) => cur_provided_name = Some(line[(start + 1)..end].trim().to_string()),
                    _ => cur_provided_name = None,
                };
            } else if cur_provided_name.is_some() && line.contains("spacetimedb::table") {
                cur_ctx_name = None;
                if let Some(start) = line.find('=') {
                    if let Some(end) = line.find(',').or(line.find(')')) {
                        let name = line[(start + 1)..end].trim().to_string();
                        cur_ctx_name = Some(name);
                    }
                }
            }
        } else if cur_ctx_name.is_some() && line.contains("pub struct") {
            if let Some(name_index) = line.find("pub struct ") {
                let start = name_index + 11;
                let line = &line[start..];

                if let Some(index) = line.find(" ") {
                    let name = line[..index].to_string();
                    all_tables.push((cur_provided_name.unwrap(), cur_ctx_name.unwrap(), name));
                }
            };

            cur_provided_name = None;
            cur_ctx_name = None;
        }
    }

    // 2. Write file
    all_tables.sort();

    let mut output = String::new();
    let mut writeln = |s: &str| {
        output.push_str(s);
        output.push_str("\r\n");
    };
    writeln("//This file is auto-generated by bitcraft\\build.rs. Do not edit.");
    writeln("");
    //writeln("use crate::import_reducers::*;");
    writeln("use crate::messages::static_data::*;");
    writeln("use crate::*;");
    writeln("use spacetimedb::*;");
    writeln("use crate::game::handlers::authentication::has_role;");
    writeln("");

    //clear_staged_static_data
    writeln("#[spacetimedb::reducer]");
    writeln("pub fn clear_staged_static_data(ctx: &ReducerContext) -> Result<(), String> {");
    writeln("    if !has_role(ctx, &ctx.sender, Role::Admin) {");
    writeln("        return Err(\"Invalid permissions\".into());");
    writeln("    }");
    writeln("");
    for (name, _, _) in &all_tables {
        writeln(format!("    for r in ctx.db.staged_{name}().iter() {{").as_str());
        writeln(format!("        ctx.db.staged_{name}().delete(r);").as_str());
        writeln("    }");
    }
    writeln("");
    writeln("    Ok(())");
    writeln("}");
    writeln("");

    //stage_table
    for (name, _, struct_name) in &all_tables {
        writeln("#[spacetimedb::reducer]");
        writeln(format!("pub fn stage_{name}(ctx: &ReducerContext, records: Vec<{struct_name}>) -> Result<(), String> {{").as_str());
        writeln("    if !has_role(ctx, &ctx.sender, Role::Admin) {");
        writeln("        return Err(\"Invalid permissions\".into());");
        writeln("    }");
        writeln("    for r in records {");
        writeln(format!("        if let Err(e) = ctx.db.staged_{name}().try_insert(r.clone()) {{").as_str());
        writeln("            spacetimedb::log::error!(\"Failed to stage record {:?}: {}\", r, e);");
        writeln("            return Err(e.to_string());");
        writeln("        }");
        writeln("    }");
        writeln("    Ok(())");
        writeln("}");
        writeln("");
    }

    //validate_staged_data
    writeln("pub fn validate_staged_data(ctx: &ReducerContext) -> Result<(), String> {");
    for (name, _, struct_name) in &all_tables {
        writeln(format!("    if ctx.db.staged_{name}().count() == 0 {{").as_str());
        writeln(format!("        return Err(\"Staged data for {struct_name} is empty, aborting.\".into());").as_str());
        writeln(format!("    }}").as_str());
    }
    writeln("    Ok(())");
    writeln("}");

    ////import_table
    //for (name, ctx, struct_name) in &all_tables {
    //    writeln("#[spacetimedb::reducer]");
    //    writeln(format!("pub fn import_{name}(ctx: &ReducerContext, records: Vec<{struct_name}>) -> Result<(), String> {{").as_str());
    //    writeln(format!("    if !has_role(ctx, &ctx.sender, Role::Admin) {{").as_str());
    //    writeln(format!("        return Err(\"Invalid permissions\".into());").as_str());
    //    writeln(format!("    }}").as_str());
    //    writeln(format!("    import_{name}_internal(ctx, records)?;").as_str());
    //    writeln(format!("    Ok(())").as_str());
    //    writeln(format!("}}").as_str());
    //    writeln(format!("fn import_{name}_internal(ctx: &ReducerContext, records: Vec<{struct_name}>) -> Result<(), String> {{").as_str());
    //    writeln(format!("    for r in ctx.db.{ctx}().iter() {{").as_str());
    //    writeln(format!("        ctx.db.{ctx}().delete(r);").as_str());
    //    writeln(format!("    }}").as_str());
    //    writeln(format!("    let len: usize = records.len();").as_str());
    //    writeln(format!("    log::info!(\"Will insert {{}} records of type {struct_name}\", len);").as_str());
    //    writeln(format!("    for record in records {{").as_str());
    //    writeln(format!("        if let Err(err) = ctx.db.{ctx}().try_insert(record.clone()) {{").as_str());
    //    writeln(format!("            return Err(format!(").as_str());
    //    writeln(
    //        format!("                \"Couldn't insert {struct_name} record. Error message: {{}}. Row: {{:#?}}\", err, record").as_str(),
    //    );
    //    writeln(format!("            ));").as_str());
    //    writeln(format!("        }}").as_str());
    //    writeln(format!("    }}").as_str());
    //    writeln(format!("    log::info!(\"Inserted {{}} records of type {struct_name}\", len);").as_str());
    //    writeln("    Ok(())");
    //    writeln("}");
    //    writeln("");
    //}
    //
    ////commit_staged_static_data
    //writeln("#[spacetimedb::reducer]");
    //writeln("pub fn commit_staged_static_data(ctx: &ReducerContext) -> Result<(), String> {");
    //writeln("    if !has_role(ctx, &ctx.sender, Role::Admin) {");
    //writeln("        return Err(\"Invalid permissions\".into());");
    //writeln("    }");
    //writeln("");
    //writeln("    pre_process_staged_static_data(ctx)?;");
    //writeln("");
    //for (name, _, struct_name) in &all_tables {
    //    writeln(format!("    let records: Vec<{struct_name}> = ctx.db.staged_{name}().iter().collect();").as_str());
    //    writeln(format!("    if records.len() == 0 {{").as_str());
    //    writeln(format!("        return Err(\"Staged data vec {struct_name} is empty, aborting.\".into());").as_str());
    //    writeln(format!("    }}").as_str());
    //    writeln(format!("    import_{name}(ctx, records)?;").as_str());
    //}
    //writeln("");
    //writeln("    post_process_staged_static_data(ctx)?;");
    //writeln("");
    //writeln("    return Ok(());");
    //writeln("}");
    //writeln("");

    write_if_file_changed("src/game/autogen/_static_data.rs", output);
}
