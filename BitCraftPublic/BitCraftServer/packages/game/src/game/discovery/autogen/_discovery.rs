//This file is auto-generated by bitcraft\build.rs. Do not edit.

use spacetimedb::{ReducerContext, Table};
use crate::{game::{discovery::Discovery, coordinates::OffsetCoordinatesSmall}, messages::{components::*, static_data::*}};
use crate::messages::components::KnowledgeAchievementState;
use crate::messages::components::KnowledgeBattleActionState;
use crate::messages::components::KnowledgeBuildingState;
use crate::messages::components::KnowledgeCargoState;
use crate::messages::components::KnowledgeClaimState;
use crate::messages::components::KnowledgeConstructionState;
use crate::messages::components::KnowledgeCraftState;
use crate::messages::components::KnowledgeDeployableState;
use crate::messages::components::KnowledgeEnemyState;
use crate::messages::components::KnowledgeExtractState;
use crate::messages::components::KnowledgeItemState;
use crate::messages::components::KnowledgeLoreState;
use crate::messages::components::KnowledgeNpcState;
use crate::messages::components::KnowledgePavingState;
use crate::messages::components::KnowledgePillarShapingState;
use crate::messages::components::KnowledgeResourcePlacementState;
use crate::messages::components::KnowledgeResourceState;
use crate::messages::components::KnowledgeRuinsState;
use crate::messages::components::KnowledgeSecondaryState;
use crate::messages::components::KnowledgeVaultState;


pub struct Knowledges {
    pub knowledge_achievement: Vec<KnowledgeEntry>,
    pub knowledge_achievement_hash: i32,
    pub knowledge_battle_action: Vec<KnowledgeEntry>,
    pub knowledge_battle_action_hash: i32,
    pub knowledge_building: Vec<KnowledgeEntry>,
    pub knowledge_building_hash: i32,
    pub knowledge_cargo: Vec<KnowledgeEntry>,
    pub knowledge_cargo_hash: i32,
    pub knowledge_claim: Vec<KnowledgeEntityEntry>,
    pub knowledge_claim_hash: i32,
    pub knowledge_construction: Vec<KnowledgeEntry>,
    pub knowledge_construction_hash: i32,
    pub knowledge_craft: Vec<KnowledgeEntry>,
    pub knowledge_craft_hash: i32,
    pub knowledge_deployable: Vec<KnowledgeEntry>,
    pub knowledge_deployable_hash: i32,
    pub knowledge_enemy: Vec<KnowledgeEntry>,
    pub knowledge_enemy_hash: i32,
    pub knowledge_extract: Vec<KnowledgeEntry>,
    pub knowledge_extract_hash: i32,
    pub knowledge_item: Vec<KnowledgeEntry>,
    pub knowledge_item_hash: i32,
    pub knowledge_lore: Vec<KnowledgeEntry>,
    pub knowledge_lore_hash: i32,
    pub knowledge_npc: Vec<KnowledgeEntry>,
    pub knowledge_npc_hash: i32,
    pub knowledge_paving: Vec<KnowledgeEntry>,
    pub knowledge_paving_hash: i32,
    pub knowledge_pillar_shaping: Vec<KnowledgeEntry>,
    pub knowledge_pillar_shaping_hash: i32,
    pub knowledge_resource_placement: Vec<KnowledgeEntry>,
    pub knowledge_resource_placement_hash: i32,
    pub knowledge_resource: Vec<KnowledgeEntry>,
    pub knowledge_resource_hash: i32,
    pub knowledge_ruins: Vec<KnowledgeLocationEntry>,
    pub knowledge_ruins_hash: i32,
    pub knowledge_secondary: Vec<KnowledgeEntry>,
    pub knowledge_secondary_hash: i32,
    pub knowledge_vault: Vec<KnowledgeEntry>,
    pub knowledge_vault_hash: i32,
}

pub fn generate_knowledges(ctx: &ReducerContext, entity_id: u64) {
    if ctx.db.knowledge_achievement_state().try_insert(KnowledgeAchievementState { entries: Vec::new(), entity_id }).is_err() {}
    if ctx.db.knowledge_battle_action_state().try_insert(KnowledgeBattleActionState { entries: Vec::new(), entity_id }).is_err() {}
    if ctx.db.knowledge_building_state().try_insert(KnowledgeBuildingState { entries: Vec::new(), entity_id }).is_err() {}
    if ctx.db.knowledge_cargo_state().try_insert(KnowledgeCargoState { entries: Vec::new(), entity_id }).is_err() {}
    if ctx.db.knowledge_claim_state().try_insert(KnowledgeClaimState { entries: Vec::new(), entity_id }).is_err() {}
    if ctx.db.knowledge_construction_state().try_insert(KnowledgeConstructionState { entries: Vec::new(), entity_id }).is_err() {}
    if ctx.db.knowledge_craft_state().try_insert(KnowledgeCraftState { entries: Vec::new(), entity_id }).is_err() {}
    if ctx.db.knowledge_deployable_state().try_insert(KnowledgeDeployableState { entries: Vec::new(), entity_id }).is_err() {}
    if ctx.db.knowledge_enemy_state().try_insert(KnowledgeEnemyState { entries: Vec::new(), entity_id }).is_err() {}
    if ctx.db.knowledge_extract_state().try_insert(KnowledgeExtractState { entries: Vec::new(), entity_id }).is_err() {}
    if ctx.db.knowledge_item_state().try_insert(KnowledgeItemState { entries: Vec::new(), entity_id }).is_err() {}
    if ctx.db.knowledge_lore_state().try_insert(KnowledgeLoreState { entries: Vec::new(), entity_id }).is_err() {}
    if ctx.db.knowledge_npc_state().try_insert(KnowledgeNpcState { entries: Vec::new(), entity_id }).is_err() {}
    if ctx.db.knowledge_paving_state().try_insert(KnowledgePavingState { entries: Vec::new(), entity_id }).is_err() {}
    if ctx.db.knowledge_pillar_shaping_state().try_insert(KnowledgePillarShapingState { entries: Vec::new(), entity_id }).is_err() {}
    if ctx.db.knowledge_resource_placement_state().try_insert(KnowledgeResourcePlacementState { entries: Vec::new(), entity_id }).is_err() {}
    if ctx.db.knowledge_resource_state().try_insert(KnowledgeResourceState { entries: Vec::new(), entity_id }).is_err() {}
    if ctx.db.knowledge_ruins_state().try_insert(KnowledgeRuinsState { entries: Vec::new(), entity_id }).is_err() {}
    if ctx.db.knowledge_secondary_state().try_insert(KnowledgeSecondaryState { entries: Vec::new(), entity_id }).is_err() {}
    if ctx.db.knowledge_vault_state().try_insert(KnowledgeVaultState { entries: Vec::new(), entity_id }).is_err() {}
}

#[allow(dead_code)]
impl Discovery {

    pub fn initialize(&mut self, ctx: &ReducerContext) {
        let player_entity_id = self.player_entity_id;
        self.knowledges = Some(Knowledges {
            knowledge_achievement: ctx.db.knowledge_achievement_state().entity_id().find(player_entity_id).unwrap().entries.clone(),
            knowledge_achievement_hash: Self::knowledge_entry_array_hash(&ctx.db.knowledge_achievement_state().entity_id().find(player_entity_id).unwrap().entries),
            knowledge_battle_action: ctx.db.knowledge_battle_action_state().entity_id().find(player_entity_id).unwrap().entries.clone(),
            knowledge_battle_action_hash: Self::knowledge_entry_array_hash(&ctx.db.knowledge_battle_action_state().entity_id().find(player_entity_id).unwrap().entries),
            knowledge_building: ctx.db.knowledge_building_state().entity_id().find(player_entity_id).unwrap().entries.clone(),
            knowledge_building_hash: Self::knowledge_entry_array_hash(&ctx.db.knowledge_building_state().entity_id().find(player_entity_id).unwrap().entries),
            knowledge_cargo: ctx.db.knowledge_cargo_state().entity_id().find(player_entity_id).unwrap().entries.clone(),
            knowledge_cargo_hash: Self::knowledge_entry_array_hash(&ctx.db.knowledge_cargo_state().entity_id().find(player_entity_id).unwrap().entries),
            knowledge_claim: ctx.db.knowledge_claim_state().entity_id().find(player_entity_id).unwrap().entries.clone(),
            knowledge_claim_hash: Self::entity_entry_array_hash(&ctx.db.knowledge_claim_state().entity_id().find(player_entity_id).unwrap().entries),
            knowledge_construction: ctx.db.knowledge_construction_state().entity_id().find(player_entity_id).unwrap().entries.clone(),
            knowledge_construction_hash: Self::knowledge_entry_array_hash(&ctx.db.knowledge_construction_state().entity_id().find(player_entity_id).unwrap().entries),
            knowledge_craft: ctx.db.knowledge_craft_state().entity_id().find(player_entity_id).unwrap().entries.clone(),
            knowledge_craft_hash: Self::knowledge_entry_array_hash(&ctx.db.knowledge_craft_state().entity_id().find(player_entity_id).unwrap().entries),
            knowledge_deployable: ctx.db.knowledge_deployable_state().entity_id().find(player_entity_id).unwrap().entries.clone(),
            knowledge_deployable_hash: Self::knowledge_entry_array_hash(&ctx.db.knowledge_deployable_state().entity_id().find(player_entity_id).unwrap().entries),
            knowledge_enemy: ctx.db.knowledge_enemy_state().entity_id().find(player_entity_id).unwrap().entries.clone(),
            knowledge_enemy_hash: Self::knowledge_entry_array_hash(&ctx.db.knowledge_enemy_state().entity_id().find(player_entity_id).unwrap().entries),
            knowledge_extract: ctx.db.knowledge_extract_state().entity_id().find(player_entity_id).unwrap().entries.clone(),
            knowledge_extract_hash: Self::knowledge_entry_array_hash(&ctx.db.knowledge_extract_state().entity_id().find(player_entity_id).unwrap().entries),
            knowledge_item: ctx.db.knowledge_item_state().entity_id().find(player_entity_id).unwrap().entries.clone(),
            knowledge_item_hash: Self::knowledge_entry_array_hash(&ctx.db.knowledge_item_state().entity_id().find(player_entity_id).unwrap().entries),
            knowledge_lore: ctx.db.knowledge_lore_state().entity_id().find(player_entity_id).unwrap().entries.clone(),
            knowledge_lore_hash: Self::knowledge_entry_array_hash(&ctx.db.knowledge_lore_state().entity_id().find(player_entity_id).unwrap().entries),
            knowledge_npc: ctx.db.knowledge_npc_state().entity_id().find(player_entity_id).unwrap().entries.clone(),
            knowledge_npc_hash: Self::knowledge_entry_array_hash(&ctx.db.knowledge_npc_state().entity_id().find(player_entity_id).unwrap().entries),
            knowledge_paving: ctx.db.knowledge_paving_state().entity_id().find(player_entity_id).unwrap().entries.clone(),
            knowledge_paving_hash: Self::knowledge_entry_array_hash(&ctx.db.knowledge_paving_state().entity_id().find(player_entity_id).unwrap().entries),
            knowledge_pillar_shaping: ctx.db.knowledge_pillar_shaping_state().entity_id().find(player_entity_id).unwrap().entries.clone(),
            knowledge_pillar_shaping_hash: Self::knowledge_entry_array_hash(&ctx.db.knowledge_pillar_shaping_state().entity_id().find(player_entity_id).unwrap().entries),
            knowledge_resource_placement: ctx.db.knowledge_resource_placement_state().entity_id().find(player_entity_id).unwrap().entries.clone(),
            knowledge_resource_placement_hash: Self::knowledge_entry_array_hash(&ctx.db.knowledge_resource_placement_state().entity_id().find(player_entity_id).unwrap().entries),
            knowledge_resource: ctx.db.knowledge_resource_state().entity_id().find(player_entity_id).unwrap().entries.clone(),
            knowledge_resource_hash: Self::knowledge_entry_array_hash(&ctx.db.knowledge_resource_state().entity_id().find(player_entity_id).unwrap().entries),
            knowledge_ruins: ctx.db.knowledge_ruins_state().entity_id().find(player_entity_id).unwrap().entries.clone(),
            knowledge_ruins_hash: Self::location_entry_array_hash(&ctx.db.knowledge_ruins_state().entity_id().find(player_entity_id).unwrap().entries),
            knowledge_secondary: ctx.db.knowledge_secondary_state().entity_id().find(player_entity_id).unwrap().entries.clone(),
            knowledge_secondary_hash: Self::knowledge_entry_array_hash(&ctx.db.knowledge_secondary_state().entity_id().find(player_entity_id).unwrap().entries),
            knowledge_vault: ctx.db.knowledge_vault_state().entity_id().find(player_entity_id).unwrap().entries.clone(),
            knowledge_vault_hash: Self::knowledge_entry_array_hash(&ctx.db.knowledge_vault_state().entity_id().find(player_entity_id).unwrap().entries),
        });
    }

    pub fn commit(&mut self, ctx: &ReducerContext) {
        if self.knowledges.is_none() {
            return;
        }

        self.on_knowledge_acquired(ctx);

        let knowledges = self.knowledges.as_mut().unwrap();

        let player_entity_id = self.player_entity_id;

        let knowledge_achievement_hash = Self::knowledge_entry_array_hash(&knowledges.knowledge_achievement);
        if knowledge_achievement_hash != knowledges.knowledge_achievement_hash {
            knowledges.knowledge_achievement_hash = knowledge_achievement_hash;
            let mut knowledge = ctx.db.knowledge_achievement_state().entity_id().find(player_entity_id).unwrap().clone();
            knowledge.entries = knowledges.knowledge_achievement.clone();
            ctx.db.knowledge_achievement_state().entity_id().update(knowledge);
        }
        let knowledge_battle_action_hash = Self::knowledge_entry_array_hash(&knowledges.knowledge_battle_action);
        if knowledge_battle_action_hash != knowledges.knowledge_battle_action_hash {
            knowledges.knowledge_battle_action_hash = knowledge_battle_action_hash;
            let mut knowledge = ctx.db.knowledge_battle_action_state().entity_id().find(player_entity_id).unwrap().clone();
            knowledge.entries = knowledges.knowledge_battle_action.clone();
            ctx.db.knowledge_battle_action_state().entity_id().update(knowledge);
        }
        let knowledge_building_hash = Self::knowledge_entry_array_hash(&knowledges.knowledge_building);
        if knowledge_building_hash != knowledges.knowledge_building_hash {
            knowledges.knowledge_building_hash = knowledge_building_hash;
            let mut knowledge = ctx.db.knowledge_building_state().entity_id().find(player_entity_id).unwrap().clone();
            knowledge.entries = knowledges.knowledge_building.clone();
            ctx.db.knowledge_building_state().entity_id().update(knowledge);
        }
        let knowledge_cargo_hash = Self::knowledge_entry_array_hash(&knowledges.knowledge_cargo);
        if knowledge_cargo_hash != knowledges.knowledge_cargo_hash {
            knowledges.knowledge_cargo_hash = knowledge_cargo_hash;
            let mut knowledge = ctx.db.knowledge_cargo_state().entity_id().find(player_entity_id).unwrap().clone();
            knowledge.entries = knowledges.knowledge_cargo.clone();
            ctx.db.knowledge_cargo_state().entity_id().update(knowledge);
        }
        let knowledge_claim_hash = Self::entity_entry_array_hash(&knowledges.knowledge_claim);
        if knowledge_claim_hash != knowledges.knowledge_claim_hash {
            knowledges.knowledge_claim_hash = knowledge_claim_hash;
            let mut knowledge = ctx.db.knowledge_claim_state().entity_id().find(player_entity_id).unwrap().clone();
            knowledge.entries = knowledges.knowledge_claim.clone();
            ctx.db.knowledge_claim_state().entity_id().update(knowledge);
        }
        let knowledge_construction_hash = Self::knowledge_entry_array_hash(&knowledges.knowledge_construction);
        if knowledge_construction_hash != knowledges.knowledge_construction_hash {
            knowledges.knowledge_construction_hash = knowledge_construction_hash;
            let mut knowledge = ctx.db.knowledge_construction_state().entity_id().find(player_entity_id).unwrap().clone();
            knowledge.entries = knowledges.knowledge_construction.clone();
            ctx.db.knowledge_construction_state().entity_id().update(knowledge);
        }
        let knowledge_craft_hash = Self::knowledge_entry_array_hash(&knowledges.knowledge_craft);
        if knowledge_craft_hash != knowledges.knowledge_craft_hash {
            knowledges.knowledge_craft_hash = knowledge_craft_hash;
            let mut knowledge = ctx.db.knowledge_craft_state().entity_id().find(player_entity_id).unwrap().clone();
            knowledge.entries = knowledges.knowledge_craft.clone();
            ctx.db.knowledge_craft_state().entity_id().update(knowledge);
        }
        let knowledge_deployable_hash = Self::knowledge_entry_array_hash(&knowledges.knowledge_deployable);
        if knowledge_deployable_hash != knowledges.knowledge_deployable_hash {
            knowledges.knowledge_deployable_hash = knowledge_deployable_hash;
            let mut knowledge = ctx.db.knowledge_deployable_state().entity_id().find(player_entity_id).unwrap().clone();
            knowledge.entries = knowledges.knowledge_deployable.clone();
            ctx.db.knowledge_deployable_state().entity_id().update(knowledge);
        }
        let knowledge_enemy_hash = Self::knowledge_entry_array_hash(&knowledges.knowledge_enemy);
        if knowledge_enemy_hash != knowledges.knowledge_enemy_hash {
            knowledges.knowledge_enemy_hash = knowledge_enemy_hash;
            let mut knowledge = ctx.db.knowledge_enemy_state().entity_id().find(player_entity_id).unwrap().clone();
            knowledge.entries = knowledges.knowledge_enemy.clone();
            ctx.db.knowledge_enemy_state().entity_id().update(knowledge);
        }
        let knowledge_extract_hash = Self::knowledge_entry_array_hash(&knowledges.knowledge_extract);
        if knowledge_extract_hash != knowledges.knowledge_extract_hash {
            knowledges.knowledge_extract_hash = knowledge_extract_hash;
            let mut knowledge = ctx.db.knowledge_extract_state().entity_id().find(player_entity_id).unwrap().clone();
            knowledge.entries = knowledges.knowledge_extract.clone();
            ctx.db.knowledge_extract_state().entity_id().update(knowledge);
        }
        let knowledge_item_hash = Self::knowledge_entry_array_hash(&knowledges.knowledge_item);
        if knowledge_item_hash != knowledges.knowledge_item_hash {
            knowledges.knowledge_item_hash = knowledge_item_hash;
            let mut knowledge = ctx.db.knowledge_item_state().entity_id().find(player_entity_id).unwrap().clone();
            knowledge.entries = knowledges.knowledge_item.clone();
            ctx.db.knowledge_item_state().entity_id().update(knowledge);
        }
        let knowledge_lore_hash = Self::knowledge_entry_array_hash(&knowledges.knowledge_lore);
        if knowledge_lore_hash != knowledges.knowledge_lore_hash {
            knowledges.knowledge_lore_hash = knowledge_lore_hash;
            let mut knowledge = ctx.db.knowledge_lore_state().entity_id().find(player_entity_id).unwrap().clone();
            knowledge.entries = knowledges.knowledge_lore.clone();
            ctx.db.knowledge_lore_state().entity_id().update(knowledge);
        }
        let knowledge_npc_hash = Self::knowledge_entry_array_hash(&knowledges.knowledge_npc);
        if knowledge_npc_hash != knowledges.knowledge_npc_hash {
            knowledges.knowledge_npc_hash = knowledge_npc_hash;
            let mut knowledge = ctx.db.knowledge_npc_state().entity_id().find(player_entity_id).unwrap().clone();
            knowledge.entries = knowledges.knowledge_npc.clone();
            ctx.db.knowledge_npc_state().entity_id().update(knowledge);
        }
        let knowledge_paving_hash = Self::knowledge_entry_array_hash(&knowledges.knowledge_paving);
        if knowledge_paving_hash != knowledges.knowledge_paving_hash {
            knowledges.knowledge_paving_hash = knowledge_paving_hash;
            let mut knowledge = ctx.db.knowledge_paving_state().entity_id().find(player_entity_id).unwrap().clone();
            knowledge.entries = knowledges.knowledge_paving.clone();
            ctx.db.knowledge_paving_state().entity_id().update(knowledge);
        }
        let knowledge_pillar_shaping_hash = Self::knowledge_entry_array_hash(&knowledges.knowledge_pillar_shaping);
        if knowledge_pillar_shaping_hash != knowledges.knowledge_pillar_shaping_hash {
            knowledges.knowledge_pillar_shaping_hash = knowledge_pillar_shaping_hash;
            let mut knowledge = ctx.db.knowledge_pillar_shaping_state().entity_id().find(player_entity_id).unwrap().clone();
            knowledge.entries = knowledges.knowledge_pillar_shaping.clone();
            ctx.db.knowledge_pillar_shaping_state().entity_id().update(knowledge);
        }
        let knowledge_resource_placement_hash = Self::knowledge_entry_array_hash(&knowledges.knowledge_resource_placement);
        if knowledge_resource_placement_hash != knowledges.knowledge_resource_placement_hash {
            knowledges.knowledge_resource_placement_hash = knowledge_resource_placement_hash;
            let mut knowledge = ctx.db.knowledge_resource_placement_state().entity_id().find(player_entity_id).unwrap().clone();
            knowledge.entries = knowledges.knowledge_resource_placement.clone();
            ctx.db.knowledge_resource_placement_state().entity_id().update(knowledge);
        }
        let knowledge_resource_hash = Self::knowledge_entry_array_hash(&knowledges.knowledge_resource);
        if knowledge_resource_hash != knowledges.knowledge_resource_hash {
            knowledges.knowledge_resource_hash = knowledge_resource_hash;
            let mut knowledge = ctx.db.knowledge_resource_state().entity_id().find(player_entity_id).unwrap().clone();
            knowledge.entries = knowledges.knowledge_resource.clone();
            ctx.db.knowledge_resource_state().entity_id().update(knowledge);
        }
        let knowledge_ruins_hash = Self::location_entry_array_hash(&knowledges.knowledge_ruins);
        if knowledge_ruins_hash != knowledges.knowledge_ruins_hash {
            knowledges.knowledge_ruins_hash = knowledge_ruins_hash;
            let mut knowledge = ctx.db.knowledge_ruins_state().entity_id().find(player_entity_id).unwrap().clone();
            knowledge.entries = knowledges.knowledge_ruins.clone();
            ctx.db.knowledge_ruins_state().entity_id().update(knowledge);
        }
        let knowledge_secondary_hash = Self::knowledge_entry_array_hash(&knowledges.knowledge_secondary);
        if knowledge_secondary_hash != knowledges.knowledge_secondary_hash {
            knowledges.knowledge_secondary_hash = knowledge_secondary_hash;
            let mut knowledge = ctx.db.knowledge_secondary_state().entity_id().find(player_entity_id).unwrap().clone();
            knowledge.entries = knowledges.knowledge_secondary.clone();
            ctx.db.knowledge_secondary_state().entity_id().update(knowledge);
            PlayerState::collect_stats(ctx, self.player_entity_id);
        }
        let knowledge_vault_hash = Self::knowledge_entry_array_hash(&knowledges.knowledge_vault);
        if knowledge_vault_hash != knowledges.knowledge_vault_hash {
            knowledges.knowledge_vault_hash = knowledge_vault_hash;
            let mut knowledge = ctx.db.knowledge_vault_state().entity_id().find(player_entity_id).unwrap().clone();
            knowledge.entries = knowledges.knowledge_vault.clone();
            ctx.db.knowledge_vault_state().entity_id().update(knowledge);
        }
        if self.acquired_achievement {
            self.acquired_achievement = false;
            AchievementDesc::evaluate_all(self.player_entity_id);
        }
    }

    pub fn already_discovered_achievement(ctx: &ReducerContext, player_entity_id: u64, achievement_id: i32) -> bool {
        if let Some(knowledge) = ctx.db.knowledge_achievement_state().entity_id().find(player_entity_id) {
            if let Some(_entry) = knowledge.entries.iter().find(|e| e.id == achievement_id) {
                // acquired or discovered means discovered
                return true;
            }
        }
        false
    }

    pub fn already_acquired_achievement(ctx: &ReducerContext, player_entity_id: u64, achievement_id: i32) -> bool {
        if let Some(knowledge) = ctx.db.knowledge_achievement_state().entity_id().find(player_entity_id) {
            if let Some(entry) = knowledge.entries.iter().find(|e| e.id == achievement_id) {
                // acquired or discovered means discovered
                return entry.state == KnowledgeState::Acquired;
            }
        }
        false
    }

    pub fn has_discovered_achievement(&self, achievement_id: i32) -> bool {
        // This should only be used internally if any change was found in the knowledges, therefore knowledges should yield a value.
        if let Some(knowledges) = &self.knowledges {
            return knowledges.knowledge_achievement.iter().any(|e| e.id == achievement_id);
        }
        false
    }

    pub fn has_acquired_achievement(&self, achievement_id: i32) -> bool {
        // This should only be used internally if any change was found in the knowledges, therefore knowledges should yield a value.
        if let Some(knowledges) = &self.knowledges {
            return knowledges.knowledge_achievement.iter().any(|e| e.id == achievement_id && e.state == KnowledgeState::Acquired);
        }
        false
    }

    pub fn discover_achievement(&mut self, ctx: &ReducerContext, achievement_id: i32) {
       if achievement_id != 0 {
            if self.knowledges.is_none() {
                if Self::already_discovered_achievement(ctx, self.player_entity_id, achievement_id) {
                    return;
                }
                self.initialize(ctx);
            }
            if self.has_discovered_achievement(achievement_id) {
                return;
            }
            let knowledges = self.knowledges.as_mut().unwrap();
            if !knowledges.knowledge_achievement.iter().any(|e| e.id == achievement_id) {
                let knowledge_entry = KnowledgeEntry {
                    id: achievement_id,
                    state: KnowledgeState::Discovered,
                };
                knowledges.knowledge_achievement.push(knowledge_entry);
            };
        }
    }

    pub fn acquire_achievement(&mut self, ctx: &ReducerContext, achievement_id: i32) {
       if achievement_id != 0 {
            if self.knowledges.is_none() {
                if Self::already_acquired_achievement(ctx, self.player_entity_id, achievement_id) {
                    return;
                }
                self.initialize(ctx);
            }
            if self.has_acquired_achievement(achievement_id) {
                return;
            }
            if !self.has_discovered_achievement(achievement_id) {
                self.discover_achievement(ctx, achievement_id);
            }
            let knowledges = self.knowledges.as_mut().unwrap();
            if let Some(entry) = knowledges.knowledge_achievement.iter_mut().find(|e| e.id == achievement_id) {
                entry.state = KnowledgeState::Acquired;
            }
            self.acquired_achievement = true;
        }
    }

    pub fn already_discovered_battle_action(ctx: &ReducerContext, player_entity_id: u64, battle_action_id: i32) -> bool {
        if let Some(knowledge) = ctx.db.knowledge_battle_action_state().entity_id().find(player_entity_id) {
            if let Some(_entry) = knowledge.entries.iter().find(|e| e.id == battle_action_id) {
                // acquired or discovered means discovered
                return true;
            }
        }
        false
    }

    pub fn already_acquired_battle_action(ctx: &ReducerContext, player_entity_id: u64, battle_action_id: i32) -> bool {
        if let Some(knowledge) = ctx.db.knowledge_battle_action_state().entity_id().find(player_entity_id) {
            if let Some(entry) = knowledge.entries.iter().find(|e| e.id == battle_action_id) {
                // acquired or discovered means discovered
                return entry.state == KnowledgeState::Acquired;
            }
        }
        false
    }

    pub fn has_discovered_battle_action(&self, battle_action_id: i32) -> bool {
        // This should only be used internally if any change was found in the knowledges, therefore knowledges should yield a value.
        if let Some(knowledges) = &self.knowledges {
            return knowledges.knowledge_battle_action.iter().any(|e| e.id == battle_action_id);
        }
        false
    }

    pub fn has_acquired_battle_action(&self, battle_action_id: i32) -> bool {
        // This should only be used internally if any change was found in the knowledges, therefore knowledges should yield a value.
        if let Some(knowledges) = &self.knowledges {
            return knowledges.knowledge_battle_action.iter().any(|e| e.id == battle_action_id && e.state == KnowledgeState::Acquired);
        }
        false
    }

    pub fn discover_battle_action(&mut self, ctx: &ReducerContext, battle_action_id: i32) {
       if battle_action_id != 0 {
            if self.knowledges.is_none() {
                if Self::already_discovered_battle_action(ctx, self.player_entity_id, battle_action_id) {
                    return;
                }
                self.initialize(ctx);
            }
            if self.has_discovered_battle_action(battle_action_id) {
                return;
            }
            let knowledges = self.knowledges.as_mut().unwrap();
            if !knowledges.knowledge_battle_action.iter().any(|e| e.id == battle_action_id) {
                let knowledge_entry = KnowledgeEntry {
                    id: battle_action_id,
                    state: KnowledgeState::Discovered,
                };
                knowledges.knowledge_battle_action.push(knowledge_entry);
            };
        }
    }

    pub fn acquire_battle_action(&mut self, ctx: &ReducerContext, battle_action_id: i32) {
       if battle_action_id != 0 {
            if self.knowledges.is_none() {
                if Self::already_acquired_battle_action(ctx, self.player_entity_id, battle_action_id) {
                    return;
                }
                self.initialize(ctx);
            }
            if self.has_acquired_battle_action(battle_action_id) {
                return;
            }
            if !self.has_discovered_battle_action(battle_action_id) {
                self.discover_battle_action(ctx, battle_action_id);
            }
            let knowledges = self.knowledges.as_mut().unwrap();
            if let Some(entry) = knowledges.knowledge_battle_action.iter_mut().find(|e| e.id == battle_action_id) {
                entry.state = KnowledgeState::Acquired;
            }
        }
    }

    pub fn already_discovered_building(ctx: &ReducerContext, player_entity_id: u64, building_id: i32) -> bool {
        if let Some(knowledge) = ctx.db.knowledge_building_state().entity_id().find(player_entity_id) {
            if let Some(_entry) = knowledge.entries.iter().find(|e| e.id == building_id) {
                // acquired or discovered means discovered
                return true;
            }
        }
        false
    }

    pub fn already_acquired_building(ctx: &ReducerContext, player_entity_id: u64, building_id: i32) -> bool {
        if let Some(knowledge) = ctx.db.knowledge_building_state().entity_id().find(player_entity_id) {
            if let Some(entry) = knowledge.entries.iter().find(|e| e.id == building_id) {
                // acquired or discovered means discovered
                return entry.state == KnowledgeState::Acquired;
            }
        }
        false
    }

    pub fn has_discovered_building(&self, building_id: i32) -> bool {
        // This should only be used internally if any change was found in the knowledges, therefore knowledges should yield a value.
        if let Some(knowledges) = &self.knowledges {
            return knowledges.knowledge_building.iter().any(|e| e.id == building_id);
        }
        false
    }

    pub fn has_acquired_building(&self, building_id: i32) -> bool {
        // This should only be used internally if any change was found in the knowledges, therefore knowledges should yield a value.
        if let Some(knowledges) = &self.knowledges {
            return knowledges.knowledge_building.iter().any(|e| e.id == building_id && e.state == KnowledgeState::Acquired);
        }
        false
    }

    pub fn discover_building(&mut self, ctx: &ReducerContext, building_id: i32) {
       if building_id != 0 {
            if self.knowledges.is_none() {
                if Self::already_discovered_building(ctx, self.player_entity_id, building_id) {
                    return;
                }
                self.initialize(ctx);
            }
            if self.has_discovered_building(building_id) {
                return;
            }
            let knowledges = self.knowledges.as_mut().unwrap();
            if !knowledges.knowledge_building.iter().any(|e| e.id == building_id) {
                let knowledge_entry = KnowledgeEntry {
                    id: building_id,
                    state: KnowledgeState::Discovered,
                };
                knowledges.knowledge_building.push(knowledge_entry);
            };
        }
    }

    pub fn acquire_building(&mut self, ctx: &ReducerContext, building_id: i32) {
       if building_id != 0 {
            if self.knowledges.is_none() {
                if Self::already_acquired_building(ctx, self.player_entity_id, building_id) {
                    return;
                }
                self.initialize(ctx);
            }
            if self.has_acquired_building(building_id) {
                return;
            }
            if !self.has_discovered_building(building_id) {
                self.discover_building(ctx, building_id);
            }
            let knowledges = self.knowledges.as_mut().unwrap();
            if let Some(entry) = knowledges.knowledge_building.iter_mut().find(|e| e.id == building_id) {
                entry.state = KnowledgeState::Acquired;
            }
        }
    }

    pub fn already_discovered_cargo(ctx: &ReducerContext, player_entity_id: u64, cargo_id: i32) -> bool {
        if let Some(knowledge) = ctx.db.knowledge_cargo_state().entity_id().find(player_entity_id) {
            if let Some(_entry) = knowledge.entries.iter().find(|e| e.id == cargo_id) {
                // acquired or discovered means discovered
                return true;
            }
        }
        false
    }

    pub fn already_acquired_cargo(ctx: &ReducerContext, player_entity_id: u64, cargo_id: i32) -> bool {
        if let Some(knowledge) = ctx.db.knowledge_cargo_state().entity_id().find(player_entity_id) {
            if let Some(entry) = knowledge.entries.iter().find(|e| e.id == cargo_id) {
                // acquired or discovered means discovered
                return entry.state == KnowledgeState::Acquired;
            }
        }
        false
    }

    pub fn has_discovered_cargo(&self, cargo_id: i32) -> bool {
        // This should only be used internally if any change was found in the knowledges, therefore knowledges should yield a value.
        if let Some(knowledges) = &self.knowledges {
            return knowledges.knowledge_cargo.iter().any(|e| e.id == cargo_id);
        }
        false
    }

    pub fn has_acquired_cargo(&self, cargo_id: i32) -> bool {
        // This should only be used internally if any change was found in the knowledges, therefore knowledges should yield a value.
        if let Some(knowledges) = &self.knowledges {
            return knowledges.knowledge_cargo.iter().any(|e| e.id == cargo_id && e.state == KnowledgeState::Acquired);
        }
        false
    }

    pub fn discover_cargo(&mut self, ctx: &ReducerContext, cargo_id: i32) {
       if cargo_id != 0 {
            if self.knowledges.is_none() {
                if Self::already_discovered_cargo(ctx, self.player_entity_id, cargo_id) {
                    return;
                }
                self.initialize(ctx);
            }
            if self.has_discovered_cargo(cargo_id) {
                return;
            }
            let knowledges = self.knowledges.as_mut().unwrap();
            if !knowledges.knowledge_cargo.iter().any(|e| e.id == cargo_id) {
                let knowledge_entry = KnowledgeEntry {
                    id: cargo_id,
                    state: KnowledgeState::Discovered,
                };
                knowledges.knowledge_cargo.push(knowledge_entry);
            };
        }
    }

    pub fn acquire_cargo(&mut self, ctx: &ReducerContext, cargo_id: i32) {
       if cargo_id != 0 {
            if self.knowledges.is_none() {
                if Self::already_acquired_cargo(ctx, self.player_entity_id, cargo_id) {
                    return;
                }
                self.initialize(ctx);
            }
            if self.has_acquired_cargo(cargo_id) {
                return;
            }
            if !self.has_discovered_cargo(cargo_id) {
                self.discover_cargo(ctx, cargo_id);
            }
            let knowledges = self.knowledges.as_mut().unwrap();
            if let Some(entry) = knowledges.knowledge_cargo.iter_mut().find(|e| e.id == cargo_id) {
                entry.state = KnowledgeState::Acquired;
            }
            self.on_cargo_acquired(ctx, cargo_id);
            self.acquired_achievement = true;
        }
    }

    pub fn already_discovered_claim(ctx: &ReducerContext, player_entity_id: u64, claim_entity_id: u64) -> bool {
        if let Some(knowledge) = ctx.db.knowledge_claim_state().entity_id().find(player_entity_id) {
            if let Some(_entry) = knowledge.entries.iter().find(|e| e.entity_id == claim_entity_id) {
                // acquired or discovered means discovered
                return true;
            }
        }
        false
    }

    pub fn already_acquired_claim(ctx: &ReducerContext, player_entity_id: u64, claim_entity_id: u64) -> bool {
        if let Some(knowledge) = ctx.db.knowledge_claim_state().entity_id().find(player_entity_id) {
            if let Some(entry) = knowledge.entries.iter().find(|e| e.entity_id == claim_entity_id) {
                // acquired or discovered means discovered
                return entry.state == KnowledgeState::Acquired;
            }
        }
        false
    }

    pub fn has_discovered_claim(&self, claim_entity_id: u64) -> bool {
        // This should only be used internally if any change was found in the knowledges, therefore knowledges should yield a value.
        if let Some(knowledges) = &self.knowledges {
            return knowledges.knowledge_claim.iter().any(|e| e.entity_id == claim_entity_id);
        }
        false
    }

    pub fn has_acquired_claim(&self, claim_entity_id: u64) -> bool {
        // This should only be used internally if any change was found in the knowledges, therefore knowledges should yield a value.
        if let Some(knowledges) = &self.knowledges {
            return knowledges.knowledge_claim.iter().any(|e| e.entity_id == claim_entity_id && e.state == KnowledgeState::Acquired);
        }
        false
    }

    pub fn discover_claim(&mut self, ctx: &ReducerContext, claim_entity_id: u64) {
       if claim_entity_id != 0 {
            if self.knowledges.is_none() {
                if Self::already_discovered_claim(ctx, self.player_entity_id, claim_entity_id) {
                    return;
                }
                self.initialize(ctx);
            }
            if self.has_discovered_claim(claim_entity_id) {
                return;
            }
            let knowledges = self.knowledges.as_mut().unwrap();
            if !knowledges.knowledge_claim.iter().any(|e| e.entity_id == claim_entity_id) {
                let knowledge_entry = KnowledgeEntityEntry {
                    entity_id: claim_entity_id,
                    state: KnowledgeState::Discovered,
                };
                knowledges.knowledge_claim.push(knowledge_entry);
            };
        }
    }

    pub fn acquire_claim(&mut self, ctx: &ReducerContext, claim_entity_id: u64) {
       if claim_entity_id != 0 {
            if self.knowledges.is_none() {
                if Self::already_acquired_claim(ctx, self.player_entity_id, claim_entity_id) {
                    return;
                }
                self.initialize(ctx);
            }
            if self.has_acquired_claim(claim_entity_id) {
                return;
            }
            if !self.has_discovered_claim(claim_entity_id) {
                self.discover_claim(ctx, claim_entity_id);
            }
            let knowledges = self.knowledges.as_mut().unwrap();
            if let Some(entry) = knowledges.knowledge_claim.iter_mut().find(|e| e.entity_id == claim_entity_id) {
                entry.state = KnowledgeState::Acquired;
            }
        }
    }

    pub fn already_discovered_construction(ctx: &ReducerContext, player_entity_id: u64, construction_id: i32) -> bool {
        if let Some(knowledge) = ctx.db.knowledge_construction_state().entity_id().find(player_entity_id) {
            if let Some(_entry) = knowledge.entries.iter().find(|e| e.id == construction_id) {
                // acquired or discovered means discovered
                return true;
            }
        }
        false
    }

    pub fn already_acquired_construction(ctx: &ReducerContext, player_entity_id: u64, construction_id: i32) -> bool {
        if let Some(knowledge) = ctx.db.knowledge_construction_state().entity_id().find(player_entity_id) {
            if let Some(entry) = knowledge.entries.iter().find(|e| e.id == construction_id) {
                // acquired or discovered means discovered
                return entry.state == KnowledgeState::Acquired;
            }
        }
        false
    }

    pub fn has_discovered_construction(&self, construction_id: i32) -> bool {
        // This should only be used internally if any change was found in the knowledges, therefore knowledges should yield a value.
        if let Some(knowledges) = &self.knowledges {
            return knowledges.knowledge_construction.iter().any(|e| e.id == construction_id);
        }
        false
    }

    pub fn has_acquired_construction(&self, construction_id: i32) -> bool {
        // This should only be used internally if any change was found in the knowledges, therefore knowledges should yield a value.
        if let Some(knowledges) = &self.knowledges {
            return knowledges.knowledge_construction.iter().any(|e| e.id == construction_id && e.state == KnowledgeState::Acquired);
        }
        false
    }

    pub fn discover_construction(&mut self, ctx: &ReducerContext, construction_id: i32) {
       if construction_id != 0 {
            if self.knowledges.is_none() {
                if Self::already_discovered_construction(ctx, self.player_entity_id, construction_id) {
                    return;
                }
                self.initialize(ctx);
            }
            if self.has_discovered_construction(construction_id) {
                return;
            }
            let knowledges = self.knowledges.as_mut().unwrap();
            if !knowledges.knowledge_construction.iter().any(|e| e.id == construction_id) {
                let knowledge_entry = KnowledgeEntry {
                    id: construction_id,
                    state: KnowledgeState::Discovered,
                };
                knowledges.knowledge_construction.push(knowledge_entry);
                self.discover_construction_recipe_components(ctx, construction_id);
            };
        }
    }

    pub fn acquire_construction(&mut self, ctx: &ReducerContext, construction_id: i32) {
       if construction_id != 0 {
            if self.knowledges.is_none() {
                if Self::already_acquired_construction(ctx, self.player_entity_id, construction_id) {
                    return;
                }
                self.initialize(ctx);
            }
            if self.has_acquired_construction(construction_id) {
                return;
            }
            if !self.has_discovered_construction(construction_id) {
                self.discover_construction(ctx, construction_id);
            }
            let knowledges = self.knowledges.as_mut().unwrap();
            if let Some(entry) = knowledges.knowledge_construction.iter_mut().find(|e| e.id == construction_id) {
                entry.state = KnowledgeState::Acquired;
            }
        }
    }

    pub fn already_discovered_craft(ctx: &ReducerContext, player_entity_id: u64, craft_id: i32) -> bool {
        if let Some(knowledge) = ctx.db.knowledge_craft_state().entity_id().find(player_entity_id) {
            if let Some(_entry) = knowledge.entries.iter().find(|e| e.id == craft_id) {
                // acquired or discovered means discovered
                return true;
            }
        }
        false
    }

    pub fn already_acquired_craft(ctx: &ReducerContext, player_entity_id: u64, craft_id: i32) -> bool {
        if let Some(knowledge) = ctx.db.knowledge_craft_state().entity_id().find(player_entity_id) {
            if let Some(entry) = knowledge.entries.iter().find(|e| e.id == craft_id) {
                // acquired or discovered means discovered
                return entry.state == KnowledgeState::Acquired;
            }
        }
        false
    }

    pub fn has_discovered_craft(&self, craft_id: i32) -> bool {
        // This should only be used internally if any change was found in the knowledges, therefore knowledges should yield a value.
        if let Some(knowledges) = &self.knowledges {
            return knowledges.knowledge_craft.iter().any(|e| e.id == craft_id);
        }
        false
    }

    pub fn has_acquired_craft(&self, craft_id: i32) -> bool {
        // This should only be used internally if any change was found in the knowledges, therefore knowledges should yield a value.
        if let Some(knowledges) = &self.knowledges {
            return knowledges.knowledge_craft.iter().any(|e| e.id == craft_id && e.state == KnowledgeState::Acquired);
        }
        false
    }

    pub fn discover_craft(&mut self, ctx: &ReducerContext, craft_id: i32) {
       if craft_id != 0 {
            if self.knowledges.is_none() {
                if Self::already_discovered_craft(ctx, self.player_entity_id, craft_id) {
                    return;
                }
                self.initialize(ctx);
            }
            if self.has_discovered_craft(craft_id) {
                return;
            }
            let knowledges = self.knowledges.as_mut().unwrap();
            if !knowledges.knowledge_craft.iter().any(|e| e.id == craft_id) {
                let knowledge_entry = KnowledgeEntry {
                    id: craft_id,
                    state: KnowledgeState::Discovered,
                };
                knowledges.knowledge_craft.push(knowledge_entry);
                self.discover_craft_recipe_components(ctx, craft_id);
            };
        }
    }

    pub fn acquire_craft(&mut self, ctx: &ReducerContext, craft_id: i32) {
       if craft_id != 0 {
            if self.knowledges.is_none() {
                if Self::already_acquired_craft(ctx, self.player_entity_id, craft_id) {
                    return;
                }
                self.initialize(ctx);
            }
            if self.has_acquired_craft(craft_id) {
                return;
            }
            if !self.has_discovered_craft(craft_id) {
                self.discover_craft(ctx, craft_id);
            }
            let knowledges = self.knowledges.as_mut().unwrap();
            if let Some(entry) = knowledges.knowledge_craft.iter_mut().find(|e| e.id == craft_id) {
                entry.state = KnowledgeState::Acquired;
            }
            self.acquired_achievement = true;
        }
    }

    pub fn already_discovered_deployable(ctx: &ReducerContext, player_entity_id: u64, deployable_id: i32) -> bool {
        if let Some(knowledge) = ctx.db.knowledge_deployable_state().entity_id().find(player_entity_id) {
            if let Some(_entry) = knowledge.entries.iter().find(|e| e.id == deployable_id) {
                // acquired or discovered means discovered
                return true;
            }
        }
        false
    }

    pub fn already_acquired_deployable(ctx: &ReducerContext, player_entity_id: u64, deployable_id: i32) -> bool {
        if let Some(knowledge) = ctx.db.knowledge_deployable_state().entity_id().find(player_entity_id) {
            if let Some(entry) = knowledge.entries.iter().find(|e| e.id == deployable_id) {
                // acquired or discovered means discovered
                return entry.state == KnowledgeState::Acquired;
            }
        }
        false
    }

    pub fn has_discovered_deployable(&self, deployable_id: i32) -> bool {
        // This should only be used internally if any change was found in the knowledges, therefore knowledges should yield a value.
        if let Some(knowledges) = &self.knowledges {
            return knowledges.knowledge_deployable.iter().any(|e| e.id == deployable_id);
        }
        false
    }

    pub fn has_acquired_deployable(&self, deployable_id: i32) -> bool {
        // This should only be used internally if any change was found in the knowledges, therefore knowledges should yield a value.
        if let Some(knowledges) = &self.knowledges {
            return knowledges.knowledge_deployable.iter().any(|e| e.id == deployable_id && e.state == KnowledgeState::Acquired);
        }
        false
    }

    pub fn discover_deployable(&mut self, ctx: &ReducerContext, deployable_id: i32) {
       if deployable_id != 0 {
            if self.knowledges.is_none() {
                if Self::already_discovered_deployable(ctx, self.player_entity_id, deployable_id) {
                    return;
                }
                self.initialize(ctx);
            }
            if self.has_discovered_deployable(deployable_id) {
                return;
            }
            let knowledges = self.knowledges.as_mut().unwrap();
            if !knowledges.knowledge_deployable.iter().any(|e| e.id == deployable_id) {
                let knowledge_entry = KnowledgeEntry {
                    id: deployable_id,
                    state: KnowledgeState::Discovered,
                };
                knowledges.knowledge_deployable.push(knowledge_entry);
            };
        }
    }

    pub fn acquire_deployable(&mut self, ctx: &ReducerContext, deployable_id: i32) {
       if deployable_id != 0 {
            if self.knowledges.is_none() {
                if Self::already_acquired_deployable(ctx, self.player_entity_id, deployable_id) {
                    return;
                }
                self.initialize(ctx);
            }
            if self.has_acquired_deployable(deployable_id) {
                return;
            }
            if !self.has_discovered_deployable(deployable_id) {
                self.discover_deployable(ctx, deployable_id);
            }
            let knowledges = self.knowledges.as_mut().unwrap();
            if let Some(entry) = knowledges.knowledge_deployable.iter_mut().find(|e| e.id == deployable_id) {
                entry.state = KnowledgeState::Acquired;
            }
        }
    }

    pub fn already_discovered_enemy(ctx: &ReducerContext, player_entity_id: u64, enemy_id: i32) -> bool {
        if let Some(knowledge) = ctx.db.knowledge_enemy_state().entity_id().find(player_entity_id) {
            if let Some(_entry) = knowledge.entries.iter().find(|e| e.id == enemy_id) {
                // acquired or discovered means discovered
                return true;
            }
        }
        false
    }

    pub fn already_acquired_enemy(ctx: &ReducerContext, player_entity_id: u64, enemy_id: i32) -> bool {
        if let Some(knowledge) = ctx.db.knowledge_enemy_state().entity_id().find(player_entity_id) {
            if let Some(entry) = knowledge.entries.iter().find(|e| e.id == enemy_id) {
                // acquired or discovered means discovered
                return entry.state == KnowledgeState::Acquired;
            }
        }
        false
    }

    pub fn has_discovered_enemy(&self, enemy_id: i32) -> bool {
        // This should only be used internally if any change was found in the knowledges, therefore knowledges should yield a value.
        if let Some(knowledges) = &self.knowledges {
            return knowledges.knowledge_enemy.iter().any(|e| e.id == enemy_id);
        }
        false
    }

    pub fn has_acquired_enemy(&self, enemy_id: i32) -> bool {
        // This should only be used internally if any change was found in the knowledges, therefore knowledges should yield a value.
        if let Some(knowledges) = &self.knowledges {
            return knowledges.knowledge_enemy.iter().any(|e| e.id == enemy_id && e.state == KnowledgeState::Acquired);
        }
        false
    }

    pub fn discover_enemy(&mut self, ctx: &ReducerContext, enemy_id: i32) {
       if enemy_id != 0 {
            if self.knowledges.is_none() {
                if Self::already_discovered_enemy(ctx, self.player_entity_id, enemy_id) {
                    return;
                }
                self.initialize(ctx);
            }
            if self.has_discovered_enemy(enemy_id) {
                return;
            }
            let knowledges = self.knowledges.as_mut().unwrap();
            if !knowledges.knowledge_enemy.iter().any(|e| e.id == enemy_id) {
                let knowledge_entry = KnowledgeEntry {
                    id: enemy_id,
                    state: KnowledgeState::Discovered,
                };
                knowledges.knowledge_enemy.push(knowledge_entry);
            };
        }
    }

    pub fn acquire_enemy(&mut self, ctx: &ReducerContext, enemy_id: i32) {
       if enemy_id != 0 {
            if self.knowledges.is_none() {
                if Self::already_acquired_enemy(ctx, self.player_entity_id, enemy_id) {
                    return;
                }
                self.initialize(ctx);
            }
            if self.has_acquired_enemy(enemy_id) {
                return;
            }
            if !self.has_discovered_enemy(enemy_id) {
                self.discover_enemy(ctx, enemy_id);
            }
            let knowledges = self.knowledges.as_mut().unwrap();
            if let Some(entry) = knowledges.knowledge_enemy.iter_mut().find(|e| e.id == enemy_id) {
                entry.state = KnowledgeState::Acquired;
            }
        }
    }

    pub fn already_discovered_extract(ctx: &ReducerContext, player_entity_id: u64, extract_id: i32) -> bool {
        if let Some(knowledge) = ctx.db.knowledge_extract_state().entity_id().find(player_entity_id) {
            if let Some(_entry) = knowledge.entries.iter().find(|e| e.id == extract_id) {
                // acquired or discovered means discovered
                return true;
            }
        }
        false
    }

    pub fn already_acquired_extract(ctx: &ReducerContext, player_entity_id: u64, extract_id: i32) -> bool {
        if let Some(knowledge) = ctx.db.knowledge_extract_state().entity_id().find(player_entity_id) {
            if let Some(entry) = knowledge.entries.iter().find(|e| e.id == extract_id) {
                // acquired or discovered means discovered
                return entry.state == KnowledgeState::Acquired;
            }
        }
        false
    }

    pub fn has_discovered_extract(&self, extract_id: i32) -> bool {
        // This should only be used internally if any change was found in the knowledges, therefore knowledges should yield a value.
        if let Some(knowledges) = &self.knowledges {
            return knowledges.knowledge_extract.iter().any(|e| e.id == extract_id);
        }
        false
    }

    pub fn has_acquired_extract(&self, extract_id: i32) -> bool {
        // This should only be used internally if any change was found in the knowledges, therefore knowledges should yield a value.
        if let Some(knowledges) = &self.knowledges {
            return knowledges.knowledge_extract.iter().any(|e| e.id == extract_id && e.state == KnowledgeState::Acquired);
        }
        false
    }

    pub fn discover_extract(&mut self, ctx: &ReducerContext, extract_id: i32) {
       if extract_id != 0 {
            if self.knowledges.is_none() {
                if Self::already_discovered_extract(ctx, self.player_entity_id, extract_id) {
                    return;
                }
                self.initialize(ctx);
            }
            if self.has_discovered_extract(extract_id) {
                return;
            }
            let knowledges = self.knowledges.as_mut().unwrap();
            if !knowledges.knowledge_extract.iter().any(|e| e.id == extract_id) {
                let knowledge_entry = KnowledgeEntry {
                    id: extract_id,
                    state: KnowledgeState::Discovered,
                };
                knowledges.knowledge_extract.push(knowledge_entry);
                self.discover_extract_recipe_components(ctx, extract_id);
            };
        }
    }

    pub fn acquire_extract(&mut self, ctx: &ReducerContext, extract_id: i32) {
       if extract_id != 0 {
            if self.knowledges.is_none() {
                if Self::already_acquired_extract(ctx, self.player_entity_id, extract_id) {
                    return;
                }
                self.initialize(ctx);
            }
            if self.has_acquired_extract(extract_id) {
                return;
            }
            if !self.has_discovered_extract(extract_id) {
                self.discover_extract(ctx, extract_id);
            }
            let knowledges = self.knowledges.as_mut().unwrap();
            if let Some(entry) = knowledges.knowledge_extract.iter_mut().find(|e| e.id == extract_id) {
                entry.state = KnowledgeState::Acquired;
            }
        }
    }

    pub fn already_discovered_item(ctx: &ReducerContext, player_entity_id: u64, item_id: i32) -> bool {
        if let Some(knowledge) = ctx.db.knowledge_item_state().entity_id().find(player_entity_id) {
            if let Some(_entry) = knowledge.entries.iter().find(|e| e.id == item_id) {
                // acquired or discovered means discovered
                return true;
            }
        }
        false
    }

    pub fn already_acquired_item(ctx: &ReducerContext, player_entity_id: u64, item_id: i32) -> bool {
        if let Some(knowledge) = ctx.db.knowledge_item_state().entity_id().find(player_entity_id) {
            if let Some(entry) = knowledge.entries.iter().find(|e| e.id == item_id) {
                // acquired or discovered means discovered
                return entry.state == KnowledgeState::Acquired;
            }
        }
        false
    }

    pub fn has_discovered_item(&self, item_id: i32) -> bool {
        // This should only be used internally if any change was found in the knowledges, therefore knowledges should yield a value.
        if let Some(knowledges) = &self.knowledges {
            return knowledges.knowledge_item.iter().any(|e| e.id == item_id);
        }
        false
    }

    pub fn has_acquired_item(&self, item_id: i32) -> bool {
        // This should only be used internally if any change was found in the knowledges, therefore knowledges should yield a value.
        if let Some(knowledges) = &self.knowledges {
            return knowledges.knowledge_item.iter().any(|e| e.id == item_id && e.state == KnowledgeState::Acquired);
        }
        false
    }

    pub fn discover_item(&mut self, ctx: &ReducerContext, item_id: i32) {
       if item_id != 0 {
            if self.knowledges.is_none() {
                if Self::already_discovered_item(ctx, self.player_entity_id, item_id) {
                    return;
                }
                self.initialize(ctx);
            }
            if self.has_discovered_item(item_id) {
                return;
            }
            let knowledges = self.knowledges.as_mut().unwrap();
            if !knowledges.knowledge_item.iter().any(|e| e.id == item_id) {
                let knowledge_entry = KnowledgeEntry {
                    id: item_id,
                    state: KnowledgeState::Discovered,
                };
                knowledges.knowledge_item.push(knowledge_entry);
            };
        }
    }

    pub fn acquire_item(&mut self, ctx: &ReducerContext, item_id: i32) {
       if item_id != 0 {
            if self.knowledges.is_none() {
                if Self::already_acquired_item(ctx, self.player_entity_id, item_id) {
                    return;
                }
                self.initialize(ctx);
            }
            if self.has_acquired_item(item_id) {
                return;
            }
            if !self.has_discovered_item(item_id) {
                self.discover_item(ctx, item_id);
            }
            let knowledges = self.knowledges.as_mut().unwrap();
            if let Some(entry) = knowledges.knowledge_item.iter_mut().find(|e| e.id == item_id) {
                entry.state = KnowledgeState::Acquired;
            }
            self.on_item_acquired(ctx, item_id);
            self.acquired_achievement = true;
        }
    }

    pub fn already_discovered_lore(ctx: &ReducerContext, player_entity_id: u64, lore_id: i32) -> bool {
        if let Some(knowledge) = ctx.db.knowledge_lore_state().entity_id().find(player_entity_id) {
            if let Some(_entry) = knowledge.entries.iter().find(|e| e.id == lore_id) {
                // acquired or discovered means discovered
                return true;
            }
        }
        false
    }

    pub fn already_acquired_lore(ctx: &ReducerContext, player_entity_id: u64, lore_id: i32) -> bool {
        if let Some(knowledge) = ctx.db.knowledge_lore_state().entity_id().find(player_entity_id) {
            if let Some(entry) = knowledge.entries.iter().find(|e| e.id == lore_id) {
                // acquired or discovered means discovered
                return entry.state == KnowledgeState::Acquired;
            }
        }
        false
    }

    pub fn has_discovered_lore(&self, lore_id: i32) -> bool {
        // This should only be used internally if any change was found in the knowledges, therefore knowledges should yield a value.
        if let Some(knowledges) = &self.knowledges {
            return knowledges.knowledge_lore.iter().any(|e| e.id == lore_id);
        }
        false
    }

    pub fn has_acquired_lore(&self, lore_id: i32) -> bool {
        // This should only be used internally if any change was found in the knowledges, therefore knowledges should yield a value.
        if let Some(knowledges) = &self.knowledges {
            return knowledges.knowledge_lore.iter().any(|e| e.id == lore_id && e.state == KnowledgeState::Acquired);
        }
        false
    }

    pub fn discover_lore(&mut self, ctx: &ReducerContext, lore_id: i32) {
       if lore_id != 0 {
            if self.knowledges.is_none() {
                if Self::already_discovered_lore(ctx, self.player_entity_id, lore_id) {
                    return;
                }
                self.initialize(ctx);
            }
            if self.has_discovered_lore(lore_id) {
                return;
            }
            let knowledges = self.knowledges.as_mut().unwrap();
            if !knowledges.knowledge_lore.iter().any(|e| e.id == lore_id) {
                let knowledge_entry = KnowledgeEntry {
                    id: lore_id,
                    state: KnowledgeState::Discovered,
                };
                knowledges.knowledge_lore.push(knowledge_entry);
            };
        }
    }

    pub fn acquire_lore(&mut self, ctx: &ReducerContext, lore_id: i32) {
       if lore_id != 0 {
            if self.knowledges.is_none() {
                if Self::already_acquired_lore(ctx, self.player_entity_id, lore_id) {
                    return;
                }
                self.initialize(ctx);
            }
            if self.has_acquired_lore(lore_id) {
                return;
            }
            if !self.has_discovered_lore(lore_id) {
                self.discover_lore(ctx, lore_id);
            }
            let knowledges = self.knowledges.as_mut().unwrap();
            if let Some(entry) = knowledges.knowledge_lore.iter_mut().find(|e| e.id == lore_id) {
                entry.state = KnowledgeState::Acquired;
            }
        }
    }

    pub fn already_discovered_npc(ctx: &ReducerContext, player_entity_id: u64, npc_id: i32) -> bool {
        if let Some(knowledge) = ctx.db.knowledge_npc_state().entity_id().find(player_entity_id) {
            if let Some(_entry) = knowledge.entries.iter().find(|e| e.id == npc_id) {
                // acquired or discovered means discovered
                return true;
            }
        }
        false
    }

    pub fn already_acquired_npc(ctx: &ReducerContext, player_entity_id: u64, npc_id: i32) -> bool {
        if let Some(knowledge) = ctx.db.knowledge_npc_state().entity_id().find(player_entity_id) {
            if let Some(entry) = knowledge.entries.iter().find(|e| e.id == npc_id) {
                // acquired or discovered means discovered
                return entry.state == KnowledgeState::Acquired;
            }
        }
        false
    }

    pub fn has_discovered_npc(&self, npc_id: i32) -> bool {
        // This should only be used internally if any change was found in the knowledges, therefore knowledges should yield a value.
        if let Some(knowledges) = &self.knowledges {
            return knowledges.knowledge_npc.iter().any(|e| e.id == npc_id);
        }
        false
    }

    pub fn has_acquired_npc(&self, npc_id: i32) -> bool {
        // This should only be used internally if any change was found in the knowledges, therefore knowledges should yield a value.
        if let Some(knowledges) = &self.knowledges {
            return knowledges.knowledge_npc.iter().any(|e| e.id == npc_id && e.state == KnowledgeState::Acquired);
        }
        false
    }

    pub fn discover_npc(&mut self, ctx: &ReducerContext, npc_id: i32) {
       if npc_id != 0 {
            if self.knowledges.is_none() {
                if Self::already_discovered_npc(ctx, self.player_entity_id, npc_id) {
                    return;
                }
                self.initialize(ctx);
            }
            if self.has_discovered_npc(npc_id) {
                return;
            }
            let knowledges = self.knowledges.as_mut().unwrap();
            if !knowledges.knowledge_npc.iter().any(|e| e.id == npc_id) {
                let knowledge_entry = KnowledgeEntry {
                    id: npc_id,
                    state: KnowledgeState::Discovered,
                };
                knowledges.knowledge_npc.push(knowledge_entry);
            };
        }
    }

    pub fn acquire_npc(&mut self, ctx: &ReducerContext, npc_id: i32) {
       if npc_id != 0 {
            if self.knowledges.is_none() {
                if Self::already_acquired_npc(ctx, self.player_entity_id, npc_id) {
                    return;
                }
                self.initialize(ctx);
            }
            if self.has_acquired_npc(npc_id) {
                return;
            }
            if !self.has_discovered_npc(npc_id) {
                self.discover_npc(ctx, npc_id);
            }
            let knowledges = self.knowledges.as_mut().unwrap();
            if let Some(entry) = knowledges.knowledge_npc.iter_mut().find(|e| e.id == npc_id) {
                entry.state = KnowledgeState::Acquired;
            }
        }
    }

    pub fn already_discovered_paving(ctx: &ReducerContext, player_entity_id: u64, paving_id: i32) -> bool {
        if let Some(knowledge) = ctx.db.knowledge_paving_state().entity_id().find(player_entity_id) {
            if let Some(_entry) = knowledge.entries.iter().find(|e| e.id == paving_id) {
                // acquired or discovered means discovered
                return true;
            }
        }
        false
    }

    pub fn already_acquired_paving(ctx: &ReducerContext, player_entity_id: u64, paving_id: i32) -> bool {
        if let Some(knowledge) = ctx.db.knowledge_paving_state().entity_id().find(player_entity_id) {
            if let Some(entry) = knowledge.entries.iter().find(|e| e.id == paving_id) {
                // acquired or discovered means discovered
                return entry.state == KnowledgeState::Acquired;
            }
        }
        false
    }

    pub fn has_discovered_paving(&self, paving_id: i32) -> bool {
        // This should only be used internally if any change was found in the knowledges, therefore knowledges should yield a value.
        if let Some(knowledges) = &self.knowledges {
            return knowledges.knowledge_paving.iter().any(|e| e.id == paving_id);
        }
        false
    }

    pub fn has_acquired_paving(&self, paving_id: i32) -> bool {
        // This should only be used internally if any change was found in the knowledges, therefore knowledges should yield a value.
        if let Some(knowledges) = &self.knowledges {
            return knowledges.knowledge_paving.iter().any(|e| e.id == paving_id && e.state == KnowledgeState::Acquired);
        }
        false
    }

    pub fn discover_paving(&mut self, ctx: &ReducerContext, paving_id: i32) {
       if paving_id != 0 {
            if self.knowledges.is_none() {
                if Self::already_discovered_paving(ctx, self.player_entity_id, paving_id) {
                    return;
                }
                self.initialize(ctx);
            }
            if self.has_discovered_paving(paving_id) {
                return;
            }
            let knowledges = self.knowledges.as_mut().unwrap();
            if !knowledges.knowledge_paving.iter().any(|e| e.id == paving_id) {
                let knowledge_entry = KnowledgeEntry {
                    id: paving_id,
                    state: KnowledgeState::Discovered,
                };
                knowledges.knowledge_paving.push(knowledge_entry);
                self.discover_paving_recipe_components(ctx, paving_id);
            };
        }
    }

    pub fn acquire_paving(&mut self, ctx: &ReducerContext, paving_id: i32) {
       if paving_id != 0 {
            if self.knowledges.is_none() {
                if Self::already_acquired_paving(ctx, self.player_entity_id, paving_id) {
                    return;
                }
                self.initialize(ctx);
            }
            if self.has_acquired_paving(paving_id) {
                return;
            }
            if !self.has_discovered_paving(paving_id) {
                self.discover_paving(ctx, paving_id);
            }
            let knowledges = self.knowledges.as_mut().unwrap();
            if let Some(entry) = knowledges.knowledge_paving.iter_mut().find(|e| e.id == paving_id) {
                entry.state = KnowledgeState::Acquired;
            }
        }
    }

    pub fn already_discovered_pillar_shaping(ctx: &ReducerContext, player_entity_id: u64, pillar_shaping_id: i32) -> bool {
        if let Some(knowledge) = ctx.db.knowledge_pillar_shaping_state().entity_id().find(player_entity_id) {
            if let Some(_entry) = knowledge.entries.iter().find(|e| e.id == pillar_shaping_id) {
                // acquired or discovered means discovered
                return true;
            }
        }
        false
    }

    pub fn already_acquired_pillar_shaping(ctx: &ReducerContext, player_entity_id: u64, pillar_shaping_id: i32) -> bool {
        if let Some(knowledge) = ctx.db.knowledge_pillar_shaping_state().entity_id().find(player_entity_id) {
            if let Some(entry) = knowledge.entries.iter().find(|e| e.id == pillar_shaping_id) {
                // acquired or discovered means discovered
                return entry.state == KnowledgeState::Acquired;
            }
        }
        false
    }

    pub fn has_discovered_pillar_shaping(&self, pillar_shaping_id: i32) -> bool {
        // This should only be used internally if any change was found in the knowledges, therefore knowledges should yield a value.
        if let Some(knowledges) = &self.knowledges {
            return knowledges.knowledge_pillar_shaping.iter().any(|e| e.id == pillar_shaping_id);
        }
        false
    }

    pub fn has_acquired_pillar_shaping(&self, pillar_shaping_id: i32) -> bool {
        // This should only be used internally if any change was found in the knowledges, therefore knowledges should yield a value.
        if let Some(knowledges) = &self.knowledges {
            return knowledges.knowledge_pillar_shaping.iter().any(|e| e.id == pillar_shaping_id && e.state == KnowledgeState::Acquired);
        }
        false
    }

    pub fn discover_pillar_shaping(&mut self, ctx: &ReducerContext, pillar_shaping_id: i32) {
       if pillar_shaping_id != 0 {
            if self.knowledges.is_none() {
                if Self::already_discovered_pillar_shaping(ctx, self.player_entity_id, pillar_shaping_id) {
                    return;
                }
                self.initialize(ctx);
            }
            if self.has_discovered_pillar_shaping(pillar_shaping_id) {
                return;
            }
            let knowledges = self.knowledges.as_mut().unwrap();
            if !knowledges.knowledge_pillar_shaping.iter().any(|e| e.id == pillar_shaping_id) {
                let knowledge_entry = KnowledgeEntry {
                    id: pillar_shaping_id,
                    state: KnowledgeState::Discovered,
                };
                knowledges.knowledge_pillar_shaping.push(knowledge_entry);
                self.discover_pillar_shaping_recipe_components(ctx, pillar_shaping_id);
            };
        }
    }

    pub fn acquire_pillar_shaping(&mut self, ctx: &ReducerContext, pillar_shaping_id: i32) {
       if pillar_shaping_id != 0 {
            if self.knowledges.is_none() {
                if Self::already_acquired_pillar_shaping(ctx, self.player_entity_id, pillar_shaping_id) {
                    return;
                }
                self.initialize(ctx);
            }
            if self.has_acquired_pillar_shaping(pillar_shaping_id) {
                return;
            }
            if !self.has_discovered_pillar_shaping(pillar_shaping_id) {
                self.discover_pillar_shaping(ctx, pillar_shaping_id);
            }
            let knowledges = self.knowledges.as_mut().unwrap();
            if let Some(entry) = knowledges.knowledge_pillar_shaping.iter_mut().find(|e| e.id == pillar_shaping_id) {
                entry.state = KnowledgeState::Acquired;
            }
        }
    }

    pub fn already_discovered_resource_placement(ctx: &ReducerContext, player_entity_id: u64, resource_placement_id: i32) -> bool {
        if let Some(knowledge) = ctx.db.knowledge_resource_placement_state().entity_id().find(player_entity_id) {
            if let Some(_entry) = knowledge.entries.iter().find(|e| e.id == resource_placement_id) {
                // acquired or discovered means discovered
                return true;
            }
        }
        false
    }

    pub fn already_acquired_resource_placement(ctx: &ReducerContext, player_entity_id: u64, resource_placement_id: i32) -> bool {
        if let Some(knowledge) = ctx.db.knowledge_resource_placement_state().entity_id().find(player_entity_id) {
            if let Some(entry) = knowledge.entries.iter().find(|e| e.id == resource_placement_id) {
                // acquired or discovered means discovered
                return entry.state == KnowledgeState::Acquired;
            }
        }
        false
    }

    pub fn has_discovered_resource_placement(&self, resource_placement_id: i32) -> bool {
        // This should only be used internally if any change was found in the knowledges, therefore knowledges should yield a value.
        if let Some(knowledges) = &self.knowledges {
            return knowledges.knowledge_resource_placement.iter().any(|e| e.id == resource_placement_id);
        }
        false
    }

    pub fn has_acquired_resource_placement(&self, resource_placement_id: i32) -> bool {
        // This should only be used internally if any change was found in the knowledges, therefore knowledges should yield a value.
        if let Some(knowledges) = &self.knowledges {
            return knowledges.knowledge_resource_placement.iter().any(|e| e.id == resource_placement_id && e.state == KnowledgeState::Acquired);
        }
        false
    }

    pub fn discover_resource_placement(&mut self, ctx: &ReducerContext, resource_placement_id: i32) {
       if resource_placement_id != 0 {
            if self.knowledges.is_none() {
                if Self::already_discovered_resource_placement(ctx, self.player_entity_id, resource_placement_id) {
                    return;
                }
                self.initialize(ctx);
            }
            if self.has_discovered_resource_placement(resource_placement_id) {
                return;
            }
            let knowledges = self.knowledges.as_mut().unwrap();
            if !knowledges.knowledge_resource_placement.iter().any(|e| e.id == resource_placement_id) {
                let knowledge_entry = KnowledgeEntry {
                    id: resource_placement_id,
                    state: KnowledgeState::Discovered,
                };
                knowledges.knowledge_resource_placement.push(knowledge_entry);
                self.discover_resource_placement_recipe_components(ctx, resource_placement_id);
            };
        }
    }

    pub fn acquire_resource_placement(&mut self, ctx: &ReducerContext, resource_placement_id: i32) {
       if resource_placement_id != 0 {
            if self.knowledges.is_none() {
                if Self::already_acquired_resource_placement(ctx, self.player_entity_id, resource_placement_id) {
                    return;
                }
                self.initialize(ctx);
            }
            if self.has_acquired_resource_placement(resource_placement_id) {
                return;
            }
            if !self.has_discovered_resource_placement(resource_placement_id) {
                self.discover_resource_placement(ctx, resource_placement_id);
            }
            let knowledges = self.knowledges.as_mut().unwrap();
            if let Some(entry) = knowledges.knowledge_resource_placement.iter_mut().find(|e| e.id == resource_placement_id) {
                entry.state = KnowledgeState::Acquired;
            }
        }
    }

    pub fn already_discovered_resource(ctx: &ReducerContext, player_entity_id: u64, resource_id: i32) -> bool {
        if let Some(knowledge) = ctx.db.knowledge_resource_state().entity_id().find(player_entity_id) {
            if let Some(_entry) = knowledge.entries.iter().find(|e| e.id == resource_id) {
                // acquired or discovered means discovered
                return true;
            }
        }
        false
    }

    pub fn already_acquired_resource(ctx: &ReducerContext, player_entity_id: u64, resource_id: i32) -> bool {
        if let Some(knowledge) = ctx.db.knowledge_resource_state().entity_id().find(player_entity_id) {
            if let Some(entry) = knowledge.entries.iter().find(|e| e.id == resource_id) {
                // acquired or discovered means discovered
                return entry.state == KnowledgeState::Acquired;
            }
        }
        false
    }

    pub fn has_discovered_resource(&self, resource_id: i32) -> bool {
        // This should only be used internally if any change was found in the knowledges, therefore knowledges should yield a value.
        if let Some(knowledges) = &self.knowledges {
            return knowledges.knowledge_resource.iter().any(|e| e.id == resource_id);
        }
        false
    }

    pub fn has_acquired_resource(&self, resource_id: i32) -> bool {
        // This should only be used internally if any change was found in the knowledges, therefore knowledges should yield a value.
        if let Some(knowledges) = &self.knowledges {
            return knowledges.knowledge_resource.iter().any(|e| e.id == resource_id && e.state == KnowledgeState::Acquired);
        }
        false
    }

    pub fn discover_resource(&mut self, ctx: &ReducerContext, resource_id: i32) {
       if resource_id != 0 {
            if self.knowledges.is_none() {
                if Self::already_discovered_resource(ctx, self.player_entity_id, resource_id) {
                    return;
                }
                self.initialize(ctx);
            }
            if self.has_discovered_resource(resource_id) {
                return;
            }
            let knowledges = self.knowledges.as_mut().unwrap();
            if !knowledges.knowledge_resource.iter().any(|e| e.id == resource_id) {
                let knowledge_entry = KnowledgeEntry {
                    id: resource_id,
                    state: KnowledgeState::Discovered,
                };
                knowledges.knowledge_resource.push(knowledge_entry);
            };
        }
    }

    pub fn acquire_resource(&mut self, ctx: &ReducerContext, resource_id: i32) {
       if resource_id != 0 {
            if self.knowledges.is_none() {
                if Self::already_acquired_resource(ctx, self.player_entity_id, resource_id) {
                    return;
                }
                self.initialize(ctx);
            }
            if self.has_acquired_resource(resource_id) {
                return;
            }
            if !self.has_discovered_resource(resource_id) {
                self.discover_resource(ctx, resource_id);
            }
            let knowledges = self.knowledges.as_mut().unwrap();
            if let Some(entry) = knowledges.knowledge_resource.iter_mut().find(|e| e.id == resource_id) {
                entry.state = KnowledgeState::Acquired;
            }
            self.acquired_achievement = true;
        }
    }

    pub fn already_discovered_ruins(ctx: &ReducerContext, player_entity_id: u64, coordinates: OffsetCoordinatesSmall) -> bool {
        if let Some(knowledge) = ctx.db.knowledge_ruins_state().entity_id().find(player_entity_id) {
            if let Some(_entry) = knowledge.entries.iter().find(|e| e.location == coordinates) {
                // acquired or discovered means discovered
                return true;
            }
        }
        false
    }

    pub fn already_acquired_ruins(ctx: &ReducerContext, player_entity_id: u64, coordinates: OffsetCoordinatesSmall) -> bool {
        if let Some(knowledge) = ctx.db.knowledge_ruins_state().entity_id().find(player_entity_id) {
            if let Some(entry) = knowledge.entries.iter().find(|e| e.location == coordinates) {
                // acquired or discovered means discovered
                return entry.state == KnowledgeState::Acquired;
            }
        }
        false
    }

    pub fn has_discovered_ruins(&self, coordinates: OffsetCoordinatesSmall) -> bool {
        // This should only be used internally if any change was found in the knowledges, therefore knowledges should yield a value.
        if let Some(knowledges) = &self.knowledges {
            return knowledges.knowledge_ruins.iter().any(|e| e.location == coordinates);
        }
        false
    }

    pub fn has_acquired_ruins(&self, coordinates: OffsetCoordinatesSmall) -> bool {
        // This should only be used internally if any change was found in the knowledges, therefore knowledges should yield a value.
        if let Some(knowledges) = &self.knowledges {
            return knowledges.knowledge_ruins.iter().any(|e| e.location == coordinates && e.state == KnowledgeState::Acquired);
        }
        false
    }

    pub fn discover_ruins(&mut self, ctx: &ReducerContext, coordinates: OffsetCoordinatesSmall) {
{
            if self.knowledges.is_none() {
                if Self::already_discovered_ruins(ctx, self.player_entity_id, coordinates) {
                    return;
                }
                self.initialize(ctx);
            }
            if self.has_discovered_ruins(coordinates) {
                return;
            }
            let knowledges = self.knowledges.as_mut().unwrap();
            if !knowledges.knowledge_ruins.iter().any(|e| e.location == coordinates) {
                let knowledge_entry = KnowledgeLocationEntry {
                    location: coordinates,
                    state: KnowledgeState::Discovered,
                };
                knowledges.knowledge_ruins.push(knowledge_entry);
            };
        }
    }

    pub fn acquire_ruins(&mut self, ctx: &ReducerContext, coordinates: OffsetCoordinatesSmall) {
{
            if self.knowledges.is_none() {
                if Self::already_acquired_ruins(ctx, self.player_entity_id, coordinates) {
                    return;
                }
                self.initialize(ctx);
            }
            if self.has_acquired_ruins(coordinates) {
                return;
            }
            if !self.has_discovered_ruins(coordinates) {
                self.discover_ruins(ctx, coordinates);
            }
            let knowledges = self.knowledges.as_mut().unwrap();
            if let Some(entry) = knowledges.knowledge_ruins.iter_mut().find(|e| e.location == coordinates) {
                entry.state = KnowledgeState::Acquired;
            }
        }
    }

    pub fn already_discovered_secondary(ctx: &ReducerContext, player_entity_id: u64, secondary_id: i32) -> bool {
        if let Some(knowledge) = ctx.db.knowledge_secondary_state().entity_id().find(player_entity_id) {
            if let Some(_entry) = knowledge.entries.iter().find(|e| e.id == secondary_id) {
                // acquired or discovered means discovered
                return true;
            }
        }
        false
    }

    pub fn already_acquired_secondary(ctx: &ReducerContext, player_entity_id: u64, secondary_id: i32) -> bool {
        if let Some(knowledge) = ctx.db.knowledge_secondary_state().entity_id().find(player_entity_id) {
            if let Some(entry) = knowledge.entries.iter().find(|e| e.id == secondary_id) {
                // acquired or discovered means discovered
                return entry.state == KnowledgeState::Acquired;
            }
        }
        false
    }

    pub fn has_discovered_secondary(&self, secondary_id: i32) -> bool {
        // This should only be used internally if any change was found in the knowledges, therefore knowledges should yield a value.
        if let Some(knowledges) = &self.knowledges {
            return knowledges.knowledge_secondary.iter().any(|e| e.id == secondary_id);
        }
        false
    }

    pub fn has_acquired_secondary(&self, secondary_id: i32) -> bool {
        // This should only be used internally if any change was found in the knowledges, therefore knowledges should yield a value.
        if let Some(knowledges) = &self.knowledges {
            return knowledges.knowledge_secondary.iter().any(|e| e.id == secondary_id && e.state == KnowledgeState::Acquired);
        }
        false
    }

    pub fn discover_secondary(&mut self, ctx: &ReducerContext, secondary_id: i32) {
       if secondary_id != 0 {
            if self.knowledges.is_none() {
                if Self::already_discovered_secondary(ctx, self.player_entity_id, secondary_id) {
                    return;
                }
                self.initialize(ctx);
            }
            if self.has_discovered_secondary(secondary_id) {
                return;
            }
            let knowledges = self.knowledges.as_mut().unwrap();
            if !knowledges.knowledge_secondary.iter().any(|e| e.id == secondary_id) {
                let knowledge_entry = KnowledgeEntry {
                    id: secondary_id,
                    state: KnowledgeState::Discovered,
                };
                knowledges.knowledge_secondary.push(knowledge_entry);
            };
        }
    }

    pub fn acquire_secondary(&mut self, ctx: &ReducerContext, secondary_id: i32) {
       if secondary_id != 0 {
            if self.knowledges.is_none() {
                if Self::already_acquired_secondary(ctx, self.player_entity_id, secondary_id) {
                    return;
                }
                self.initialize(ctx);
            }
            if self.has_acquired_secondary(secondary_id) {
                return;
            }
            if !self.has_discovered_secondary(secondary_id) {
                self.discover_secondary(ctx, secondary_id);
            }
            let knowledges = self.knowledges.as_mut().unwrap();
            if let Some(entry) = knowledges.knowledge_secondary.iter_mut().find(|e| e.id == secondary_id) {
                entry.state = KnowledgeState::Acquired;
            }
        }
    }

    pub fn already_discovered_vault(ctx: &ReducerContext, player_entity_id: u64, vault_id: i32) -> bool {
        if let Some(knowledge) = ctx.db.knowledge_vault_state().entity_id().find(player_entity_id) {
            if let Some(_entry) = knowledge.entries.iter().find(|e| e.id == vault_id) {
                // acquired or discovered means discovered
                return true;
            }
        }
        false
    }

    pub fn already_acquired_vault(ctx: &ReducerContext, player_entity_id: u64, vault_id: i32) -> bool {
        if let Some(knowledge) = ctx.db.knowledge_vault_state().entity_id().find(player_entity_id) {
            if let Some(entry) = knowledge.entries.iter().find(|e| e.id == vault_id) {
                // acquired or discovered means discovered
                return entry.state == KnowledgeState::Acquired;
            }
        }
        false
    }

    pub fn has_discovered_vault(&self, vault_id: i32) -> bool {
        // This should only be used internally if any change was found in the knowledges, therefore knowledges should yield a value.
        if let Some(knowledges) = &self.knowledges {
            return knowledges.knowledge_vault.iter().any(|e| e.id == vault_id);
        }
        false
    }

    pub fn has_acquired_vault(&self, vault_id: i32) -> bool {
        // This should only be used internally if any change was found in the knowledges, therefore knowledges should yield a value.
        if let Some(knowledges) = &self.knowledges {
            return knowledges.knowledge_vault.iter().any(|e| e.id == vault_id && e.state == KnowledgeState::Acquired);
        }
        false
    }

    pub fn discover_vault(&mut self, ctx: &ReducerContext, vault_id: i32) {
       if vault_id != 0 {
            if self.knowledges.is_none() {
                if Self::already_discovered_vault(ctx, self.player_entity_id, vault_id) {
                    return;
                }
                self.initialize(ctx);
            }
            if self.has_discovered_vault(vault_id) {
                return;
            }
            let knowledges = self.knowledges.as_mut().unwrap();
            if !knowledges.knowledge_vault.iter().any(|e| e.id == vault_id) {
                let knowledge_entry = KnowledgeEntry {
                    id: vault_id,
                    state: KnowledgeState::Discovered,
                };
                knowledges.knowledge_vault.push(knowledge_entry);
            };
        }
    }

    pub fn acquire_vault(&mut self, ctx: &ReducerContext, vault_id: i32) {
       if vault_id != 0 {
            if self.knowledges.is_none() {
                if Self::already_acquired_vault(ctx, self.player_entity_id, vault_id) {
                    return;
                }
                self.initialize(ctx);
            }
            if self.has_acquired_vault(vault_id) {
                return;
            }
            if !self.has_discovered_vault(vault_id) {
                self.discover_vault(ctx, vault_id);
            }
            let knowledges = self.knowledges.as_mut().unwrap();
            if let Some(entry) = knowledges.knowledge_vault.iter_mut().find(|e| e.id == vault_id) {
                entry.state = KnowledgeState::Acquired;
            }
        }
    }

}
